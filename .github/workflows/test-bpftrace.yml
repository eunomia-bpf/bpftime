name: BPFtime Syscall Tracing Test (Revised & Corrected)

on:
  push:
    branches: [ "*" ]
  pull_request:
    branches: [ "*" ]

jobs:
  syscall-tracing-test:
    runs-on: ubuntu-22.04
    container:
      # Ensure the image has necessary tools (bpftrace, build tools, sudo)
      # If manjusakalza/bpftime-base-image:ubuntu-2204 doesn't have sudo configured passwordless
      # for the runner user, this might need adjustments or a different base image.
      image: "manjusakalza/bpftime-base-image:ubuntu-2204"
      options: "--privileged" # Essential for bpf/bpftrace

    steps:
      - uses: actions/checkout@v3 # Use a more recent version
        with:
          submodules: 'recursive'

      - name: Install dependencies
        run: |
          apt-get update
          # Ensure sudo is installed and configured if not already in the base image
          # Adding sudo here just in case, though it's usually present.
          apt-get install -y --no-install-recommends \
            lcov tree strace gdb sudo tmux screen bpftrace \
            llvm-dev libelf-dev libbpf-dev libc6-dev # Add build deps just in case
          echo "Runner user: $(whoami)"
          # Verify bpftrace installation
          which bpftrace || (echo "bpftrace not found" && exit 1)
          bpftrace --version || (echo "bpftrace not working" && exit 1)
          # Verify sudo works passwordless for the runner user (important for -E)
          # This assumes the container user can sudo without password. If not, this step needs adjustment.
          sudo -n true || (echo "Passwordless sudo check failed. Ensure container user can sudo without password." && exit 1)

      - name: Build and install runtime
        run: |
          # Using $HOME which is standard in Actions
          echo "Building bpftime, installing to $HOME/.bpftime"
          # Ensure install prefix is correctly set and used
          cmake -Bbuild  -DCMAKE_BUILD_TYPE:STRING=RelWithDebInfo \
            -DCMAKE_INSTALL_PREFIX=$HOME/.bpftime \
            -DBPFTIME_LLVM_JIT=1 \
            -DBUILD_BPFTIME_DAEMON=1 \
            -DCMAKE_CXX_FLAGS="-DDEFAULT_LOGGER_OUTPUT_PATH='\"console\"'"
          # Run install target
          cmake --build build --config RelWithDebInfo --target install -j$(nproc)

      - name: Verify installation
        run: |
          echo "Checking installed bpftime files in $HOME/.bpftime:"
          ls -la $HOME/.bpftime/
          # Ensure key libraries exist IN THE CORRECT LOCATION (directly under .bpftime)
          test -f $HOME/.bpftime/libbpftime-syscall-server.so || (echo "$HOME/.bpftime/libbpftime-syscall-server.so not found!" && exit 1)
          test -f $HOME/.bpftime/libbpftime-agent-transformer.so || (echo "$HOME/.bpftime/libbpftime-agent-transformer.so not found!" && exit 1)
          test -f $HOME/.bpftime/libbpftime-agent.so || (echo "$HOME/.bpftime/libbpftime-agent.so not found!" && exit 1)
          # Ensure executables are present too (optional but good practice)
          test -f $HOME/.bpftime/bpftime || (echo "$HOME/.bpftime/bpftime executable not found!" && exit 1)

          # Ensure bpftrace (system one) can be found by sudo
          sudo which bpftrace

          # Create test files needed by the client
          mkdir -p build
          echo "/test/path/from/ci/1" > build/install_manifest.txt
          echo "/test/path/from/ci/2" >> build/install_manifest.txt
          echo "Created test file (build/install_manifest.txt):"
          cat build/install_manifest.txt

      - name: Create script files for server and client
        run: |
          # Using $HOME directly. LD_PRELOAD paths point to the install location.
          # Added sudo -E to match manual commands.
          # Using full path for bpftrace just to be safe within sudo.
          BPFTRACE_PATH=$(which bpftrace)

          # Create server script
          cat > server_script.sh << EOF
          #!/bin/bash
          set -e # Exit on error
          echo "Starting bpftrace server with preload..."
          echo "Using bpftrace at: $BPFTRACE_PATH"
          # CORRECTED PATH: Points directly into $HOME/.bpftime
          echo "Preloading: $HOME/.bpftime/libbpftime-syscall-server.so"
          ls -la $HOME/.bpftime/libbpftime-syscall-server.so # Verify lib exists just before use

          # Use sudo -E to preserve environment variables like LD_PRELOAD
          # Log stderr to stdout for easier capture
          # CORRECTED PATH: LD_PRELOAD points directly into $HOME/.bpftime
          sudo -E bash -c "BPFTIME_VM_NAME=llvm LD_PRELOAD=\$HOME/.bpftime/libbpftime-syscall-server.so $BPFTRACE_PATH -e 'tracepoint:syscalls:sys_enter_openat { printf(\"%-16s %s\\n\", comm, str(args->filename)); }'" 2>&1

          echo "Server script intended execution finished." # Should not be reached if bpftrace blocks
          EOF
          chmod +x server_script.sh
          echo "--- Server Script Content ---"
          cat server_script.sh
          echo "-----------------------------"

          # Create client script
          cat > client_script.sh << EOF
          #!/bin/bash
          set -e # Exit on error
          echo "Running cat client with agent preload..."
          # CORRECTED PATH: Points directly into $HOME/.bpftime
          echo "Preloading: $HOME/.bpftime/libbpftime-agent-transformer.so"
          # CORRECTED PATH: Points directly into $HOME/.bpftime
          echo "Agent SO: $HOME/.bpftime/libbpftime-agent.so"
          echo "Target file: build/install_manifest.txt"
          # CORRECTED PATH: Verify libs directly in $HOME/.bpftime
          ls -la $HOME/.bpftime/libbpftime-agent-transformer.so $HOME/.bpftime/libbpftime-agent.so # Verify libs exist just before use

          # Use sudo -E to preserve environment variables
          # Log stderr to stdout
          # CORRECTED PATH: LD_PRELOAD and AGENT_SO point directly into $HOME/.bpftime
          sudo -E bash -c "BPFTIME_VM_NAME=llvm LD_PRELOAD=\$HOME/.bpftime/libbpftime-agent-transformer.so BPFTIME_LOG_OUTPUT=stderr AGENT_SO=\$HOME/.bpftime/libbpftime-agent.so cat build/install_manifest.txt" 2>&1

          echo "Client script finished."
          EOF
          chmod +x client_script.sh
          echo "--- Client Script Content ---"
          cat client_script.sh
          echo "-----------------------------"

      - name: Test Server and Client Interaction
        run: |
          echo "Starting server script in background..."
          # Redirect stdout/stderr to a file. Run with bash explicitly.
          ./server_script.sh > server.log 2>&1 &
          SERVER_PID=$!
          echo "Server PID: $SERVER_PID"

          # Allow server some time to initialize (adjust as needed)
          echo "Waiting 10 seconds for server initialization..."
          sleep 10

          # Check if server process is still running before starting client
          if ! ps -p $SERVER_PID > /dev/null; then
            echo "Server process $SERVER_PID exited prematurely!"
            echo "--- Server Log Start (Premature Exit) ---"
            cat server.log || echo "server.log not found or empty"
            echo "--- Server Log End (Premature Exit) ---"
            exit 1
          fi
          echo "Server process $SERVER_PID is running."

          echo "Running client script..."
          # Run client script and capture its output
          ./client_script.sh > client.log 2>&1
          CLIENT_EXIT_CODE=$?
          echo "Client script exited with code $CLIENT_EXIT_CODE"

          echo "--- Client Log Start ---"
          cat client.log || echo "client.log not found or empty"
          echo "--- Client Log End ---"

          # Allow some time for server to process events and flush logs
          echo "Waiting 5 seconds for server to process events..."
          sleep 5

          echo "Stopping server script (PID: $SERVER_PID)..."
          # Use sudo to kill if the server was started with sudo indirectly
          # Adding -9 for forceful kill if graceful (-15, default) doesn't work quickly
          sudo kill -9 $SERVER_PID || echo "Kill command failed (server process $SERVER_PID likely already stopped)."
          # Wait for the process to ensure it's cleaned up
          # timeout is useful in case kill fails silently but process lingers
          timeout 5s wait $SERVER_PID || echo "Server process $SERVER_PID did not terminate gracefully after kill or was already gone."

          echo "Server script stopped."

          echo "--- Server Log Start ---"
          cat server.log || echo "server.log not found or empty"
          echo "--- Server Log End ---"

          echo "Verifying server captured the client's openat syscall..."
          # Check if the server log contains the expected trace line for install_manifest.txt
          # Adjust the grep pattern if the 'comm' field might vary (e.g., 'cat', 'sudo')
          # Use grep -E for extended regex (to match 'cat' or 'sudo')
          # Use grep -q for quiet check, then echo success/failure
          # Allow spaces after command name using ' *'
          if grep -Eq ' (cat|sudo) *.*build/install_manifest.txt' server.log; then
            echo "[SUCCESS] Server log contains the expected openat trace."
          else
            echo "[FAILURE] Server log does NOT contain the expected openat trace for 'build/install_manifest.txt'."
            echo "Expected pattern: ' (cat|sudo) *.*build/install_manifest.txt'"
            exit 1
          fi

          # Optional: Check client exit code if needed
          if [ $CLIENT_EXIT_CODE -ne 0 ]; then
             echo "[WARNING] Client script exited with non-zero status ($CLIENT_EXIT_CODE)."
             # Decide if this should be a failure
             # exit 1
          fi

      - name: Final Summary
        if: always() # Run even if previous steps failed
        run: |
          echo "==== Test Summary ===="
          echo "Attempted to run bpftrace server in background and cat client in foreground."
          echo "Checked server logs for expected syscall trace from the client."
          echo "Final status: ${{ job.status }}"
          echo "Listing key files:"
          ls -la $HOME/.bpftime/ # List the actual install directory content
          ls -la build/
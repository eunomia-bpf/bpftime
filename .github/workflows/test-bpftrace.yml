name: BPFtime Syscall Tracing Test

on:
  push:
    branches: [ "*" ]
  pull_request:
    branches: [ "*" ]
  workflow_dispatch: # Enable manual trigger

env:
  BPFTIME_VM_NAME: llvm
  
jobs:
  syscall-tracing-test:
    runs-on: ubuntu-22.04
    container:
      image: "manjusakalza/bpftime-base-image:ubuntu-2204"
      # Add /dev/shm mount for shared memory (might be needed by BPFTIME)
      # Ensure /tmp is writable for named pipe
      options: "--privileged -v /sys/kernel/debug/:/sys/kernel/debug:rw -v /sys/kernel/tracing:/sys/kernel/tracing:rw -v /dev/shm:/dev/shm:rw"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'
      # - name: Setup tmate session
      #   uses: mxschmitt/action-tmate@v3
      #   with:
      #     limit-access-to-actor: false

      - name: System setup and kernel headers
        run: |
          apt-get update
          apt-get install -y --no-install-recommends \
            lcov tree strace gdb sudo libc6-dev bpftrace \
            linux-headers-generic linux-tools-generic \
            linux-headers-$(uname -r) \
            libelf-dev # Needed for bpftrace compilation often
          
          echo "==== System Information ===="
          uname -a
          cat /etc/os-release
          
          echo "==== Checking bpftrace availability ===="
          which bpftrace
          bpftrace --version
          
          echo "==== Checking tracepoint availability ===="
          # Check for raw_syscalls tracepoints specifically as they are used
          bpftrace -l 'tracepoint:raw_syscalls:*' > /dev/null 2>&1 || { echo "raw_syscalls tracepoints not found or bpftrace failed"; exit 1; }
          echo "raw_syscalls tracepoints found."
          
          echo "==== Checking kernel capabilities ===="
          ls -la /sys/kernel/debug/tracing/ || echo "Debug tracing not accessible"
          ls -la /sys/kernel/tracing/ || echo "Kernel tracing not accessible" # Check kernel tracing as well
          
          echo "==== Preparing test files and directories ===="
          mkdir -p build logs /tmp/bpftime
          echo "TEST_MARKER_LINE_1" > build/install_manifest.txt
          echo "TEST_MARKER_LINE_2" >> build/install_manifest.txt
          cat build/install_manifest.txt
          
          # Ensure /tmp/bpftime_uprobe_pipe can be created/used
          touch /tmp/bpftime_uprobe_pipe || echo "Warning: Cannot touch /tmp/bpftime_uprobe_pipe"

      # Use a simplified bpftrace test to check functionality
      - name: Test bpftrace basic functionality
        run: |
          echo "==== Testing bpftrace basic functionality ===="
          
          # Create a simpler test without BEGIN/END probes
          cat > syscall_test.bt << 'EOF'
          tracepoint:raw_syscalls:sys_enter 
          {
              @syscalls[args->id] = count();
              if (@syscalls[args->id] == 1) {
                  printf("First occurrence of syscall ID %d\n", args->id);
              }
          }
          
          interval:s:3 { 
              printf("Exiting after 3 seconds\n"); 
              exit(); 
          }
          EOF
          
          # Run the test with a shorter timeout
          echo "Running syscall test (will run for max 4s)..."
          timeout -k 5s 4s bpftrace syscall_test.bt > logs/bpftrace_test.log 2>&1 || echo "Bpftrace test completed with non-zero exit code (expected with timeout)"
          
          cat logs/bpftrace_test.log
          
          # Check for any output indicating bpftrace ran successfully
          if grep -q "First occurrence of syscall\|Attaching\|Exiting" logs/bpftrace_test.log; then
            echo "SUCCESS: Basic bpftrace test ran and produced output"
          else
            echo "WARNING: No expected output detected in basic test, but continuing anyway"
          fi

      - name: Build and install runtime
        run: |
          export INSTALL_DIR=$HOME/.bpftime
          echo "Building bpftime, installing to $INSTALL_DIR"
          
          cmake -Bbuild -DCMAKE_BUILD_TYPE:STRING=RelWithDebInfo \
            -DCMAKE_INSTALL_PREFIX=$INSTALL_DIR \
            -DBPFTIME_LLVM_JIT=1 \
            -DBUILD_BPFTIME_DAEMON=1 \
            -DCMAKE_CXX_FLAGS="-DDEFAULT_LOGGER_OUTPUT_PATH='\"console\"'" \
            -DBUILD_AGENT=1 # Ensure agent is built
          
          cmake --build build --config RelWithDebInfo --target install -j$(nproc)
          
          echo "Installed files:"
          ls -la $INSTALL_DIR/
          
          chmod +x $INSTALL_DIR/* || echo "Warning: Could not chmod installed files"
          
          export PATH=$PATH:$INSTALL_DIR
          echo "PATH=$PATH" >> $GITHUB_ENV
          echo "BPFTIME_INSTALL_DIR=$INSTALL_DIR" >> $GITHUB_ENV
          echo "HOME_DIR=$HOME" >> $GITHUB_ENV

      - name: Create test scripts and programs
        run: |
          echo "==== Creating test scripts and programs ===="
          
          # Update test_syscalls.c with proper C-style comments
          cat > test_syscalls.c << 'EOF'
          #include <stdio.h>
          #include <fcntl.h>
          #include <unistd.h>
          #include <string.h>
          #include <errno.h>
          #include <stdlib.h>
          
          int main() {
              printf("Test program starting (PID %d)\n", getpid());
              
              // 重复执行openat系统调用，增加被捕获的机会
              for (int i = 0; i < 5; i++) { // Reduced iterations for faster test
                  printf("Iteration %d: Attempting to open file build/install_manifest.txt\n", i);
                  // Use O_CLOEXEC to avoid leaking FD to potential subprocesses (good practice)
                  int fd = open("build/install_manifest.txt", O_RDONLY | O_CLOEXEC);
                  if (fd >= 0) {
                      printf("Successfully opened file (FD %d)\n", fd);
                      char buffer[256];
                      ssize_t bytes_read = read(fd, buffer, sizeof(buffer) - 1);
                      if (bytes_read > 0) {
                          buffer[bytes_read] = '\0'; // Null-terminate
                          printf("Read %zd bytes: '%s'\n", bytes_read, buffer);
                      } else if (bytes_read == 0) {
                          printf("Read 0 bytes (End of file)\n");
                      } else {
                          perror("read failed");
                      }
                      close(fd);
                      usleep(50000); // 休眠50ms
                  } else {
                      perror("openat failed");
                      // Don't exit immediately on open failure, continue iterations
                      usleep(50000); // Still sleep on failure
                  }
              }
              
              printf("Test program completed (PID %d)\n", getpid());
              return EXIT_SUCCESS; // Return success if reached here
          }
          EOF
          
          # Compile test program
          gcc -o test_syscalls test_syscalls.c
          
          # Create raw_syscalls test script for bpftrace server
          cat > raw_syscalls_trace.bt << 'EOF'
          #include <linux/sched.h>
          
          tracepoint:raw_syscalls:sys_enter {
              // Filter by command name to avoid tracing bpftrace itself excessively
              if (comm == "test_syscalls") {
                  printf("Syscall enter: PID %d, Comm %s, ID %d\n", pid, comm, args->id);
                  if (args->id == 257) { // SYS_openat is commonly 257 on x86_64
                      printf("  Detected openat syscall by test_syscalls!\n");
                  }
              }
          }
          
          tracepoint:raw_syscalls:sys_exit {
              if (comm == "test_syscalls") {
                  printf("Syscall exit : PID %d, Comm %s, ID %d, Ret %d\n", pid, comm, args->id, args->ret);
              }
          }
          
          // Add a probe to signal readiness, typically uses the named pipe
          // This requires specific bpftime probe points, which might not map directly from bpftrace
          // A simple timeout or checking pipe existence might be easier for the script
          // Let's rely on the pipe logic being internal to the preloaded libraries
          
          interval:s:10 { // Run for a maximum duration
              printf("Bpftrace server timeout, exiting.\n");
              exit();
          }
          EOF
          
          # Create raw_syscalls test coordination script (using named pipe)
          cat > raw_syscalls_test.sh << 'EOF'
          #!/bin/bash
          set -x
          
          export HOME_DIR=$HOME
          export BPFTIME_VM_NAME=llvm
          export BPFTIME_LOG_OUTPUT=console # Or 'file' for logs in a file
          
          BPF_SERVER_SO="$HOME_DIR/.bpftime/libbpftime-syscall-server.so"
          BPF_AGENT_TRANSFORMER_SO="$HOME_DIR/.bpftime/libbpftime-agent-transformer.so"
          BPF_AGENT_SO="$HOME_DIR/.bpftime/libbpftime-agent.so"
          PIPE_PATH="/tmp/bpftime_uprobe_pipe" # Default named pipe path
          
          # Check if required libraries exist
          if [ ! -f "$BPF_SERVER_SO" ]; then echo "ERROR: $BPF_SERVER_SO not found!"; exit 1; fi
          if [ ! -f "$BPF_AGENT_TRANSFORMER_SO" ]; then echo "ERROR: $BPF_AGENT_TRANSFORMER_SO not found!"; exit 1; fi
          if [ ! -f "$BPF_AGENT_SO" ]; then echo "ERROR: $BPF_AGENT_SO not found!"; exit 1; fi
          
          # Create the named pipe
          rm -f "$PIPE_PATH"
          mkfifo "$PIPE_PATH" || { echo "ERROR: Failed to create named pipe $PIPE_PATH"; exit 1; }
          
          echo "Starting bpftrace server with preload ($BPF_SERVER_SO)..."
          # Run server in background, redirecting output
          LD_PRELOAD="$BPF_SERVER_SO" \
          bpftrace raw_syscalls_trace.bt > logs/raw_server.log 2>&1 &
          
          SERVER_PID=$!
          echo "Server PID: $SERVER_PID"
          
          # Wait a moment for the server to initialize and potentially open the pipe
          sleep 2
          
          # Check if server process is running
          if ! ps -p $SERVER_PID > /dev/null; then
            echo "ERROR: Bpftrace server failed to start!"
            cat logs/raw_server.log
            exit 1
          fi
          
          echo "Running client with agent preload ($BPF_AGENT_TRANSFORMER_SO) and agent SO ($BPF_AGENT_SO)..."
          # Run client, relying on agent to use the named pipe and shared memory
          LD_PRELOAD="$BPF_AGENT_TRANSFORMER_SO" \
          AGENT_SO="$BPF_AGENT_SO" \
          "$PWD"/test_syscalls > logs/raw_client.log 2>&1
          
          CLIENT_EXIT_CODE=$?
          echo "Client script completed with exit code: $CLIENT_EXIT_CODE"
          
          # Give server time to process final events and potentially exit
          sleep 2
          
          # Terminate the server process
          if ps -p $SERVER_PID > /dev/null; then
            echo "Stopping server PID $SERVER_PID..."
            kill $SERVER_PID 2>/dev/null
            wait $SERVER_PID 2>/dev/null
          fi
          
          # Clean up the pipe
          rm -f "$PIPE_PATH"
          
          # Display logs
          echo "=== Server Log (raw_server.log) ==="
          cat logs/raw_server.log
          
          echo "=== Client Log (raw_client.log) ==="
          cat logs/raw_client.log
          
          # Check results
          # Check if the server log contains evidence of syscalls being traced from the client
          if grep -q "Detected openat syscall by test_syscalls!" logs/raw_server.log; then
            echo "SUCCESS: raw_syscalls test: Server traced client's openat"
            exit 0 # Indicate success for this script
          else
            echo "WARNING: raw_syscalls test: No openat trace output found in server log."
            echo "Dumping dmesg tail for potential kernel errors:"
            sudo dmesg | tail -n 50
            exit 1 # Indicate failure for this script
          fi
          EOF
          chmod +x raw_syscalls_test.sh
          
          # Create daemon mode BPF script (compile it later)
          cat > daemon_openat_trace.bt << 'EOF'
          #include <linux/sched.h>
          
          tracepoint:raw_syscalls:sys_enter {
              if (comm == "test_syscalls") {
                  if (args->id == 257) { // SYS_openat
                      printf("Daemon traced openat from PID %d, Comm %s\n", pid, comm);
                  }
              }
          }
          // bpftime daemon programs typically don't need explicit exit from probe
          // Program lifetime is managed by the daemon/loader
          EOF

      - name: Test combination with raw_syscalls (LD_PRELOAD server/agent)
        run: |
          echo "==== Testing with raw_syscalls (LD_PRELOAD server/agent) ===="
          # Run the corrected test script
          ./raw_syscalls_test.sh || { echo "raw_syscalls test failed"; exit 1; }

      - name: Test with daemon mode
        run: |
          echo "==== Testing with daemon mode ===="
          export HOME_DIR=$HOME
          export BPFTIME_VM_NAME=llvm
          
          BPF_DAEMON="$HOME/.bpftime/bpftime_daemon"
          BPF_LOAD="$HOME/.bpftime/bpftime"
          BPF_AGENT_SO="$HOME_DIR/.bpftime/libbpftime-agent.so"
          BPF_TRACE_SCRIPT="daemon_openat_trace.bt"
          BPF_OBJECT_FILE="daemon_openat_trace.o"
          
          # Check required files
          if [ ! -f "$BPF_DAEMON" ]; then echo "ERROR: $BPF_DAEMON not found!"; exit 1; fi
          if [ ! -f "$BPF_LOAD" ]; then echo "ERROR: $BPF_LOAD not found!"; exit 1; fi
          if [ ! -f "$BPF_AGENT_SO" ]; then echo "ERROR: $BPF_AGENT_SO not found!"; exit 1; fi
          if [ ! -f "$BPF_TRACE_SCRIPT" ]; then echo "ERROR: $BPF_TRACE_SCRIPT not found!"; exit 1; fi
          
          # Start daemon
          echo "Starting bpftime daemon..."
          "$BPF_DAEMON" > logs/daemon.log 2>&1 &
          DAEMON_PID=$!
          echo "Daemon started with PID: $DAEMON_PID"
          
          # Wait for daemon to initialize
          sleep 3
          
          # Check if daemon is running
          if ! ps -p $DAEMON_PID > /dev/null; then
            echo "ERROR: Daemon process not found after startup."
            cat logs/daemon.log
            exit 1
          fi
          echo "Daemon is running."
          
          # Compile bpftrace script to BPF object file
          echo "Compiling bpftrace script $BPF_TRACE_SCRIPT to $BPF_OBJECT_FILE..."
          # Use bpftrace to compile the script
          bpftrace -o "$BPF_OBJECT_FILE" "$BPF_TRACE_SCRIPT" > logs/daemon_compile_bpftrace.log 2>&1
          COMPILE_EXIT_CODE=$?
          cat logs/daemon_compile_bpftrace.log
          if [ $COMPILE_EXIT_CODE -ne 0 ]; then
            echo "ERROR: Failed to compile bpftrace script."
            kill $DAEMON_PID 2>/dev/null # Clean up daemon
            exit 1
          fi
          echo "Bpftrace script compiled successfully."
          
          # Load the compiled BPF object file into the daemon
          echo "Loading BPF program $BPF_OBJECT_FILE into the daemon..."
          
          echo "Attempting to load compiled BPF program into daemon..."
          "$BPF_LOAD" "$BPF_OBJECT_FILE" > logs/daemon_load_bpf.log 2>&1
          LOAD_EXIT_CODE=$?
          cat logs/daemon_load_bpf.log
          if [ $LOAD_EXIT_CODE -ne 0 ]; then
            echo "ERROR: Failed to load BPF program into daemon."
            kill $DAEMON_PID 2>/dev/null # Clean up daemon
            exit 1
          fi
          echo "BPF program loaded into daemon."
          
          # Run the test program with the daemon agent
          echo "Running test program with daemon agent ($BPF_AGENT_SO)..."
          LD_PRELOAD="$BPF_AGENT_SO" \
          "$PWD"/test_syscalls > logs/daemon_client.log 2>&1
          
          CLIENT_EXIT_CODE=$?
          echo "Test program completed with exit code: $CLIENT_EXIT_CODE"
          
          # Give daemon time to log final events
          sleep 2
          
          # Terminate daemon
          echo "Stopping daemon PID $DAEMON_PID..."
          kill $DAEMON_PID 2>/dev/null
          wait $DAEMON_PID 2>/dev/null
          
          # Display logs
          echo "=== Daemon Log (daemon.log) ==="
          cat logs/daemon.log
          
          echo "=== Daemon Compile Bpftrace Log (daemon_compile_bpftrace.log) ==="
          cat logs/daemon_compile_bpftrace.log # Should be empty on success
          
          echo "=== Daemon Load BPF Log (daemon_load_bpf.log) ==="
          cat logs/daemon_load_bpf.log
          
          echo "=== Daemon Client Log (daemon_client.log) ==="
          cat logs/daemon_client.log
          
          # Check results: Look for the specific printf output in the daemon log
          if grep -q "Daemon traced openat from PID .* Comm test_syscalls" logs/daemon.log; then
            echo "SUCCESS: Daemon mode test: Daemon traced client's openat"
            exit 0 # Indicate success for this step
          else
            echo "WARNING: Daemon mode test: No openat trace output found in daemon log."
            echo "Dumping dmesg tail for potential kernel errors:"
            sudo dmesg | tail -n 50
            exit 1 # Indicate failure for this step
          fi

      - name: Test summary
        run: |
          echo "==== Test Summary ===="
          
          # Evaluate test results based on specific SUCCESS messages printed by the steps
          # This is more robust than checking general log content
          
          RAW_SYSCALLS_TEST_STATUS=$(grep "SUCCESS: raw_syscalls test:" logs/raw_server.log logs/raw_client.log 2>/dev/null || true)
          DAEMON_TEST_STATUS=$(grep "SUCCESS: Daemon mode test:" logs/daemon.log logs/daemon_client.log logs/daemon_load_bpf.log 2>/dev/null || true)
          
          echo "Raw Syscalls Test Status: ${RAW_SYSCALLS_TEST_STATUS:-NOT TESTED OR FAILED}"
          echo "Daemon Test Status: ${DAEMON_TEST_STATUS:-NOT TESTED OR FAILED}"
          
          # Check if *any* major test reported success
          if echo "$RAW_SYSCALLS_TEST_STATUS" | grep -q "SUCCESS" || echo "$DAEMON_TEST_STATUS" | grep -q "SUCCESS"; then
            echo "OVERALL RESULT: At least one major test passed!"
            exit 0
          else
            echo "OVERALL RESULT: All major tests failed or did not run."
            
            # Display important logs for debugging
            echo "==== Debug Logs Overview ===="
            echo "--- logs/raw_server.log ---"
            cat logs/raw_server.log || echo "File not found"
            echo "--- logs/raw_client.log ---"
            cat logs/raw_client.log || echo "File not found"
            echo "--- logs/daemon.log ---"
            cat logs/daemon.log || echo "File not found"
            echo "--- logs/daemon_load_bpf.log ---"
            cat logs/daemon_load_bpf.log || echo "File not found"
            echo "--- logs/daemon_client.log ---"
            cat logs/daemon_client.log || echo "File not found"
            echo "--- dmesg tail ---"
            sudo dmesg | tail -n 50 || echo "Could not get dmesg"

            exit 1
          fi

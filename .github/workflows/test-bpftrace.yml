name: BPFtime Syscall Tracing Test

on:
  push:
    branches: [ "*" ]
  pull_request:
    branches: [ "*" ]

jobs:
  syscall-tracing-test:
    runs-on: ubuntu-22.04
    container: 
      image: "manjusakalza/bpftime-base-image:ubuntu-2204"
      options: "--privileged"
    
    steps:
      - uses: actions/checkout@v2
        with:
          submodules: 'recursive'
      
      - name: Install dependencies
        run: |
          apt-get update
          apt-get install -y lcov tree strace gdb
          
      - name: Build and install runtime
        run: |
          cmake -Bbuild  -DCMAKE_BUILD_TYPE:STRING=RelWithDebInfo \
            -DBPFTIME_LLVM_JIT=1 \
            -DBUILD_BPFTIME_DAEMON=1 \
            -DCMAKE_CXX_FLAGS="-DDEFAULT_LOGGER_OUTPUT_PATH='\"console\"'"
          cmake --build build --config RelWithDebInfo --target install -j
          
      - name: Check bpftime and bpftrace versions
        run: |
          export PATH=$PATH:~/.bpftime
          echo "Checking bpftime version:"
          ~/.bpftime/bpftime --version || echo "No version command available"
          echo "Checking bpftime help:"
          ~/.bpftime/bpftime --help
          echo "Checking bpftrace version:"
          bpftrace --version || echo "bpftrace version not available"
          
      - name: Test bpftrace openat syscall tracing
        run: |
          # Create a test file to cat
          echo "Test content" > test_file.txt
          
          # Create a script to capture the output
          cat > test_syscall.sh << 'EOF'
          #!/bin/bash
          set -e
          
          # Start bpftrace in background and save PID
          sudo SPDLOG_LEVEL=error ~/.bpftime/bpftime load bpftrace -e 'tracepoint:syscalls:sys_enter_openat { printf("%s %s\n", comm, str(args->filename)); }' > trace_output.txt &
          BPFTRACE_PID=$!
          
          # Wait for bpftrace to initialize
          sleep 2
          
          # Run the cat command that should be traced
          cat test_file.txt
          
          # Give time for output to be captured
          sleep 1
          
          # Kill the bpftrace process
          kill $BPFTRACE_PID || true
          
          # Display captured output
          cat trace_output.txt
          
          # Verify that cat command was captured in the trace
          grep -q "cat test_file.txt" trace_output.txt && echo "✅ TEST PASSED: openat syscall for cat was traced" || { echo "❌ TEST FAILED: didn't find expected trace"; exit 1; }
          EOF
          
          chmod +x test_syscall.sh
          ./test_syscall.sh
      
      - name: Test bpftime start with cat command
        run: |
          # Create a test manifest file
          mkdir -p build
          echo "/test/path/1" > build/install_manifest.txt
          echo "/test/path/2" >> build/install_manifest.txt
          
          # Run the bpftime start command and capture output
          output=$(sudo SPDLOG_LEVEL=error ~/.bpftime/bpftime start -s cat build/install_manifest.txt)
          
          # Print the captured output
          echo "Command output:"
          echo "$output"
          
          # Verify that the manifest contents were displayed
          echo "$output" | grep -q "/test/path/1" && echo " TEST PASSED: First manifest path was found" || { echo "❌ TEST FAILED: First manifest path not found"; exit 1; }
          echo "$output" | grep -q "/test/path/2" && echo " TEST PASSED: Second manifest path was found" || { echo "❌ TEST FAILED: Second manifest path not found"; exit 1; }
      
      - name: Test userspace bpftrace example
        run: |
          # Create a simple bpftrace script
          cat > simple_trace.bt << 'EOF'
          BEGIN { printf("Userspace bpftrace test started\n"); }
          tracepoint:syscalls:sys_enter_write { printf("Write syscall by %s\n", comm); }
          END { printf("Userspace bpftrace test completed\n"); exit(); }
          EOF
          
          # Run with bpftime in userspace mode
          sudo SPDLOG_LEVEL=error ~/.bpftime/bpftime load bpftrace simple_trace.bt -c "echo 'Testing write syscall'" > userspace_output.txt
          
          # Display result
          cat userspace_output.txt
          
          # Verify expected output
          grep -q "Userspace bpftrace test started" userspace_output.txt && echo " TEST PASSED: Userspace test started properly" || { echo "❌ TEST FAILED: Test didn't start properly"; exit 1; }
          grep -q "Write syscall by" userspace_output.txt && echo " TEST PASSED: Write syscall was traced" || { echo "❌ TEST FAILED: Write syscall not traced"; exit 1; }
          grep -q "Userspace bpftrace test completed" userspace_output.txt && echo " TEST PASSED: Test completed properly" || { echo "❌ TEST FAILED: Test didn't complete properly"; exit 1; }
      
      - name: Handle test failures (if any)
        if: ${{ failure() }}
        run: |
          echo "=== Debug information for failure analysis ==="
          echo "System information:"
          uname -a
          lsb_release -a || true
          
          echo "bpftime installation:"
          ls -la ~/.bpftime/
          
          echo "bpftrace status:"
          which bpftrace || echo "bpftrace not found"
          bpftrace --info || echo "bpftrace info not available"
          
          echo "Process status during test:"
          ps aux | grep -E 'bpf|trace'
          
          echo "Kernel capabilities:"
          cat /proc/sys/kernel/cap_last_cap || echo "Cannot read capabilities"
          
          echo "Loaded kernel modules:"
          lsmod | grep -E 'bpf|trace' || echo "No BPF modules found"
          
          echo "Check permissions on BPF filesystem:"
          ls -la /sys/fs/bpf/ || echo "BPF filesystem not accessible"
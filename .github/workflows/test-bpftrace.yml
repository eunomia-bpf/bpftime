name: BPFtime Syscall Tracing Test

on:
  push:
    branches: [ "*" ]
  pull_request:
    branches: [ "*" ]

jobs:
  syscall-tracing-test:
    runs-on: ubuntu-22.04
    container: 
      image: "manjusakalza/bpftime-base-image:ubuntu-2204"
      options: "--privileged"
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          submodules: 'recursive'
      
      - name: System preparation
        run: |
          # Update and install dependencies
          apt-get update
          apt-get install -y lcov tree strace gdb sudo tmux bpftrace
          
          # Setup environment
          echo "HOME=/root" >> $GITHUB_ENV
          
          # Ensure trace/debug filesystems are mounted
          if ! mount | grep tracefs; then
            mkdir -p /sys/kernel/tracing
            mount -t tracefs nodev /sys/kernel/tracing || echo "Failed to mount tracefs"
          fi
          
          if ! mount | grep debugfs; then
            mkdir -p /sys/kernel/debug
            mount -t debugfs nodev /sys/kernel/debug || echo "Failed to mount debugfs"
          fi
          
          # Display system information
          echo "===== System Information ====="
          uname -a
          mount | grep -E 'tracefs|debugfs'
          find /sys/kernel/*/tracing/events/syscalls -name "sys_enter_*" | head -5 || echo "No tracepoints found"
      
      - name: Build and install runtime
        run: |
          # Build with debug options
          cmake -Bbuild -DCMAKE_BUILD_TYPE:STRING=RelWithDebInfo \
            -DBPFTIME_LLVM_JIT=1 \
            -DBUILD_BPFTIME_DAEMON=1 \
            -DCMAKE_CXX_FLAGS="-DDEFAULT_LOGGER_OUTPUT_PATH='\"console\"'" \
            -DCMAKE_INSTALL_PREFIX=/root/.bpftime
          
          cmake --build build --config RelWithDebInfo -j
          cmake --build build --config RelWithDebInfo --target install
          
          # Verify installation
          echo "===== Installation verification ====="
          ls -la /root/.bpftime/
          
          # Create test files
          echo "Test content for example 1" > example1_test.txt
          mkdir -p build
          echo "/test/path/1" > build/install_manifest.txt
          echo "/test/path/2" >> build/install_manifest.txt
      
      - name: Create test scripts
        run: |
          #----------------
          # Server script
          #----------------
          cat > server_script.sh << 'EOF'
          #!/bin/bash
          set -x
          export HOME_DIR=/root
          
          # Check for server library
          if [ ! -f "$HOME_DIR/.bpftime/libbpftime-syscall-server.so" ]; then
            echo "ERROR: libbpftime-syscall-server.so not found!"
            ls -la $HOME_DIR/.bpftime/
            exit 1
          fi
          
          # Find available tracepoints
          if [ -d "/sys/kernel/debug/tracing/events/syscalls/sys_enter_openat" ] || 
             [ -d "/sys/kernel/tracing/events/syscalls/sys_enter_openat" ]; then
            TRACEPOINT="tracepoint:syscalls:sys_enter_openat"
            BPF_PROGRAM='tracepoint:syscalls:sys_enter_openat { printf("%s %s\n", comm, str(args->filename)); }'
          else
            # Try to find any available syscall tracepoint
            AVAILABLE_TP=$(find /sys/kernel/*/tracing/events/syscalls -name "sys_enter_*" | head -1)
            
            if [ -n "$AVAILABLE_TP" ]; then
              AVAILABLE_TP=$(basename $AVAILABLE_TP)
              TRACEPOINT="tracepoint:syscalls:$AVAILABLE_TP"
              echo "Using alternative tracepoint: $TRACEPOINT"
              BPF_PROGRAM="$TRACEPOINT { printf(\"Syscall by %s (PID: %d)\\n\", comm, pid); }"
            else
              # Fallback to kprobe as last resort
              TRACEPOINT="kprobe:do_sys_open"
              echo "Falling back to: $TRACEPOINT"
              BPF_PROGRAM="$TRACEPOINT { printf(\"Open syscall by %s (PID: %d)\\n\", comm, pid); }"
            fi
          fi
          
          echo "Using BPF program: $BPF_PROGRAM"
          
          # Run bpftrace with system trace preload
          export LD_LIBRARY_PATH=$HOME_DIR/.bpftime:$LD_LIBRARY_PATH
          BPFTIME_DEBUG_LEVEL=4 BPFTIME_VM_NAME=llvm \
            LD_PRELOAD=$HOME_DIR/.bpftime/libbpftime-syscall-server.so \
            bpftrace -e "$BPF_PROGRAM"
          
          echo "Server script completed with status $?"
          EOF
          chmod +x server_script.sh
          
          #----------------
          # Client script
          #----------------
          cat > client_script.sh << 'EOF'
          #!/bin/bash
          set -x
          export HOME_DIR=/root
          
          # Wait for server to initialize
          echo "Waiting for server to initialize..."
          sleep 8
          
          # Check for agent libraries
          if [ ! -f "$HOME_DIR/.bpftime/libbpftime-agent-transformer.so" ]; then
            echo "ERROR: libbpftime-agent-transformer.so not found!"
            exit 1
          fi
          
          if [ ! -f "$HOME_DIR/.bpftime/libbpftime-agent.so" ]; then
            echo "ERROR: libbpftime-agent.so not found!"
            exit 1
          fi
          
          # Check for test file
          if [ ! -f "build/install_manifest.txt" ]; then
            echo "WARNING: Test file not found, creating it"
            mkdir -p build
            echo "/test/path/1" > build/install_manifest.txt
            echo "/test/path/2" >> build/install_manifest.txt
          fi
          
          # Run cat with agent preload
          export LD_LIBRARY_PATH=$HOME_DIR/.bpftime:$LD_LIBRARY_PATH
          BPFTIME_DEBUG_LEVEL=4 BPFTIME_VM_NAME=llvm \
            LD_PRELOAD=$HOME_DIR/.bpftime/libbpftime-agent-transformer.so \
            BPFTIME_LOG_OUTPUT=console \
            AGENT_SO=$HOME_DIR/.bpftime/libbpftime-agent.so \
            /bin/cat build/install_manifest.txt
          
          EXIT_CODE=$?
          echo "Client command exited with status $EXIT_CODE"
          
          if [ $EXIT_CODE -ne 0 ]; then
            echo "Trying direct cat as a test:"
            /bin/cat build/install_manifest.txt
          fi
          
          echo "Client script completed"
          EOF
          chmod +x client_script.sh
      
      - name: Test with tmux approach
        id: tmux_test
        run: |
          echo "===== Running Primary Test with tmux ====="
          mkdir -p logs
          
          # Start tmux server in detached mode with logging
          tmux -v new-session -d -s bpftime_server 'bash -x ./server_script.sh 2>&1 | tee logs/server_tmux.log'
          
          # Verify session started
          sleep 2
          if ! tmux has-session -t bpftime_server 2>/dev/null; then
            echo "ERROR: Failed to start tmux session"
            exit 1
          fi
          
          # Run client script
          bash -x ./client_script.sh 2>&1 | tee logs/client_tmux.log
          
          # Capture output to check
          if grep -q "/test/path/" logs/client_tmux.log; then
            echo "success=true" >> $GITHUB_OUTPUT
          else
            echo "success=false" >> $GITHUB_OUTPUT
          fi
          
          # Kill tmux session
          tmux kill-session -t bpftime_server || echo "Tmux session already ended"
      
      - name: Fallback test with daemon
        if: steps.tmux_test.outputs.success != 'true'
        run: |
          echo "===== Running Fallback Test with daemon ====="
          
          # Start daemon in background
          /root/.bpftime/bpftime_daemon > logs/daemon.log 2>&1 &
          DAEMON_PID=$!
          sleep 5
          
          # Try running with bpftime command
          /root/.bpftime/bpftime load /bin/cat build/install_manifest.txt > logs/daemon_client.log 2>&1 || \
            echo "Daemon client test failed"
          
          # Try alternative direct approach if needed
          /root/.bpftime/bpftime load bpftrace -e 'BEGIN { printf("Test\n"); exit(); }' \
            -c "/bin/cat build/install_manifest.txt" >> logs/daemon_client.log 2>&1 || \
            echo "Daemon bpftrace test failed"
          
          # Cleanup
          kill $DAEMON_PID || echo "Daemon process already ended"
      
      - name: Direct test method
        if: steps.tmux_test.outputs.success != 'true'
        run: |
          echo "===== Running Direct Execution Test ====="
          
          # Direct execution with environment variables
          export LD_LIBRARY_PATH=/root/.bpftime:$LD_LIBRARY_PATH
          
          # Start server directly in background
          BPFTIME_DEBUG_LEVEL=4 BPFTIME_VM_NAME=llvm \
            LD_PRELOAD=/root/.bpftime/libbpftime-syscall-server.so \
            bpftrace -e 'BEGIN { printf("Server started\n"); }' > logs/direct_server.log 2>&1 &
          
          SERVER_PID=$!
          sleep 5
          
          # Run client directly
          BPFTIME_DEBUG_LEVEL=4 BPFTIME_VM_NAME=llvm \
            LD_PRELOAD=/root/.bpftime/libbpftime-agent-transformer.so \
            BPFTIME_LOG_OUTPUT=console \
            AGENT_SO=/root/.bpftime/libbpftime-agent.so \
            /bin/cat build/install_manifest.txt > logs/direct_client.log 2>&1
          
          # Cleanup
          kill $SERVER_PID || echo "Server process already ended"
      
      - name: Collect diagnostic information
        if: always()
        run: |
          echo "===== Collecting Diagnostic Information ====="
          
          # Gather system state
          ps aux > logs/process_list.txt
          mount > logs/mount_info.txt
          dmesg | tail -n 200 > logs/dmesg.txt
          find /sys/kernel/*/tracing -type d | sort > logs/tracing_paths.txt
          
          # Check files
          ls -la /root/.bpftime/ > logs/bpftime_files.txt
          ls -la build/ > logs/build_files.txt
          
          # Show summary
          echo "===== Test Summary ====="
          grep -l "/test/path/" logs/*.log || echo "No successful test output found"
      
      - name: Upload logs
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: bpftime-test-logs
          path: logs/
          retention-days: 5
      
      - name: Result assessment
        run: |
          # Check all logs for any evidence of success
          if grep -q "/test/path/" logs/*.log; then
            echo "✅ TEST PASSED: Found expected output in logs"
            exit 0
          else
            echo "❌ TEST FAILED: Did not find expected output"
            # See if we can find any related output
            grep -i "path\|openat\|syscall" logs/*.log || echo "No relevant output found"
            exit 1
          fi
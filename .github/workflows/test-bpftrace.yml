name: BPFtime Syscall Tracing Test with Debug Session # Renamed for clarity

# Combined triggers from both original workflows
on:
  push:
    branches: [ "*" ]
  pull_request:
    branches: [ "*" ]

env:
  # Environment variable from the bpftime workflow
  BPFTIME_VM_NAME: llvm

jobs:
  # Renamed the job for clarity, kept the original logic
  syscall-tracing-test:
    # Use the specific runner and container required by bpftime tests
    runs-on: ubuntu-22.04
    container:
      image: "manjusakalza/bpftime-base-image:ubuntu-2204"
      options: "--privileged -v /sys/kernel/debug/:/sys/kernel/debug:rw -v /sys/kernel/tracing:/sys/kernel/tracing:rw"

    steps:
      # Step 1: Checkout code (using v4 from the tmate example, keeping submodules)
      - name: Checkout code
        uses: actions/checkout@v4 # Use a newer version like in the tmate example
        with:
          submodules: 'recursive'

      # Step 2: System setup and kernel headers (from bpftime workflow)
      - name: System setup and kernel headers
        run: |
          apt-get update
          apt-get install -y --no-install-recommends \
            lcov tree strace gdb sudo libc6-dev bpftrace \
            linux-headers-generic linux-tools-generic \
            linux-headers-$(uname -r)

          # 显示系统信息
          echo "==== System Information ===="
          uname -a
          cat /etc/os-release

          # 检查bpftrace可用性
          echo "==== Checking bpftrace availability ===="
          which bpftrace
          bpftrace --version

          # 检查跟踪点可用性
          echo "==== Checking tracepoint availability ===="
          bpftrace -l 'tracepoint:syscalls:*' | grep openat || echo "syscalls:openat tracepoint not found"
          bpftrace -l 'tracepoint:raw_syscalls:*' || echo "raw_syscalls tracepoints not found"

          # 显示内核功能
          echo "==== Checking kernel capabilities ===="
          ls -la /sys/kernel/debug/tracing/ || echo "Debug tracing not accessible"

          # 创建测试文件
          mkdir -p build
          echo "TEST_MARKER_LINE_1" > build/install_manifest.txt
          echo "TEST_MARKER_LINE_2" >> build/install_manifest.txt
          cat build/install_manifest.txt

          # 创建日志目录
          mkdir -p logs

      # Step 3: Test bpftrace basic functionality (from bpftime workflow)
      - name: Test bpftrace basic functionality
        run: |
          echo "==== Testing bpftrace basic functionality ===="

          # 测试简单的bpftrace脚本
          cat > simple_test.bt << 'EOF'
          BEGIN {
              printf("Simple bpftrace test started\n");
          }
          END {
              printf("Simple bpftrace test completed\n");
              exit();
          }
          EOF

          # 运行简单测试
          bpftrace simple_test.bt | tee logs/bpftrace_simple.log || echo "Simple bpftrace test failed"

          # 测试tracepoint
          cat > tracepoint_test.bt << 'EOF'
          tracepoint:raw_syscalls:sys_enter {
              printf("Syscall ID: %d\n", args->id);
              if (args->id == 257) {
                  printf("Detected openat syscall\n");
              }
              if (comm == "cat") {
                  printf("Command: cat\n");
              }
              exit();
          }
          EOF

          # 运行tracepoint测试
          timeout 5s bpftrace tracepoint_test.bt > logs/bpftrace_tracepoint.log 2>&1 &
          BPFTRACE_PID=$!
          sleep 2
          cat /etc/os-release # Keep this command if it's needed for the test logic
          sleep 2
          kill $BPFTRACE_PID 2>/dev/null || echo "bpftrace already ended"

          cat logs/bpftrace_tracepoint.log

          # 检查是否有基本跟踪输出
          if grep -q "Syscall ID\|Detected openat\|Command: cat" logs/bpftrace_tracepoint.log; then
            echo "SUCCESS: Basic tracepoint test passed"
          else
            echo "WARNING: No tracepoint output detected, continuing with other tests"
          fi

      # Step 4: Build and install runtime (from bpftime workflow)
      - name: Build and install runtime
        run: |
          export INSTALL_DIR=$HOME/.bpftime
          echo "Building bpftime, installing to $INSTALL_DIR"

          cmake -Bbuild -DCMAKE_BUILD_TYPE:STRING=RelWithDebInfo \
            -DCMAKE_INSTALL_PREFIX=$INSTALL_DIR \
            -DBPFTIME_LLVM_JIT=1 \
            -DBUILD_BPFTIME_DAEMON=1 \
            -DCMAKE_CXX_FLAGS="-DDEFAULT_LOGGER_OUTPUT_PATH='\"console\"'"

          cmake --build build --config RelWithDebInfo --target install -j$(nproc)

          # 验证安装
          echo "Installed files:"
          ls -la $INSTALL_DIR/

          # 确保有正确的权限
          chmod +x $INSTALL_DIR/*

          # 配置环境变量
          export PATH=$PATH:$INSTALL_DIR
          echo "PATH=$PATH" >> $GITHUB_ENV
          echo "BPFTIME_INSTALL_DIR=$INSTALL_DIR" >> $GITHUB_ENV
          echo "HOME_DIR=$HOME" >> $GITHUB_ENV

      # Step 5: Create test scripts (from bpftime workflow)
      - name: Create test scripts
        run: |
          echo "==== Creating test scripts ===="

          # 创建系统调用测试程序
          cat > test_syscalls.c << 'EOF'
          #include <stdio.h>
          #include <fcntl.h>
          #include <unistd.h>
          #include <string.h>

          int main() {
              printf("Test program starting\n");

              // 重复执行openat系统调用，增加被捕获的机会
              for (int i = 0; i < 10; i++) {
                  printf("Iteration %d: Opening file\n", i);
                  int fd = open("build/install_manifest.txt", O_RDONLY);
                  if (fd >= 0) {
                      char buffer[256];
                      ssize_t bytes_read = read(fd, buffer, sizeof(buffer) - 1); // Capture return value
                      if (bytes_read > 0) buffer[bytes_read] = '\0'; // Null-terminate
                      close(fd);
                      usleep(100000); // 休眠100ms
                  } else {
                      perror("Failed to open file"); // Add error handling
                  }
              }

              printf("Test program completed\n");
              return 0;
          }
          EOF

          # 编译测试程序
          gcc -o test_syscalls test_syscalls.c

          # 创建服务器脚本
          cat > server_script.sh << 'EOF'
          #!/bin/bash
          set -x

          echo "Starting bpftrace server with preload..."
          export HOME_DIR=${HOME_DIR:-$HOME} # Ensure HOME_DIR is set
          export BPFTIME_VM_NAME=${BPFTIME_VM_NAME:-llvm}
          export BPFTIME_LOG_OUTPUT=console

          # 检查是否存在libbpftime-syscall-server.so
          if [ ! -f "$HOME_DIR/.bpftime/libbpftime-syscall-server.so" ]; then
            echo "ERROR: libbpftime-syscall-server.so not found in $HOME_DIR/.bpftime!"
            ls -la $HOME_DIR/.bpftime/ # List contents for debugging
            exit 1
          fi

          # 使用最简单的bpftrace脚本，只跟踪BEGIN和END，减少复杂性
          LD_PRELOAD=$HOME_DIR/.bpftime/libbpftime-syscall-server.so \
          bpftrace -e 'BEGIN { printf("Server started\n"); } END { printf("Server ended\n"); }' > server_log.txt 2>&1

          echo "Server script completed"
          EOF
          chmod +x server_script.sh

          # 创建客户端脚本
          cat > client_script.sh << 'EOF'
          #!/bin/bash
          set -x

          echo "Running client with agent preload..."
          export HOME_DIR=${HOME_DIR:-$HOME} # Ensure HOME_DIR is set
          export BPFTIME_VM_NAME=${BPFTIME_VM_NAME:-llvm}
          export BPFTIME_LOG_OUTPUT=console

          # 检查是否存在libbpftime-agent-transformer.so和libbpftime-agent.so
          if [ ! -f "$HOME_DIR/.bpftime/libbpftime-agent-transformer.so" ]; then
            echo "ERROR: libbpftime-agent-transformer.so not found in $HOME_DIR/.bpftime!"
            ls -la $HOME_DIR/.bpftime/ # List contents for debugging
            exit 1
          fi

          if [ ! -f "$HOME_DIR/.bpftime/libbpftime-agent.so" ]; then
            echo "ERROR: libbpftime-agent.so not found in $HOME_DIR/.bpftime!"
            ls -la $HOME_DIR/.bpftime/ # List contents for debugging
            exit 1
          fi

          # 使用agent预加载运行测试程序
          LD_PRELOAD=$HOME_DIR/.bpftime/libbpftime-agent-transformer.so \
          AGENT_SO=$HOME_DIR/.bpftime/libbpftime-agent.so \
          ./test_syscalls > client_log.txt 2>&1

          echo "Client script completed"
          EOF
          chmod +x client_script.sh

      # Step 6: Test combination with raw_syscalls (from bpftime workflow)
      - name: Test combination with raw_syscalls
        run: |
          echo "==== Testing with raw_syscalls ===="

          # 创建raw_syscalls测试脚本
          cat > raw_syscalls_test.sh << 'EOF'
          #!/bin/bash
          set -e # Exit on error for better debugging
          set -x

          export HOME_DIR=${HOME_DIR:-$HOME}
          export BPFTIME_VM_NAME=${BPFTIME_VM_NAME:-llvm}
          export BPFTIME_INSTALL_DIR=${BPFTIME_INSTALL_DIR:-$HOME_DIR/.bpftime}

          # 检查 preload 库
          if [ ! -f "$BPFTIME_INSTALL_DIR/libbpftime-syscall-server.so" ]; then
            echo "ERROR: Server preload library not found at $BPFTIME_INSTALL_DIR/libbpftime-syscall-server.so"
            exit 1
          fi
          if [ ! -f "$BPFTIME_INSTALL_DIR/libbpftime-agent-transformer.so" ]; then
            echo "ERROR: Agent transformer preload library not found at $BPFTIME_INSTALL_DIR/libbpftime-agent-transformer.so"
            exit 1
          fi
           if [ ! -f "$BPFTIME_INSTALL_DIR/libbpftime-agent.so" ]; then
            echo "ERROR: Agent library not found at $BPFTIME_INSTALL_DIR/libbpftime-agent.so"
            exit 1
          fi

          # 开始跟踪
          echo "Starting raw_syscalls tracing..."
          LD_PRELOAD=$BPFTIME_INSTALL_DIR/libbpftime-syscall-server.so \
          bpftrace -e 'BEGIN { printf("Server started\n"); } raw_syscalls:sys_enter /comm == "test_syscalls"/ { @syscalls[args->id]++; } END { printf("Server ending\n"); print(@syscalls); }' > raw_server.log 2>&1 &
          # Modified bpftrace script to count syscalls from test_syscalls and wait for END

          SERVER_PID=$!
          echo "Server PID: $SERVER_PID"
          sleep 3 # Give server time to initialize

          # 运行客户端
          echo "Running client..."
          LD_PRELOAD=$BPFTIME_INSTALL_DIR/libbpftime-agent-transformer.so \
          BPFTIME_VM_NAME=$BPFTIME_VM_NAME \
          BPFTIME_LOG_OUTPUT=console \
          AGENT_SO=$BPFTIME_INSTALL_DIR/libbpftime-agent.so \
          ./test_syscalls > raw_client.log 2>&1
          CLIENT_EXIT_CODE=$?
          echo "Client finished with exit code $CLIENT_EXIT_CODE"

          # 给服务器时间处理 (important for END block)
          sleep 5 # Increase sleep time

          # 终止服务器 (use SIGTERM first)
          echo "Stopping server PID: $SERVER_PID"
          if ps -p $SERVER_PID > /dev/null; then
            kill -SIGTERM $SERVER_PID # Try graceful shutdown first
            sleep 2
            if ps -p $SERVER_PID > /dev/null; then
               kill -SIGKILL $SERVER_PID # Force kill if still running
            fi
          else
             echo "Server process $SERVER_PID not found"
          fi
          wait $SERVER_PID 2>/dev/null # Wait for the process to actually terminate

          # 显示日志
          echo "=== Server Log (raw_server.log) ==="
          cat raw_server.log

          echo "=== Client Log (raw_client.log) ==="
          cat raw_client.log

          # 检查结果
          FINAL_EXIT_CODE=0
          if grep -q "Server started" raw_server.log && grep -q "Server ending" raw_server.log && grep -q "@syscalls" raw_server.log; then
            echo "SUCCESS: Server started, ended, and collected syscalls with raw_syscalls tracing"
          else
            echo "ERROR: Server did not run correctly with raw_syscalls tracing"
            FINAL_EXIT_CODE=1
          fi

          if [ $CLIENT_EXIT_CODE -eq 0 ] && grep -q "Test program starting" raw_client.log && grep -q "Test program completed" raw_client.log; then
            echo "SUCCESS: Client executed successfully"
          else
            echo "ERROR: Client execution issues detected (Exit code: $CLIENT_EXIT_CODE)"
            FINAL_EXIT_CODE=1
          fi
          exit $FINAL_EXIT_CODE
          EOF
          chmod +x raw_syscalls_test.sh

          # 运行测试
          ./raw_syscalls_test.sh

      # Step 7: Sequential test with named pipe (from bpftime workflow)
      # Note: This test might be inherently problematic if the server exits before the client needs it.
      # Consider if this test logic needs adjustment based on bpftime's expected behavior.
      - name: Sequential test with named pipe (Placeholder - Review Logic)
        run: |
          echo "==== Testing sequential execution (Review Logic) ===="

          # Create a minimal BPF program
          cat > minimal_bpf.bt << 'EOF'
          BEGIN {
              printf("Minimal BPF program started\n");
              # Removed exit() - let the server run until killed or client finishes if needed
          }
          END {
              printf("Minimal BPF program ended\n");
          }
          EOF

          cat > sequential_test.sh << 'EOF'
          #!/bin/bash
          set -e # Exit on error
          set -x

          export HOME_DIR=${HOME_DIR:-$HOME}
          export BPFTIME_VM_NAME=${BPFTIME_VM_NAME:-llvm}
          export BPFTIME_INSTALL_DIR=${BPFTIME_INSTALL_DIR:-$HOME_DIR/.bpftime}

          # Check libraries
          if [ ! -f "$BPFTIME_INSTALL_DIR/libbpftime-syscall-server.so" ]; then echo "ERROR: Server lib missing"; exit 1; fi
          if [ ! -f "$BPFTIME_INSTALL_DIR/libbpftime-agent-transformer.so" ]; then echo "ERROR: Agent transformer lib missing"; exit 1; fi
          if [ ! -f "$BPFTIME_INSTALL_DIR/libbpftime-agent.so" ]; then echo "ERROR: Agent lib missing"; exit 1; fi


          # Start server in background
          echo "Starting minimal server process in background..."
          LD_PRELOAD=$BPFTIME_INSTALL_DIR/libbpftime-syscall-server.so \
          bpftrace minimal_bpf.bt > sequential_server.log 2>&1 &
          SERVER_PID=$!
          echo "Server PID: $SERVER_PID"
          sleep 3 # Allow server to start

          # Check if server is running
          if ! ps -p $SERVER_PID > /dev/null; then
              echo "ERROR: Server failed to start!"
              cat sequential_server.log
              exit 1
          fi

          # Run client
          echo "Running client process..."
          LD_PRELOAD=$BPFTIME_INSTALL_DIR/libbpftime-agent-transformer.so \
          BPFTIME_VM_NAME=$BPFTIME_VM_NAME \
          BPFTIME_LOG_OUTPUT=console \
          AGENT_SO=$BPFTIME_INSTALL_DIR/libbpftime-agent.so \
          ./test_syscalls > sequential_client.log 2>&1
          CLIENT_EXIT=$?
          echo "Client process exited with status: $CLIENT_EXIT"

          # Stop the server
          echo "Stopping server PID: $SERVER_PID"
           if ps -p $SERVER_PID > /dev/null; then
               kill -SIGTERM $SERVER_PID || true # Allow failure if already exited
               sleep 2
               kill -SIGKILL $SERVER_PID || true # Force kill if needed
           fi
           wait $SERVER_PID 2>/dev/null

          # Display logs
          echo "=== Server Log (sequential_server.log) ==="
          cat sequential_server.log

          echo "=== Client Log (sequential_client.log) ==="
          cat sequential_client.log

          # Check results
          FINAL_EXIT_CODE=0
          if grep -q "Minimal BPF program started" sequential_server.log; then
              echo "SUCCESS: Minimal server started"
          else
              echo "ERROR: Server did not start properly"
              FINAL_EXIT_CODE=1
          fi

          if [ $CLIENT_EXIT -eq 0 ] && grep -q "Test program starting" sequential_client.log && grep -q "Test program completed" sequential_client.log; then
              echo "SUCCESS: Client executed successfully"
          else
              echo "ERROR: Client execution issues detected (Exit code: $CLIENT_EXIT)"
              FINAL_EXIT_CODE=1
          fi
          exit $FINAL_EXIT_CODE
          EOF
          chmod +x sequential_test.sh

          # Run test
          ./sequential_test.sh

      # Step 8: Test with daemon mode (from bpftime workflow)
      - name: Test with daemon mode
        run: |
          echo "==== Testing with daemon mode ===="
          set -e # Exit on error
          set -x

          export HOME_DIR=${HOME_DIR:-$HOME}
          export BPFTIME_INSTALL_DIR=${BPFTIME_INSTALL_DIR:-$HOME_DIR/.bpftime}
          export BPFTIME_DAEMON_PATH=$BPFTIME_INSTALL_DIR/bpftime_daemon
          export BPFTIME_LOAD_PATH=$BPFTIME_INSTALL_DIR/bpftime

          # Check daemon/load executables
          if [ ! -x "$BPFTIME_DAEMON_PATH" ]; then echo "ERROR: bpftime_daemon not found or not executable"; exit 1; fi
          if [ ! -x "$BPFTIME_LOAD_PATH" ]; then echo "ERROR: bpftime load not found or not executable"; exit 1; fi

          # Start daemon
          echo "Starting daemon..."
          $BPFTIME_DAEMON_PATH > logs/daemon.log 2>&1 &
          DAEMON_PID=$!
          echo "Daemon potentially started with PID: $DAEMON_PID"

          # Wait for daemon initialization and check
          sleep 5 # Increase wait time
          if ps -p $DAEMON_PID > /dev/null; then
            echo "Daemon is running with PID: $DAEMON_PID"
          else
            echo "ERROR: Daemon process $DAEMON_PID not found after starting!"
            echo "--- Daemon Log ---"
            cat logs/daemon.log
            echo "------------------"
            exit 1
          fi

          # Create a bpftrace script for daemon test
          cat > daemon_test.bt << 'EOF'
          BEGIN {
              printf("Daemon mode bpftrace test started\n");
              printf("This should be captured by the bpftime daemon\n");
          }
          // Add a tracepoint to ensure interaction
          tracepoint:syscalls:sys_enter_openat /comm == "test_syscalls"/ {
              printf("Daemon saw openat\n");
              @opens++;
          }
          END {
             printf("Daemon mode bpftrace test ended. Opens: %d\n", @opens);
             // exit(); // Let bpftime load handle exit
          }
          EOF

          # Use bpftime load to run bpftrace
          echo "Running bpftrace with daemon via bpftime load..."
          # Run bpftrace in background controlled by bpftime load
          $BPFTIME_LOAD_PATH bpftrace daemon_test.bt > logs/daemon_bpftrace_load.log 2>&1 &
          BPFTRACE_LOAD_PID=$!
          echo "bpftime load (bpftrace) PID: $BPFTRACE_LOAD_PID"
          sleep 2 # Give it time to attach

          # Use bpftime load to run the test program
          echo "Running test program with daemon via bpftime load..."
          $BPFTIME_LOAD_PATH ./test_syscalls > logs/daemon_test_load.log 2>&1
          TEST_EXIT_CODE=$?
          echo "Test program finished with exit code $TEST_EXIT_CODE"

          # Allow bpftrace END block to run - need to signal termination appropriately
          # This part is tricky - how does bpftime load signal termination to the controlled process?
          # Assuming killing the load process might work, or maybe it exits automatically.
          sleep 3 # Give bpftrace time to process END block if possible
          if ps -p $BPFTRACE_LOAD_PID > /dev/null; then
              echo "Stopping bpftime load (bpftrace)..."
              kill -SIGTERM $BPFTRACE_LOAD_PID || true
              sleep 1
              kill -SIGKILL $BPFTRACE_LOAD_PID || true
          fi
          wait $BPFTRACE_LOAD_PID 2>/dev/null

          # Terminate daemon
          echo "Stopping daemon PID: $DAEMON_PID"
          kill -SIGTERM $DAEMON_PID || echo "Daemon $DAEMON_PID already ended?"
          sleep 2
          kill -SIGKILL $DAEMON_PID || true # Force kill if needed
          wait $DAEMON_PID 2>/dev/null

          # Display logs
          echo "=== Daemon Log (logs/daemon.log) ==="
          cat logs/daemon.log

          echo "=== Daemon Bpftrace Load Log (logs/daemon_bpftrace_load.log) ==="
          cat logs/daemon_bpftrace_load.log

          echo "=== Daemon Test Program Load Log (logs/daemon_test_load.log) ==="
          cat logs/daemon_test_load.log

          # Check results
          FINAL_EXIT_CODE=0
          # Check bpftrace output *within the daemon log* if that's where it goes, or load log
          # Adjust grep location based on expected output destination
          if grep -q "Daemon mode bpftrace test started" logs/daemon.log || grep -q "Daemon mode bpftrace test started" logs/daemon_bpftrace_load.log ; then
              echo "SUCCESS: Daemon mode bpftrace test started"
              if grep -q "Daemon saw openat" logs/daemon.log || grep -q "Daemon saw openat" logs/daemon_bpftrace_load.log; then
                   echo "SUCCESS: Daemon mode bpftrace saw tracepoint"
              else
                   echo "WARNING: Daemon mode bpftrace did not see tracepoint hit"
                   # FINAL_EXIT_CODE=1 # Optional: make this a failure condition
              fi
          else
              echo "ERROR: Daemon mode bpftrace test did not start correctly"
              FINAL_EXIT_CODE=1
          fi

          if [ $TEST_EXIT_CODE -eq 0 ] && grep -q "Test program starting" logs/daemon_test_load.log && grep -q "Test program completed" logs/daemon_test_load.log; then
            echo "SUCCESS: Daemon mode test program executed successfully via load"
          else
            echo "ERROR: Daemon mode test program execution failed (Exit Code: $TEST_EXIT_CODE)"
            FINAL_EXIT_CODE=1
          fi
          exit $FINAL_EXIT_CODE


      # Step 9: Test summary (modified to exit 0 only if ALL tests implicitly passed by not exiting earlier)
      # Note: with set -e in test scripts, the workflow will fail on the first error.
      # This summary step might only be reached if all tests passed or used `|| true` / explicit exit codes.
      - name: Test summary
        run: |
          echo "==== Test Summary ===="
          # If we reached here without any prior step failing (due to set -e or explicit exit 1), assume success.
          echo "OVERALL RESULT: All executed tests passed or completed without critical errors."
          # Optional: Add more specific checks on logs if needed for weaker pass conditions
          exit 0


      # Step 10: Add tmate for debugging *only if* any previous step failed
      # This step will only run if any of the steps above it failed (returned non-zero exit code)
      - name: Setup tmate session on failure
        uses: mxschmitt/action-tmate@v3
        if: failure() # IMPORTANT: Only run this step if the job has failed
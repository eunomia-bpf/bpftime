name: BPFtime Syscall Tracing (Load/Start) Test

on:
  push:
    branches: [ "*" ]
  pull_request:
    branches: [ "*" ]
  workflow_dispatch: # Enable manual trigger

env:
  BPFTIME_VM_NAME: llvm
  # Set log level and output for debugging, can be info or debug if needed
  SPDLOG_LEVEL: error
  BPFTIME_LOG_OUTPUT: console
  # Default shared memory path, overridden if needed below
  BPFTIME_SHARED_MEMORY_PATH: /dev/shm

jobs:
  syscall-tracing-load-start-test:
    runs-on: ubuntu-22.04
    container:
      image: "manjusakalza/bpftime-base-image:ubuntu-2204"
      # Add necessary mounts and privileges for BPF/tracing/shared memory
      options: "--privileged -v /sys/kernel/debug:/sys/kernel/debug:rw -v /sys/kernel/tracing:/sys/kernel/tracing:rw -v /dev/shm:/dev/shm:rw -v /tmp:/tmp:rw"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'

      - name: System setup and kernel headers
        run: |
          apt-get update
          apt-get install -y --no-install-recommends \
            lcov tree strace gdb sudo libc6-dev bpftrace \
            linux-headers-generic linux-tools-generic \
            linux-headers-$(uname -r) \
            libelf-dev # Needed for bpftrace compilation often

          echo "==== System Information ===="
          uname -a
          cat /etc/os-release

          echo "==== Checking bpftrace availability ===="
          which bpftrace
          bpftrace --version

          echo "==== Checking tracepoint availability ===="
          # Check for the specific tracepoint used in the test
          bpftrace -l 'tracepoint:syscalls:sys_enter_openat' > /dev/null 2>&1 || { echo "syscalls:sys_enter_openat tracepoint not found or bpftrace failed"; exit 1; }
          echo "syscalls:sys_enter_openat tracepoint found."

          echo "==== Checking kernel capabilities ===="
          ls -la /sys/kernel/debug/tracing/ || echo "Debug tracing not accessible"
          ls -la /sys/kernel/tracing/ || echo "Kernel tracing not accessible"

          # Ensure /dev/shm exists and is writable, or use /tmp as fallback
          mkdir -p /dev/shm /run/shm /tmp/bpftime_shm
          chmod 777 /dev/shm /run/shm /tmp/bpftime_shm
          ls -la /dev/shm /run/shm /tmp/bpftime_shm || echo "Warning: Could not list shm dirs"

          echo "==== Preparing test files and directories ===="
          mkdir -p build logs
          # Create the file that 'cat' will try to open
          echo "TEST_MARKER_LINE_1" > build/install_manifest.txt
          echo "TEST_MARKER_LINE_2" >> build/install_manifest.txt
          echo "Created build/install_manifest.txt:"
          cat build/install_manifest.txt

      - name: Test bpftrace basic functionality (sanity check)
        run: |
          echo "==== Testing bpftrace basic functionality ===="
          # Simple test to see if bpftrace can attach and run
          timeout -k 5s 4s bpftrace -e 'tracepoint:raw_syscalls:sys_enter { printf("Syscall ID %d\n", args->id); exit(0); }' > logs/bpftrace_sanity_test.log 2>&1 || echo "Bpftrace sanity test completed with non-zero exit (expected with timeout/exit)"
          echo "Bpftrace sanity test log:"
          cat logs/bpftrace_sanity_test.log
          if grep -q "Syscall ID" logs/bpftrace_sanity_test.log; then
             echo "SUCCESS: Basic bpftrace sanity test ran and produced output."
          else
             echo "WARNING: Basic bpftrace sanity test did not produce expected output, but continuing."
          fi


      - name: Build and install runtime
        run: |
          export INSTALL_DIR=$HOME/.bpftime
          echo "Building bpftime, installing to $INSTALL_DIR"

          # Note: Ensure BUILD_BPFTIME_DAEMON=1 and BUILD_AGENT=1 are set for the load/start model
          cmake -Bbuild -DCMAKE_BUILD_TYPE:STRING=RelWithDebInfo \
            -DCMAKE_INSTALL_PREFIX=$INSTALL_DIR \
            -DBPFTIME_LLVM_JIT=1 \
            -DBUILD_BPFTIME_DAEMON=1 \
            -DBUILD_AGENT=1 \
            -DCMAKE_CXX_FLAGS="-DDEFAULT_LOGGER_OUTPUT_PATH='\"console\"'"

          cmake --build build --config RelWithDebInfo --target install -j$(nproc)

          echo "Installed files:"
          ls -la $INSTALL_DIR/
          chmod +x $INSTALL_DIR/* || echo "Warning: Could not chmod installed files"

          # Add install dir to PATH for subsequent steps
          echo "PATH=$INSTALL_DIR:$PATH" >> $GITHUB_ENV
          echo "BPFTIME_INSTALL_DIR=$INSTALL_DIR" >> $GITHUB_ENV
          echo "HOME_DIR=$HOME" >> $GITHUB_ENV

      - name: Run BPFTIME Load/Start Syscall Tracing Test
        run: |
          echo "==== Running BPFTIME load/start test ===="

          # Use an available writable shared memory path
          SHM_PATH="/dev/shm"
          if [ ! -d "$SHM_PATH" ] || [ ! -w "$SHM_PATH" ]; then
             SHM_PATH="/run/shm"
          fi
          if [ ! -d "$SHM_PATH" ] || [ ! -w "$SHM_PATH" ]; then
             SHM_PATH="/tmp" # Fallback
          fi
           if [ ! -d "$SHM_PATH" ] || [ ! -w "$SHM_PATH" ]; then
             SHM_PATH="/tmp/bpftime_shm" # Another fallback
          fi
          export BPFTIME_SHARED_MEMORY_PATH="$SHM_PATH"
          echo "Using BPFTIME_SHARED_MEMORY_PATH=$BPFTIME_SHARED_MEMORY_PATH"

          BPFTIME_BIN="$HOME/.bpftime/bpftime"
          # Define the bpftrace script inline
          BPFTRACE_SCRIPT='tracepoint:syscalls:sys_enter_openat { printf("%s %s\n", comm, str(args->filename)); }'
          CLIENT_COMMAND="cat build/install_manifest.txt" # The command to run via bpftime start
          SERVER_LOG="logs/bpftime_server.log"
          CLIENT_LOG="logs/bpftime_client.log"

          # Check if bpftime binary exists and is executable
          if [ ! -x "$BPFTIME_BIN" ]; then
            echo "ERROR: bpftime binary not found or not executable at $BPFTIME_BIN"
            exit 1
          fi

          echo "Starting bpftime load (server) with bpftrace script..."
          # Start the server in the background. Use timeout to prevent it hanging.
          # Redirect stdout/stderr to the log file.
          # Note: bpftrace with tracepoints often needs root, so use sudo.
          # SPDLOG_LEVEL and BPFTIME_LOG_OUTPUT are picked up from env.
          sudo -E timeout -k 40s 35s "$BPFTIME_BIN" load bpftrace -e "$BPFTRACE_SCRIPT" > "$SERVER_LOG" 2>&1 &
          SERVER_PID=$!
          echo "BPFTIME server PID: $SERVER_PID"

          # Give the server a few seconds to initialize and load the program
          echo "Waiting for server to initialize..."
          sleep 7 # Increased sleep duration for stability

          # Check if server process is still running
          if ! ps -p $SERVER_PID > /dev/null; then
            echo "ERROR: BPFTIME server failed to start or exited prematurely!"
            echo "Server log:"
            cat "$SERVER_LOG"
            # Attempt to get dmesg for kernel errors
            sudo dmesg | tail -n 50 || echo "Could not get dmesg"
            exit 1
          fi
          echo "Server is running (PID $SERVER_PID)."

          echo "Running bpftime start (client) command: '$CLIENT_COMMAND'..."
          # Run the client command using bpftime start.
          # The agent SO is automatically found by bpftime if it's in the install dir.
          # Use sudo as the client might interact with the kernel/agent needs privs.
          # Capture client stdout/stderr separately if needed, but for this test,
          # we only care if the server captures its syscalls.
          sudo -E "$BPFTIME_BIN" start -s "$CLIENT_COMMAND" > "$CLIENT_LOG" 2>&1
          CLIENT_EXIT_CODE=$?
          echo "Client command exit code: $CLIENT_EXIT_CODE"

          # Give the server a moment to process final events after the client finishes
          echo "Waiting for server to capture final events..."
          sleep 3

          echo "Stopping BPFTIME server PID $SERVER_PID..."
          # Check if the server is still running before trying to kill it
          if ps -p $SERVER_PID > /dev/null; then
            kill $SERVER_PID 2>/dev/null || true # Kill gracefully
            wait $SERVER_PID 2>/dev/null || true # Wait for it to exit
            echo "Server stopped."
          else
            echo "WARNING: Server process $SERVER_PID already exited."
          fi

          echo "=== BPFTIME Server Log ==="
          cat "$SERVER_LOG" || echo "No server log available"

          echo "=== BPFTIME Client Log ==="
          cat "$CLIENT_LOG" || echo "No client log available"


          # --- Test Result Check ---
          echo "Checking server log for expected openat traces from client..."

          # Expected output patterns from bpftrace script:
          # The command name (comm) will be 'cat', the filename will be the one cat opens.
          # cat usually opens /usr/lib/locale/locale-archive first, then build/install_manifest.txt
          EXPECTED_PATTERNS=(
            "cat /usr/lib/locale/locale-archive"
            "cat build/install_manifest.txt"
          )

          TEST_SUCCESS=false
          for pattern in "${EXPECTED_PATTERNS[@]}"; do
            echo "Searching for pattern: '$pattern'"
            if grep -q "$pattern" "$SERVER_LOG"; then
              echo "Found pattern: '$pattern'"
              TEST_SUCCESS=true
              # Break after finding any required pattern, or check all if desired
              # break # uncomment to pass if *any* match
            fi
          done

          if [ "$TEST_SUCCESS" = "true" ]; then
            echo "SUCCESS: Detected expected openat syscall traces in server log."
            exit 0
          else
            echo "ERROR: Did not detect expected openat syscall traces for 'cat' command in server log."
            echo "Dumping dmesg tail for potential kernel errors:"
            sudo dmesg | tail -n 50 || echo "Could not get dmesg"
            exit 1
          fi
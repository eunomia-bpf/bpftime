name: BPFtime Syscall Tracing (LD_PRELOAD Method)

on:
  push:
    branches: [ "*" ]
  pull_request:
    branches: [ "*" ]
  workflow_dispatch:

env:
  BPFTIME_VM_NAME: llvm
  SPDLOG_LEVEL: debug
  BPFTIME_LOG_OUTPUT: console
  BPFTIME_SHARED_MEMORY_PATH: /dev/shm
  SERVER_LOG: logs/bpftime_server.log
  CLIENT_LOG: logs/bpftime_client.log
  TRACE_LOG: logs/trace_output.log

jobs:
  syscall-tracing-load-start-test:
    runs-on: ubuntu-22.04
    container:
      image: "manjusakalza/bpftime-base-image:ubuntu-2204"
      options: "--privileged -v /sys/kernel/debug:/sys/kernel/debug:rw -v /sys/kernel/tracing:/sys/kernel/tracing:rw -v /dev/shm:/dev/shm:rw -v /tmp:/tmp:rw -v /run/shm:/run/shm:rw"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'

      - name: System setup and kernel headers
        run: |
          apt-get update
          apt-get install -y --no-install-recommends \
            lcov tree strace gdb sudo libc6-dev bpftrace \
            linux-headers-generic linux-tools-generic \
            linux-headers-$(uname -r) \
            libelf-dev procps
          echo "==== System Information ===="; uname -a && cat /etc/os-release
          echo "==== bpftrace version ===="; which bpftrace && bpftrace --version || echo "bpftrace not found"
          mkdir -p logs build
          echo "TEST_DATA_LINE_1_ABC" > build/install_manifest.txt
          echo "TEST_DATA_LINE_2_XYZ" >> build/install_manifest.txt
          echo "Created build/install_manifest.txt:"; cat build/install_manifest.txt

      - name: Build bpftime
        run: |
          echo "Building bpftime with CMake"
          cmake -Bbuild -DCMAKE_BUILD_TYPE:STRING=RelWithDebInfo \
            -DBPFTIME_LLVM_JIT=1 \
            -DBUILD_BPFTIME_DAEMON=1 \
            -DBUILD_AGENT=1 \
            -DCMAKE_CXX_FLAGS="-DDEFAULT_LOGGER_OUTPUT_PATH='\"console\"'"
          cmake --build build --config RelWithDebInfo -j$(nproc)
          
          echo "Checking built libraries:"
          ls -la build/runtime/agent/
          ls -la build/runtime/syscall-server/
          
          # 检查库文件依赖
          echo "Checking library dependencies:"
          ldd build/runtime/agent/libbpftime-agent.so || echo "Could not check agent dependencies"
          ldd build/runtime/syscall-server/libbpftime-syscall-server.so || echo "Could not check server dependencies"

      - name: Verify environment
        run: |
          echo "=== Verifying environment ==="
          
          # 检查环境变量
          echo "Environment variables:"
          env | grep BPFTIME || echo "No BPFTIME environment variables found"
          
          # 确保共享内存目录存在且权限正确
          sudo mkdir -p $BPFTIME_SHARED_MEMORY_PATH
          sudo chmod 1777 $BPFTIME_SHARED_MEMORY_PATH
          ls -la $BPFTIME_SHARED_MEMORY_PATH
          
          # 验证bpftrace功能
          echo "Testing basic bpftrace functionality..."
          timeout 5s bpftrace -e 'BEGIN { printf("bpftrace test successful\n"); exit(); }' || echo "Basic bpftrace test failed"

      - name: Verify openat syscall with strace
        run: |
          echo "=== Verifying openat syscall with strace ==="
          
          # 使用strace验证cat命令确实调用了openat系统调用
          strace -e openat cat build/install_manifest.txt > logs/cat_output.txt 2> logs/cat_strace.txt
          
          echo "Cat command output:"
          cat logs/cat_output.txt
          
          echo "Strace output:"
          cat logs/cat_strace.txt
          
          # 确认openat调用
          if grep -q "openat.*build/install_manifest.txt" logs/cat_strace.txt; then
            echo "CONFIRMED: 'cat build/install_manifest.txt' does call openat syscall"
          else
            echo "ERROR: Could not confirm openat syscall in strace output"
            exit 1
          fi

      - name: Start syscall server with LD_PRELOAD
        run: |
          echo "=== Starting syscall server with LD_PRELOAD ==="
          
          # 确保日志目录存在
          mkdir -p logs
          
          # 创建一个明确的bpftrace脚本，专门用于捕获cat命令
          cat > /tmp/cat_trace.bt << 'EOT'
          tracepoint:syscalls:sys_enter_openat { 
              printf("SERVER_TRACE (openat): %s %s\n", comm, str(args->filename));
              if (comm == "cat") {
                  printf("CAT_COMMAND_DETECTED: %s is accessing file %s\n", comm, str(args->filename));
              }
          }
          EOT
          
          # 设置库路径
          SERVER_LIB="$PWD/build/runtime/syscall-server/libbpftime-syscall-server.so"
          
          # 确保库文件存在
          if [ ! -f "$SERVER_LIB" ]; then
            echo "ERROR: Server library not found at $SERVER_LIB"
            exit 1
          fi
          
          # 启动服务器，使用script命令确保输出不缓冲
          script -c "sudo -E LD_PRELOAD=$SERVER_LIB bpftrace /tmp/cat_trace.bt" -f "$SERVER_LOG" &
          
          SERVER_PID=$!
          echo "Server started with PID: $SERVER_PID"
          echo "SERVER_PID=$SERVER_PID" >> $GITHUB_ENV
          
          # 等待服务器初始化
          echo "Waiting for server to initialize (20s)..."
          sleep 20
          
          # 检查服务器进程是否在运行
          if ps -p $SERVER_PID > /dev/null; then
            echo "Server process $SERVER_PID is running"
          else
            echo "ERROR: Server process $SERVER_PID did not start or died!"
            cat "$SERVER_LOG" || echo "Server log not found"
            exit 1
          fi
          
          # 检查服务器日志
          echo "Initial server log:"
          cat "$SERVER_LOG" || echo "Server log not available yet"
          
          # 检查是否有"Attaching"消息
          if grep -q "Attaching" "$SERVER_LOG"; then
            echo "Server initialized with probe(s) attached"
          else
            echo "WARNING: Did not find 'Attaching' message in server log"
          fi
          
          # 检查共享内存文件
          ls -l "$BPFTIME_SHARED_MEMORY_PATH/bpftime_maps_shm" || echo "WARNING: SHM file not found"

      - name: Run cat command with LD_PRELOAD
        run: |
          echo "=== Running cat command with LD_PRELOAD ==="
          
          # 验证服务器仍在运行
          SERVER_PID_CHECK=${{ env.SERVER_PID }}
          if [ -z "$SERVER_PID_CHECK" ] || ! ps -p $SERVER_PID_CHECK > /dev/null; then
            echo "ERROR: Server process is not running!"
            cat "$SERVER_LOG" || echo "Server log not found"
            exit 1
          fi
          
          # 设置库路径
          AGENT_LIB="$PWD/build/runtime/agent/libbpftime-agent.so"
          
          # 确保库文件存在
          if [ ! -f "$AGENT_LIB" ]; then
            echo "ERROR: Agent library not found at $AGENT_LIB"
            exit 1
          fi
          
          # 在服务器日志中添加标记
          echo "=== BEFORE CAT COMMAND EXECUTION ===" | sudo tee -a "$SERVER_LOG"
          
          # 运行cat命令
          echo "Running cat command with LD_PRELOAD..."
          sudo -E LD_PRELOAD=$AGENT_LIB cat build/install_manifest.txt | tee "$CLIENT_LOG"
          
          CAT_EXIT_CODE=$?
          echo "CAT_EXIT_CODE=$CAT_EXIT_CODE" >> $GITHUB_ENV
          
          # 添加结束标记
          echo "=== AFTER CAT COMMAND EXECUTION ===" | sudo tee -a "$SERVER_LOG"
          
          # 等待一会儿让服务器处理事件
          echo "Waiting for server to process events (10s)..."
          sleep 10
          
          # 强制刷新任何缓冲的输出
          sync
          
          # 显示服务器日志
          echo "Server log after cat command execution:"
          cat "$SERVER_LOG" || echo "Server log not available"

      - name: Run additional cat commands
        run: |
          echo "=== Running additional cat commands ==="
          
          # 设置库路径
          AGENT_LIB="$PWD/build/runtime/agent/libbpftime-agent.so"
          
          # 添加标记
          echo "=== BEFORE ADDITIONAL CAT COMMANDS ===" | sudo tee -a "$SERVER_LOG"
          
          # 运行多个cat命令访问不同的文件
          echo "Running cat on /etc/passwd..."
          sudo -E LD_PRELOAD=$AGENT_LIB cat /etc/passwd > /dev/null
          
          echo "Running cat on /etc/hosts..."
          sudo -E LD_PRELOAD=$AGENT_LIB cat /etc/hosts > /dev/null
          
          echo "Running cat on /etc/os-release..."
          sudo -E LD_PRELOAD=$AGENT_LIB cat /etc/os-release > /dev/null
          
          # 添加结束标记
          echo "=== AFTER ADDITIONAL CAT COMMANDS ===" | sudo tee -a "$SERVER_LOG"
          
          # 等待处理事件
          sleep 10
          
          # 强制刷新
          sync

      - name: Check for cat command traces
        run: |
          echo "=== Checking for cat command traces ==="
          
          # 强制刷新文件系统缓冲区
          sync
          
          # 显示完整的服务器日志
          echo "Full server log content:"
          cat "$SERVER_LOG" || echo "Server log not available"
          
          # 检查是否有任何CAT_COMMAND_DETECTED输出
          if grep -q "CAT_COMMAND_DETECTED" "$SERVER_LOG"; then
            echo "SUCCESS: Found CAT_COMMAND_DETECTED output in server log"
            CAT_COMMAND_DETECTED="true"
          else
            echo "FAILURE: No CAT_COMMAND_DETECTED output found in server log"
            CAT_COMMAND_DETECTED="false"
          fi
          
          # 检查是否有任何cat命令的SERVER_TRACE输出
          if grep -q "SERVER_TRACE.*cat.*" "$SERVER_LOG"; then
            echo "SUCCESS: Found SERVER_TRACE for cat command in server log"
            CAT_TRACE_FOUND="true"
          else
            echo "FAILURE: No SERVER_TRACE for cat command found in server log"
            CAT_TRACE_FOUND="false"
          fi
          
          # 检查特定文件的跟踪
          if grep -q "SERVER_TRACE.*cat.*build/install_manifest.txt" "$SERVER_LOG"; then
            echo "SUCCESS: Found trace for cat accessing build/install_manifest.txt"
            MANIFEST_TRACE_FOUND="true"
          else
            echo "FAILURE: Did not find trace for cat accessing build/install_manifest.txt"
            MANIFEST_TRACE_FOUND="false"
          fi
          
          # 保存结果到环境变量
          echo "CAT_COMMAND_DETECTED=$CAT_COMMAND_DETECTED" >> $GITHUB_ENV
          echo "CAT_TRACE_FOUND=$CAT_TRACE_FOUND" >> $GITHUB_ENV
          echo "MANIFEST_TRACE_FOUND=$MANIFEST_TRACE_FOUND" >> $GITHUB_ENV

      - name: Stop Server and Analyze Results
        if: always()
        run: |
          echo "=== Stop Server and Analyze Results ==="
          SERVER_PID_TO_KILL=${{ env.SERVER_PID }}
          CAT_EXIT_CODE=${CAT_EXIT_CODE:-99}
          CAT_COMMAND_DETECTED=${CAT_COMMAND_DETECTED:-false}
          CAT_TRACE_FOUND=${CAT_TRACE_FOUND:-false}
          MANIFEST_TRACE_FOUND=${MANIFEST_TRACE_FOUND:-false}
          
          # 停止服务器
          if [ -n "$SERVER_PID_TO_KILL" ] && ps -p $SERVER_PID_TO_KILL > /dev/null; then
            echo "Stopping server process PID $SERVER_PID_TO_KILL..."
            sudo kill -9 $SERVER_PID_TO_KILL 2>/dev/null || echo "Kill failed"
            sleep 2
          fi
          
          # 分析结果
          echo "=== Final Analysis ==="
          
          # 检查cat命令是否成功运行
          if [ "$CAT_EXIT_CODE" = "0" ]; then
            echo "SUCCESS: Cat command executed successfully with exit code 0"
            CAT_SUCCESS="true"
          else
            echo "FAILURE: Cat command failed with exit code $CAT_EXIT_CODE"
            CAT_SUCCESS="false"
          fi
          
          # 检查是否检测到cat命令的系统调用
          if [ "$CAT_COMMAND_DETECTED" = "true" ] || [ "$CAT_TRACE_FOUND" = "true" ] || [ "$MANIFEST_TRACE_FOUND" = "true" ]; then
            echo "SUCCESS: Cat command tracing is working"
            TRACING_SUCCESS="true"
          else
            echo "FAILURE: Cat command tracing is NOT working"
            TRACING_SUCCESS="false"
          fi
          
          # 最终结果判断
          if [ "$CAT_SUCCESS" = "true" ] && [ "$TRACING_SUCCESS" = "true" ]; then
            echo "OVERALL SUCCESS: Cat command ran successfully AND tracing detected cat command"
            exit 0
          else
            echo "FAILURE: Test did not meet all success criteria"
            if [ "$CAT_SUCCESS" != "true" ]; then
              echo "  - Cat command execution failed with exit code $CAT_EXIT_CODE"
            fi
            if [ "$TRACING_SUCCESS" != "true" ]; then
              echo "  - Cat command tracing is not working"
            fi
            exit 1
          fi

name: BPFtime Syscall Tracing (Load/Start) Test

on:
  push:
    branches: [ "*" ]
  pull_request:
    branches: [ "*" ]
  workflow_dispatch: # Enable manual trigger

env:
  BPFTIME_VM_NAME: llvm
  # Keep log level high for debugging
  SPDLOG_LEVEL: debug
  BPFTIME_LOG_OUTPUT: console
  # Default shared memory path
  BPFTIME_SHARED_MEMORY_PATH: /dev/shm

jobs:
  syscall-tracing-load-start-test:
    runs-on: ubuntu-22.04
    container:
      image: "manjusakalza/bpftime-base-image:ubuntu-2204"
      # Ensure all relevant paths are mounted and writable
      options: "--privileged -v /sys/kernel/debug:/sys/kernel/debug:rw -v /sys/kernel/tracing:/sys/kernel/tracing:rw -v /dev/shm:/dev/shm:rw -v /tmp:/tmp:rw -v /run/shm:/run/shm:rw"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'

      - name: System setup and kernel headers
        run: |
          apt-get update
          # Add strace for system call tracing
          apt-get install -y --no-install-recommends \
            lcov tree strace gdb sudo libc6-dev bpftrace \
            linux-headers-generic linux-tools-generic \
            linux-headers-$(uname -r) \
            libelf-dev procps strace

          echo "==== System Information ===="
          uname -a
          cat /etc/os-release

          echo "==== Checking bpftrace availability ===="
          which bpftrace && bpftrace --version || echo "bpftrace not found"

          echo "==== Checking tracepoint availability ===="
          bpftrace -l 'tracepoint:syscalls:sys_enter_openat' > /dev/null 2>&1 || echo "WARNING: syscalls:sys_enter_openat tracepoint check failed"
          echo "syscalls:sys_enter_openat tracepoint check complete."

          echo "==== Checking kernel capabilities ===="
          ls -la /sys/kernel/debug/tracing/ || echo "Debug tracing not accessible"
          ls -la /sys/kernel/tracing/ || echo "Kernel tracing not accessible"

          echo "==== Preparing test files and directories ===="
          mkdir -p build logs
          mkdir -p /dev/shm /run/shm /tmp/bpftime_shm
          chmod 777 /dev/shm /run/shm /tmp/bpftime_shm
          ls -la /dev/shm /run/shm /tmp/bpftime_shm || echo "Warning: Could not list shm dirs"

          echo "TEST_MARKER_LINE_1" > build/install_manifest.txt
          echo "TEST_MARKER_LINE_2" >> build/install_manifest.txt
          echo "Created build/install_manifest.txt:"
          cat build/install_manifest.txt
          ls -l build/install_manifest.txt

      # Keep sanity checks
      - name: Test bpftrace basic functionality (sanity check)
        run: |
          echo "==== Testing bpftrace basic functionality ===="
          timeout -k 5s 4s bpftrace -e 'tracepoint:raw_syscalls:sys_enter { printf("Syscall ID %d\n", args->id); exit(0); }' > logs/bpftrace_sanity_test.log 2>&1 || true
          cat logs/bpftrace_sanity_test.log
          grep -q "Syscall ID" logs/bpftrace_sanity_test.log && echo "SUCCESS: Basic bpftrace sanity test ran." || echo "WARNING: Basic bpftrace sanity test missing expected output."

      - name: Build and install runtime
        run: |
          export INSTALL_DIR=$HOME/.bpftime
          echo "Building bpftime, installing to $INSTALL_DIR"
          cmake -Bbuild -DCMAKE_BUILD_TYPE:STRING=RelWithDebInfo \
            -DCMAKE_INSTALL_PREFIX=$INSTALL_DIR \
            -DBPFTIME_LLVM_JIT=1 \
            -DBUILD_BPFTIME_DAEMON=1 \
            -DBUILD_AGENT=1 \
            -DCMAKE_CXX_FLAGS="-DDEFAULT_LOGGER_OUTPUT_PATH='\"console\"'"
          cmake --build build --config RelWithDebInfo --target install -j$(nproc)
          echo "Installed files:"
          ls -la $INSTALL_DIR/
          # Verify agent library exists
          ls -l $INSTALL_DIR/libbpftime-agent.so || { echo "ERROR: libbpftime-agent.so not found after install!"; exit 1; }
          chmod +x $INSTALL_DIR/* || echo "Warning: Could not chmod installed files"
          echo "PATH=$INSTALL_DIR:$PATH" >> $GITHUB_ENV
          echo "BPFTIME_INSTALL_DIR=$INSTALL_DIR" >> $GITHUB_ENV
          echo "HOME_DIR=$HOME" >> $GITHUB_ENV

      - name: Verify client command directly
        run: |
          echo "==== Verifying client command runs directly ===="
          cat build/install_manifest.txt || { echo "ERROR: Direct cat command failed!"; exit 1; }
          echo "Direct cat command succeeded."

      - name: Run BPFTIME Load/Start Syscall Tracing Test
        run: |
          echo "==== Running BPFTIME load/start test ===="
          set -x # Enable command tracing

          # Determine SHM path robustly
          SHM_PATH="/dev/shm"
          if [ ! -d "$SHM_PATH" ] || [ ! -w "$SHM_PATH" ]; then SHM_PATH="/run/shm"; fi
          if [ ! -d "$SHM_PATH" ] || [ ! -w "$SHM_PATH" ]; then SHM_PATH="/tmp"; fi
          if [ ! -d "$SHM_PATH" ] || [ ! -w "$SHM_PATH" ]; then SHM_PATH="/tmp/bpftime_shm"; fi
          export BPFTIME_SHARED_MEMORY_PATH="$SHM_PATH"
          echo "Using BPFTIME_SHARED_MEMORY_PATH=$BPFTIME_SHARED_MEMORY_PATH"

          BPFTIME_BIN="$HOME/.bpftime/bpftime"
          BPFTRACE_SCRIPT='tracepoint:syscalls:sys_enter_openat { printf("CLIENT_SYSCALL_TRACE: %s %s\n", comm, str(args->filename)); }' # Added prefix for clarity
          CLIENT_COMMAND="cat build/install_manifest.txt"
          SERVER_LOG="logs/bpftime_server.log"
          CLIENT_LOG="logs/bpftime_client.log"
          CLIENT_STRACE_LOG="logs/bpftime_client_strace.log"

          # Ensure bpftime binary is executable
          if [ ! -x "$BPFTIME_BIN" ]; then
            echo "ERROR: bpftime binary not found or not executable at $BPFTIME_BIN"
            ls -l "$HOME/.bpftime/"
            exit 1
          fi

          echo "Starting bpftime load (server) with bpftrace script..."
          sudo -E timeout -k 45s 40s "$BPFTIME_BIN" load bpftrace -e "$BPFTRACE_SCRIPT" > "$SERVER_LOG" 2>&1 &
          SERVER_PID=$!
          echo "BPFTIME server PID: $SERVER_PID"

          echo "Waiting for server to initialize (12s)..."
          sleep 12

          # Check server process and shared memory file
          if ! ps -p $SERVER_PID > /dev/null; then
            echo "ERROR: BPFTIME server failed to start or exited prematurely!"
            echo "--- Server Log Start ---"
            cat "$SERVER_LOG" || echo "Server log file not found"
            echo "--- Server Log End ---"
            sudo dmesg | tail -n 50 || echo "Could not get dmesg"
            exit 1
          fi
          echo "Server process $SERVER_PID is running."
          echo "Inspecting shared memory file..."
          ls -l "$BPFTIME_SHARED_MEMORY_PATH/bpftime_maps_shm" || echo "WARNING: Could not list $BPFTIME_SHARED_MEMORY_PATH/bpftime_maps_shm"

          echo "Running bpftime start (client) command with strace: '$CLIENT_COMMAND'..."
          # Run with strace, capture exit code, redirect stdout/stderr to client log
          sudo -E strace -f -s 256 -o "$CLIENT_STRACE_LOG" "$BPFTIME_BIN" start -s "$CLIENT_COMMAND" > "$CLIENT_LOG" 2>&1
          CLIENT_EXIT_CODE=$?
          echo "Client command finished with exit code: $CLIENT_EXIT_CODE"

          # Wait a bit more before stopping server
          echo "Waiting briefly before stopping server..."
          sleep 3

          echo "Stopping BPFTIME server PID $SERVER_PID..."
          if ps -p $SERVER_PID > /dev/null; then
            kill $SERVER_PID 2>/dev/null || true
            wait $SERVER_PID 2>/dev/null || true
            echo "Server stopped."
          else
            echo "WARNING: Server process $SERVER_PID already exited."
          fi

          # --- Crucial Log Output ---
          # Make sure these logs are clearly visible
          echo ""
          echo "#############################################"
          echo "### FINAL CLIENT LOG (logs/bpftime_client.log) ###"
          echo "#############################################"
          cat "$CLIENT_LOG" || echo "<<< Client log file not found or empty >>>"
          echo "#############################################"
          echo ""
          echo "#############################################"
          echo "### FINAL SERVER LOG (logs/bpftime_server.log) ###"
          echo "#############################################"
          cat "$SERVER_LOG" || echo "<<< Server log file not found or empty >>>"
          echo "#############################################"
          echo ""
          echo "#############################################"
          echo "### FINAL CLIENT STRACE LOG (Tail) (logs/bpftime_client_strace.log) ###"
          echo "#############################################"
          tail -n 150 "$CLIENT_STRACE_LOG" || echo "<<< Client strace log file not found or empty >>>"
          echo "#############################################"
          echo ""

          # --- Analysis ---
          echo "Analyzing results..."

          # 1. Primary check: Did the client command fail?
          if [ "$CLIENT_EXIT_CODE" -ne 0 ]; then
             echo ">>> PRIMARY FAILURE: Client command ('$CLIENT_COMMAND' via bpftime start) exited with non-zero code ($CLIENT_EXIT_CODE). <<<"
             echo ">>> This indicates a problem with bpftime start, agent injection, or agent initialization. <<<"
             echo ">>> Please examine the DETAILED Client Log and Client Strace Log printed above. <<<"
             echo ">>> Look for errors related to: shared memory (shm_open, mmap), permissions (EACCES, EPERM), file not found (ENOENT), or agent messages. <<<"
             exit 1 # Fail the job definitively
          fi

          # 2. Secondary check: If client succeeded, did the server trace the syscalls?
          EXPECTED_PATTERN="CLIENT_SYSCALL_TRACE: cat build/install_manifest.txt" # Be more specific
          echo "Searching server log for pattern: '$EXPECTED_PATTERN'"

          if grep -F -q "$EXPECTED_PATTERN" "$SERVER_LOG"; then
            echo "Found expected pattern in server log."
            # Optionally check for the locale pattern too
            if grep -F -q "CLIENT_SYSCALL_TRACE: cat /usr/lib/locale/locale-archive" "$SERVER_LOG"; then
                echo "Also found locale pattern in server log."
            else
                echo "WARNING: Did not find locale pattern, but found target file pattern."
            fi
            echo ">>> SUCCESS: Client ran successfully and server traced the expected syscall. <<<"
            exit 0
          else
            echo ">>> SECONDARY FAILURE: Client ran successfully (Exit Code 0), BUT the server did NOT detect the expected syscall trace ('$EXPECTED_PATTERN'). <<<"
            echo ">>> This might indicate: <<<"
            echo ">>>   - The BPF program loaded by the server didn't attach correctly."
            echo ">>>   - Communication between agent and server failed silently."
            echo ">>>   - The client didn't actually perform the expected syscall (less likely for cat)."
            echo ">>> Examine the Server Log above for bpftrace/server errors. <<<"
            sudo dmesg | tail -n 50 || echo "Could not get dmesg"
            exit 1
          fi
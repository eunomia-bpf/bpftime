static char __nv_inited_managed_rt = 0;
static void **__nv_fatbinhandle_for_managed_rt;
static void __nv_save_fatbinhandle_for_managed_rt(void **in)
{
	__nv_fatbinhandle_for_managed_rt = in;
}
static char __nv_init_managed_rt_with_module(void **);
static inline void __nv_init_managed_rt(void)
{
	__nv_inited_managed_rt =
		(__nv_inited_managed_rt ?
			 __nv_inited_managed_rt :
			 __nv_init_managed_rt_with_module(
				 __nv_fatbinhandle_for_managed_rt));
}

typedef unsigned char __u_char;
typedef unsigned short __u_short;
typedef unsigned __u_int;
typedef unsigned long __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short __int16_t;
typedef unsigned short __uint16_t;
typedef signed int __int32_t;
typedef unsigned __uint32_t;
typedef signed long __int64_t;
typedef unsigned long __uint64_t;
typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;
typedef long __quad_t;
typedef unsigned long __u_quad_t;
typedef long __intmax_t;
typedef unsigned long __uintmax_t;
typedef unsigned long __dev_t;
typedef unsigned __uid_t;
typedef unsigned __gid_t;
typedef unsigned long __ino_t;
typedef unsigned long __ino64_t;
typedef unsigned __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
typedef struct {
	int __val[2];
} __fsid_t;
typedef long __clock_t;
typedef unsigned long __rlim_t;
typedef unsigned long __rlim64_t;
typedef unsigned __id_t;
typedef long __time_t;
typedef unsigned __useconds_t;
typedef long __suseconds_t;
typedef long __suseconds64_t;
typedef int __daddr_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void *__timer_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __blkcnt64_t;
typedef unsigned long __fsblkcnt_t;
typedef unsigned long __fsblkcnt64_t;
typedef unsigned long __fsfilcnt_t;
typedef unsigned long __fsfilcnt64_t;
typedef long __fsword_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef unsigned long __syscall_ulong_t;
typedef __off64_t __loff_t;
typedef char *__caddr_t;
typedef long __intptr_t;
typedef unsigned __socklen_t;
typedef int __sig_atomic_t;
extern "C" {
enum {
	_ISupper = ((0 < 8) ? (1 << 0) << 8 : ((1 << 0) >> 8)),
	_ISlower = ((1 < 8) ? (1 << 1) << 8 : ((1 << 1) >> 8)),
	_ISalpha = ((2 < 8) ? (1 << 2) << 8 : ((1 << 2) >> 8)),
	_ISdigit = ((3 < 8) ? (1 << 3) << 8 : ((1 << 3) >> 8)),
	_ISxdigit = ((4 < 8) ? (1 << 4) << 8 : ((1 << 4) >> 8)),
	_ISspace = ((5 < 8) ? (1 << 5) << 8 : ((1 << 5) >> 8)),
	_ISprint = ((6 < 8) ? (1 << 6) << 8 : ((1 << 6) >> 8)),
	_ISgraph = ((7 < 8) ? (1 << 7) << 8 : ((1 << 7) >> 8)),
	_ISblank = ((8 < 8) ? (1 << 8) << 8 : ((1 << 8) >> 8)),
	_IScntrl,
	_ISpunct = ((10 < 8) ? (1 << 10) << 8 : ((1 << 10) >> 8)),
	_ISalnum = ((11 < 8) ? (1 << 11) << 8 : ((1 << 11) >> 8))
};
extern const unsigned short **__ctype_b_loc() noexcept(true)
	__attribute((const));
extern const __int32_t **__ctype_tolower_loc() noexcept(true)
	__attribute((const));
extern const __int32_t **__ctype_toupper_loc() noexcept(true)
	__attribute((const));
extern int isalnum(int) noexcept(true);
extern int isalpha(int) noexcept(true);
extern int iscntrl(int) noexcept(true);
extern int isdigit(int) noexcept(true);
extern int islower(int) noexcept(true);
extern int isgraph(int) noexcept(true);
extern int isprint(int) noexcept(true);
extern int ispunct(int) noexcept(true);
extern int isspace(int) noexcept(true);
extern int isupper(int) noexcept(true);
extern int isxdigit(int) noexcept(true);
extern int tolower(int __c) noexcept(true);
extern int toupper(int __c) noexcept(true);
extern int isblank(int) noexcept(true);
extern int isctype(int __c, int __mask) noexcept(true);
extern int isascii(int __c) noexcept(true);
extern int toascii(int __c) noexcept(true);
extern int _toupper(int) noexcept(true);
extern int _tolower(int) noexcept(true);
struct __locale_struct {
	struct __locale_data *__locales[13];
	const unsigned short *__ctype_b;
	const int *__ctype_tolower;
	const int *__ctype_toupper;
	const char *__names[13];
};
typedef __locale_struct *__locale_t;
typedef __locale_t locale_t;
extern int isalnum_l(int, locale_t) noexcept(true);
extern int isalpha_l(int, locale_t) noexcept(true);
extern int iscntrl_l(int, locale_t) noexcept(true);
extern int isdigit_l(int, locale_t) noexcept(true);
extern int islower_l(int, locale_t) noexcept(true);
extern int isgraph_l(int, locale_t) noexcept(true);
extern int isprint_l(int, locale_t) noexcept(true);
extern int ispunct_l(int, locale_t) noexcept(true);
extern int isspace_l(int, locale_t) noexcept(true);
extern int isupper_l(int, locale_t) noexcept(true);
extern int isxdigit_l(int, locale_t) noexcept(true);
extern int isblank_l(int, locale_t) noexcept(true);
extern int __tolower_l(int __c, locale_t __l) noexcept(true);
extern int tolower_l(int __c, locale_t __l) noexcept(true);
extern int __toupper_l(int __c, locale_t __l) noexcept(true);
extern int toupper_l(int __c, locale_t __l) noexcept(true);
}
extern "C" {
extern long __sysconf(int __name) noexcept(true);
}
typedef long ptrdiff_t;
typedef unsigned long size_t;

enum cudaRoundMode {
	cudaRoundNearest,
	cudaRoundZero,
	cudaRoundPosInf,
	cudaRoundMinInf
};

struct char1 {
	signed char x;
};

struct uchar1 {
	unsigned char x;
};

struct __attribute__((aligned(2))) char2 {
	signed char x, y;
};

struct __attribute__((aligned(2))) uchar2 {
	unsigned char x, y;
};

struct char3 {
	signed char x, y, z;
};

struct uchar3 {
	unsigned char x, y, z;
};

struct __attribute__((aligned(4))) char4 {
	signed char x, y, z, w;
};

struct __attribute__((aligned(4))) uchar4 {
	unsigned char x, y, z, w;
};

struct short1 {
	short x;
};

struct ushort1 {
	unsigned short x;
};

struct __attribute__((aligned(4))) short2 {
	short x, y;
};

struct __attribute__((aligned(4))) ushort2 {
	unsigned short x, y;
};

struct short3 {
	short x, y, z;
};

struct ushort3 {
	unsigned short x, y, z;
};

struct __attribute__((aligned(8))) short4 {
	short x;
	short y;
	short z;
	short w;
};
struct __attribute__((aligned(8))) ushort4 {
	unsigned short x;
	unsigned short y;
	unsigned short z;
	unsigned short w;
};

struct int1 {
	int x;
};

struct uint1 {
	unsigned int x;
};

struct __attribute__((aligned(8))) int2 {
	int x;
	int y;
};
struct __attribute__((aligned(8))) uint2 {
	unsigned int x;
	unsigned int y;
};

struct int3 {
	int x, y, z;
};

struct uint3 {
	unsigned int x, y, z;
};

struct __attribute__((aligned(16))) int4 {
	int x, y, z, w;
};

struct __attribute__((aligned(16))) uint4 {
	unsigned int x, y, z, w;
};

struct long1 {
	long int x;
};

struct ulong1 {
	unsigned long x;
};

struct __attribute__((aligned(2 * sizeof(long int)))) long2 {
	long int x, y;
};

struct __attribute__((aligned(2 * sizeof(unsigned long int)))) ulong2 {
	unsigned long int x, y;
};

struct long3 {
	long int x, y, z;
};

struct ulong3 {
	unsigned long int x, y, z;
};

struct __attribute__((aligned(16))) long4 {
	long int x, y, z, w;
};

struct __attribute__((aligned(16))) ulong4 {
	unsigned long int x, y, z, w;
};

struct float1 {
	float x;
};
struct __attribute__((aligned(8))) float2 {
	float x;
	float y;
};

struct float3 {
	float x, y, z;
};

struct __attribute__((aligned(16))) float4 {
	float x, y, z, w;
};

struct longlong1 {
	long long int x;
};

struct ulonglong1 {
	unsigned long long int x;
};

struct __attribute__((aligned(16))) longlong2 {
	long long int x, y;
};

struct __attribute__((aligned(16))) ulonglong2 {
	unsigned long long int x, y;
};

struct longlong3 {
	long long int x, y, z;
};

struct ulonglong3 {
	unsigned long long int x, y, z;
};

struct __attribute__((aligned(16))) longlong4 {
	long long int x, y, z, w;
};

struct __attribute__((aligned(16))) ulonglong4 {
	unsigned long long int x, y, z, w;
};

struct double1 {
	double x;
};

struct __attribute__((aligned(16))) double2 {
	double x, y;
};

struct double3 {
	double x, y, z;
};

struct __attribute__((aligned(16))) double4 {
	double x, y, z, w;
};
typedef struct char1 char1;
typedef struct uchar1 uchar1;
typedef struct char2 char2;
typedef struct uchar2 uchar2;
typedef struct char3 char3;
typedef struct uchar3 uchar3;
typedef struct char4 char4;
typedef struct uchar4 uchar4;
typedef struct short1 short1;
typedef struct ushort1 ushort1;
typedef struct short2 short2;
typedef struct ushort2 ushort2;
typedef struct short3 short3;
typedef struct ushort3 ushort3;
typedef struct short4 short4;
typedef struct ushort4 ushort4;
typedef struct int1 int1;
typedef struct uint1 uint1;
typedef struct int2 int2;
typedef struct uint2 uint2;
typedef struct int3 int3;
typedef struct uint3 uint3;
typedef struct int4 int4;
typedef struct uint4 uint4;
typedef struct long1 long1;
typedef struct ulong1 ulong1;
typedef struct long2 long2;
typedef struct ulong2 ulong2;
typedef struct long3 long3;
typedef struct ulong3 ulong3;
typedef struct long4 long4;
typedef struct ulong4 ulong4;
typedef struct float1 float1;
typedef struct float2 float2;
typedef struct float3 float3;
typedef struct float4 float4;
typedef struct longlong1 longlong1;
typedef struct ulonglong1 ulonglong1;
typedef struct longlong2 longlong2;
typedef struct ulonglong2 ulonglong2;
typedef struct longlong3 longlong3;
typedef struct ulonglong3 ulonglong3;
typedef struct longlong4 longlong4;
typedef struct ulonglong4 ulonglong4;
typedef struct double1 double1;
typedef struct double2 double2;
typedef struct double3 double3;
typedef struct double4 double4;
struct dim3 {
	unsigned int x, y, z;

	constexpr dim3(unsigned int vx = 1, unsigned int vy = 1,
		       unsigned int vz = 1)
		: x(vx), y(vy), z(vz)
	{
	}
	constexpr dim3(uint3 v) : x(v.x), y(v.y), z(v.z)
	{
	}
	constexpr operator uint3(void) const
	{
		return uint3{ x, y, z };
	}
};

typedef struct dim3 dim3;
enum cudaError {

	cudaSuccess = 0,

	cudaErrorInvalidValue = 1,

	cudaErrorMemoryAllocation = 2,

	cudaErrorInitializationError = 3,

	cudaErrorCudartUnloading = 4,

	cudaErrorProfilerDisabled = 5,

	cudaErrorProfilerNotInitialized = 6,

	cudaErrorProfilerAlreadyStarted = 7,

	cudaErrorProfilerAlreadyStopped = 8,

	cudaErrorInvalidConfiguration = 9,

	cudaErrorInvalidPitchValue = 12,

	cudaErrorInvalidSymbol = 13,

	cudaErrorInvalidHostPointer = 16,

	cudaErrorInvalidDevicePointer = 17,

	cudaErrorInvalidTexture = 18,

	cudaErrorInvalidTextureBinding = 19,

	cudaErrorInvalidChannelDescriptor = 20,

	cudaErrorInvalidMemcpyDirection = 21,
	cudaErrorAddressOfConstant = 22,
	cudaErrorTextureFetchFailed = 23,
	cudaErrorTextureNotBound = 24,
	cudaErrorSynchronizationError = 25,

	cudaErrorInvalidFilterSetting = 26,

	cudaErrorInvalidNormSetting = 27,

	cudaErrorMixedDeviceExecution = 28,

	cudaErrorNotYetImplemented = 31,
	cudaErrorMemoryValueTooLarge = 32,

	cudaErrorStubLibrary = 34,

	cudaErrorInsufficientDriver = 35,

	cudaErrorCallRequiresNewerDriver = 36,

	cudaErrorInvalidSurface = 37,

	cudaErrorDuplicateVariableName = 43,

	cudaErrorDuplicateTextureName = 44,

	cudaErrorDuplicateSurfaceName = 45,
	cudaErrorDevicesUnavailable = 46,
	cudaErrorIncompatibleDriverContext = 49,

	cudaErrorMissingConfiguration = 52,
	cudaErrorPriorLaunchFailure = 53,

	cudaErrorLaunchMaxDepthExceeded = 65,

	cudaErrorLaunchFileScopedTex = 66,

	cudaErrorLaunchFileScopedSurf = 67,
	cudaErrorSyncDepthExceeded = 68,
	cudaErrorLaunchPendingCountExceeded = 69,

	cudaErrorInvalidDeviceFunction = 98,

	cudaErrorNoDevice = 100,

	cudaErrorInvalidDevice = 101,

	cudaErrorDeviceNotLicensed = 102,
	cudaErrorSoftwareValidityNotEstablished = 103,

	cudaErrorStartupFailure = 127,

	cudaErrorInvalidKernelImage = 200,
	cudaErrorDeviceUninitialized = 201,

	cudaErrorMapBufferObjectFailed = 205,

	cudaErrorUnmapBufferObjectFailed = 206,

	cudaErrorArrayIsMapped = 207,

	cudaErrorAlreadyMapped = 208,

	cudaErrorNoKernelImageForDevice = 209,

	cudaErrorAlreadyAcquired = 210,

	cudaErrorNotMapped = 211,

	cudaErrorNotMappedAsArray = 212,

	cudaErrorNotMappedAsPointer = 213,

	cudaErrorECCUncorrectable = 214,

	cudaErrorUnsupportedLimit = 215,

	cudaErrorDeviceAlreadyInUse = 216,

	cudaErrorPeerAccessUnsupported = 217,

	cudaErrorInvalidPtx = 218,

	cudaErrorInvalidGraphicsContext = 219,

	cudaErrorNvlinkUncorrectable = 220,

	cudaErrorJitCompilerNotFound = 221,

	cudaErrorUnsupportedPtxVersion = 222,

	cudaErrorJitCompilationDisabled = 223,

	cudaErrorUnsupportedExecAffinity = 224,

	cudaErrorUnsupportedDevSideSync = 225,

	cudaErrorInvalidSource = 300,

	cudaErrorFileNotFound = 301,

	cudaErrorSharedObjectSymbolNotFound = 302,

	cudaErrorSharedObjectInitFailed = 303,

	cudaErrorOperatingSystem = 304,

	cudaErrorInvalidResourceHandle = 400,

	cudaErrorIllegalState = 401,

	cudaErrorLossyQuery = 402,

	cudaErrorSymbolNotFound = 500,

	cudaErrorNotReady = 600,

	cudaErrorIllegalAddress = 700,
	cudaErrorLaunchOutOfResources = 701,
	cudaErrorLaunchTimeout = 702,

	cudaErrorLaunchIncompatibleTexturing = 703,

	cudaErrorPeerAccessAlreadyEnabled = 704,

	cudaErrorPeerAccessNotEnabled = 705,
	cudaErrorSetOnActiveProcess = 708,

	cudaErrorContextIsDestroyed = 709,

	cudaErrorAssert = 710,

	cudaErrorTooManyPeers = 711,

	cudaErrorHostMemoryAlreadyRegistered = 712,

	cudaErrorHostMemoryNotRegistered = 713,
	cudaErrorHardwareStackError = 714,

	cudaErrorIllegalInstruction = 715,
	cudaErrorMisalignedAddress = 716,
	cudaErrorInvalidAddressSpace = 717,

	cudaErrorInvalidPc = 718,
	cudaErrorLaunchFailure = 719,
	cudaErrorCooperativeLaunchTooLarge = 720,

	cudaErrorNotPermitted = 800,

	cudaErrorNotSupported = 801,
	cudaErrorSystemNotReady = 802,

	cudaErrorSystemDriverMismatch = 803,
	cudaErrorCompatNotSupportedOnDevice = 804,

	cudaErrorMpsConnectionFailed = 805,

	cudaErrorMpsRpcFailure = 806,

	cudaErrorMpsServerNotReady = 807,

	cudaErrorMpsMaxClientsReached = 808,

	cudaErrorMpsMaxConnectionsReached = 809,

	cudaErrorMpsClientTerminated = 810,

	cudaErrorCdpNotSupported = 811,

	cudaErrorCdpVersionMismatch = 812,

	cudaErrorStreamCaptureUnsupported = 900,

	cudaErrorStreamCaptureInvalidated = 901,

	cudaErrorStreamCaptureMerge = 902,

	cudaErrorStreamCaptureUnmatched = 903,

	cudaErrorStreamCaptureUnjoined = 904,

	cudaErrorStreamCaptureIsolation = 905,

	cudaErrorStreamCaptureImplicit = 906,

	cudaErrorCapturedEvent = 907,

	cudaErrorStreamCaptureWrongThread = 908,

	cudaErrorTimeout = 909,

	cudaErrorGraphExecUpdateFailure = 910,
	cudaErrorExternalDevice = 911,

	cudaErrorInvalidClusterSize = 912,

	cudaErrorFunctionNotLoaded = 913,

	cudaErrorInvalidResourceType = 914,

	cudaErrorInvalidResourceConfiguration = 915,

	cudaErrorUnknown = 999

	,
	cudaErrorApiFailureBase = 10000
};

enum cudaChannelFormatKind {
	cudaChannelFormatKindSigned = 0,
	cudaChannelFormatKindUnsigned = 1,
	cudaChannelFormatKindFloat = 2,
	cudaChannelFormatKindNone = 3,
	cudaChannelFormatKindNV12 = 4,
	cudaChannelFormatKindUnsignedNormalized8X1 = 5,
	cudaChannelFormatKindUnsignedNormalized8X2 = 6,
	cudaChannelFormatKindUnsignedNormalized8X4 = 7,
	cudaChannelFormatKindUnsignedNormalized16X1 = 8,
	cudaChannelFormatKindUnsignedNormalized16X2 = 9,
	cudaChannelFormatKindUnsignedNormalized16X4 = 10,
	cudaChannelFormatKindSignedNormalized8X1 = 11,
	cudaChannelFormatKindSignedNormalized8X2 = 12,
	cudaChannelFormatKindSignedNormalized8X4 = 13,
	cudaChannelFormatKindSignedNormalized16X1 = 14,
	cudaChannelFormatKindSignedNormalized16X2 = 15,
	cudaChannelFormatKindSignedNormalized16X4 = 16,
	cudaChannelFormatKindUnsignedBlockCompressed1 = 17,
	cudaChannelFormatKindUnsignedBlockCompressed1SRGB = 18,
	cudaChannelFormatKindUnsignedBlockCompressed2 = 19,
	cudaChannelFormatKindUnsignedBlockCompressed2SRGB = 20,
	cudaChannelFormatKindUnsignedBlockCompressed3 = 21,
	cudaChannelFormatKindUnsignedBlockCompressed3SRGB = 22,
	cudaChannelFormatKindUnsignedBlockCompressed4 = 23,
	cudaChannelFormatKindSignedBlockCompressed4 = 24,
	cudaChannelFormatKindUnsignedBlockCompressed5 = 25,
	cudaChannelFormatKindSignedBlockCompressed5 = 26,
	cudaChannelFormatKindUnsignedBlockCompressed6H = 27,
	cudaChannelFormatKindSignedBlockCompressed6H = 28,
	cudaChannelFormatKindUnsignedBlockCompressed7 = 29,
	cudaChannelFormatKindUnsignedBlockCompressed7SRGB = 30
};

struct cudaChannelFormatDesc {
	int x;
	int y;
	int z;
	int w;
	enum cudaChannelFormatKind f;
};

typedef struct cudaArray *cudaArray_t;

typedef const struct cudaArray *cudaArray_const_t;

struct cudaArray;

typedef struct cudaMipmappedArray *cudaMipmappedArray_t;

typedef const struct cudaMipmappedArray *cudaMipmappedArray_const_t;

struct cudaMipmappedArray;
struct cudaArraySparseProperties {
	struct {
		unsigned int width;
		unsigned int height;
		unsigned int depth;
	} tileExtent;
	unsigned int miptailFirstLevel;
	unsigned long long miptailSize;
	unsigned int flags;
	unsigned int reserved[4];
};

struct cudaArrayMemoryRequirements {
	size_t size;
	size_t alignment;
	unsigned int reserved[4];
};

enum cudaMemoryType {
	cudaMemoryTypeUnregistered = 0,
	cudaMemoryTypeHost = 1,
	cudaMemoryTypeDevice = 2,
	cudaMemoryTypeManaged = 3
};

enum cudaMemcpyKind {
	cudaMemcpyHostToHost = 0,
	cudaMemcpyHostToDevice = 1,
	cudaMemcpyDeviceToHost = 2,
	cudaMemcpyDeviceToDevice = 3,
	cudaMemcpyDefault = 4
};

struct cudaPitchedPtr {
	void *ptr;
	size_t pitch;
	size_t xsize;
	size_t ysize;
};

struct cudaExtent {
	size_t width;
	size_t height;
	size_t depth;
};

struct cudaPos {
	size_t x;
	size_t y;
	size_t z;
};

struct cudaMemcpy3DParms {
	cudaArray_t srcArray;
	struct cudaPos srcPos;
	struct cudaPitchedPtr srcPtr;

	cudaArray_t dstArray;
	struct cudaPos dstPos;
	struct cudaPitchedPtr dstPtr;

	struct cudaExtent extent;
	enum cudaMemcpyKind kind;
};

struct cudaMemcpyNodeParams {
	int flags;
	int reserved[3];
	struct cudaMemcpy3DParms copyParams;
};

struct cudaMemcpy3DPeerParms {
	cudaArray_t srcArray;
	struct cudaPos srcPos;
	struct cudaPitchedPtr srcPtr;
	int srcDevice;

	cudaArray_t dstArray;
	struct cudaPos dstPos;
	struct cudaPitchedPtr dstPtr;
	int dstDevice;

	struct cudaExtent extent;
};

struct cudaMemsetParams {
	void *dst;
	size_t pitch;
	unsigned int value;
	unsigned int elementSize;
	size_t width;
	size_t height;
};

struct cudaMemsetParamsV2 {
	void *dst;
	size_t pitch;
	unsigned int value;
	unsigned int elementSize;
	size_t width;
	size_t height;
};

enum cudaAccessProperty {
	cudaAccessPropertyNormal = 0,
	cudaAccessPropertyStreaming = 1,
	cudaAccessPropertyPersisting = 2
};
struct cudaAccessPolicyWindow {
	void *base_ptr;
	size_t num_bytes;
	float hitRatio;
	enum cudaAccessProperty hitProp;
	enum cudaAccessProperty missProp;
};
typedef void (*cudaHostFn_t)(void *userData);

struct cudaHostNodeParams {
	cudaHostFn_t fn;
	void *userData;
};

struct cudaHostNodeParamsV2 {
	cudaHostFn_t fn;
	void *userData;
};

enum cudaStreamCaptureStatus {
	cudaStreamCaptureStatusNone = 0,
	cudaStreamCaptureStatusActive = 1,
	cudaStreamCaptureStatusInvalidated = 2

};

enum cudaStreamCaptureMode {
	cudaStreamCaptureModeGlobal = 0,
	cudaStreamCaptureModeThreadLocal = 1,
	cudaStreamCaptureModeRelaxed = 2
};

enum cudaSynchronizationPolicy {
	cudaSyncPolicyAuto = 1,
	cudaSyncPolicySpin = 2,
	cudaSyncPolicyYield = 3,
	cudaSyncPolicyBlockingSync = 4
};

enum cudaClusterSchedulingPolicy {
	cudaClusterSchedulingPolicyDefault = 0,
	cudaClusterSchedulingPolicySpread = 1,
	cudaClusterSchedulingPolicyLoadBalancing = 2
};

enum cudaStreamUpdateCaptureDependenciesFlags {
	cudaStreamAddCaptureDependencies = 0x0,
	cudaStreamSetCaptureDependencies = 0x1
};

enum cudaUserObjectFlags { cudaUserObjectNoDestructorSync = 0x1 };

enum cudaUserObjectRetainFlags { cudaGraphUserObjectMove = 0x1 };

struct cudaGraphicsResource;

enum cudaGraphicsRegisterFlags {
	cudaGraphicsRegisterFlagsNone = 0,
	cudaGraphicsRegisterFlagsReadOnly = 1,
	cudaGraphicsRegisterFlagsWriteDiscard = 2,
	cudaGraphicsRegisterFlagsSurfaceLoadStore = 4,
	cudaGraphicsRegisterFlagsTextureGather = 8
};

enum cudaGraphicsMapFlags {
	cudaGraphicsMapFlagsNone = 0,
	cudaGraphicsMapFlagsReadOnly = 1,
	cudaGraphicsMapFlagsWriteDiscard = 2
};

enum cudaGraphicsCubeFace {
	cudaGraphicsCubeFacePositiveX = 0x00,
	cudaGraphicsCubeFaceNegativeX = 0x01,
	cudaGraphicsCubeFacePositiveY = 0x02,
	cudaGraphicsCubeFaceNegativeY = 0x03,
	cudaGraphicsCubeFacePositiveZ = 0x04,
	cudaGraphicsCubeFaceNegativeZ = 0x05
};

enum cudaResourceType {
	cudaResourceTypeArray = 0x00,
	cudaResourceTypeMipmappedArray = 0x01,
	cudaResourceTypeLinear = 0x02,
	cudaResourceTypePitch2D = 0x03
};

enum cudaResourceViewFormat {
	cudaResViewFormatNone = 0x00,
	cudaResViewFormatUnsignedChar1 = 0x01,
	cudaResViewFormatUnsignedChar2 = 0x02,
	cudaResViewFormatUnsignedChar4 = 0x03,
	cudaResViewFormatSignedChar1 = 0x04,
	cudaResViewFormatSignedChar2 = 0x05,
	cudaResViewFormatSignedChar4 = 0x06,
	cudaResViewFormatUnsignedShort1 = 0x07,
	cudaResViewFormatUnsignedShort2 = 0x08,
	cudaResViewFormatUnsignedShort4 = 0x09,
	cudaResViewFormatSignedShort1 = 0x0a,
	cudaResViewFormatSignedShort2 = 0x0b,
	cudaResViewFormatSignedShort4 = 0x0c,
	cudaResViewFormatUnsignedInt1 = 0x0d,
	cudaResViewFormatUnsignedInt2 = 0x0e,
	cudaResViewFormatUnsignedInt4 = 0x0f,
	cudaResViewFormatSignedInt1 = 0x10,
	cudaResViewFormatSignedInt2 = 0x11,
	cudaResViewFormatSignedInt4 = 0x12,
	cudaResViewFormatHalf1 = 0x13,
	cudaResViewFormatHalf2 = 0x14,
	cudaResViewFormatHalf4 = 0x15,
	cudaResViewFormatFloat1 = 0x16,
	cudaResViewFormatFloat2 = 0x17,
	cudaResViewFormatFloat4 = 0x18,
	cudaResViewFormatUnsignedBlockCompressed1 = 0x19,
	cudaResViewFormatUnsignedBlockCompressed2 = 0x1a,
	cudaResViewFormatUnsignedBlockCompressed3 = 0x1b,
	cudaResViewFormatUnsignedBlockCompressed4 = 0x1c,
	cudaResViewFormatSignedBlockCompressed4 = 0x1d,
	cudaResViewFormatUnsignedBlockCompressed5 = 0x1e,
	cudaResViewFormatSignedBlockCompressed5 = 0x1f,
	cudaResViewFormatUnsignedBlockCompressed6H = 0x20,
	cudaResViewFormatSignedBlockCompressed6H = 0x21,
	cudaResViewFormatUnsignedBlockCompressed7 = 0x22
};

struct cudaResourceDesc {
	enum cudaResourceType resType;

	union {
		struct {
			cudaArray_t array;
		} array;
		struct {
			cudaMipmappedArray_t mipmap;
		} mipmap;
		struct {
			void *devPtr;
			struct cudaChannelFormatDesc desc;
			size_t sizeInBytes;
		} linear;
		struct {
			void *devPtr;
			struct cudaChannelFormatDesc desc;
			size_t width;
			size_t height;
			size_t pitchInBytes;
		} pitch2D;
	} res;
};

struct cudaResourceViewDesc {
	enum cudaResourceViewFormat format;
	size_t width;
	size_t height;
	size_t depth;
	unsigned int firstMipmapLevel;
	unsigned int lastMipmapLevel;
	unsigned int firstLayer;
	unsigned int lastLayer;
};

struct cudaPointerAttributes {
	enum cudaMemoryType type;
	int device;

	void *devicePointer;
	void *hostPointer;
};

struct cudaFuncAttributes {
	size_t sharedSizeBytes;

	size_t constSizeBytes;

	size_t localSizeBytes;

	int maxThreadsPerBlock;

	int numRegs;

	int ptxVersion;

	int binaryVersion;

	int cacheModeCA;

	int maxDynamicSharedSizeBytes;
	int preferredShmemCarveout;

	int clusterDimMustBeSet;
	int requiredClusterWidth;
	int requiredClusterHeight;
	int requiredClusterDepth;

	int clusterSchedulingPolicyPreference;
	int nonPortableClusterSizeAllowed;

	int reserved[16];
};

enum cudaFuncAttribute {
	cudaFuncAttributeMaxDynamicSharedMemorySize = 8,
	cudaFuncAttributePreferredSharedMemoryCarveout = 9,
	cudaFuncAttributeClusterDimMustBeSet = 10,
	cudaFuncAttributeRequiredClusterWidth = 11,
	cudaFuncAttributeRequiredClusterHeight = 12,
	cudaFuncAttributeRequiredClusterDepth = 13,
	cudaFuncAttributeNonPortableClusterSizeAllowed = 14,
	cudaFuncAttributeClusterSchedulingPolicyPreference = 15,
	cudaFuncAttributeMax
};

enum cudaFuncCache {
	cudaFuncCachePreferNone = 0,
	cudaFuncCachePreferShared = 1,
	cudaFuncCachePreferL1 = 2,
	cudaFuncCachePreferEqual = 3
};

enum cudaSharedMemConfig {
	cudaSharedMemBankSizeDefault = 0,
	cudaSharedMemBankSizeFourByte = 1,
	cudaSharedMemBankSizeEightByte = 2
};

enum cudaSharedCarveout {
	cudaSharedmemCarveoutDefault = -1,
	cudaSharedmemCarveoutMaxShared = 100,
	cudaSharedmemCarveoutMaxL1 = 0
};

enum cudaComputeMode {
	cudaComputeModeDefault = 0,
	cudaComputeModeExclusive = 1,
	cudaComputeModeProhibited = 2,
	cudaComputeModeExclusiveProcess = 3
};

enum cudaLimit {
	cudaLimitStackSize = 0x00,
	cudaLimitPrintfFifoSize = 0x01,
	cudaLimitMallocHeapSize = 0x02,
	cudaLimitDevRuntimeSyncDepth = 0x03,
	cudaLimitDevRuntimePendingLaunchCount = 0x04,
	cudaLimitMaxL2FetchGranularity = 0x05,
	cudaLimitPersistingL2CacheSize = 0x06
};

enum cudaMemoryAdvise {
	cudaMemAdviseSetReadMostly = 1,
	cudaMemAdviseUnsetReadMostly = 2,
	cudaMemAdviseSetPreferredLocation = 3,
	cudaMemAdviseUnsetPreferredLocation = 4,
	cudaMemAdviseSetAccessedBy = 5,
	cudaMemAdviseUnsetAccessedBy = 6
};

enum cudaMemRangeAttribute {
	cudaMemRangeAttributeReadMostly = 1,
	cudaMemRangeAttributePreferredLocation = 2,
	cudaMemRangeAttributeAccessedBy = 3,
	cudaMemRangeAttributeLastPrefetchLocation = 4,
	cudaMemRangeAttributePreferredLocationType = 5,
	cudaMemRangeAttributePreferredLocationId = 6,
	cudaMemRangeAttributeLastPrefetchLocationType = 7,
	cudaMemRangeAttributeLastPrefetchLocationId = 8
};

enum cudaFlushGPUDirectRDMAWritesOptions {
	cudaFlushGPUDirectRDMAWritesOptionHost = 1 << 0,
	cudaFlushGPUDirectRDMAWritesOptionMemOps = 1 << 1
};

enum cudaGPUDirectRDMAWritesOrdering {
	cudaGPUDirectRDMAWritesOrderingNone = 0,
	cudaGPUDirectRDMAWritesOrderingOwner = 100,
	cudaGPUDirectRDMAWritesOrderingAllDevices = 200
};

enum cudaFlushGPUDirectRDMAWritesScope {
	cudaFlushGPUDirectRDMAWritesToOwner = 100,
	cudaFlushGPUDirectRDMAWritesToAllDevices = 200
};

enum cudaFlushGPUDirectRDMAWritesTarget {
	cudaFlushGPUDirectRDMAWritesTargetCurrentDevice
};

enum cudaDeviceAttr {
	cudaDevAttrMaxThreadsPerBlock = 1,
	cudaDevAttrMaxBlockDimX = 2,
	cudaDevAttrMaxBlockDimY = 3,
	cudaDevAttrMaxBlockDimZ = 4,
	cudaDevAttrMaxGridDimX = 5,
	cudaDevAttrMaxGridDimY = 6,
	cudaDevAttrMaxGridDimZ = 7,
	cudaDevAttrMaxSharedMemoryPerBlock = 8,
	cudaDevAttrTotalConstantMemory = 9,
	cudaDevAttrWarpSize = 10,
	cudaDevAttrMaxPitch = 11,
	cudaDevAttrMaxRegistersPerBlock = 12,
	cudaDevAttrClockRate = 13,
	cudaDevAttrTextureAlignment = 14,
	cudaDevAttrGpuOverlap = 15,
	cudaDevAttrMultiProcessorCount = 16,
	cudaDevAttrKernelExecTimeout = 17,
	cudaDevAttrIntegrated = 18,
	cudaDevAttrCanMapHostMemory = 19,
	cudaDevAttrComputeMode = 20,
	cudaDevAttrMaxTexture1DWidth = 21,
	cudaDevAttrMaxTexture2DWidth = 22,
	cudaDevAttrMaxTexture2DHeight = 23,
	cudaDevAttrMaxTexture3DWidth = 24,
	cudaDevAttrMaxTexture3DHeight = 25,
	cudaDevAttrMaxTexture3DDepth = 26,
	cudaDevAttrMaxTexture2DLayeredWidth = 27,
	cudaDevAttrMaxTexture2DLayeredHeight = 28,
	cudaDevAttrMaxTexture2DLayeredLayers = 29,
	cudaDevAttrSurfaceAlignment = 30,
	cudaDevAttrConcurrentKernels = 31,
	cudaDevAttrEccEnabled = 32,
	cudaDevAttrPciBusId = 33,
	cudaDevAttrPciDeviceId = 34,
	cudaDevAttrTccDriver = 35,
	cudaDevAttrMemoryClockRate = 36,
	cudaDevAttrGlobalMemoryBusWidth = 37,
	cudaDevAttrL2CacheSize = 38,
	cudaDevAttrMaxThreadsPerMultiProcessor = 39,
	cudaDevAttrAsyncEngineCount = 40,
	cudaDevAttrUnifiedAddressing = 41,
	cudaDevAttrMaxTexture1DLayeredWidth = 42,
	cudaDevAttrMaxTexture1DLayeredLayers = 43,
	cudaDevAttrMaxTexture2DGatherWidth = 45,
	cudaDevAttrMaxTexture2DGatherHeight = 46,
	cudaDevAttrMaxTexture3DWidthAlt = 47,
	cudaDevAttrMaxTexture3DHeightAlt = 48,
	cudaDevAttrMaxTexture3DDepthAlt = 49,
	cudaDevAttrPciDomainId = 50,
	cudaDevAttrTexturePitchAlignment = 51,
	cudaDevAttrMaxTextureCubemapWidth = 52,
	cudaDevAttrMaxTextureCubemapLayeredWidth = 53,
	cudaDevAttrMaxTextureCubemapLayeredLayers = 54,
	cudaDevAttrMaxSurface1DWidth = 55,
	cudaDevAttrMaxSurface2DWidth = 56,
	cudaDevAttrMaxSurface2DHeight = 57,
	cudaDevAttrMaxSurface3DWidth = 58,
	cudaDevAttrMaxSurface3DHeight = 59,
	cudaDevAttrMaxSurface3DDepth = 60,
	cudaDevAttrMaxSurface1DLayeredWidth = 61,
	cudaDevAttrMaxSurface1DLayeredLayers = 62,
	cudaDevAttrMaxSurface2DLayeredWidth = 63,
	cudaDevAttrMaxSurface2DLayeredHeight = 64,
	cudaDevAttrMaxSurface2DLayeredLayers = 65,
	cudaDevAttrMaxSurfaceCubemapWidth = 66,
	cudaDevAttrMaxSurfaceCubemapLayeredWidth = 67,
	cudaDevAttrMaxSurfaceCubemapLayeredLayers = 68,
	cudaDevAttrMaxTexture1DLinearWidth = 69,
	cudaDevAttrMaxTexture2DLinearWidth = 70,
	cudaDevAttrMaxTexture2DLinearHeight = 71,
	cudaDevAttrMaxTexture2DLinearPitch = 72,
	cudaDevAttrMaxTexture2DMipmappedWidth = 73,
	cudaDevAttrMaxTexture2DMipmappedHeight = 74,
	cudaDevAttrComputeCapabilityMajor = 75,
	cudaDevAttrComputeCapabilityMinor = 76,
	cudaDevAttrMaxTexture1DMipmappedWidth = 77,
	cudaDevAttrStreamPrioritiesSupported = 78,
	cudaDevAttrGlobalL1CacheSupported = 79,
	cudaDevAttrLocalL1CacheSupported = 80,
	cudaDevAttrMaxSharedMemoryPerMultiprocessor = 81,
	cudaDevAttrMaxRegistersPerMultiprocessor = 82,
	cudaDevAttrManagedMemory = 83,
	cudaDevAttrIsMultiGpuBoard = 84,
	cudaDevAttrMultiGpuBoardGroupID = 85,
	cudaDevAttrHostNativeAtomicSupported = 86,
	cudaDevAttrSingleToDoublePrecisionPerfRatio = 87,
	cudaDevAttrPageableMemoryAccess = 88,
	cudaDevAttrConcurrentManagedAccess = 89,
	cudaDevAttrComputePreemptionSupported = 90,
	cudaDevAttrCanUseHostPointerForRegisteredMem = 91,
	cudaDevAttrReserved92 = 92,
	cudaDevAttrReserved93 = 93,
	cudaDevAttrReserved94 = 94,
	cudaDevAttrCooperativeLaunch = 95,
	cudaDevAttrCooperativeMultiDeviceLaunch = 96,
	cudaDevAttrMaxSharedMemoryPerBlockOptin = 97,
	cudaDevAttrCanFlushRemoteWrites = 98,
	cudaDevAttrHostRegisterSupported = 99,
	cudaDevAttrPageableMemoryAccessUsesHostPageTables = 100,
	cudaDevAttrDirectManagedMemAccessFromHost = 101,
	cudaDevAttrMaxBlocksPerMultiprocessor = 106,
	cudaDevAttrMaxPersistingL2CacheSize = 108,
	cudaDevAttrMaxAccessPolicyWindowSize = 109,
	cudaDevAttrReservedSharedMemoryPerBlock = 111,
	cudaDevAttrSparseCudaArraySupported = 112,
	cudaDevAttrHostRegisterReadOnlySupported = 113,
	cudaDevAttrTimelineSemaphoreInteropSupported = 114,
	cudaDevAttrMaxTimelineSemaphoreInteropSupported = 114,
	cudaDevAttrMemoryPoolsSupported = 115,
	cudaDevAttrGPUDirectRDMASupported = 116,
	cudaDevAttrGPUDirectRDMAFlushWritesOptions = 117,
	cudaDevAttrGPUDirectRDMAWritesOrdering = 118,
	cudaDevAttrMemoryPoolSupportedHandleTypes = 119,
	cudaDevAttrClusterLaunch = 120,
	cudaDevAttrDeferredMappingCudaArraySupported = 121,
	cudaDevAttrReserved122 = 122,
	cudaDevAttrReserved123 = 123,
	cudaDevAttrReserved124 = 124,
	cudaDevAttrIpcEventSupport = 125,
	cudaDevAttrMemSyncDomainCount = 126,
	cudaDevAttrReserved127 = 127,
	cudaDevAttrReserved128 = 128,
	cudaDevAttrReserved129 = 129,
	cudaDevAttrNumaConfig = 130,
	cudaDevAttrNumaId = 131,
	cudaDevAttrReserved132 = 132,
	cudaDevAttrMpsEnabled = 133,
	cudaDevAttrHostNumaId = 134,
	cudaDevAttrD3D12CigSupported = 135,
	cudaDevAttrMax
};

enum cudaMemPoolAttr {
	cudaMemPoolReuseFollowEventDependencies = 0x1,

	cudaMemPoolReuseAllowOpportunistic = 0x2,

	cudaMemPoolReuseAllowInternalDependencies = 0x3,
	cudaMemPoolAttrReleaseThreshold = 0x4,

	cudaMemPoolAttrReservedMemCurrent = 0x5,

	cudaMemPoolAttrReservedMemHigh = 0x6,

	cudaMemPoolAttrUsedMemCurrent = 0x7,

	cudaMemPoolAttrUsedMemHigh = 0x8
};

enum cudaMemLocationType {
	cudaMemLocationTypeInvalid = 0,
	cudaMemLocationTypeDevice = 1,
	cudaMemLocationTypeHost = 2,
	cudaMemLocationTypeHostNuma = 3,
	cudaMemLocationTypeHostNumaCurrent = 4
};

struct cudaMemLocation {
	enum cudaMemLocationType type;
	int id;
};

enum cudaMemAccessFlags {
	cudaMemAccessFlagsProtNone = 0,
	cudaMemAccessFlagsProtRead = 1,
	cudaMemAccessFlagsProtReadWrite = 3
};

struct cudaMemAccessDesc {
	struct cudaMemLocation location;
	enum cudaMemAccessFlags flags;
};

enum cudaMemAllocationType {
	cudaMemAllocationTypeInvalid = 0x0,

	cudaMemAllocationTypePinned = 0x1,
	cudaMemAllocationTypeMax = 0x7FFFFFFF
};

enum cudaMemAllocationHandleType {
	cudaMemHandleTypeNone = 0x0,
	cudaMemHandleTypePosixFileDescriptor = 0x1,
	cudaMemHandleTypeWin32 = 0x2,
	cudaMemHandleTypeWin32Kmt = 0x4,
	cudaMemHandleTypeFabric = 0x8
};

struct cudaMemPoolProps {
	enum cudaMemAllocationType allocType;
	enum cudaMemAllocationHandleType handleTypes;
	struct cudaMemLocation location;

	void *win32SecurityAttributes;
	size_t maxSize;
	unsigned short usage;
	unsigned char reserved[54];
};

struct cudaMemPoolPtrExportData {
	unsigned char reserved[64];
};

struct cudaMemAllocNodeParams {
	struct cudaMemPoolProps poolProps;
	const struct cudaMemAccessDesc *accessDescs;
	size_t accessDescCount;
	size_t bytesize;
	void *dptr;
};

struct cudaMemAllocNodeParamsV2 {
	struct cudaMemPoolProps poolProps;
	const struct cudaMemAccessDesc *accessDescs;
	size_t accessDescCount;
	size_t bytesize;
	void *dptr;
};

struct cudaMemFreeNodeParams {
	void *dptr;
};

enum cudaGraphMemAttributeType {

	cudaGraphMemAttrUsedMemCurrent = 0x0,

	cudaGraphMemAttrUsedMemHigh = 0x1,

	cudaGraphMemAttrReservedMemCurrent = 0x2,

	cudaGraphMemAttrReservedMemHigh = 0x3
};

enum cudaDeviceP2PAttr {
	cudaDevP2PAttrPerformanceRank = 1,
	cudaDevP2PAttrAccessSupported = 2,
	cudaDevP2PAttrNativeAtomicSupported = 3,
	cudaDevP2PAttrCudaArrayAccessSupported = 4
};

struct CUuuid_st {
	char bytes[16];
};
typedef struct CUuuid_st CUuuid;

typedef struct CUuuid_st cudaUUID_t;

struct cudaDeviceProp {
	char name[256];
	cudaUUID_t uuid;
	char luid[8];
	unsigned int luidDeviceNodeMask;
	size_t totalGlobalMem;
	size_t sharedMemPerBlock;
	int regsPerBlock;
	int warpSize;
	size_t memPitch;
	int maxThreadsPerBlock;
	int maxThreadsDim[3];
	int maxGridSize[3];
	int clockRate;
	size_t totalConstMem;
	int major;
	int minor;
	size_t textureAlignment;
	size_t texturePitchAlignment;
	int deviceOverlap;
	int multiProcessorCount;
	int kernelExecTimeoutEnabled;
	int integrated;
	int canMapHostMemory;
	int computeMode;
	int maxTexture1D;
	int maxTexture1DMipmap;
	int maxTexture1DLinear;
	int maxTexture2D[2];
	int maxTexture2DMipmap[2];
	int maxTexture2DLinear[3];
	int maxTexture2DGather[2];
	int maxTexture3D[3];
	int maxTexture3DAlt[3];
	int maxTextureCubemap;
	int maxTexture1DLayered[2];
	int maxTexture2DLayered[3];
	int maxTextureCubemapLayered[2];
	int maxSurface1D;
	int maxSurface2D[2];
	int maxSurface3D[3];
	int maxSurface1DLayered[2];
	int maxSurface2DLayered[3];
	int maxSurfaceCubemap;
	int maxSurfaceCubemapLayered[2];
	size_t surfaceAlignment;
	int concurrentKernels;
	int ECCEnabled;
	int pciBusID;
	int pciDeviceID;
	int pciDomainID;
	int tccDriver;
	int asyncEngineCount;
	int unifiedAddressing;
	int memoryClockRate;
	int memoryBusWidth;
	int l2CacheSize;
	int persistingL2CacheMaxSize;
	int maxThreadsPerMultiProcessor;
	int streamPrioritiesSupported;
	int globalL1CacheSupported;
	int localL1CacheSupported;
	size_t sharedMemPerMultiprocessor;
	int regsPerMultiprocessor;
	int managedMemory;
	int isMultiGpuBoard;
	int multiGpuBoardGroupID;
	int hostNativeAtomicSupported;
	int singleToDoublePrecisionPerfRatio;
	int pageableMemoryAccess;
	int concurrentManagedAccess;
	int computePreemptionSupported;
	int canUseHostPointerForRegisteredMem;
	int cooperativeLaunch;
	int cooperativeMultiDeviceLaunch;
	size_t sharedMemPerBlockOptin;
	int pageableMemoryAccessUsesHostPageTables;
	int directManagedMemAccessFromHost;
	int maxBlocksPerMultiProcessor;
	int accessPolicyMaxWindowSize;
	size_t reservedSharedMemPerBlock;
	int hostRegisterSupported;
	int sparseCudaArraySupported;
	int hostRegisterReadOnlySupported;
	int timelineSemaphoreInteropSupported;
	int memoryPoolsSupported;
	int gpuDirectRDMASupported;
	unsigned int gpuDirectRDMAFlushWritesOptions;
	int gpuDirectRDMAWritesOrdering;
	unsigned int memoryPoolSupportedHandleTypes;
	int deferredMappingCudaArraySupported;
	int ipcEventSupported;
	int clusterLaunch;
	int unifiedFunctionPointers;
	int reserved2[2];
	int reserved1[1];
	int reserved[60];
};
typedef struct cudaIpcEventHandle_st {
	char reserved[64];
} cudaIpcEventHandle_t;

typedef struct cudaIpcMemHandle_st {
	char reserved[64];
} cudaIpcMemHandle_t;

typedef struct cudaMemFabricHandle_st {
	char reserved[64];
} cudaMemFabricHandle_t;

enum cudaExternalMemoryHandleType {

	cudaExternalMemoryHandleTypeOpaqueFd = 1,

	cudaExternalMemoryHandleTypeOpaqueWin32 = 2,

	cudaExternalMemoryHandleTypeOpaqueWin32Kmt = 3,

	cudaExternalMemoryHandleTypeD3D12Heap = 4,

	cudaExternalMemoryHandleTypeD3D12Resource = 5,

	cudaExternalMemoryHandleTypeD3D11Resource = 6,

	cudaExternalMemoryHandleTypeD3D11ResourceKmt = 7,

	cudaExternalMemoryHandleTypeNvSciBuf = 8
};
struct cudaExternalMemoryHandleDesc {
	enum cudaExternalMemoryHandleType type;
	union {
		int fd;
		struct {
			void *handle;

			const void *name;
		} win32;

		const void *nvSciBufObject;
	} handle;

	unsigned long long size;

	unsigned int flags;
};

struct cudaExternalMemoryBufferDesc {
	unsigned long long offset;

	unsigned long long size;

	unsigned int flags;
};

struct cudaExternalMemoryMipmappedArrayDesc {
	unsigned long long offset;

	struct cudaChannelFormatDesc formatDesc;

	struct cudaExtent extent;

	unsigned int flags;

	unsigned int numLevels;
};

enum cudaExternalSemaphoreHandleType {

	cudaExternalSemaphoreHandleTypeOpaqueFd = 1,

	cudaExternalSemaphoreHandleTypeOpaqueWin32 = 2,

	cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt = 3,

	cudaExternalSemaphoreHandleTypeD3D12Fence = 4,

	cudaExternalSemaphoreHandleTypeD3D11Fence = 5,

	cudaExternalSemaphoreHandleTypeNvSciSync = 6,

	cudaExternalSemaphoreHandleTypeKeyedMutex = 7,

	cudaExternalSemaphoreHandleTypeKeyedMutexKmt = 8,

	cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd = 9,

	cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32 = 10
};

struct cudaExternalSemaphoreHandleDesc {
	enum cudaExternalSemaphoreHandleType type;
	union {
		int fd;
		struct {
			void *handle;

			const void *name;
		} win32;

		const void *nvSciSyncObj;
	} handle;

	unsigned int flags;
};

struct cudaExternalSemaphoreSignalParams_v1 {
	struct {
		struct {
			unsigned long long value;
		} fence;
		union {
			void *fence;
			unsigned long long reserved;
		} nvSciSync;

		struct {
			unsigned long long key;
		} keyedMutex;
	} params;
	unsigned int flags;
};

struct cudaExternalSemaphoreWaitParams_v1 {
	struct {
		struct {
			unsigned long long value;
		} fence;
		union {
			void *fence;
			unsigned long long reserved;
		} nvSciSync;

		struct {
			unsigned long long key;

			unsigned int timeoutMs;
		} keyedMutex;
	} params;
	unsigned int flags;
};

struct cudaExternalSemaphoreSignalParams {
	struct {
		struct {
			unsigned long long value;
		} fence;
		union {
			void *fence;
			unsigned long long reserved;
		} nvSciSync;

		struct {
			unsigned long long key;
		} keyedMutex;
		unsigned int reserved[12];
	} params;
	unsigned int flags;
	unsigned int reserved[16];
};

struct cudaExternalSemaphoreWaitParams {
	struct {
		struct {
			unsigned long long value;
		} fence;
		union {
			void *fence;
			unsigned long long reserved;
		} nvSciSync;

		struct {
			unsigned long long key;

			unsigned int timeoutMs;
		} keyedMutex;
		unsigned int reserved[10];
	} params;
	unsigned int flags;
	unsigned int reserved[16];
};
typedef enum cudaError cudaError_t;

typedef struct CUstream_st *cudaStream_t;

typedef struct CUevent_st *cudaEvent_t;

typedef struct cudaGraphicsResource *cudaGraphicsResource_t;

typedef struct CUexternalMemory_st *cudaExternalMemory_t;

typedef struct CUexternalSemaphore_st *cudaExternalSemaphore_t;

typedef struct CUgraph_st *cudaGraph_t;

typedef struct CUgraphNode_st *cudaGraphNode_t;

typedef struct CUuserObject_st *cudaUserObject_t;

typedef unsigned long long cudaGraphConditionalHandle;

typedef struct CUfunc_st *cudaFunction_t;

typedef struct CUkern_st *cudaKernel_t;

typedef struct CUmemPoolHandle_st *cudaMemPool_t;

enum cudaCGScope {
	cudaCGScopeInvalid = 0,
	cudaCGScopeGrid = 1,
	cudaCGScopeMultiGrid = 2
};

struct cudaLaunchParams {
	void *func;
	dim3 gridDim;
	dim3 blockDim;
	void **args;
	size_t sharedMem;
	cudaStream_t stream;
};

struct cudaKernelNodeParams {
	void *func;
	dim3 gridDim;
	dim3 blockDim;
	unsigned int sharedMemBytes;
	void **kernelParams;
	void **extra;
};

struct cudaKernelNodeParamsV2 {
	void *func;

	dim3 gridDim;
	dim3 blockDim;

	unsigned int sharedMemBytes;
	void **kernelParams;
	void **extra;
};

struct cudaExternalSemaphoreSignalNodeParams {
	cudaExternalSemaphore_t *extSemArray;
	const struct cudaExternalSemaphoreSignalParams *paramsArray;
	unsigned int numExtSems;
};

struct cudaExternalSemaphoreSignalNodeParamsV2 {
	cudaExternalSemaphore_t *extSemArray;
	const struct cudaExternalSemaphoreSignalParams *paramsArray;
	unsigned int numExtSems;
};

struct cudaExternalSemaphoreWaitNodeParams {
	cudaExternalSemaphore_t *extSemArray;
	const struct cudaExternalSemaphoreWaitParams *paramsArray;
	unsigned int numExtSems;
};

struct cudaExternalSemaphoreWaitNodeParamsV2 {
	cudaExternalSemaphore_t *extSemArray;
	const struct cudaExternalSemaphoreWaitParams *paramsArray;
	unsigned int numExtSems;
};

enum cudaGraphConditionalHandleFlags { cudaGraphCondAssignDefault = 1 };

enum cudaGraphConditionalNodeType {
	cudaGraphCondTypeIf = 0,
	cudaGraphCondTypeWhile = 1,
};

struct cudaConditionalNodeParams {
	cudaGraphConditionalHandle handle;

	enum cudaGraphConditionalNodeType type;
	unsigned int size;
	cudaGraph_t *phGraph_out;
};

enum cudaGraphNodeType {
	cudaGraphNodeTypeKernel = 0x00,
	cudaGraphNodeTypeMemcpy = 0x01,
	cudaGraphNodeTypeMemset = 0x02,
	cudaGraphNodeTypeHost = 0x03,
	cudaGraphNodeTypeGraph = 0x04,
	cudaGraphNodeTypeEmpty = 0x05,
	cudaGraphNodeTypeWaitEvent = 0x06,
	cudaGraphNodeTypeEventRecord = 0x07,
	cudaGraphNodeTypeExtSemaphoreSignal = 0x08,
	cudaGraphNodeTypeExtSemaphoreWait = 0x09,
	cudaGraphNodeTypeMemAlloc = 0x0a,
	cudaGraphNodeTypeMemFree = 0x0b,
	cudaGraphNodeTypeConditional = 0x0d,
	cudaGraphNodeTypeCount
};

struct cudaChildGraphNodeParams {
	cudaGraph_t graph;
};

struct cudaEventRecordNodeParams {
	cudaEvent_t event;
};

struct cudaEventWaitNodeParams {
	cudaEvent_t event;
};

struct cudaGraphNodeParams {
	enum cudaGraphNodeType type;
	int reserved0[3];

	union {
		long long reserved1[29];
		struct cudaKernelNodeParamsV2 kernel;
		struct cudaMemcpyNodeParams memcpy;
		struct cudaMemsetParamsV2 memset;
		struct cudaHostNodeParamsV2 host;
		struct cudaChildGraphNodeParams graph;
		struct cudaEventWaitNodeParams eventWait;
		struct cudaEventRecordNodeParams eventRecord;
		struct cudaExternalSemaphoreSignalNodeParamsV2 extSemSignal;
		struct cudaExternalSemaphoreWaitNodeParamsV2 extSemWait;
		struct cudaMemAllocNodeParamsV2 alloc;
		struct cudaMemFreeNodeParams free;
		struct cudaConditionalNodeParams conditional;
	};

	long long reserved2;
};

typedef enum cudaGraphDependencyType_enum {
	cudaGraphDependencyTypeDefault = 0,
	cudaGraphDependencyTypeProgrammatic = 1

} cudaGraphDependencyType;

typedef struct cudaGraphEdgeData_st {
	unsigned char from_port;
	unsigned char to_port;

	unsigned char type;

	unsigned char reserved[5];

} cudaGraphEdgeData;
typedef struct CUgraphExec_st *cudaGraphExec_t;

enum cudaGraphExecUpdateResult {
	cudaGraphExecUpdateSuccess = 0x0,
	cudaGraphExecUpdateError = 0x1,
	cudaGraphExecUpdateErrorTopologyChanged = 0x2,
	cudaGraphExecUpdateErrorNodeTypeChanged = 0x3,
	cudaGraphExecUpdateErrorFunctionChanged = 0x4,
	cudaGraphExecUpdateErrorParametersChanged = 0x5,
	cudaGraphExecUpdateErrorNotSupported = 0x6,
	cudaGraphExecUpdateErrorUnsupportedFunctionChange = 0x7,
	cudaGraphExecUpdateErrorAttributesChanged = 0x8
};

typedef enum cudaGraphInstantiateResult {
	cudaGraphInstantiateSuccess = 0,
	cudaGraphInstantiateError = 1,
	cudaGraphInstantiateInvalidStructure = 2,
	cudaGraphInstantiateNodeOperationNotSupported = 3,
	cudaGraphInstantiateMultipleDevicesNotSupported = 4
} cudaGraphInstantiateResult;

typedef struct cudaGraphInstantiateParams_st {
	unsigned long long flags;
	cudaStream_t uploadStream;
	cudaGraphNode_t errNode_out;
	cudaGraphInstantiateResult result_out;
} cudaGraphInstantiateParams;

typedef struct cudaGraphExecUpdateResultInfo_st {
	enum cudaGraphExecUpdateResult result;

	cudaGraphNode_t errorNode;

	cudaGraphNode_t errorFromNode;
} cudaGraphExecUpdateResultInfo;

typedef struct CUgraphDeviceUpdatableNode_st *cudaGraphDeviceNode_t;

enum cudaGraphKernelNodeField {
	cudaGraphKernelNodeFieldInvalid = 0,
	cudaGraphKernelNodeFieldGridDim,
	cudaGraphKernelNodeFieldParam,
	cudaGraphKernelNodeFieldEnabled
};

struct cudaGraphKernelNodeUpdate {
	cudaGraphDeviceNode_t node;
	enum cudaGraphKernelNodeField field;
	union {
		dim3 gridDim;

		struct {
			const void *pValue;
			size_t offset;
			size_t size;
		} param;
		unsigned int isEnabled;
	} updateData;
};

enum cudaGetDriverEntryPointFlags {
	cudaEnableDefault = 0x0,
	cudaEnableLegacyStream = 0x1,
	cudaEnablePerThreadDefaultStream = 0x2
};

enum cudaDriverEntryPointQueryResult {
	cudaDriverEntryPointSuccess = 0,
	cudaDriverEntryPointSymbolNotFound = 1,
	cudaDriverEntryPointVersionNotSufficent = 2
};

enum cudaGraphDebugDotFlags {
	cudaGraphDebugDotFlagsVerbose = 1 << 0,
	cudaGraphDebugDotFlagsKernelNodeParams = 1 << 2,
	cudaGraphDebugDotFlagsMemcpyNodeParams = 1 << 3,
	cudaGraphDebugDotFlagsMemsetNodeParams = 1 << 4,
	cudaGraphDebugDotFlagsHostNodeParams = 1 << 5,
	cudaGraphDebugDotFlagsEventNodeParams = 1 << 6,
	cudaGraphDebugDotFlagsExtSemasSignalNodeParams = 1 << 7,
	cudaGraphDebugDotFlagsExtSemasWaitNodeParams = 1 << 8,
	cudaGraphDebugDotFlagsKernelNodeAttributes = 1 << 9,
	cudaGraphDebugDotFlagsHandles = 1 << 10,
	cudaGraphDebugDotFlagsConditionalNodeParams = 1 << 15,
};

enum cudaGraphInstantiateFlags {
	cudaGraphInstantiateFlagAutoFreeOnLaunch = 1,
	cudaGraphInstantiateFlagUpload = 2

	,
	cudaGraphInstantiateFlagDeviceLaunch = 4

	,
	cudaGraphInstantiateFlagUseNodePriority = 8

};
typedef enum cudaLaunchMemSyncDomain {
	cudaLaunchMemSyncDomainDefault = 0,
	cudaLaunchMemSyncDomainRemote = 1
} cudaLaunchMemSyncDomain;
typedef struct cudaLaunchMemSyncDomainMap_st {
	unsigned char default_;
	unsigned char remote;
} cudaLaunchMemSyncDomainMap;

typedef enum cudaLaunchAttributeID {
	cudaLaunchAttributeIgnore = 0,
	cudaLaunchAttributeAccessPolicyWindow = 1

	,
	cudaLaunchAttributeCooperative = 2

	,
	cudaLaunchAttributeSynchronizationPolicy = 3,
	cudaLaunchAttributeClusterDimension = 4

	,
	cudaLaunchAttributeClusterSchedulingPolicyPreference = 5

	,
	cudaLaunchAttributeProgrammaticStreamSerialization = 6,
	cudaLaunchAttributeProgrammaticEvent = 7,
	cudaLaunchAttributePriority = 8

	,
	cudaLaunchAttributeMemSyncDomainMap = 9

	,
	cudaLaunchAttributeMemSyncDomain = 10

	,
	cudaLaunchAttributeLaunchCompletionEvent = 12,
	cudaLaunchAttributeDeviceUpdatableKernelNode = 13,
	cudaLaunchAttributePreferredSharedMemoryCarveout = 14

} cudaLaunchAttributeID;

typedef union cudaLaunchAttributeValue {
	char pad[64];
	struct cudaAccessPolicyWindow accessPolicyWindow;
	int cooperative;

	enum cudaSynchronizationPolicy syncPolicy;
	struct {
		unsigned int x;
		unsigned int y;
		unsigned int z;
	} clusterDim;
	enum cudaClusterSchedulingPolicy clusterSchedulingPolicyPreference;

	int programmaticStreamSerializationAllowed;
	struct {
		cudaEvent_t event;
		int flags;
		int triggerAtBlockStart;
	} programmaticEvent;
	int priority;
	cudaLaunchMemSyncDomainMap memSyncDomainMap;

	cudaLaunchMemSyncDomain memSyncDomain;
	struct {
		cudaEvent_t event;
		int flags;
	} launchCompletionEvent;

	struct {
		int deviceUpdatable;
		cudaGraphDeviceNode_t devNode;
	} deviceUpdatableKernelNode;
	unsigned int sharedMemCarveout;
} cudaLaunchAttributeValue;

typedef struct cudaLaunchAttribute_st {
	cudaLaunchAttributeID id;
	char pad[8 - sizeof(cudaLaunchAttributeID)];
	cudaLaunchAttributeValue val;
} cudaLaunchAttribute;

typedef struct cudaLaunchConfig_st {
	dim3 gridDim;
	dim3 blockDim;
	size_t dynamicSmemBytes;
	cudaStream_t stream;
	cudaLaunchAttribute *attrs;
	unsigned int numAttrs;
} cudaLaunchConfig_t;
enum cudaDeviceNumaConfig {
	cudaDeviceNumaConfigNone = 0,
	cudaDeviceNumaConfigNumaNode,
};

typedef struct cudaAsyncCallbackEntry *cudaAsyncCallbackHandle_t;

struct cudaAsyncCallbackEntry;

typedef enum cudaAsyncNotificationType_enum {
	cudaAsyncNotificationTypeOverBudget = 0x1
} cudaAsyncNotificationType;

typedef struct cudaAsyncNotificationInfo {
	cudaAsyncNotificationType type;
	union {
		struct {
			unsigned long long bytesOverBudget;
		} overBudget;
	} info;
} cudaAsyncNotificationInfo_t;

typedef void (*cudaAsyncCallback)(cudaAsyncNotificationInfo_t *, void *,
				  cudaAsyncCallbackHandle_t);

enum cudaSurfaceBoundaryMode {
	cudaBoundaryModeZero = 0,
	cudaBoundaryModeClamp = 1,
	cudaBoundaryModeTrap = 2
};

enum cudaSurfaceFormatMode { cudaFormatModeForced = 0, cudaFormatModeAuto = 1 };

typedef unsigned long long cudaSurfaceObject_t;
enum cudaTextureAddressMode {
	cudaAddressModeWrap = 0,
	cudaAddressModeClamp = 1,
	cudaAddressModeMirror = 2,
	cudaAddressModeBorder = 3
};

enum cudaTextureFilterMode {
	cudaFilterModePoint = 0,
	cudaFilterModeLinear = 1
};

enum cudaTextureReadMode {
	cudaReadModeElementType = 0,
	cudaReadModeNormalizedFloat = 1
};

struct cudaTextureDesc {
	enum cudaTextureAddressMode addressMode[3];

	enum cudaTextureFilterMode filterMode;

	enum cudaTextureReadMode readMode;

	int sRGB;

	float borderColor[4];

	int normalizedCoords;

	unsigned int maxAnisotropy;

	enum cudaTextureFilterMode mipmapFilterMode;

	float mipmapLevelBias;

	float minMipmapLevelClamp;

	float maxMipmapLevelClamp;

	int disableTrilinearOptimization;

	int seamlessCubemap;
};

typedef unsigned long long cudaTextureObject_t;
typedef struct {
	long long __max_align_ll
		__attribute((__aligned__(__alignof__(long long))));
	long double __max_align_ld
		__attribute((__aligned__(__alignof__(long double))));
} max_align_t;
typedef __decltype((nullptr)) nullptr_t;

typedef struct cudaArray *cudaArray_t;
typedef const cudaArray *cudaArray_const_t;
struct cudaArray;
typedef struct cudaMipmappedArray *cudaMipmappedArray_t;
typedef const cudaMipmappedArray *cudaMipmappedArray_const_t;
struct cudaMipmappedArray;
typedef void (*cudaHostFn_t)(void *userData);
struct cudaGraphicsResource;
typedef struct CUgraphExec_st *cudaGraphExec_t;
typedef struct CUgraphDeviceUpdatableNode_st *cudaGraphDeviceNode_t;
typedef struct cudaAsyncCallbackEntry *cudaAsyncCallbackHandle_t;
struct cudaAsyncCallbackEntry;
typedef void (*cudaAsyncCallback)(cudaAsyncNotificationInfo_t *, void *,
				  cudaAsyncCallbackHandle_t);
typedef enum cudaDataType_t {
	CUDA_R_16F = 2,
	CUDA_C_16F = 6,
	CUDA_R_16BF = 14,
	CUDA_C_16BF,
	CUDA_R_32F = 0,
	CUDA_C_32F = 4,
	CUDA_R_64F = 1,
	CUDA_C_64F = 5,
	CUDA_R_4I = 16,
	CUDA_C_4I,
	CUDA_R_4U,
	CUDA_C_4U,
	CUDA_R_8I = 3,
	CUDA_C_8I = 7,
	CUDA_R_8U,
	CUDA_C_8U,
	CUDA_R_16I = 20,
	CUDA_C_16I,
	CUDA_R_16U,
	CUDA_C_16U,
	CUDA_R_32I = 10,
	CUDA_C_32I,
	CUDA_R_32U,
	CUDA_C_32U,
	CUDA_R_64I = 24,
	CUDA_C_64I,
	CUDA_R_64U,
	CUDA_C_64U,
	CUDA_R_8F_E4M3,
	CUDA_R_8F_E5M2
} cudaDataType;
typedef enum libraryPropertyType_t {
	MAJOR_VERSION,
	MINOR_VERSION,
	PATCH_LEVEL
} libraryPropertyType;

namespace std
{
typedef unsigned long size_t;
typedef long ptrdiff_t;
typedef __decltype((nullptr)) nullptr_t;
__attribute((__noreturn__, __always_inline__)) inline void
__terminate() noexcept
{
	void terminate() noexcept __attribute((__noreturn__));
	terminate();
}
} // namespace std
namespace std
{
inline namespace __cxx11 __attribute((__abi_tag__("cxx11")))
{
}
} // namespace std
namespace __gnu_cxx
{
inline namespace __cxx11 __attribute((__abi_tag__("cxx11")))
{
}
} // namespace __gnu_cxx
namespace std
{
constexpr bool __is_constant_evaluated() noexcept
{
	return __builtin_is_constant_evaluated();
}
} // namespace std
extern "C" {
typedef float _Float32;
typedef double _Float64;
typedef double _Float32x;
typedef long double _Float64x;
typedef struct {
	int quot;
	int rem;
} div_t;
typedef struct {
	long quot;
	long rem;
} ldiv_t;
__extension__ typedef struct {
	long long quot;
	long long rem;
} lldiv_t;
extern size_t __ctype_get_mb_cur_max() noexcept(true);
extern double atof(const char *__nptr) noexcept(true) __attribute((__pure__))
__attribute((__nonnull__(1)));
extern int atoi(const char *__nptr) noexcept(true) __attribute((__pure__))
__attribute((__nonnull__(1)));
extern long atol(const char *__nptr) noexcept(true) __attribute((__pure__))
__attribute((__nonnull__(1)));
__extension__ extern long long atoll(const char *__nptr) noexcept(true)
	__attribute((__pure__)) __attribute((__nonnull__(1)));
extern double strtod(const char *__restrict__ __nptr,
		     char **__restrict__ __endptr) noexcept(true)
	__attribute((__nonnull__(1)));
extern float strtof(const char *__restrict__ __nptr,
		    char **__restrict__ __endptr) noexcept(true)
	__attribute((__nonnull__(1)));
extern long double strtold(const char *__restrict__ __nptr,
			   char **__restrict__ __endptr) noexcept(true)
	__attribute((__nonnull__(1)));
extern _Float32 strtof32(const char *__restrict__ __nptr,
			 char **__restrict__ __endptr) noexcept(true)
	__attribute((__nonnull__(1)));
extern _Float64 strtof64(const char *__restrict__ __nptr,
			 char **__restrict__ __endptr) noexcept(true)
	__attribute((__nonnull__(1)));
extern _Float32x strtof32x(const char *__restrict__ __nptr,
			   char **__restrict__ __endptr) noexcept(true)
	__attribute((__nonnull__(1)));
extern _Float64x strtof64x(const char *__restrict__ __nptr,
			   char **__restrict__ __endptr) noexcept(true)
	__attribute((__nonnull__(1)));
extern long strtol(const char *__restrict__ __nptr,
		   char **__restrict__ __endptr, int __base) noexcept(true)
	__attribute((__nonnull__(1)));
extern unsigned long strtoul(const char *__restrict__ __nptr,
			     char **__restrict__ __endptr,
			     int __base) noexcept(true)
	__attribute((__nonnull__(1)));
__extension__ extern long long strtoq(const char *__restrict__ __nptr,
				      char **__restrict__ __endptr,
				      int __base) noexcept(true)
	__attribute((__nonnull__(1)));
__extension__ extern unsigned long long strtouq(const char *__restrict__ __nptr,
						char **__restrict__ __endptr,
						int __base) noexcept(true)
	__attribute((__nonnull__(1)));
__extension__ extern long long strtoll(const char *__restrict__ __nptr,
				       char **__restrict__ __endptr,
				       int __base) noexcept(true)
	__attribute((__nonnull__(1)));
__extension__ extern unsigned long long
strtoull(const char *__restrict__ __nptr, char **__restrict__ __endptr,
	 int __base) noexcept(true) __attribute((__nonnull__(1)));
extern int strfromd(char *__dest, size_t __size, const char *__format,
		    double __f) noexcept(true) __attribute((__nonnull__(3)));
extern int strfromf(char *__dest, size_t __size, const char *__format,
		    float __f) noexcept(true) __attribute((__nonnull__(3)));
extern int strfroml(char *__dest, size_t __size, const char *__format,
		    long double __f) noexcept(true)
	__attribute((__nonnull__(3)));
extern int strfromf32(char *__dest, size_t __size, const char *__format,
		      _Float32 __f) noexcept(true)
	__attribute((__nonnull__(3)));
extern int strfromf64(char *__dest, size_t __size, const char *__format,
		      _Float64 __f) noexcept(true)
	__attribute((__nonnull__(3)));
extern int strfromf32x(char *__dest, size_t __size, const char *__format,
		       _Float32x __f) noexcept(true)
	__attribute((__nonnull__(3)));
extern int strfromf64x(char *__dest, size_t __size, const char *__format,
		       _Float64x __f) noexcept(true)
	__attribute((__nonnull__(3)));
extern long strtol_l(const char *__restrict__ __nptr,
		     char **__restrict__ __endptr, int __base,
		     locale_t __loc) noexcept(true)
	__attribute((__nonnull__(1, 4)));
extern unsigned long strtoul_l(const char *__restrict__ __nptr,
			       char **__restrict__ __endptr, int __base,
			       locale_t __loc) noexcept(true)
	__attribute((__nonnull__(1, 4)));
__extension__ extern long long
strtoll_l(const char *__restrict__ __nptr, char **__restrict__ __endptr,
	  int __base, locale_t __loc) noexcept(true)
	__attribute((__nonnull__(1, 4)));
__extension__ extern unsigned long long
strtoull_l(const char *__restrict__ __nptr, char **__restrict__ __endptr,
	   int __base, locale_t __loc) noexcept(true)
	__attribute((__nonnull__(1, 4)));
extern double strtod_l(const char *__restrict__ __nptr,
		       char **__restrict__ __endptr,
		       locale_t __loc) noexcept(true)
	__attribute((__nonnull__(1, 3)));
extern float strtof_l(const char *__restrict__ __nptr,
		      char **__restrict__ __endptr,
		      locale_t __loc) noexcept(true)
	__attribute((__nonnull__(1, 3)));
extern long double strtold_l(const char *__restrict__ __nptr,
			     char **__restrict__ __endptr,
			     locale_t __loc) noexcept(true)
	__attribute((__nonnull__(1, 3)));
extern _Float32 strtof32_l(const char *__restrict__ __nptr,
			   char **__restrict__ __endptr,
			   locale_t __loc) noexcept(true)
	__attribute((__nonnull__(1, 3)));
extern _Float64 strtof64_l(const char *__restrict__ __nptr,
			   char **__restrict__ __endptr,
			   locale_t __loc) noexcept(true)
	__attribute((__nonnull__(1, 3)));
extern _Float32x strtof32x_l(const char *__restrict__ __nptr,
			     char **__restrict__ __endptr,
			     locale_t __loc) noexcept(true)
	__attribute((__nonnull__(1, 3)));
extern _Float64x strtof64x_l(const char *__restrict__ __nptr,
			     char **__restrict__ __endptr,
			     locale_t __loc) noexcept(true)
	__attribute((__nonnull__(1, 3)));
extern char *l64a(long __n) noexcept(true);
extern long a64l(const char *__s) noexcept(true) __attribute((__pure__))
__attribute((__nonnull__(1)));
extern "C" {
typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;
typedef __loff_t loff_t;
typedef __ino_t ino_t;
typedef __ino64_t ino64_t;
typedef __dev_t dev_t;
typedef __gid_t gid_t;
typedef __mode_t mode_t;
typedef __nlink_t nlink_t;
typedef __uid_t uid_t;
typedef __off_t off_t;
typedef __off64_t off64_t;
typedef __pid_t pid_t;
typedef __id_t id_t;
typedef __ssize_t ssize_t;
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;
typedef __key_t key_t;
typedef __clock_t clock_t;
typedef __clockid_t clockid_t;
typedef __time_t time_t;
typedef __timer_t timer_t;
typedef __useconds_t useconds_t;
typedef __suseconds_t suseconds_t;
typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned uint;
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;
typedef long register_t __attribute((__mode__(__word__)));
static inline __uint16_t __bswap_16(__uint16_t __bsx)
{
	return __builtin_bswap16(__bsx);
}
static inline __uint32_t __bswap_32(__uint32_t __bsx)
{
	return __builtin_bswap32(__bsx);
}
__extension__ static inline __uint64_t __bswap_64(__uint64_t __bsx)
{
	return __builtin_bswap64(__bsx);
}
static inline __uint16_t __uint16_identity(__uint16_t __x)
{
	return __x;
}
static inline __uint32_t __uint32_identity(__uint32_t __x)
{
	return __x;
}
static inline __uint64_t __uint64_identity(__uint64_t __x)
{
	return __x;
}
typedef struct {
	unsigned long __val[(1024) / ((8) * sizeof(unsigned long))];
} __sigset_t;
typedef __sigset_t sigset_t;
struct timeval {
	__time_t tv_sec;
	__suseconds_t tv_usec;
};
struct timespec {
	__time_t tv_sec;
	__syscall_slong_t tv_nsec;
};
typedef long __fd_mask;
typedef struct {
	__fd_mask fds_bits[1024 / (8 * ((int)sizeof(__fd_mask)))];
} fd_set;
typedef __fd_mask fd_mask;
extern "C" {
extern int select(int __nfds, fd_set *__restrict__ __readfds,
		  fd_set *__restrict__ __writefds,
		  fd_set *__restrict__ __exceptfds,
		  timeval *__restrict__ __timeout);
extern int pselect(int __nfds, fd_set *__restrict__ __readfds,
		   fd_set *__restrict__ __writefds,
		   fd_set *__restrict__ __exceptfds,
		   const timespec *__restrict__ __timeout,
		   const __sigset_t *__restrict__ __sigmask);
}
typedef __blksize_t blksize_t;
typedef __blkcnt_t blkcnt_t;
typedef __fsblkcnt_t fsblkcnt_t;
typedef __fsfilcnt_t fsfilcnt_t;
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;
typedef union {
	__extension__ unsigned long long __value64;
	struct {
		unsigned __low;
		unsigned __high;
	} __value32;
} __atomic_wide_counter;
typedef struct __pthread_internal_list {
	__pthread_internal_list *__prev;
	__pthread_internal_list *__next;
} __pthread_list_t;
typedef struct __pthread_internal_slist {
	__pthread_internal_slist *__next;
} __pthread_slist_t;
struct __pthread_mutex_s {
	int __lock;
	unsigned __count;
	int __owner;
	unsigned __nusers;
	int __kind;
	short __spins;
	short __elision;
	__pthread_list_t __list;
};
struct __pthread_rwlock_arch_t {
	unsigned __readers;
	unsigned __writers;
	unsigned __wrphase_futex;
	unsigned __writers_futex;
	unsigned __pad3;
	unsigned __pad4;
	int __cur_writer;
	int __shared;
	signed char __rwelision;
	unsigned char __pad1[7];
	unsigned long __pad2;
	unsigned __flags;
};
struct __pthread_cond_s {
	__atomic_wide_counter __wseq;
	__atomic_wide_counter __g1_start;
	unsigned __g_refs[2];
	unsigned __g_size[2];
	unsigned __g1_orig_size;
	unsigned __wrefs;
	unsigned __g_signals[2];
};
typedef unsigned __tss_t;
typedef unsigned long __thrd_t;
typedef struct {
	int __data;
} __once_flag;
typedef unsigned long pthread_t;
typedef union {
	char __size[4];
	int __align;
} pthread_mutexattr_t;
typedef union {
	char __size[4];
	int __align;
} pthread_condattr_t;
typedef unsigned pthread_key_t;
typedef int pthread_once_t;
union pthread_attr_t {
	char __size[56];
	long __align;
};
typedef pthread_attr_t pthread_attr_t;
typedef union {
	__pthread_mutex_s __data;
	char __size[40];
	long __align;
} pthread_mutex_t;
typedef union {
	__pthread_cond_s __data;
	char __size[48];
	__extension__ long long __align;
} pthread_cond_t;
typedef union {
	__pthread_rwlock_arch_t __data;
	char __size[56];
	long __align;
} pthread_rwlock_t;
typedef union {
	char __size[8];
	long __align;
} pthread_rwlockattr_t;
typedef volatile int pthread_spinlock_t;
typedef union {
	char __size[32];
	long __align;
} pthread_barrier_t;
typedef union {
	char __size[4];
	int __align;
} pthread_barrierattr_t;
}
extern long random() noexcept(true);
extern void srandom(unsigned __seed) noexcept(true);
extern char *initstate(unsigned __seed, char *__statebuf,
		       size_t __statelen) noexcept(true)
	__attribute((__nonnull__(2)));
extern char *setstate(char *__statebuf) noexcept(true)
	__attribute((__nonnull__(1)));
struct random_data {
	int32_t *fptr;
	int32_t *rptr;
	int32_t *state;
	int rand_type;
	int rand_deg;
	int rand_sep;
	int32_t *end_ptr;
};
extern int random_r(random_data *__restrict__ __buf,
		    int32_t *__restrict__ __result) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int srandom_r(unsigned __seed, random_data *__buf) noexcept(true)
	__attribute((__nonnull__(2)));
extern int initstate_r(unsigned __seed, char *__restrict__ __statebuf,
		       size_t __statelen,
		       random_data *__restrict__ __buf) noexcept(true)
	__attribute((__nonnull__(2, 4)));
extern int setstate_r(char *__restrict__ __statebuf,
		      random_data *__restrict__ __buf) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int rand() noexcept(true);
extern void srand(unsigned __seed) noexcept(true);
extern int rand_r(unsigned *__seed) noexcept(true);
extern double drand48() noexcept(true);
extern double erand48(unsigned short __xsubi[3]) noexcept(true)
	__attribute((__nonnull__(1)));
extern long lrand48() noexcept(true);
extern long nrand48(unsigned short __xsubi[3]) noexcept(true)
	__attribute((__nonnull__(1)));
extern long mrand48() noexcept(true);
extern long jrand48(unsigned short __xsubi[3]) noexcept(true)
	__attribute((__nonnull__(1)));
extern void srand48(long __seedval) noexcept(true);
extern unsigned short *seed48(unsigned short __seed16v[3]) noexcept(true)
	__attribute((__nonnull__(1)));
extern void lcong48(unsigned short __param[7]) noexcept(true)
	__attribute((__nonnull__(1)));
struct drand48_data {
	unsigned short __x[3];
	unsigned short __old_x[3];
	unsigned short __c;
	unsigned short __init;
	__extension__ unsigned long long __a;
};
extern int drand48_r(drand48_data *__restrict__ __buffer,
		     double *__restrict__ __result) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int erand48_r(unsigned short __xsubi[3],
		     drand48_data *__restrict__ __buffer,
		     double *__restrict__ __result) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int lrand48_r(drand48_data *__restrict__ __buffer,
		     long *__restrict__ __result) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int nrand48_r(unsigned short __xsubi[3],
		     drand48_data *__restrict__ __buffer,
		     long *__restrict__ __result) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int mrand48_r(drand48_data *__restrict__ __buffer,
		     long *__restrict__ __result) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int jrand48_r(unsigned short __xsubi[3],
		     drand48_data *__restrict__ __buffer,
		     long *__restrict__ __result) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int srand48_r(long __seedval, drand48_data *__buffer) noexcept(true)
	__attribute((__nonnull__(2)));
extern int seed48_r(unsigned short __seed16v[3],
		    drand48_data *__buffer) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int lcong48_r(unsigned short __param[7],
		     drand48_data *__buffer) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern __uint32_t arc4random() noexcept(true);
extern void arc4random_buf(void *__buf, size_t __size) noexcept(true)
	__attribute((__nonnull__(1)));
extern __uint32_t arc4random_uniform(__uint32_t __upper_bound) noexcept(true);
extern void *malloc(size_t __size) noexcept(true) __attribute((__malloc__))
__attribute((__alloc_size__(1)));
extern void *calloc(size_t __nmemb, size_t __size) noexcept(true)
	__attribute((__malloc__)) __attribute((__alloc_size__(1, 2)));
extern void *realloc(void *__ptr, size_t __size) noexcept(true)
	__attribute((__warn_unused_result__)) __attribute((__alloc_size__(2)));
extern void free(void *__ptr) noexcept(true);
extern void *reallocarray(void *__ptr, size_t __nmemb,
			  size_t __size) noexcept(true)
	__attribute((__warn_unused_result__))
	__attribute((__alloc_size__(2, 3)))
	__attribute((__malloc__(__builtin_free, 1)));
extern void *reallocarray(void *__ptr, size_t __nmemb,
			  size_t __size) noexcept(true)
	__attribute((__malloc__(reallocarray, 1)));
extern "C" {
extern void *alloca(size_t __size) noexcept(true);
}
extern void *valloc(size_t __size) noexcept(true) __attribute((__malloc__))
__attribute((__alloc_size__(1)));
extern int posix_memalign(void **__memptr, size_t __alignment,
			  size_t __size) noexcept(true)
	__attribute((__nonnull__(1)));
extern void *aligned_alloc(size_t __alignment, size_t __size) noexcept(true)
	__attribute((__malloc__)) __attribute((__alloc_align__(1)))
	__attribute((__alloc_size__(2)));
extern void abort() noexcept(true) __attribute((__noreturn__));
extern int atexit(void (*__func)(void)) noexcept(true)
	__attribute((__nonnull__(1)));
extern "C++" int
at_quick_exit(void (*__func)(void)) noexcept(true) __asm__("at_quick_exit")
	__attribute((__nonnull__(1)));
extern int on_exit(void (*__func)(int __status, void *__arg),
		   void *__arg) noexcept(true) __attribute((__nonnull__(1)));
extern void exit(int __status) noexcept(true) __attribute((__noreturn__));
extern void quick_exit(int __status) noexcept(true) __attribute((__noreturn__));
extern void _Exit(int __status) noexcept(true) __attribute((__noreturn__));
extern char *getenv(const char *__name) noexcept(true)
	__attribute((__nonnull__(1)));
extern char *secure_getenv(const char *__name) noexcept(true)
	__attribute((__nonnull__(1)));
extern int putenv(char *__string) noexcept(true) __attribute((__nonnull__(1)));
extern int setenv(const char *__name, const char *__value,
		  int __replace) noexcept(true) __attribute((__nonnull__(2)));
extern int unsetenv(const char *__name) noexcept(true)
	__attribute((__nonnull__(1)));
extern int clearenv() noexcept(true);
extern char *mktemp(char *__template) noexcept(true)
	__attribute((__nonnull__(1)));
extern int mkstemp(char *__template) __attribute((__nonnull__(1)));
extern int mkstemp64(char *__template) __attribute((__nonnull__(1)));
extern int mkstemps(char *__template, int __suffixlen)
	__attribute((__nonnull__(1)));
extern int mkstemps64(char *__template, int __suffixlen)
	__attribute((__nonnull__(1)));
extern char *mkdtemp(char *__template) noexcept(true)
	__attribute((__nonnull__(1)));
extern int mkostemp(char *__template, int __flags)
	__attribute((__nonnull__(1)));
extern int mkostemp64(char *__template, int __flags)
	__attribute((__nonnull__(1)));
extern int mkostemps(char *__template, int __suffixlen, int __flags)
	__attribute((__nonnull__(1)));
extern int mkostemps64(char *__template, int __suffixlen, int __flags)
	__attribute((__nonnull__(1)));
extern int system(const char *__command);
extern char *canonicalize_file_name(const char *__name) noexcept(true)
	__attribute((__nonnull__(1))) __attribute((__malloc__))
	__attribute((__malloc__(__builtin_free, 1)));
extern char *realpath(const char *__restrict__ __name,
		      char *__restrict__ __resolved) noexcept(true);
typedef int (*__compar_fn_t)(const void *, const void *);
typedef __compar_fn_t comparison_fn_t;
typedef int (*__compar_d_fn_t)(const void *, const void *, void *);
extern void *bsearch(const void *__key, const void *__base, size_t __nmemb,
		     size_t __size, __compar_fn_t __compar)
	__attribute((__nonnull__(1, 2, 5)));
extern void qsort(void *__base, size_t __nmemb, size_t __size,
		  __compar_fn_t __compar) __attribute((__nonnull__(1, 4)));
extern void qsort_r(void *__base, size_t __nmemb, size_t __size,
		    __compar_d_fn_t __compar, void *__arg)
	__attribute((__nonnull__(1, 4)));
extern int abs(int __x) noexcept(true) __attribute((const));
extern long labs(long __x) noexcept(true) __attribute((const));
__extension__ extern long long llabs(long long __x) noexcept(true)
	__attribute((const));
extern div_t div(int __numer, int __denom) noexcept(true) __attribute((const));
extern ldiv_t ldiv(long __numer, long __denom) noexcept(true)
	__attribute((const));
__extension__ extern lldiv_t lldiv(long long __numer,
				   long long __denom) noexcept(true)
	__attribute((const));
extern char *ecvt(double __value, int __ndigit, int *__restrict__ __decpt,
		  int *__restrict__ __sign) noexcept(true)
	__attribute((__nonnull__(3, 4)));
extern char *fcvt(double __value, int __ndigit, int *__restrict__ __decpt,
		  int *__restrict__ __sign) noexcept(true)
	__attribute((__nonnull__(3, 4)));
extern char *gcvt(double __value, int __ndigit, char *__buf) noexcept(true)
	__attribute((__nonnull__(3)));
extern char *qecvt(long double __value, int __ndigit, int *__restrict__ __decpt,
		   int *__restrict__ __sign) noexcept(true)
	__attribute((__nonnull__(3, 4)));
extern char *qfcvt(long double __value, int __ndigit, int *__restrict__ __decpt,
		   int *__restrict__ __sign) noexcept(true)
	__attribute((__nonnull__(3, 4)));
extern char *qgcvt(long double __value, int __ndigit,
		   char *__buf) noexcept(true) __attribute((__nonnull__(3)));
extern int ecvt_r(double __value, int __ndigit, int *__restrict__ __decpt,
		  int *__restrict__ __sign, char *__restrict__ __buf,
		  size_t __len) noexcept(true)
	__attribute((__nonnull__(3, 4, 5)));
extern int fcvt_r(double __value, int __ndigit, int *__restrict__ __decpt,
		  int *__restrict__ __sign, char *__restrict__ __buf,
		  size_t __len) noexcept(true)
	__attribute((__nonnull__(3, 4, 5)));
extern int qecvt_r(long double __value, int __ndigit, int *__restrict__ __decpt,
		   int *__restrict__ __sign, char *__restrict__ __buf,
		   size_t __len) noexcept(true)
	__attribute((__nonnull__(3, 4, 5)));
extern int qfcvt_r(long double __value, int __ndigit, int *__restrict__ __decpt,
		   int *__restrict__ __sign, char *__restrict__ __buf,
		   size_t __len) noexcept(true)
	__attribute((__nonnull__(3, 4, 5)));
extern int mblen(const char *__s, size_t __n) noexcept(true);
extern int mbtowc(wchar_t *__restrict__ __pwc, const char *__restrict__ __s,
		  size_t __n) noexcept(true);
extern int wctomb(char *__s, wchar_t __wchar) noexcept(true);
extern size_t mbstowcs(wchar_t *__restrict__ __pwcs,
		       const char *__restrict__ __s, size_t __n) noexcept(true)
	__attribute((__access__(__read_only__, 2)));
extern size_t wcstombs(char *__restrict__ __s,
		       const wchar_t *__restrict__ __pwcs,
		       size_t __n) noexcept(true)
	__attribute((__access__(__write_only__, 1, 3)))
	__attribute((__access__(__read_only__, 2)));
extern int rpmatch(const char *__response) noexcept(true)
	__attribute((__nonnull__(1)));
extern int getsubopt(char **__restrict__ __optionp,
		     char *const *__restrict__ __tokens,
		     char **__restrict__ __valuep) noexcept(true)
	__attribute((__nonnull__(1, 2, 3)));
extern int posix_openpt(int __oflag);
extern int grantpt(int __fd) noexcept(true);
extern int unlockpt(int __fd) noexcept(true);
extern char *ptsname(int __fd) noexcept(true);
extern int ptsname_r(int __fd, char *__buf, size_t __buflen) noexcept(true)
	__attribute((__nonnull__(2)))
	__attribute((__access__(__write_only__, 2, 3)));
extern int getpt();
extern int getloadavg(double __loadavg[], int __nelem) noexcept(true)
	__attribute((__nonnull__(1)));
}
extern "C++" {
namespace std __attribute((__visibility__("default")))
{
	using ::abs;
	inline long abs(long __i)
	{
		return __builtin_labs(__i);
	}
	inline long long abs(long long __x)
	{
		return __builtin_llabs(__x);
	}
	constexpr double abs(double __x)
	{
		return __builtin_fabs(__x);
	}
	constexpr float abs(float __x)
	{
		return __builtin_fabsf(__x);
	}
	constexpr long double abs(long double __x)
	{
		return __builtin_fabsl(__x);
	}
	__extension__ constexpr __int128 abs(__int128 __x)
	{
		return (__x >= (0)) ? __x : (-__x);
	}
} // namespace )
}
extern "C++" {
namespace std __attribute((__visibility__("default")))
{
	using ::abort;
	using ::aligned_alloc;
	using ::at_quick_exit;
	using ::atexit;
	using ::atof;
	using ::atoi;
	using ::atol;
	using ::bsearch;
	using ::calloc;
	using ::div;
	using ::div_t;
	using ::exit;
	using ::free;
	using ::getenv;
	using ::labs;
	using ::ldiv;
	using ::ldiv_t;
	using ::malloc;
	using ::mblen;
	using ::mbstowcs;
	using ::mbtowc;
	using ::qsort;
	using ::quick_exit;
	using ::rand;
	using ::realloc;
	using ::srand;
	using ::strtod;
	using ::strtol;
	using ::strtoul;
	using ::system;
	using ::wcstombs;
	using ::wctomb;
	inline ldiv_t div(long __i, long __j)
	{
		return ldiv(__i, __j);
	}
} // namespace )
namespace __gnu_cxx __attribute((__visibility__("default")))
{
	using ::_Exit;
	using ::llabs;
	using ::lldiv_t;
	inline lldiv_t div(long long __n, long long __d)
	{
		lldiv_t __q;
		(__q.quot) = (__n / __d);
		(__q.rem) = (__n % __d);
		return __q;
	}
	using ::atoll;
	using ::lldiv;
	using ::strtof;
	using ::strtold;
	using ::strtoll;
	using ::strtoull;
} // namespace )
namespace std
{
using __gnu_cxx::_Exit;
using __gnu_cxx::atoll;
using __gnu_cxx::div;
using __gnu_cxx::llabs;
using __gnu_cxx::lldiv;
using __gnu_cxx::lldiv_t;
using __gnu_cxx::strtof;
using __gnu_cxx::strtold;
using __gnu_cxx::strtoll;
using __gnu_cxx::strtoull;
} // namespace std
}
using std::abort;
using std::abs;
using std::at_quick_exit;
using std::atexit;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::exit;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;
using std::mblen;
using std::mbstowcs;
using std::mbtowc;
using std::qsort;
using std::quick_exit;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;
using std::wcstombs;
using std::wctomb;

extern "C" {
__attribute__((unused)) extern cudaError_t
__cudaDeviceSynchronizeDeprecationAvoidance();
__attribute__((unused)) extern cudaError_t
__cudaCDP2DeviceGetAttribute(int *value, cudaDeviceAttr attr, int device);
__attribute__((unused)) extern cudaError_t
__cudaCDP2DeviceGetLimit(size_t *pValue, cudaLimit limit);
__attribute__((unused)) extern cudaError_t
__cudaCDP2DeviceGetCacheConfig(cudaFuncCache *pCacheConfig);
__attribute__((unused)) extern cudaError_t
__cudaCDP2DeviceGetSharedMemConfig(cudaSharedMemConfig *pConfig);
__attribute__((unused)) extern cudaError_t __cudaCDP2GetLastError();
__attribute__((unused)) extern cudaError_t __cudaCDP2PeekAtLastError();
__attribute__((unused)) extern const char *
__cudaCDP2GetErrorString(cudaError_t error);
__attribute__((unused)) extern const char *
__cudaCDP2GetErrorName(cudaError_t error);
__attribute__((unused)) extern cudaError_t __cudaCDP2GetDeviceCount(int *count);
__attribute__((unused)) extern cudaError_t __cudaCDP2GetDevice(int *device);
__attribute__((unused)) extern cudaError_t
__cudaCDP2StreamCreateWithFlags(cudaStream_t *pStream, unsigned flags);
__attribute__((unused)) extern cudaError_t
__cudaCDP2StreamDestroy(cudaStream_t stream);
__attribute__((unused)) extern cudaError_t
__cudaCDP2StreamWaitEvent(cudaStream_t stream, cudaEvent_t event,
			  unsigned flags);
__attribute__((unused)) extern cudaError_t
__cudaCDP2StreamWaitEvent_ptsz(cudaStream_t stream, cudaEvent_t event,
			       unsigned flags);
__attribute__((unused)) extern cudaError_t
__cudaCDP2EventCreateWithFlags(cudaEvent_t *event, unsigned flags);
__attribute__((unused)) extern cudaError_t
__cudaCDP2EventRecord(cudaEvent_t event, cudaStream_t stream);
__attribute__((unused)) extern cudaError_t
__cudaCDP2EventRecord_ptsz(cudaEvent_t event, cudaStream_t stream);
__attribute__((unused)) extern cudaError_t
__cudaCDP2EventRecordWithFlags(cudaEvent_t event, cudaStream_t stream,
			       unsigned flags);
__attribute__((unused)) extern cudaError_t
__cudaCDP2EventRecordWithFlags_ptsz(cudaEvent_t event, cudaStream_t stream,
				    unsigned flags);
__attribute__((unused)) extern cudaError_t
__cudaCDP2EventDestroy(cudaEvent_t event);
__attribute__((unused)) extern cudaError_t
__cudaCDP2FuncGetAttributes(cudaFuncAttributes *attr, const void *func);
__attribute__((unused)) extern cudaError_t __cudaCDP2Free(void *devPtr);
__attribute__((unused)) extern cudaError_t __cudaCDP2Malloc(void **devPtr,
							    size_t size);
__attribute__((unused)) extern cudaError_t
__cudaCDP2MemcpyAsync(void *dst, const void *src, size_t count,
		      cudaMemcpyKind kind, cudaStream_t stream);
__attribute__((unused)) extern cudaError_t
__cudaCDP2MemcpyAsync_ptsz(void *dst, const void *src, size_t count,
			   cudaMemcpyKind kind, cudaStream_t stream);
__attribute__((unused)) extern cudaError_t
__cudaCDP2Memcpy2DAsync(void *dst, size_t dpitch, const void *src,
			size_t spitch, size_t width, size_t height,
			cudaMemcpyKind kind, cudaStream_t stream);
__attribute__((unused)) extern cudaError_t
__cudaCDP2Memcpy2DAsync_ptsz(void *dst, size_t dpitch, const void *src,
			     size_t spitch, size_t width, size_t height,
			     cudaMemcpyKind kind, cudaStream_t stream);
__attribute__((unused)) extern cudaError_t
__cudaCDP2Memcpy3DAsync(const cudaMemcpy3DParms *p, cudaStream_t stream);
__attribute__((unused)) extern cudaError_t
__cudaCDP2Memcpy3DAsync_ptsz(const cudaMemcpy3DParms *p, cudaStream_t stream);
__attribute__((unused)) extern cudaError_t
__cudaCDP2MemsetAsync(void *devPtr, int value, size_t count,
		      cudaStream_t stream);
__attribute__((unused)) extern cudaError_t
__cudaCDP2MemsetAsync_ptsz(void *devPtr, int value, size_t count,
			   cudaStream_t stream);
__attribute__((unused)) extern cudaError_t
__cudaCDP2Memset2DAsync(void *devPtr, size_t pitch, int value, size_t width,
			size_t height, cudaStream_t stream);
__attribute__((unused)) extern cudaError_t
__cudaCDP2Memset2DAsync_ptsz(void *devPtr, size_t pitch, int value,
			     size_t width, size_t height, cudaStream_t stream);
__attribute__((unused)) extern cudaError_t
__cudaCDP2Memset3DAsync(cudaPitchedPtr pitchedDevPtr, int value,
			cudaExtent extent, cudaStream_t stream);
__attribute__((unused)) extern cudaError_t
__cudaCDP2Memset3DAsync_ptsz(cudaPitchedPtr pitchedDevPtr, int value,
			     cudaExtent extent, cudaStream_t stream);
__attribute__((unused)) extern cudaError_t
__cudaCDP2RuntimeGetVersion(int *runtimeVersion);
__attribute__((unused)) extern void *
__cudaCDP2GetParameterBuffer(size_t alignment, size_t size);
__attribute__((unused)) extern void *
__cudaCDP2GetParameterBufferV2(void *func, dim3 gridDimension,
			       dim3 blockDimension, unsigned sharedMemSize);
__attribute__((unused)) extern cudaError_t
__cudaCDP2LaunchDevice_ptsz(void *func, void *parameterBuffer,
			    dim3 gridDimension, dim3 blockDimension,
			    unsigned sharedMemSize, cudaStream_t stream);
__attribute__((unused)) extern cudaError_t
__cudaCDP2LaunchDeviceV2_ptsz(void *parameterBuffer, cudaStream_t stream);
__attribute__((unused)) extern cudaError_t
__cudaCDP2LaunchDevice(void *func, void *parameterBuffer, dim3 gridDimension,
		       dim3 blockDimension, unsigned sharedMemSize,
		       cudaStream_t stream);
__attribute__((unused)) extern cudaError_t
__cudaCDP2LaunchDeviceV2(void *parameterBuffer, cudaStream_t stream);
__attribute__((unused)) extern cudaError_t
__cudaCDP2OccupancyMaxActiveBlocksPerMultiprocessor(int *numBlocks,
						    const void *func,
						    int blockSize,
						    size_t dynamicSmemSize);
__attribute__((unused)) extern cudaError_t
__cudaCDP2OccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
	int *numBlocks, const void *func, int blockSize, size_t dynamicSmemSize,
	unsigned flags);
extern cudaError_t cudaGraphLaunch(cudaGraphExec_t graphExec,
				   cudaStream_t stream);
__attribute__((unused)) static inline cudaGraphExec_t cudaGetCurrentGraphExec()
{
	int volatile ___ = 1;
	::exit(___);
}
__attribute__((unused)) extern cudaError_t
cudaGraphKernelNodeSetParam(cudaGraphDeviceNode_t node, size_t offset,
			    const void *value, size_t size);
__attribute__((unused)) extern cudaError_t
cudaGraphKernelNodeSetEnabled(cudaGraphDeviceNode_t node, bool enable);
__attribute__((unused)) extern cudaError_t
cudaGraphKernelNodeSetGridDim(cudaGraphDeviceNode_t node, dim3 gridDim);
__attribute__((unused)) extern cudaError_t
cudaGraphKernelNodeUpdatesApply(const cudaGraphKernelNodeUpdate *updates,
				size_t updateCount);
__attribute__((unused)) static inline void
cudaTriggerProgrammaticLaunchCompletion()
{
	int volatile ___ = 1;
	::exit(___);
}
__attribute__((unused)) static inline void cudaGridDependencySynchronize()
{
	int volatile ___ = 1;
	::exit(___);
}
__attribute__((unused)) extern void
cudaGraphSetConditional(cudaGraphConditionalHandle handle, unsigned value);
__attribute__((unused)) extern unsigned long long
cudaCGGetIntrinsicHandle(cudaCGScope scope);
__attribute__((unused)) extern cudaError_t
cudaCGSynchronize(unsigned long long handle, unsigned flags);
__attribute__((unused)) extern cudaError_t
cudaCGSynchronizeGrid(unsigned long long handle, unsigned flags);
__attribute__((unused)) extern cudaError_t
cudaCGGetSize(unsigned *numThreads, unsigned *numGrids,
	      unsigned long long handle);
__attribute__((unused)) extern cudaError_t
cudaCGGetRank(unsigned *threadRank, unsigned *gridRank,
	      unsigned long long handle);
__attribute__((unused)) static inline void *
cudaGetParameterBuffer(size_t alignment, size_t size)
{
	int volatile ___ = 1;
	(void)alignment;
	(void)size;
	::exit(___);
}
__attribute__((unused)) static inline void *
cudaGetParameterBufferV2(void *func, dim3 gridDimension, dim3 blockDimension,
			 unsigned sharedMemSize)
{
	int volatile ___ = 1;
	(void)func;
	(void)gridDimension;
	(void)blockDimension;
	(void)sharedMemSize;
	::exit(___);
}
__attribute__((unused)) static inline cudaError_t
cudaLaunchDevice_ptsz(void *func, void *parameterBuffer, dim3 gridDimension,
		      dim3 blockDimension, unsigned sharedMemSize,
		      cudaStream_t stream)
{
	int volatile ___ = 1;
	(void)func;
	(void)parameterBuffer;
	(void)gridDimension;
	(void)blockDimension;
	(void)sharedMemSize;
	(void)stream;
	::exit(___);
}
__attribute__((unused)) static inline cudaError_t
cudaLaunchDeviceV2_ptsz(void *parameterBuffer, cudaStream_t stream)
{
	int volatile ___ = 1;
	(void)parameterBuffer;
	(void)stream;
	::exit(___);
}
__attribute__((unused)) static inline cudaError_t
cudaLaunchDevice(void *func, void *parameterBuffer, dim3 gridDimension,
		 dim3 blockDimension, unsigned sharedMemSize,
		 cudaStream_t stream)
{
	int volatile ___ = 1;
	(void)func;
	(void)parameterBuffer;
	(void)gridDimension;
	(void)blockDimension;
	(void)sharedMemSize;
	(void)stream;
	::exit(___);
}
__attribute__((unused)) static inline cudaError_t
cudaLaunchDeviceV2(void *parameterBuffer, cudaStream_t stream)
{
	int volatile ___ = 1;
	(void)parameterBuffer;
	(void)stream;
	::exit(___);
}
}
template <class T>
static inline cudaError_t cudaMalloc(T **devPtr, size_t size);
template <class T>
static inline cudaError_t cudaFuncGetAttributes(cudaFuncAttributes *attr,
						T *entry);
template <class T>
static inline cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(
	int *numBlocks, T func, int blockSize, size_t dynamicSmemSize);
template <class T>
static inline cudaError_t
cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int *numBlocks, T func,
						       int blockSize,
						       size_t dynamicSmemSize,
						       unsigned flags);
template <class T>
__attribute__((unused)) static inline cudaError_t
cudaGraphKernelNodeSetParam(cudaGraphDeviceNode_t node, size_t offset,
			    const T &value)
{
	int volatile ___ = 1;
	(void)node;
	(void)offset;
	(void)value;
	::exit(___);
}
extern "C" {
extern cudaError_t cudaDeviceReset();
extern cudaError_t cudaDeviceSynchronize();
extern cudaError_t cudaDeviceSetLimit(cudaLimit limit, size_t value);
extern cudaError_t cudaDeviceGetLimit(size_t *pValue, cudaLimit limit);
extern cudaError_t
cudaDeviceGetTexture1DLinearMaxWidth(size_t *maxWidthInElements,
				     const cudaChannelFormatDesc *fmtDesc,
				     int device);
extern cudaError_t cudaDeviceGetCacheConfig(cudaFuncCache *pCacheConfig);
extern cudaError_t cudaDeviceGetStreamPriorityRange(int *leastPriority,
						    int *greatestPriority);
extern cudaError_t cudaDeviceSetCacheConfig(cudaFuncCache cacheConfig);
extern cudaError_t cudaDeviceGetByPCIBusId(int *device, const char *pciBusId);
extern cudaError_t cudaDeviceGetPCIBusId(char *pciBusId, int len, int device);
extern cudaError_t cudaIpcGetEventHandle(cudaIpcEventHandle_t *handle,
					 cudaEvent_t event);
extern cudaError_t cudaIpcOpenEventHandle(cudaEvent_t *event,
					  cudaIpcEventHandle_t handle);
extern cudaError_t cudaIpcGetMemHandle(cudaIpcMemHandle_t *handle,
				       void *devPtr);
extern cudaError_t
cudaIpcOpenMemHandle(void **devPtr, cudaIpcMemHandle_t handle, unsigned flags);
extern cudaError_t cudaIpcCloseMemHandle(void *devPtr);
extern cudaError_t
cudaDeviceFlushGPUDirectRDMAWrites(cudaFlushGPUDirectRDMAWritesTarget target,
				   cudaFlushGPUDirectRDMAWritesScope scope);
extern cudaError_t
cudaDeviceRegisterAsyncNotification(int device, cudaAsyncCallback callbackFunc,
				    void *userData,
				    cudaAsyncCallbackHandle_t *callback);
extern cudaError_t
cudaDeviceUnregisterAsyncNotification(int device,
				      cudaAsyncCallbackHandle_t callback);
__attribute((deprecated)) extern cudaError_t
cudaDeviceGetSharedMemConfig(cudaSharedMemConfig *pConfig);
__attribute((deprecated)) extern cudaError_t
cudaDeviceSetSharedMemConfig(cudaSharedMemConfig config);
__attribute((deprecated)) extern cudaError_t cudaThreadExit();
__attribute((deprecated)) extern cudaError_t cudaThreadSynchronize();
__attribute((deprecated)) extern cudaError_t cudaThreadSetLimit(cudaLimit limit,
								size_t value);
__attribute((deprecated)) extern cudaError_t
cudaThreadGetLimit(size_t *pValue, cudaLimit limit);
__attribute((deprecated)) extern cudaError_t
cudaThreadGetCacheConfig(cudaFuncCache *pCacheConfig);
__attribute((deprecated)) extern cudaError_t
cudaThreadSetCacheConfig(cudaFuncCache cacheConfig);
extern cudaError_t cudaGetLastError();
extern cudaError_t cudaPeekAtLastError();
extern const char *cudaGetErrorName(cudaError_t error);
extern const char *cudaGetErrorString(cudaError_t error);
extern cudaError_t cudaGetDeviceCount(int *count);
extern cudaError_t cudaGetDeviceProperties_v2(cudaDeviceProp *prop, int device);
extern cudaError_t cudaDeviceGetAttribute(int *value, cudaDeviceAttr attr,
					  int device);
extern cudaError_t cudaDeviceGetDefaultMemPool(cudaMemPool_t *memPool,
					       int device);
extern cudaError_t cudaDeviceSetMemPool(int device, cudaMemPool_t memPool);
extern cudaError_t cudaDeviceGetMemPool(cudaMemPool_t *memPool, int device);
extern cudaError_t cudaDeviceGetNvSciSyncAttributes(void *nvSciSyncAttrList,
						    int device, int flags);
extern cudaError_t cudaDeviceGetP2PAttribute(int *value, cudaDeviceP2PAttr attr,
					     int srcDevice, int dstDevice);
extern cudaError_t cudaChooseDevice(int *device, const cudaDeviceProp *prop);
extern cudaError_t cudaInitDevice(int device, unsigned deviceFlags,
				  unsigned flags);
extern cudaError_t cudaSetDevice(int device);
extern cudaError_t cudaGetDevice(int *device);
extern cudaError_t cudaSetValidDevices(int *device_arr, int len);
extern cudaError_t cudaSetDeviceFlags(unsigned flags);
extern cudaError_t cudaGetDeviceFlags(unsigned *flags);
extern cudaError_t cudaStreamCreate(cudaStream_t *pStream);
extern cudaError_t cudaStreamCreateWithFlags(cudaStream_t *pStream,
					     unsigned flags);
extern cudaError_t cudaStreamCreateWithPriority(cudaStream_t *pStream,
						unsigned flags, int priority);
extern cudaError_t cudaStreamGetPriority(cudaStream_t hStream, int *priority);
extern cudaError_t cudaStreamGetFlags(cudaStream_t hStream, unsigned *flags);
extern cudaError_t cudaStreamGetId(cudaStream_t hStream,
				   unsigned long long *streamId);
extern cudaError_t cudaCtxResetPersistingL2Cache();
extern cudaError_t cudaStreamCopyAttributes(cudaStream_t dst, cudaStream_t src);
extern cudaError_t cudaStreamGetAttribute(cudaStream_t hStream,
					  cudaLaunchAttributeID attr,
					  cudaLaunchAttributeValue *value_out);
extern cudaError_t
cudaStreamSetAttribute(cudaStream_t hStream, cudaLaunchAttributeID attr,
		       const cudaLaunchAttributeValue *value);
extern cudaError_t cudaStreamDestroy(cudaStream_t stream);
extern cudaError_t cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event,
				       unsigned flags = 0);
typedef void (*cudaStreamCallback_t)(cudaStream_t stream, cudaError_t status,
				     void *userData);
extern cudaError_t cudaStreamAddCallback(cudaStream_t stream,
					 cudaStreamCallback_t callback,
					 void *userData, unsigned flags);
extern cudaError_t cudaStreamSynchronize(cudaStream_t stream);
extern cudaError_t cudaStreamQuery(cudaStream_t stream);
extern cudaError_t cudaStreamAttachMemAsync(cudaStream_t stream, void *devPtr,
					    size_t length = 0,
					    unsigned flags = 4);
extern cudaError_t cudaStreamBeginCapture(cudaStream_t stream,
					  cudaStreamCaptureMode mode);
extern cudaError_t
cudaStreamBeginCaptureToGraph(cudaStream_t stream, cudaGraph_t graph,
			      const cudaGraphNode_t *dependencies,
			      const cudaGraphEdgeData *dependencyData,
			      size_t numDependencies,
			      cudaStreamCaptureMode mode);
extern cudaError_t
cudaThreadExchangeStreamCaptureMode(cudaStreamCaptureMode *mode);
extern cudaError_t cudaStreamEndCapture(cudaStream_t stream,
					cudaGraph_t *pGraph);
extern cudaError_t
cudaStreamIsCapturing(cudaStream_t stream,
		      cudaStreamCaptureStatus *pCaptureStatus);
extern cudaError_t cudaStreamGetCaptureInfo_v2(
	cudaStream_t stream, cudaStreamCaptureStatus *captureStatus_out,
	unsigned long long *id_out = 0, cudaGraph_t *graph_out = 0,
	const cudaGraphNode_t **dependencies_out = 0,
	size_t *numDependencies_out = 0);
extern cudaError_t cudaStreamGetCaptureInfo_v3(
	cudaStream_t stream, cudaStreamCaptureStatus *captureStatus_out,
	unsigned long long *id_out = 0, cudaGraph_t *graph_out = 0,
	const cudaGraphNode_t **dependencies_out = 0,
	const cudaGraphEdgeData **edgeData_out = 0,
	size_t *numDependencies_out = 0);
extern cudaError_t
cudaStreamUpdateCaptureDependencies(cudaStream_t stream,
				    cudaGraphNode_t *dependencies,
				    size_t numDependencies, unsigned flags = 0);
extern cudaError_t cudaStreamUpdateCaptureDependencies_v2(
	cudaStream_t stream, cudaGraphNode_t *dependencies,
	const cudaGraphEdgeData *dependencyData, size_t numDependencies,
	unsigned flags = 0);
extern cudaError_t cudaEventCreate(cudaEvent_t *event);
extern cudaError_t cudaEventCreateWithFlags(cudaEvent_t *event, unsigned flags);
extern cudaError_t cudaEventRecord(cudaEvent_t event, cudaStream_t stream = 0);
extern cudaError_t cudaEventRecordWithFlags(cudaEvent_t event,
					    cudaStream_t stream = 0,
					    unsigned flags = 0);
extern cudaError_t cudaEventQuery(cudaEvent_t event);
extern cudaError_t cudaEventSynchronize(cudaEvent_t event);
extern cudaError_t cudaEventDestroy(cudaEvent_t event);
extern cudaError_t cudaEventElapsedTime(float *ms, cudaEvent_t start,
					cudaEvent_t end);
extern cudaError_t
cudaImportExternalMemory(cudaExternalMemory_t *extMem_out,
			 const cudaExternalMemoryHandleDesc *memHandleDesc);
extern cudaError_t cudaExternalMemoryGetMappedBuffer(
	void **devPtr, cudaExternalMemory_t extMem,
	const cudaExternalMemoryBufferDesc *bufferDesc);
extern cudaError_t cudaExternalMemoryGetMappedMipmappedArray(
	cudaMipmappedArray_t *mipmap, cudaExternalMemory_t extMem,
	const cudaExternalMemoryMipmappedArrayDesc *mipmapDesc);
extern cudaError_t cudaDestroyExternalMemory(cudaExternalMemory_t extMem);
extern cudaError_t cudaImportExternalSemaphore(
	cudaExternalSemaphore_t *extSem_out,
	const cudaExternalSemaphoreHandleDesc *semHandleDesc);
extern cudaError_t cudaSignalExternalSemaphoresAsync_v2(
	const cudaExternalSemaphore_t *extSemArray,
	const cudaExternalSemaphoreSignalParams *paramsArray,
	unsigned numExtSems, cudaStream_t stream = 0);
extern cudaError_t cudaWaitExternalSemaphoresAsync_v2(
	const cudaExternalSemaphore_t *extSemArray,
	const cudaExternalSemaphoreWaitParams *paramsArray, unsigned numExtSems,
	cudaStream_t stream = 0);
extern cudaError_t cudaDestroyExternalSemaphore(cudaExternalSemaphore_t extSem);
extern cudaError_t cudaLaunchKernel(const void *func, dim3 gridDim,
				    dim3 blockDim, void **args,
				    size_t sharedMem, cudaStream_t stream);
extern cudaError_t cudaLaunchKernelExC(const cudaLaunchConfig_t *config,
				       const void *func, void **args);
extern cudaError_t cudaLaunchCooperativeKernel(const void *func, dim3 gridDim,
					       dim3 blockDim, void **args,
					       size_t sharedMem,
					       cudaStream_t stream);
__attribute((deprecated)) extern cudaError_t
cudaLaunchCooperativeKernelMultiDevice(cudaLaunchParams *launchParamsList,
				       unsigned numDevices, unsigned flags = 0);
extern cudaError_t cudaFuncSetCacheConfig(const void *func,
					  cudaFuncCache cacheConfig);
extern cudaError_t cudaFuncGetAttributes(cudaFuncAttributes *attr,
					 const void *func);
extern cudaError_t cudaFuncSetAttribute(const void *func,
					cudaFuncAttribute attr, int value);
extern cudaError_t cudaFuncGetName(const char **name, const void *func);
extern cudaError_t cudaFuncGetParamInfo(const void *func, size_t paramIndex,
					size_t *paramOffset, size_t *paramSize);
__attribute((deprecated)) extern cudaError_t cudaSetDoubleForDevice(double *d);
__attribute((deprecated)) extern cudaError_t cudaSetDoubleForHost(double *d);
extern cudaError_t cudaLaunchHostFunc(cudaStream_t stream, cudaHostFn_t fn,
				      void *userData);
__attribute((deprecated)) extern cudaError_t
cudaFuncSetSharedMemConfig(const void *func, cudaSharedMemConfig config);
extern cudaError_t
cudaOccupancyMaxActiveBlocksPerMultiprocessor(int *numBlocks, const void *func,
					      int blockSize,
					      size_t dynamicSMemSize);
extern cudaError_t
cudaOccupancyAvailableDynamicSMemPerBlock(size_t *dynamicSmemSize,
					  const void *func, int numBlocks,
					  int blockSize);
extern cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
	int *numBlocks, const void *func, int blockSize, size_t dynamicSMemSize,
	unsigned flags);
extern cudaError_t
cudaOccupancyMaxPotentialClusterSize(int *clusterSize, const void *func,
				     const cudaLaunchConfig_t *launchConfig);
extern cudaError_t
cudaOccupancyMaxActiveClusters(int *numClusters, const void *func,
			       const cudaLaunchConfig_t *launchConfig);
extern cudaError_t cudaMallocManaged(void **devPtr, size_t size,
				     unsigned flags = 1);
extern cudaError_t cudaMalloc(void **devPtr, size_t size);
extern cudaError_t cudaMallocHost(void **ptr, size_t size);
extern cudaError_t cudaMallocPitch(void **devPtr, size_t *pitch, size_t width,
				   size_t height);
extern cudaError_t cudaMallocArray(cudaArray_t *array,
				   const cudaChannelFormatDesc *desc,
				   size_t width, size_t height = 0,
				   unsigned flags = 0);
extern cudaError_t cudaFree(void *devPtr);
extern cudaError_t cudaFreeHost(void *ptr);
extern cudaError_t cudaFreeArray(cudaArray_t array);
extern cudaError_t cudaFreeMipmappedArray(cudaMipmappedArray_t mipmappedArray);
extern cudaError_t cudaHostAlloc(void **pHost, size_t size, unsigned flags);
extern cudaError_t cudaHostRegister(void *ptr, size_t size, unsigned flags);
extern cudaError_t cudaHostUnregister(void *ptr);
extern cudaError_t cudaHostGetDevicePointer(void **pDevice, void *pHost,
					    unsigned flags);
extern cudaError_t cudaHostGetFlags(unsigned *pFlags, void *pHost);
extern cudaError_t cudaMalloc3D(cudaPitchedPtr *pitchedDevPtr,
				cudaExtent extent);
extern cudaError_t cudaMalloc3DArray(cudaArray_t *array,
				     const cudaChannelFormatDesc *desc,
				     cudaExtent extent, unsigned flags = 0);
extern cudaError_t
cudaMallocMipmappedArray(cudaMipmappedArray_t *mipmappedArray,
			 const cudaChannelFormatDesc *desc, cudaExtent extent,
			 unsigned numLevels, unsigned flags = 0);
extern cudaError_t
cudaGetMipmappedArrayLevel(cudaArray_t *levelArray,
			   cudaMipmappedArray_const_t mipmappedArray,
			   unsigned level);
extern cudaError_t cudaMemcpy3D(const cudaMemcpy3DParms *p);
extern cudaError_t cudaMemcpy3DPeer(const cudaMemcpy3DPeerParms *p);
extern cudaError_t cudaMemcpy3DAsync(const cudaMemcpy3DParms *p,
				     cudaStream_t stream = 0);
extern cudaError_t cudaMemcpy3DPeerAsync(const cudaMemcpy3DPeerParms *p,
					 cudaStream_t stream = 0);
extern cudaError_t cudaMemGetInfo(size_t *free, size_t *total);
extern cudaError_t cudaArrayGetInfo(cudaChannelFormatDesc *desc,
				    cudaExtent *extent, unsigned *flags,
				    cudaArray_t array);
extern cudaError_t cudaArrayGetPlane(cudaArray_t *pPlaneArray,
				     cudaArray_t hArray, unsigned planeIdx);
extern cudaError_t
cudaArrayGetMemoryRequirements(cudaArrayMemoryRequirements *memoryRequirements,
			       cudaArray_t array, int device);
extern cudaError_t cudaMipmappedArrayGetMemoryRequirements(
	cudaArrayMemoryRequirements *memoryRequirements,
	cudaMipmappedArray_t mipmap, int device);
extern cudaError_t
cudaArrayGetSparseProperties(cudaArraySparseProperties *sparseProperties,
			     cudaArray_t array);
extern cudaError_t cudaMipmappedArrayGetSparseProperties(
	cudaArraySparseProperties *sparseProperties,
	cudaMipmappedArray_t mipmap);
extern cudaError_t cudaMemcpy(void *dst, const void *src, size_t count,
			      cudaMemcpyKind kind);
extern cudaError_t cudaMemcpyPeer(void *dst, int dstDevice, const void *src,
				  int srcDevice, size_t count);
extern cudaError_t cudaMemcpy2D(void *dst, size_t dpitch, const void *src,
				size_t spitch, size_t width, size_t height,
				cudaMemcpyKind kind);
extern cudaError_t cudaMemcpy2DToArray(cudaArray_t dst, size_t wOffset,
				       size_t hOffset, const void *src,
				       size_t spitch, size_t width,
				       size_t height, cudaMemcpyKind kind);
extern cudaError_t cudaMemcpy2DFromArray(void *dst, size_t dpitch,
					 cudaArray_const_t src, size_t wOffset,
					 size_t hOffset, size_t width,
					 size_t height, cudaMemcpyKind kind);
extern cudaError_t
cudaMemcpy2DArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst,
			 cudaArray_const_t src, size_t wOffsetSrc,
			 size_t hOffsetSrc, size_t width, size_t height,
			 cudaMemcpyKind kind = cudaMemcpyDeviceToDevice);
extern cudaError_t
cudaMemcpyToSymbol(const void *symbol, const void *src, size_t count,
		   size_t offset = 0,
		   cudaMemcpyKind kind = cudaMemcpyHostToDevice);
extern cudaError_t
cudaMemcpyFromSymbol(void *dst, const void *symbol, size_t count,
		     size_t offset = 0,
		     cudaMemcpyKind kind = cudaMemcpyDeviceToHost);
extern cudaError_t cudaMemcpyAsync(void *dst, const void *src, size_t count,
				   cudaMemcpyKind kind,
				   cudaStream_t stream = 0);
extern cudaError_t cudaMemcpyPeerAsync(void *dst, int dstDevice,
				       const void *src, int srcDevice,
				       size_t count, cudaStream_t stream = 0);
extern cudaError_t cudaMemcpy2DAsync(void *dst, size_t dpitch, const void *src,
				     size_t spitch, size_t width, size_t height,
				     cudaMemcpyKind kind,
				     cudaStream_t stream = 0);
extern cudaError_t cudaMemcpy2DToArrayAsync(cudaArray_t dst, size_t wOffset,
					    size_t hOffset, const void *src,
					    size_t spitch, size_t width,
					    size_t height, cudaMemcpyKind kind,
					    cudaStream_t stream = 0);
extern cudaError_t cudaMemcpy2DFromArrayAsync(void *dst, size_t dpitch,
					      cudaArray_const_t src,
					      size_t wOffset, size_t hOffset,
					      size_t width, size_t height,
					      cudaMemcpyKind kind,
					      cudaStream_t stream = 0);
extern cudaError_t cudaMemcpyToSymbolAsync(const void *symbol, const void *src,
					   size_t count, size_t offset,
					   cudaMemcpyKind kind,
					   cudaStream_t stream = 0);
extern cudaError_t cudaMemcpyFromSymbolAsync(void *dst, const void *symbol,
					     size_t count, size_t offset,
					     cudaMemcpyKind kind,
					     cudaStream_t stream = 0);
extern cudaError_t cudaMemset(void *devPtr, int value, size_t count);
extern cudaError_t cudaMemset2D(void *devPtr, size_t pitch, int value,
				size_t width, size_t height);
extern cudaError_t cudaMemset3D(cudaPitchedPtr pitchedDevPtr, int value,
				cudaExtent extent);
extern cudaError_t cudaMemsetAsync(void *devPtr, int value, size_t count,
				   cudaStream_t stream = 0);
extern cudaError_t cudaMemset2DAsync(void *devPtr, size_t pitch, int value,
				     size_t width, size_t height,
				     cudaStream_t stream = 0);
extern cudaError_t cudaMemset3DAsync(cudaPitchedPtr pitchedDevPtr, int value,
				     cudaExtent extent,
				     cudaStream_t stream = 0);
extern cudaError_t cudaGetSymbolAddress(void **devPtr, const void *symbol);
extern cudaError_t cudaGetSymbolSize(size_t *size, const void *symbol);
extern cudaError_t cudaMemPrefetchAsync(const void *devPtr, size_t count,
					int dstDevice, cudaStream_t stream = 0);
extern cudaError_t cudaMemPrefetchAsync_v2(const void *devPtr, size_t count,
					   cudaMemLocation location,
					   unsigned flags,
					   cudaStream_t stream = 0);
extern cudaError_t cudaMemAdvise(const void *devPtr, size_t count,
				 cudaMemoryAdvise advice, int device);
extern cudaError_t cudaMemAdvise_v2(const void *devPtr, size_t count,
				    cudaMemoryAdvise advice,
				    cudaMemLocation location);
extern cudaError_t cudaMemRangeGetAttribute(void *data, size_t dataSize,
					    cudaMemRangeAttribute attribute,
					    const void *devPtr, size_t count);
extern cudaError_t cudaMemRangeGetAttributes(void **data, size_t *dataSizes,
					     cudaMemRangeAttribute *attributes,
					     size_t numAttributes,
					     const void *devPtr, size_t count);
__attribute((deprecated)) extern cudaError_t
cudaMemcpyToArray(cudaArray_t dst, size_t wOffset, size_t hOffset,
		  const void *src, size_t count, cudaMemcpyKind kind);
__attribute((deprecated)) extern cudaError_t
cudaMemcpyFromArray(void *dst, cudaArray_const_t src, size_t wOffset,
		    size_t hOffset, size_t count, cudaMemcpyKind kind);
__attribute((deprecated)) extern cudaError_t
cudaMemcpyArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst,
		       cudaArray_const_t src, size_t wOffsetSrc,
		       size_t hOffsetSrc, size_t count,
		       cudaMemcpyKind kind = cudaMemcpyDeviceToDevice);
__attribute((deprecated)) extern cudaError_t
cudaMemcpyToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset,
		       const void *src, size_t count, cudaMemcpyKind kind,
		       cudaStream_t stream = 0);
__attribute((deprecated)) extern cudaError_t
cudaMemcpyFromArrayAsync(void *dst, cudaArray_const_t src, size_t wOffset,
			 size_t hOffset, size_t count, cudaMemcpyKind kind,
			 cudaStream_t stream = 0);
extern cudaError_t cudaMallocAsync(void **devPtr, size_t size,
				   cudaStream_t hStream);
extern cudaError_t cudaFreeAsync(void *devPtr, cudaStream_t hStream);
extern cudaError_t cudaMemPoolTrimTo(cudaMemPool_t memPool,
				     size_t minBytesToKeep);
extern cudaError_t cudaMemPoolSetAttribute(cudaMemPool_t memPool,
					   cudaMemPoolAttr attr, void *value);
extern cudaError_t cudaMemPoolGetAttribute(cudaMemPool_t memPool,
					   cudaMemPoolAttr attr, void *value);
extern cudaError_t cudaMemPoolSetAccess(cudaMemPool_t memPool,
					const cudaMemAccessDesc *descList,
					size_t count);
extern cudaError_t cudaMemPoolGetAccess(cudaMemAccessFlags *flags,
					cudaMemPool_t memPool,
					cudaMemLocation *location);
extern cudaError_t cudaMemPoolCreate(cudaMemPool_t *memPool,
				     const cudaMemPoolProps *poolProps);
extern cudaError_t cudaMemPoolDestroy(cudaMemPool_t memPool);
extern cudaError_t cudaMallocFromPoolAsync(void **ptr, size_t size,
					   cudaMemPool_t memPool,
					   cudaStream_t stream);
extern cudaError_t
cudaMemPoolExportToShareableHandle(void *shareableHandle, cudaMemPool_t memPool,
				   cudaMemAllocationHandleType handleType,
				   unsigned flags);
extern cudaError_t cudaMemPoolImportFromShareableHandle(
	cudaMemPool_t *memPool, void *shareableHandle,
	cudaMemAllocationHandleType handleType, unsigned flags);
extern cudaError_t
cudaMemPoolExportPointer(cudaMemPoolPtrExportData *exportData, void *ptr);
extern cudaError_t
cudaMemPoolImportPointer(void **ptr, cudaMemPool_t memPool,
			 cudaMemPoolPtrExportData *exportData);
extern cudaError_t cudaPointerGetAttributes(cudaPointerAttributes *attributes,
					    const void *ptr);
extern cudaError_t cudaDeviceCanAccessPeer(int *canAccessPeer, int device,
					   int peerDevice);
extern cudaError_t cudaDeviceEnablePeerAccess(int peerDevice, unsigned flags);
extern cudaError_t cudaDeviceDisablePeerAccess(int peerDevice);
extern cudaError_t
cudaGraphicsUnregisterResource(cudaGraphicsResource_t resource);
extern cudaError_t
cudaGraphicsResourceSetMapFlags(cudaGraphicsResource_t resource,
				unsigned flags);
extern cudaError_t cudaGraphicsMapResources(int count,
					    cudaGraphicsResource_t *resources,
					    cudaStream_t stream = 0);
extern cudaError_t cudaGraphicsUnmapResources(int count,
					      cudaGraphicsResource_t *resources,
					      cudaStream_t stream = 0);
extern cudaError_t
cudaGraphicsResourceGetMappedPointer(void **devPtr, size_t *size,
				     cudaGraphicsResource_t resource);
extern cudaError_t
cudaGraphicsSubResourceGetMappedArray(cudaArray_t *array,
				      cudaGraphicsResource_t resource,
				      unsigned arrayIndex, unsigned mipLevel);
extern cudaError_t cudaGraphicsResourceGetMappedMipmappedArray(
	cudaMipmappedArray_t *mipmappedArray, cudaGraphicsResource_t resource);
extern cudaError_t cudaGetChannelDesc(cudaChannelFormatDesc *desc,
				      cudaArray_const_t array);
extern cudaChannelFormatDesc cudaCreateChannelDesc(int x, int y, int z, int w,
						   cudaChannelFormatKind f);
extern cudaError_t
cudaCreateTextureObject(cudaTextureObject_t *pTexObject,
			const cudaResourceDesc *pResDesc,
			const cudaTextureDesc *pTexDesc,
			const cudaResourceViewDesc *pResViewDesc);
extern cudaError_t cudaDestroyTextureObject(cudaTextureObject_t texObject);
extern cudaError_t
cudaGetTextureObjectResourceDesc(cudaResourceDesc *pResDesc,
				 cudaTextureObject_t texObject);
extern cudaError_t
cudaGetTextureObjectTextureDesc(cudaTextureDesc *pTexDesc,
				cudaTextureObject_t texObject);
extern cudaError_t
cudaGetTextureObjectResourceViewDesc(cudaResourceViewDesc *pResViewDesc,
				     cudaTextureObject_t texObject);
extern cudaError_t cudaCreateSurfaceObject(cudaSurfaceObject_t *pSurfObject,
					   const cudaResourceDesc *pResDesc);
extern cudaError_t cudaDestroySurfaceObject(cudaSurfaceObject_t surfObject);
extern cudaError_t
cudaGetSurfaceObjectResourceDesc(cudaResourceDesc *pResDesc,
				 cudaSurfaceObject_t surfObject);
extern cudaError_t cudaDriverGetVersion(int *driverVersion);
extern cudaError_t cudaRuntimeGetVersion(int *runtimeVersion);
extern cudaError_t cudaGraphCreate(cudaGraph_t *pGraph, unsigned flags);
extern cudaError_t
cudaGraphAddKernelNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph,
		       const cudaGraphNode_t *pDependencies,
		       size_t numDependencies,
		       const cudaKernelNodeParams *pNodeParams);
extern cudaError_t
cudaGraphKernelNodeGetParams(cudaGraphNode_t node,
			     cudaKernelNodeParams *pNodeParams);
extern cudaError_t
cudaGraphKernelNodeSetParams(cudaGraphNode_t node,
			     const cudaKernelNodeParams *pNodeParams);
extern cudaError_t cudaGraphKernelNodeCopyAttributes(cudaGraphNode_t hSrc,
						     cudaGraphNode_t hDst);
extern cudaError_t
cudaGraphKernelNodeGetAttribute(cudaGraphNode_t hNode,
				cudaLaunchAttributeID attr,
				cudaLaunchAttributeValue *value_out);
extern cudaError_t
cudaGraphKernelNodeSetAttribute(cudaGraphNode_t hNode,
				cudaLaunchAttributeID attr,
				const cudaLaunchAttributeValue *value);
extern cudaError_t cudaGraphAddMemcpyNode(cudaGraphNode_t *pGraphNode,
					  cudaGraph_t graph,
					  const cudaGraphNode_t *pDependencies,
					  size_t numDependencies,
					  const cudaMemcpy3DParms *pCopyParams);
extern cudaError_t
cudaGraphAddMemcpyNodeToSymbol(cudaGraphNode_t *pGraphNode, cudaGraph_t graph,
			       const cudaGraphNode_t *pDependencies,
			       size_t numDependencies, const void *symbol,
			       const void *src, size_t count, size_t offset,
			       cudaMemcpyKind kind);
extern cudaError_t cudaGraphAddMemcpyNodeFromSymbol(
	cudaGraphNode_t *pGraphNode, cudaGraph_t graph,
	const cudaGraphNode_t *pDependencies, size_t numDependencies, void *dst,
	const void *symbol, size_t count, size_t offset, cudaMemcpyKind kind);
extern cudaError_t
cudaGraphAddMemcpyNode1D(cudaGraphNode_t *pGraphNode, cudaGraph_t graph,
			 const cudaGraphNode_t *pDependencies,
			 size_t numDependencies, void *dst, const void *src,
			 size_t count, cudaMemcpyKind kind);
extern cudaError_t cudaGraphMemcpyNodeGetParams(cudaGraphNode_t node,
						cudaMemcpy3DParms *pNodeParams);
extern cudaError_t
cudaGraphMemcpyNodeSetParams(cudaGraphNode_t node,
			     const cudaMemcpy3DParms *pNodeParams);
extern cudaError_t
cudaGraphMemcpyNodeSetParamsToSymbol(cudaGraphNode_t node, const void *symbol,
				     const void *src, size_t count,
				     size_t offset, cudaMemcpyKind kind);
extern cudaError_t
cudaGraphMemcpyNodeSetParamsFromSymbol(cudaGraphNode_t node, void *dst,
				       const void *symbol, size_t count,
				       size_t offset, cudaMemcpyKind kind);
extern cudaError_t cudaGraphMemcpyNodeSetParams1D(cudaGraphNode_t node,
						  void *dst, const void *src,
						  size_t count,
						  cudaMemcpyKind kind);
extern cudaError_t
cudaGraphAddMemsetNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph,
		       const cudaGraphNode_t *pDependencies,
		       size_t numDependencies,
		       const cudaMemsetParams *pMemsetParams);
extern cudaError_t cudaGraphMemsetNodeGetParams(cudaGraphNode_t node,
						cudaMemsetParams *pNodeParams);
extern cudaError_t
cudaGraphMemsetNodeSetParams(cudaGraphNode_t node,
			     const cudaMemsetParams *pNodeParams);
extern cudaError_t cudaGraphAddHostNode(cudaGraphNode_t *pGraphNode,
					cudaGraph_t graph,
					const cudaGraphNode_t *pDependencies,
					size_t numDependencies,
					const cudaHostNodeParams *pNodeParams);
extern cudaError_t cudaGraphHostNodeGetParams(cudaGraphNode_t node,
					      cudaHostNodeParams *pNodeParams);
extern cudaError_t
cudaGraphHostNodeSetParams(cudaGraphNode_t node,
			   const cudaHostNodeParams *pNodeParams);
extern cudaError_t
cudaGraphAddChildGraphNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph,
			   const cudaGraphNode_t *pDependencies,
			   size_t numDependencies, cudaGraph_t childGraph);
extern cudaError_t cudaGraphChildGraphNodeGetGraph(cudaGraphNode_t node,
						   cudaGraph_t *pGraph);
extern cudaError_t cudaGraphAddEmptyNode(cudaGraphNode_t *pGraphNode,
					 cudaGraph_t graph,
					 const cudaGraphNode_t *pDependencies,
					 size_t numDependencies);
extern cudaError_t
cudaGraphAddEventRecordNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph,
			    const cudaGraphNode_t *pDependencies,
			    size_t numDependencies, cudaEvent_t event);
extern cudaError_t cudaGraphEventRecordNodeGetEvent(cudaGraphNode_t node,
						    cudaEvent_t *event_out);
extern cudaError_t cudaGraphEventRecordNodeSetEvent(cudaGraphNode_t node,
						    cudaEvent_t event);
extern cudaError_t
cudaGraphAddEventWaitNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph,
			  const cudaGraphNode_t *pDependencies,
			  size_t numDependencies, cudaEvent_t event);
extern cudaError_t cudaGraphEventWaitNodeGetEvent(cudaGraphNode_t node,
						  cudaEvent_t *event_out);
extern cudaError_t cudaGraphEventWaitNodeSetEvent(cudaGraphNode_t node,
						  cudaEvent_t event);
extern cudaError_t cudaGraphAddExternalSemaphoresSignalNode(
	cudaGraphNode_t *pGraphNode, cudaGraph_t graph,
	const cudaGraphNode_t *pDependencies, size_t numDependencies,
	const cudaExternalSemaphoreSignalNodeParams *nodeParams);
extern cudaError_t cudaGraphExternalSemaphoresSignalNodeGetParams(
	cudaGraphNode_t hNode,
	cudaExternalSemaphoreSignalNodeParams *params_out);
extern cudaError_t cudaGraphExternalSemaphoresSignalNodeSetParams(
	cudaGraphNode_t hNode,
	const cudaExternalSemaphoreSignalNodeParams *nodeParams);
extern cudaError_t cudaGraphAddExternalSemaphoresWaitNode(
	cudaGraphNode_t *pGraphNode, cudaGraph_t graph,
	const cudaGraphNode_t *pDependencies, size_t numDependencies,
	const cudaExternalSemaphoreWaitNodeParams *nodeParams);
extern cudaError_t cudaGraphExternalSemaphoresWaitNodeGetParams(
	cudaGraphNode_t hNode, cudaExternalSemaphoreWaitNodeParams *params_out);
extern cudaError_t cudaGraphExternalSemaphoresWaitNodeSetParams(
	cudaGraphNode_t hNode,
	const cudaExternalSemaphoreWaitNodeParams *nodeParams);
extern cudaError_t
cudaGraphAddMemAllocNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph,
			 const cudaGraphNode_t *pDependencies,
			 size_t numDependencies,
			 cudaMemAllocNodeParams *nodeParams);
extern cudaError_t
cudaGraphMemAllocNodeGetParams(cudaGraphNode_t node,
			       cudaMemAllocNodeParams *params_out);
extern cudaError_t cudaGraphAddMemFreeNode(cudaGraphNode_t *pGraphNode,
					   cudaGraph_t graph,
					   const cudaGraphNode_t *pDependencies,
					   size_t numDependencies, void *dptr);
extern cudaError_t cudaGraphMemFreeNodeGetParams(cudaGraphNode_t node,
						 void *dptr_out);
extern cudaError_t cudaDeviceGraphMemTrim(int device);
extern cudaError_t
cudaDeviceGetGraphMemAttribute(int device, cudaGraphMemAttributeType attr,
			       void *value);
extern cudaError_t
cudaDeviceSetGraphMemAttribute(int device, cudaGraphMemAttributeType attr,
			       void *value);
extern cudaError_t cudaGraphClone(cudaGraph_t *pGraphClone,
				  cudaGraph_t originalGraph);
extern cudaError_t cudaGraphNodeFindInClone(cudaGraphNode_t *pNode,
					    cudaGraphNode_t originalNode,
					    cudaGraph_t clonedGraph);
extern cudaError_t cudaGraphNodeGetType(cudaGraphNode_t node,
					cudaGraphNodeType *pType);
extern cudaError_t cudaGraphGetNodes(cudaGraph_t graph, cudaGraphNode_t *nodes,
				     size_t *numNodes);
extern cudaError_t cudaGraphGetRootNodes(cudaGraph_t graph,
					 cudaGraphNode_t *pRootNodes,
					 size_t *pNumRootNodes);
extern cudaError_t cudaGraphGetEdges(cudaGraph_t graph, cudaGraphNode_t *from,
				     cudaGraphNode_t *to, size_t *numEdges);
extern cudaError_t cudaGraphGetEdges_v2(cudaGraph_t graph,
					cudaGraphNode_t *from,
					cudaGraphNode_t *to,
					cudaGraphEdgeData *edgeData,
					size_t *numEdges);
extern cudaError_t cudaGraphNodeGetDependencies(cudaGraphNode_t node,
						cudaGraphNode_t *pDependencies,
						size_t *pNumDependencies);
extern cudaError_t cudaGraphNodeGetDependencies_v2(
	cudaGraphNode_t node, cudaGraphNode_t *pDependencies,
	cudaGraphEdgeData *edgeData, size_t *pNumDependencies);
extern cudaError_t
cudaGraphNodeGetDependentNodes(cudaGraphNode_t node,
			       cudaGraphNode_t *pDependentNodes,
			       size_t *pNumDependentNodes);
extern cudaError_t cudaGraphNodeGetDependentNodes_v2(
	cudaGraphNode_t node, cudaGraphNode_t *pDependentNodes,
	cudaGraphEdgeData *edgeData, size_t *pNumDependentNodes);
extern cudaError_t cudaGraphAddDependencies(cudaGraph_t graph,
					    const cudaGraphNode_t *from,
					    const cudaGraphNode_t *to,
					    size_t numDependencies);
extern cudaError_t
cudaGraphAddDependencies_v2(cudaGraph_t graph, const cudaGraphNode_t *from,
			    const cudaGraphNode_t *to,
			    const cudaGraphEdgeData *edgeData,
			    size_t numDependencies);
extern cudaError_t cudaGraphRemoveDependencies(cudaGraph_t graph,
					       const cudaGraphNode_t *from,
					       const cudaGraphNode_t *to,
					       size_t numDependencies);
extern cudaError_t
cudaGraphRemoveDependencies_v2(cudaGraph_t graph, const cudaGraphNode_t *from,
			       const cudaGraphNode_t *to,
			       const cudaGraphEdgeData *edgeData,
			       size_t numDependencies);
extern cudaError_t cudaGraphDestroyNode(cudaGraphNode_t node);
extern cudaError_t cudaGraphInstantiate(cudaGraphExec_t *pGraphExec,
					cudaGraph_t graph,
					unsigned long long flags = 0);
extern cudaError_t cudaGraphInstantiateWithFlags(cudaGraphExec_t *pGraphExec,
						 cudaGraph_t graph,
						 unsigned long long flags = 0);
extern cudaError_t
cudaGraphInstantiateWithParams(cudaGraphExec_t *pGraphExec, cudaGraph_t graph,
			       cudaGraphInstantiateParams *instantiateParams);
extern cudaError_t cudaGraphExecGetFlags(cudaGraphExec_t graphExec,
					 unsigned long long *flags);
extern cudaError_t
cudaGraphExecKernelNodeSetParams(cudaGraphExec_t hGraphExec,
				 cudaGraphNode_t node,
				 const cudaKernelNodeParams *pNodeParams);
extern cudaError_t
cudaGraphExecMemcpyNodeSetParams(cudaGraphExec_t hGraphExec,
				 cudaGraphNode_t node,
				 const cudaMemcpy3DParms *pNodeParams);
extern cudaError_t cudaGraphExecMemcpyNodeSetParamsToSymbol(
	cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const void *symbol,
	const void *src, size_t count, size_t offset, cudaMemcpyKind kind);
extern cudaError_t cudaGraphExecMemcpyNodeSetParamsFromSymbol(
	cudaGraphExec_t hGraphExec, cudaGraphNode_t node, void *dst,
	const void *symbol, size_t count, size_t offset, cudaMemcpyKind kind);
extern cudaError_t cudaGraphExecMemcpyNodeSetParams1D(
	cudaGraphExec_t hGraphExec, cudaGraphNode_t node, void *dst,
	const void *src, size_t count, cudaMemcpyKind kind);
extern cudaError_t
cudaGraphExecMemsetNodeSetParams(cudaGraphExec_t hGraphExec,
				 cudaGraphNode_t node,
				 const cudaMemsetParams *pNodeParams);
extern cudaError_t
cudaGraphExecHostNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node,
			       const cudaHostNodeParams *pNodeParams);
extern cudaError_t
cudaGraphExecChildGraphNodeSetParams(cudaGraphExec_t hGraphExec,
				     cudaGraphNode_t node,
				     cudaGraph_t childGraph);
extern cudaError_t
cudaGraphExecEventRecordNodeSetEvent(cudaGraphExec_t hGraphExec,
				     cudaGraphNode_t hNode, cudaEvent_t event);
extern cudaError_t
cudaGraphExecEventWaitNodeSetEvent(cudaGraphExec_t hGraphExec,
				   cudaGraphNode_t hNode, cudaEvent_t event);
extern cudaError_t cudaGraphExecExternalSemaphoresSignalNodeSetParams(
	cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode,
	const cudaExternalSemaphoreSignalNodeParams *nodeParams);
extern cudaError_t cudaGraphExecExternalSemaphoresWaitNodeSetParams(
	cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode,
	const cudaExternalSemaphoreWaitNodeParams *nodeParams);
extern cudaError_t cudaGraphNodeSetEnabled(cudaGraphExec_t hGraphExec,
					   cudaGraphNode_t hNode,
					   unsigned isEnabled);
extern cudaError_t cudaGraphNodeGetEnabled(cudaGraphExec_t hGraphExec,
					   cudaGraphNode_t hNode,
					   unsigned *isEnabled);
extern cudaError_t
cudaGraphExecUpdate(cudaGraphExec_t hGraphExec, cudaGraph_t hGraph,
		    cudaGraphExecUpdateResultInfo *resultInfo);
extern cudaError_t cudaGraphUpload(cudaGraphExec_t graphExec,
				   cudaStream_t stream);
extern cudaError_t cudaGraphLaunch(cudaGraphExec_t graphExec,
				   cudaStream_t stream);
extern cudaError_t cudaGraphExecDestroy(cudaGraphExec_t graphExec);
extern cudaError_t cudaGraphDestroy(cudaGraph_t graph);
extern cudaError_t cudaGraphDebugDotPrint(cudaGraph_t graph, const char *path,
					  unsigned flags);
extern cudaError_t cudaUserObjectCreate(cudaUserObject_t *object_out, void *ptr,
					cudaHostFn_t destroy,
					unsigned initialRefcount,
					unsigned flags);
extern cudaError_t cudaUserObjectRetain(cudaUserObject_t object,
					unsigned count = 1);
extern cudaError_t cudaUserObjectRelease(cudaUserObject_t object,
					 unsigned count = 1);
extern cudaError_t cudaGraphRetainUserObject(cudaGraph_t graph,
					     cudaUserObject_t object,
					     unsigned count = 1,
					     unsigned flags = 0);
extern cudaError_t cudaGraphReleaseUserObject(cudaGraph_t graph,
					      cudaUserObject_t object,
					      unsigned count = 1);
extern cudaError_t cudaGraphAddNode(cudaGraphNode_t *pGraphNode,
				    cudaGraph_t graph,
				    const cudaGraphNode_t *pDependencies,
				    size_t numDependencies,
				    cudaGraphNodeParams *nodeParams);
extern cudaError_t cudaGraphAddNode_v2(cudaGraphNode_t *pGraphNode,
				       cudaGraph_t graph,
				       const cudaGraphNode_t *pDependencies,
				       const cudaGraphEdgeData *dependencyData,
				       size_t numDependencies,
				       cudaGraphNodeParams *nodeParams);
extern cudaError_t cudaGraphNodeSetParams(cudaGraphNode_t node,
					  cudaGraphNodeParams *nodeParams);
extern cudaError_t cudaGraphExecNodeSetParams(cudaGraphExec_t graphExec,
					      cudaGraphNode_t node,
					      cudaGraphNodeParams *nodeParams);
extern cudaError_t cudaGraphConditionalHandleCreate(
	cudaGraphConditionalHandle *pHandle_out, cudaGraph_t graph,
	unsigned defaultLaunchValue = 0, unsigned flags = 0);
extern cudaError_t
cudaGetDriverEntryPoint(const char *symbol, void **funcPtr,
			unsigned long long flags,
			cudaDriverEntryPointQueryResult *driverStatus = 0);
extern cudaError_t cudaGetDriverEntryPointByVersion(
	const char *symbol, void **funcPtr, unsigned cudaVersion,
	unsigned long long flags,
	cudaDriverEntryPointQueryResult *driverStatus = 0);
extern cudaError_t cudaGetExportTable(const void **ppExportTable,
				      const cudaUUID_t *pExportTableId);
extern cudaError_t cudaGetFuncBySymbol(cudaFunction_t *functionPtr,
				       const void *symbolPtr);
extern cudaError_t cudaGetKernel(cudaKernel_t *kernelPtr,
				 const void *entryFuncAddr);
}
template <class T> inline cudaChannelFormatDesc cudaCreateChannelDesc()
{
	return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone);
}
static inline cudaChannelFormatDesc cudaCreateChannelDescHalf()
{
	int e = (((int)sizeof(unsigned short)) * 8);
	return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}
static inline cudaChannelFormatDesc cudaCreateChannelDescHalf1()
{
	int e = (((int)sizeof(unsigned short)) * 8);
	return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}
static inline cudaChannelFormatDesc cudaCreateChannelDescHalf2()
{
	int e = (((int)sizeof(unsigned short)) * 8);
	return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat);
}
static inline cudaChannelFormatDesc cudaCreateChannelDescHalf4()
{
	int e = (((int)sizeof(unsigned short)) * 8);
	return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<char>()
{
	int e = (((int)sizeof(char)) * 8);
	return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<signed char>()
{
	int e = (((int)sizeof(signed char)) * 8);
	return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<unsigned char>()
{
	int e = (((int)sizeof(unsigned char)) * 8);
	return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<char1>()
{
	int e = (((int)sizeof(signed char)) * 8);
	return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<uchar1>()
{
	int e = (((int)sizeof(unsigned char)) * 8);
	return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<char2>()
{
	int e = (((int)sizeof(signed char)) * 8);
	return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<uchar2>()
{
	int e = (((int)sizeof(unsigned char)) * 8);
	return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<char4>()
{
	int e = (((int)sizeof(signed char)) * 8);
	return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<uchar4>()
{
	int e = (((int)sizeof(unsigned char)) * 8);
	return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<short>()
{
	int e = (((int)sizeof(short)) * 8);
	return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<unsigned short>()
{
	int e = (((int)sizeof(unsigned short)) * 8);
	return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<short1>()
{
	int e = (((int)sizeof(short)) * 8);
	return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<ushort1>()
{
	int e = (((int)sizeof(unsigned short)) * 8);
	return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<short2>()
{
	int e = (((int)sizeof(short)) * 8);
	return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<ushort2>()
{
	int e = (((int)sizeof(unsigned short)) * 8);
	return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<short4>()
{
	int e = (((int)sizeof(short)) * 8);
	return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<ushort4>()
{
	int e = (((int)sizeof(unsigned short)) * 8);
	return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<int>()
{
	int e = (((int)sizeof(int)) * 8);
	return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<unsigned>()
{
	int e = (((int)sizeof(unsigned)) * 8);
	return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<int1>()
{
	int e = (((int)sizeof(int)) * 8);
	return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<uint1>()
{
	int e = (((int)sizeof(unsigned)) * 8);
	return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<int2>()
{
	int e = (((int)sizeof(int)) * 8);
	return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<uint2>()
{
	int e = (((int)sizeof(unsigned)) * 8);
	return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<int4>()
{
	int e = (((int)sizeof(int)) * 8);
	return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<uint4>()
{
	int e = (((int)sizeof(unsigned)) * 8);
	return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<float>()
{
	int e = (((int)sizeof(float)) * 8);
	return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<float1>()
{
	int e = (((int)sizeof(float)) * 8);
	return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<float2>()
{
	int e = (((int)sizeof(float)) * 8);
	return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat);
}
template <> inline cudaChannelFormatDesc cudaCreateChannelDesc<float4>()
{
	int e = (((int)sizeof(float)) * 8);
	return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat);
}
static inline cudaChannelFormatDesc cudaCreateChannelDescNV12()
{
	int e = (((int)sizeof(char)) * 8);
	return cudaCreateChannelDesc(e, e, e, 0, cudaChannelFormatKindNV12);
}
template <cudaChannelFormatKind>
inline cudaChannelFormatDesc cudaCreateChannelDesc()
{
	return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindSignedNormalized8X1>()
{
	return cudaCreateChannelDesc(8, 0, 0, 0,
				     cudaChannelFormatKindSignedNormalized8X1);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindSignedNormalized8X2>()
{
	return cudaCreateChannelDesc(8, 8, 0, 0,
				     cudaChannelFormatKindSignedNormalized8X2);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindSignedNormalized8X4>()
{
	return cudaCreateChannelDesc(8, 8, 8, 8,
				     cudaChannelFormatKindSignedNormalized8X4);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindUnsignedNormalized8X1>()
{
	return cudaCreateChannelDesc(
		8, 0, 0, 0, cudaChannelFormatKindUnsignedNormalized8X1);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindUnsignedNormalized8X2>()
{
	return cudaCreateChannelDesc(
		8, 8, 0, 0, cudaChannelFormatKindUnsignedNormalized8X2);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindUnsignedNormalized8X4>()
{
	return cudaCreateChannelDesc(
		8, 8, 8, 8, cudaChannelFormatKindUnsignedNormalized8X4);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindSignedNormalized16X1>()
{
	return cudaCreateChannelDesc(16, 0, 0, 0,
				     cudaChannelFormatKindSignedNormalized16X1);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindSignedNormalized16X2>()
{
	return cudaCreateChannelDesc(16, 16, 0, 0,
				     cudaChannelFormatKindSignedNormalized16X2);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindSignedNormalized16X4>()
{
	return cudaCreateChannelDesc(16, 16, 16, 16,
				     cudaChannelFormatKindSignedNormalized16X4);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindUnsignedNormalized16X1>()
{
	return cudaCreateChannelDesc(
		16, 0, 0, 0, cudaChannelFormatKindUnsignedNormalized16X1);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindUnsignedNormalized16X2>()
{
	return cudaCreateChannelDesc(
		16, 16, 0, 0, cudaChannelFormatKindUnsignedNormalized16X2);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindUnsignedNormalized16X4>()
{
	return cudaCreateChannelDesc(
		16, 16, 16, 16, cudaChannelFormatKindUnsignedNormalized16X4);
}
template <>
inline cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindNV12>()
{
	return cudaCreateChannelDesc(8, 8, 8, 0, cudaChannelFormatKindNV12);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed1>()
{
	return cudaCreateChannelDesc(
		8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed1);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed1SRGB>()
{
	return cudaCreateChannelDesc(
		8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed1SRGB);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed2>()
{
	return cudaCreateChannelDesc(
		8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed2);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed2SRGB>()
{
	return cudaCreateChannelDesc(
		8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed2SRGB);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed3>()
{
	return cudaCreateChannelDesc(
		8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed3);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed3SRGB>()
{
	return cudaCreateChannelDesc(
		8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed3SRGB);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed4>()
{
	return cudaCreateChannelDesc(
		8, 0, 0, 0, cudaChannelFormatKindUnsignedBlockCompressed4);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindSignedBlockCompressed4>()
{
	return cudaCreateChannelDesc(
		8, 0, 0, 0, cudaChannelFormatKindSignedBlockCompressed4);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed5>()
{
	return cudaCreateChannelDesc(
		8, 8, 0, 0, cudaChannelFormatKindUnsignedBlockCompressed5);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindSignedBlockCompressed5>()
{
	return cudaCreateChannelDesc(
		8, 8, 0, 0, cudaChannelFormatKindSignedBlockCompressed5);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed6H>()
{
	return cudaCreateChannelDesc(
		16, 16, 16, 0, cudaChannelFormatKindUnsignedBlockCompressed6H);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindSignedBlockCompressed6H>()
{
	return cudaCreateChannelDesc(
		16, 16, 16, 0, cudaChannelFormatKindSignedBlockCompressed6H);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed7>()
{
	return cudaCreateChannelDesc(
		8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed7);
}
template <>
inline cudaChannelFormatDesc
cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed7SRGB>()
{
	return cudaCreateChannelDesc(
		8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed7SRGB);
}
static inline cudaPitchedPtr make_cudaPitchedPtr(void *d, size_t p, size_t xsz,
						 size_t ysz)
{
	cudaPitchedPtr s;
	(s.ptr) = d;
	(s.pitch) = p;
	(s.xsize) = xsz;
	(s.ysize) = ysz;
	return s;
}
static inline cudaPos make_cudaPos(size_t x, size_t y, size_t z)
{
	cudaPos p;
	(p.x) = x;
	(p.y) = y;
	(p.z) = z;
	return p;
}
static inline cudaExtent make_cudaExtent(size_t w, size_t h, size_t d)
{
	cudaExtent e;
	(e.width) = w;
	(e.height) = h;
	(e.depth) = d;
	return e;
}
static inline char1 make_char1(signed char x);
static inline uchar1 make_uchar1(unsigned char x);
static inline char2 make_char2(signed char x, signed char y);
static inline uchar2 make_uchar2(unsigned char x, unsigned char y);
static inline char3 make_char3(signed char x, signed char y, signed char z);
static inline uchar3 make_uchar3(unsigned char x, unsigned char y,
				 unsigned char z);
static inline char4 make_char4(signed char x, signed char y, signed char z,
			       signed char w);
static inline uchar4 make_uchar4(unsigned char x, unsigned char y,
				 unsigned char z, unsigned char w);
static inline short1 make_short1(short x);
static inline ushort1 make_ushort1(unsigned short x);
static inline short2 make_short2(short x, short y);
static inline ushort2 make_ushort2(unsigned short x, unsigned short y);
static inline short3 make_short3(short x, short y, short z);
static inline ushort3 make_ushort3(unsigned short x, unsigned short y,
				   unsigned short z);
static inline short4 make_short4(short x, short y, short z, short w);
static inline ushort4 make_ushort4(unsigned short x, unsigned short y,
				   unsigned short z, unsigned short w);
static inline int1 make_int1(int x);
static inline uint1 make_uint1(unsigned x);
static inline int2 make_int2(int x, int y);
static inline uint2 make_uint2(unsigned x, unsigned y);
static inline int3 make_int3(int x, int y, int z);
static inline uint3 make_uint3(unsigned x, unsigned y, unsigned z);
static inline int4 make_int4(int x, int y, int z, int w);
static inline uint4 make_uint4(unsigned x, unsigned y, unsigned z, unsigned w);
static inline long1 make_long1(long x);
static inline ulong1 make_ulong1(unsigned long x);
static inline long2 make_long2(long x, long y);
static inline ulong2 make_ulong2(unsigned long x, unsigned long y);
static inline long3 make_long3(long x, long y, long z);
static inline ulong3 make_ulong3(unsigned long x, unsigned long y,
				 unsigned long z);
static inline long4 make_long4(long x, long y, long z, long w);
static inline ulong4 make_ulong4(unsigned long x, unsigned long y,
				 unsigned long z, unsigned long w);
static inline float1 make_float1(float x);
static inline float2 make_float2(float x, float y);
static inline float3 make_float3(float x, float y, float z);
static inline float4 make_float4(float x, float y, float z, float w);
static inline longlong1 make_longlong1(long long x);
static inline ulonglong1 make_ulonglong1(unsigned long long x);
static inline longlong2 make_longlong2(long long x, long long y);
static inline ulonglong2 make_ulonglong2(unsigned long long x,
					 unsigned long long y);
static inline longlong3 make_longlong3(long long x, long long y, long long z);
static inline ulonglong3 make_ulonglong3(unsigned long long x,
					 unsigned long long y,
					 unsigned long long z);
static inline longlong4 make_longlong4(long long x, long long y, long long z,
				       long long w);
static inline ulonglong4 make_ulonglong4(unsigned long long x,
					 unsigned long long y,
					 unsigned long long z,
					 unsigned long long w);
static inline double1 make_double1(double x);
static inline double2 make_double2(double x, double y);
static inline double3 make_double3(double x, double y, double z);
static inline double4 make_double4(double x, double y, double z, double w);
static inline char1 make_char1(signed char x)
{
	char1 t;
	(t.x) = x;
	return t;
}
static inline uchar1 make_uchar1(unsigned char x)
{
	uchar1 t;
	(t.x) = x;
	return t;
}
static inline char2 make_char2(signed char x, signed char y)
{
	char2 t;
	(t.x) = x;
	(t.y) = y;
	return t;
}
static inline uchar2 make_uchar2(unsigned char x, unsigned char y)
{
	uchar2 t;
	(t.x) = x;
	(t.y) = y;
	return t;
}
static inline char3 make_char3(signed char x, signed char y, signed char z)
{
	char3 t;
	(t.x) = x;
	(t.y) = y;
	(t.z) = z;
	return t;
}
static inline uchar3 make_uchar3(unsigned char x, unsigned char y,
				 unsigned char z)
{
	uchar3 t;
	(t.x) = x;
	(t.y) = y;
	(t.z) = z;
	return t;
}
static inline char4 make_char4(signed char x, signed char y, signed char z,
			       signed char w)
{
	char4 t;
	(t.x) = x;
	(t.y) = y;
	(t.z) = z;
	(t.w) = w;
	return t;
}
static inline uchar4 make_uchar4(unsigned char x, unsigned char y,
				 unsigned char z, unsigned char w)
{
	uchar4 t;
	(t.x) = x;
	(t.y) = y;
	(t.z) = z;
	(t.w) = w;
	return t;
}
static inline short1 make_short1(short x)
{
	short1 t;
	(t.x) = x;
	return t;
}
static inline ushort1 make_ushort1(unsigned short x)
{
	ushort1 t;
	(t.x) = x;
	return t;
}
static inline short2 make_short2(short x, short y)
{
	short2 t;
	(t.x) = x;
	(t.y) = y;
	return t;
}
static inline ushort2 make_ushort2(unsigned short x, unsigned short y)
{
	ushort2 t;
	(t.x) = x;
	(t.y) = y;
	return t;
}
static inline short3 make_short3(short x, short y, short z)
{
	short3 t;
	(t.x) = x;
	(t.y) = y;
	(t.z) = z;
	return t;
}
static inline ushort3 make_ushort3(unsigned short x, unsigned short y,
				   unsigned short z)
{
	ushort3 t;
	(t.x) = x;
	(t.y) = y;
	(t.z) = z;
	return t;
}
static inline short4 make_short4(short x, short y, short z, short w)
{
	short4 t;
	(t.x) = x;
	(t.y) = y;
	(t.z) = z;
	(t.w) = w;
	return t;
}
static inline ushort4 make_ushort4(unsigned short x, unsigned short y,
				   unsigned short z, unsigned short w)
{
	ushort4 t;
	(t.x) = x;
	(t.y) = y;
	(t.z) = z;
	(t.w) = w;
	return t;
}
static inline int1 make_int1(int x)
{
	int1 t;
	(t.x) = x;
	return t;
}
static inline uint1 make_uint1(unsigned x)
{
	uint1 t;
	(t.x) = x;
	return t;
}
static inline int2 make_int2(int x, int y)
{
	int2 t;
	(t.x) = x;
	(t.y) = y;
	return t;
}
static inline uint2 make_uint2(unsigned x, unsigned y)
{
	uint2 t;
	(t.x) = x;
	(t.y) = y;
	return t;
}
static inline int3 make_int3(int x, int y, int z)
{
	int3 t;
	(t.x) = x;
	(t.y) = y;
	(t.z) = z;
	return t;
}
static inline uint3 make_uint3(unsigned x, unsigned y, unsigned z)
{
	uint3 t;
	(t.x) = x;
	(t.y) = y;
	(t.z) = z;
	return t;
}
static inline int4 make_int4(int x, int y, int z, int w)
{
	int4 t;
	(t.x) = x;
	(t.y) = y;
	(t.z) = z;
	(t.w) = w;
	return t;
}
static inline uint4 make_uint4(unsigned x, unsigned y, unsigned z, unsigned w)
{
	uint4 t;
	(t.x) = x;
	(t.y) = y;
	(t.z) = z;
	(t.w) = w;
	return t;
}
static inline long1 make_long1(long x)
{
	long1 t;
	(t.x) = x;
	return t;
}
static inline ulong1 make_ulong1(unsigned long x)
{
	ulong1 t;
	(t.x) = x;
	return t;
}
static inline long2 make_long2(long x, long y)
{
	long2 t;
	(t.x) = x;
	(t.y) = y;
	return t;
}
static inline ulong2 make_ulong2(unsigned long x, unsigned long y)
{
	ulong2 t;
	(t.x) = x;
	(t.y) = y;
	return t;
}
static inline long3 make_long3(long x, long y, long z)
{
	long3 t;
	(t.x) = x;
	(t.y) = y;
	(t.z) = z;
	return t;
}
static inline ulong3 make_ulong3(unsigned long x, unsigned long y,
				 unsigned long z)
{
	ulong3 t;
	(t.x) = x;
	(t.y) = y;
	(t.z) = z;
	return t;
}
static inline long4 make_long4(long x, long y, long z, long w)
{
	long4 t;
	(t.x) = x;
	(t.y) = y;
	(t.z) = z;
	(t.w) = w;
	return t;
}
static inline ulong4 make_ulong4(unsigned long x, unsigned long y,
				 unsigned long z, unsigned long w)
{
	ulong4 t;
	(t.x) = x;
	(t.y) = y;
	(t.z) = z;
	(t.w) = w;
	return t;
}
static inline float1 make_float1(float x)
{
	float1 t;
	(t.x) = x;
	return t;
}
static inline float2 make_float2(float x, float y)
{
	float2 t;
	(t.x) = x;
	(t.y) = y;
	return t;
}
static inline float3 make_float3(float x, float y, float z)
{
	float3 t;
	(t.x) = x;
	(t.y) = y;
	(t.z) = z;
	return t;
}
static inline float4 make_float4(float x, float y, float z, float w)
{
	float4 t;
	(t.x) = x;
	(t.y) = y;
	(t.z) = z;
	(t.w) = w;
	return t;
}
static inline longlong1 make_longlong1(long long x)
{
	longlong1 t;
	(t.x) = x;
	return t;
}
static inline ulonglong1 make_ulonglong1(unsigned long long x)
{
	ulonglong1 t;
	(t.x) = x;
	return t;
}
static inline longlong2 make_longlong2(long long x, long long y)
{
	longlong2 t;
	(t.x) = x;
	(t.y) = y;
	return t;
}
static inline ulonglong2 make_ulonglong2(unsigned long long x,
					 unsigned long long y)
{
	ulonglong2 t;
	(t.x) = x;
	(t.y) = y;
	return t;
}
static inline longlong3 make_longlong3(long long x, long long y, long long z)
{
	longlong3 t;
	(t.x) = x;
	(t.y) = y;
	(t.z) = z;
	return t;
}
static inline ulonglong3 make_ulonglong3(unsigned long long x,
					 unsigned long long y,
					 unsigned long long z)
{
	ulonglong3 t;
	(t.x) = x;
	(t.y) = y;
	(t.z) = z;
	return t;
}
static inline longlong4 make_longlong4(long long x, long long y, long long z,
				       long long w)
{
	longlong4 t;
	(t.x) = x;
	(t.y) = y;
	(t.z) = z;
	(t.w) = w;
	return t;
}
static inline ulonglong4 make_ulonglong4(unsigned long long x,
					 unsigned long long y,
					 unsigned long long z,
					 unsigned long long w)
{
	ulonglong4 t;
	(t.x) = x;
	(t.y) = y;
	(t.z) = z;
	(t.w) = w;
	return t;
}
static inline double1 make_double1(double x)
{
	double1 t;
	(t.x) = x;
	return t;
}
static inline double2 make_double2(double x, double y)
{
	double2 t;
	(t.x) = x;
	(t.y) = y;
	return t;
}
static inline double3 make_double3(double x, double y, double z)
{
	double3 t;
	(t.x) = x;
	(t.y) = y;
	(t.z) = z;
	return t;
}
static inline double4 make_double4(double x, double y, double z, double w)
{
	double4 t;
	(t.x) = x;
	(t.y) = y;
	(t.z) = z;
	(t.w) = w;
	return t;
}

extern "C" {
extern void *memcpy(void *__restrict__ __dest, const void *__restrict__ __src,
		    size_t __n) noexcept(true) __attribute((__nonnull__(1, 2)));
extern void *memmove(void *__dest, const void *__src, size_t __n) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern void *memccpy(void *__restrict__ __dest, const void *__restrict__ __src,
		     int __c, size_t __n) noexcept(true)
	__attribute((__nonnull__(1, 2)))
	__attribute((__access__(__write_only__, 1, 4)));
extern void *memset(void *__s, int __c, size_t __n) noexcept(true)
	__attribute((__nonnull__(1)));
extern int memcmp(const void *__s1, const void *__s2, size_t __n) noexcept(true)
	__attribute((__pure__)) __attribute((__nonnull__(1, 2)));
extern int __memcmpeq(const void *__s1, const void *__s2,
		      size_t __n) noexcept(true) __attribute((__pure__))
__attribute((__nonnull__(1, 2)));
extern "C++" {
extern void *memchr(void *__s, int __c,
		    size_t __n) noexcept(true) __asm__("memchr")
	__attribute((__pure__)) __attribute((__nonnull__(1)));
extern const void *memchr(const void *__s, int __c,
			  size_t __n) noexcept(true) __asm__("memchr")
	__attribute((__pure__)) __attribute((__nonnull__(1)));
}
extern "C++" void *rawmemchr(void *__s,
			     int __c) noexcept(true) __asm__("rawmemchr")
	__attribute((__pure__)) __attribute((__nonnull__(1)));
extern "C++" const void *rawmemchr(const void *__s,
				   int __c) noexcept(true) __asm__("rawmemchr")
	__attribute((__pure__)) __attribute((__nonnull__(1)));
extern "C++" void *memrchr(void *__s, int __c,
			   size_t __n) noexcept(true) __asm__("memrchr")
	__attribute((__pure__)) __attribute((__nonnull__(1)))
	__attribute((__access__(__read_only__, 1, 3)));
extern "C++" const void *memrchr(const void *__s, int __c,
				 size_t __n) noexcept(true) __asm__("memrchr")
	__attribute((__pure__)) __attribute((__nonnull__(1)))
	__attribute((__access__(__read_only__, 1, 3)));
extern char *strcpy(char *__restrict__ __dest,
		    const char *__restrict__ __src) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern char *strncpy(char *__restrict__ __dest, const char *__restrict__ __src,
		     size_t __n) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern char *strcat(char *__restrict__ __dest,
		    const char *__restrict__ __src) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern char *strncat(char *__restrict__ __dest, const char *__restrict__ __src,
		     size_t __n) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int strcmp(const char *__s1, const char *__s2) noexcept(true)
	__attribute((__pure__)) __attribute((__nonnull__(1, 2)));
extern int strncmp(const char *__s1, const char *__s2,
		   size_t __n) noexcept(true) __attribute((__pure__))
__attribute((__nonnull__(1, 2)));
extern int strcoll(const char *__s1, const char *__s2) noexcept(true)
	__attribute((__pure__)) __attribute((__nonnull__(1, 2)));
extern size_t strxfrm(char *__restrict__ __dest, const char *__restrict__ __src,
		      size_t __n) noexcept(true) __attribute((__nonnull__(2)))
__attribute((__access__(__write_only__, 1, 3)));
extern int strcoll_l(const char *__s1, const char *__s2,
		     locale_t __l) noexcept(true) __attribute((__pure__))
__attribute((__nonnull__(1, 2, 3)));
extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n,
			locale_t __l) noexcept(true)
	__attribute((__nonnull__(2, 4)))
	__attribute((__access__(__write_only__, 1, 3)));
extern char *strdup(const char *__s) noexcept(true) __attribute((__malloc__))
__attribute((__nonnull__(1)));
extern char *strndup(const char *__string, size_t __n) noexcept(true)
	__attribute((__malloc__)) __attribute((__nonnull__(1)));
extern "C++" {
extern char *strchr(char *__s, int __c) noexcept(true) __asm__("strchr")
	__attribute((__pure__)) __attribute((__nonnull__(1)));
extern const char *strchr(const char *__s,
			  int __c) noexcept(true) __asm__("strchr")
	__attribute((__pure__)) __attribute((__nonnull__(1)));
}
extern "C++" {
extern char *strrchr(char *__s, int __c) noexcept(true) __asm__("strrchr")
	__attribute((__pure__)) __attribute((__nonnull__(1)));
extern const char *strrchr(const char *__s,
			   int __c) noexcept(true) __asm__("strrchr")
	__attribute((__pure__)) __attribute((__nonnull__(1)));
}
extern "C++" char *strchrnul(char *__s,
			     int __c) noexcept(true) __asm__("strchrnul")
	__attribute((__pure__)) __attribute((__nonnull__(1)));
extern "C++" const char *strchrnul(const char *__s,
				   int __c) noexcept(true) __asm__("strchrnul")
	__attribute((__pure__)) __attribute((__nonnull__(1)));
extern size_t strcspn(const char *__s, const char *__reject) noexcept(true)
	__attribute((__pure__)) __attribute((__nonnull__(1, 2)));
extern size_t strspn(const char *__s, const char *__accept) noexcept(true)
	__attribute((__pure__)) __attribute((__nonnull__(1, 2)));
extern "C++" {
extern char *strpbrk(char *__s,
		     const char *__accept) noexcept(true) __asm__("strpbrk")
	__attribute((__pure__)) __attribute((__nonnull__(1, 2)));
extern const char *
strpbrk(const char *__s, const char *__accept) noexcept(true) __asm__("strpbrk")
	__attribute((__pure__)) __attribute((__nonnull__(1, 2)));
}
extern "C++" {
extern char *strstr(char *__haystack,
		    const char *__needle) noexcept(true) __asm__("strstr")
	__attribute((__pure__)) __attribute((__nonnull__(1, 2)));
extern const char *strstr(const char *__haystack,
			  const char *__needle) noexcept(true) __asm__("strstr")
	__attribute((__pure__)) __attribute((__nonnull__(1, 2)));
}
extern char *strtok(char *__restrict__ __s,
		    const char *__restrict__ __delim) noexcept(true)
	__attribute((__nonnull__(2)));
extern char *__strtok_r(char *__restrict__ __s,
			const char *__restrict__ __delim,
			char **__restrict__ __save_ptr) noexcept(true)
	__attribute((__nonnull__(2, 3)));
extern char *strtok_r(char *__restrict__ __s, const char *__restrict__ __delim,
		      char **__restrict__ __save_ptr) noexcept(true)
	__attribute((__nonnull__(2, 3)));
extern "C++" char *
strcasestr(char *__haystack,
	   const char *__needle) noexcept(true) __asm__("strcasestr")
	__attribute((__pure__)) __attribute((__nonnull__(1, 2)));
extern "C++" const char *
strcasestr(const char *__haystack,
	   const char *__needle) noexcept(true) __asm__("strcasestr")
	__attribute((__pure__)) __attribute((__nonnull__(1, 2)));
extern void *memmem(const void *__haystack, size_t __haystacklen,
		    const void *__needle, size_t __needlelen) noexcept(true)
	__attribute((__pure__)) __attribute((__nonnull__(1, 3)))
	__attribute((__access__(__read_only__, 1, 2)))
	__attribute((__access__(__read_only__, 3, 4)));
extern void *__mempcpy(void *__restrict__ __dest,
		       const void *__restrict__ __src,
		       size_t __n) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern void *mempcpy(void *__restrict__ __dest, const void *__restrict__ __src,
		     size_t __n) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern size_t strlen(const char *__s) noexcept(true) __attribute((__pure__))
__attribute((__nonnull__(1)));
extern size_t strnlen(const char *__string, size_t __maxlen) noexcept(true)
	__attribute((__pure__)) __attribute((__nonnull__(1)));
extern char *strerror(int __errnum) noexcept(true);
extern char *strerror_r(int __errnum, char *__buf,
			size_t __buflen) noexcept(true)
	__attribute((__nonnull__(2)))
	__attribute((__access__(__write_only__, 2, 3)));
extern const char *strerrordesc_np(int __err) noexcept(true);
extern const char *strerrorname_np(int __err) noexcept(true);
extern char *strerror_l(int __errnum, locale_t __l) noexcept(true);
extern "C" {
extern int bcmp(const void *__s1, const void *__s2, size_t __n) noexcept(true)
	__attribute((__pure__)) __attribute((__nonnull__(1, 2)));
extern void bcopy(const void *__src, void *__dest, size_t __n) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern void bzero(void *__s, size_t __n) noexcept(true)
	__attribute((__nonnull__(1)));
extern "C++" {
extern char *index(char *__s, int __c) noexcept(true) __asm__("index")
	__attribute((__pure__)) __attribute((__nonnull__(1)));
extern const char *index(const char *__s,
			 int __c) noexcept(true) __asm__("index")
	__attribute((__pure__)) __attribute((__nonnull__(1)));
}
extern "C++" {
extern char *rindex(char *__s, int __c) noexcept(true) __asm__("rindex")
	__attribute((__pure__)) __attribute((__nonnull__(1)));
extern const char *rindex(const char *__s,
			  int __c) noexcept(true) __asm__("rindex")
	__attribute((__pure__)) __attribute((__nonnull__(1)));
}
extern int ffs(int __i) noexcept(true) __attribute((const));
extern int ffsl(long __l) noexcept(true) __attribute((const));
__extension__ extern int ffsll(long long __ll) noexcept(true)
	__attribute((const));
extern int strcasecmp(const char *__s1, const char *__s2) noexcept(true)
	__attribute((__pure__)) __attribute((__nonnull__(1, 2)));
extern int strncasecmp(const char *__s1, const char *__s2,
		       size_t __n) noexcept(true) __attribute((__pure__))
__attribute((__nonnull__(1, 2)));
extern int strcasecmp_l(const char *__s1, const char *__s2,
			locale_t __loc) noexcept(true) __attribute((__pure__))
__attribute((__nonnull__(1, 2, 3)));
extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n,
			 locale_t __loc) noexcept(true) __attribute((__pure__))
__attribute((__nonnull__(1, 2, 4)));
}
extern void explicit_bzero(void *__s, size_t __n) noexcept(true)
	__attribute((__nonnull__(1)))
	__attribute((__access__(__write_only__, 1, 2)));
extern char *strsep(char **__restrict__ __stringp,
		    const char *__restrict__ __delim) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern char *strsignal(int __sig) noexcept(true);
extern const char *sigabbrev_np(int __sig) noexcept(true);
extern const char *sigdescr_np(int __sig) noexcept(true);
extern char *__stpcpy(char *__restrict__ __dest,
		      const char *__restrict__ __src) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern char *stpcpy(char *__restrict__ __dest,
		    const char *__restrict__ __src) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern char *__stpncpy(char *__restrict__ __dest,
		       const char *__restrict__ __src,
		       size_t __n) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern char *stpncpy(char *__restrict__ __dest, const char *__restrict__ __src,
		     size_t __n) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int strverscmp(const char *__s1, const char *__s2) noexcept(true)
	__attribute((__pure__)) __attribute((__nonnull__(1, 2)));
extern char *strfry(char *__string) noexcept(true)
	__attribute((__nonnull__(1)));
extern void *memfrob(void *__s, size_t __n) noexcept(true)
	__attribute((__nonnull__(1)))
	__attribute((__access__(__read_write__, 1, 2)));
extern "C++" char *basename(char *__filename) noexcept(true) __asm__("basename")
	__attribute((__nonnull__(1)));
extern "C++" const char *
basename(const char *__filename) noexcept(true) __asm__("basename")
	__attribute((__nonnull__(1)));
}
struct timex {
	unsigned modes;
	__syscall_slong_t offset;
	__syscall_slong_t freq;
	__syscall_slong_t maxerror;
	__syscall_slong_t esterror;
	int status;
	__syscall_slong_t constant;
	__syscall_slong_t precision;
	__syscall_slong_t tolerance;
	timeval time;
	__syscall_slong_t tick;
	__syscall_slong_t ppsfreq;
	__syscall_slong_t jitter;
	int shift;
	__syscall_slong_t stabil;
	__syscall_slong_t jitcnt;
	__syscall_slong_t calcnt;
	__syscall_slong_t errcnt;
	__syscall_slong_t stbcnt;
	int tai;
	int : 32;
	int : 32;
	int : 32;
	int : 32;
	int : 32;
	int : 32;
	int : 32;
	int : 32;
	int : 32;
	int : 32;
	int : 32;
};
extern "C" {
extern int clock_adjtime(__clockid_t __clock_id, timex *__utx) noexcept(true)
	__attribute((__nonnull__(2)));
}
struct tm {
	int tm_sec;
	int tm_min;
	int tm_hour;
	int tm_mday;
	int tm_mon;
	int tm_year;
	int tm_wday;
	int tm_yday;
	int tm_isdst;
	long tm_gmtoff;
	const char *tm_zone;
};
struct itimerspec {
	timespec it_interval;
	timespec it_value;
};
struct sigevent;
extern "C" {
extern clock_t clock() noexcept(true);
extern time_t time(time_t *__timer) noexcept(true);
extern double difftime(time_t __time1, time_t __time0) noexcept(true)
	__attribute((const));
extern time_t mktime(tm *__tp) noexcept(true);
extern size_t strftime(char *__restrict__ __s, size_t __maxsize,
		       const char *__restrict__ __format,
		       const tm *__restrict__ __tp) noexcept(true);
extern char *strptime(const char *__restrict__ __s,
		      const char *__restrict__ __fmt, tm *__tp) noexcept(true);
extern size_t strftime_l(char *__restrict__ __s, size_t __maxsize,
			 const char *__restrict__ __format,
			 const tm *__restrict__ __tp,
			 locale_t __loc) noexcept(true);
extern char *strptime_l(const char *__restrict__ __s,
			const char *__restrict__ __fmt, tm *__tp,
			locale_t __loc) noexcept(true);
extern tm *gmtime(const time_t *__timer) noexcept(true);
extern tm *localtime(const time_t *__timer) noexcept(true);
extern tm *gmtime_r(const time_t *__restrict__ __timer,
		    tm *__restrict__ __tp) noexcept(true);
extern tm *localtime_r(const time_t *__restrict__ __timer,
		       tm *__restrict__ __tp) noexcept(true);
extern char *asctime(const tm *__tp) noexcept(true);
extern char *ctime(const time_t *__timer) noexcept(true);
extern char *asctime_r(const tm *__restrict__ __tp,
		       char *__restrict__ __buf) noexcept(true);
extern char *ctime_r(const time_t *__restrict__ __timer,
		     char *__restrict__ __buf) noexcept(true);
extern char *__tzname[2];
extern int __daylight;
extern long __timezone;
extern char *tzname[2];
extern void tzset() noexcept(true);
extern int daylight;
extern long timezone;
extern time_t timegm(tm *__tp) noexcept(true);
extern time_t timelocal(tm *__tp) noexcept(true);
extern int dysize(int __year) noexcept(true) __attribute((const));
extern int nanosleep(const timespec *__requested_time, timespec *__remaining);
extern int clock_getres(clockid_t __clock_id, timespec *__res) noexcept(true);
extern int clock_gettime(clockid_t __clock_id, timespec *__tp) noexcept(true)
	__attribute((__nonnull__(2)));
extern int clock_settime(clockid_t __clock_id,
			 const timespec *__tp) noexcept(true)
	__attribute((__nonnull__(2)));
extern int clock_nanosleep(clockid_t __clock_id, int __flags,
			   const timespec *__req, timespec *__rem);
extern int clock_getcpuclockid(pid_t __pid,
			       clockid_t *__clock_id) noexcept(true);
extern int timer_create(clockid_t __clock_id, sigevent *__restrict__ __evp,
			timer_t *__restrict__ __timerid) noexcept(true);
extern int timer_delete(timer_t __timerid) noexcept(true);
extern int timer_settime(timer_t __timerid, int __flags,
			 const itimerspec *__restrict__ __value,
			 itimerspec *__restrict__ __ovalue) noexcept(true);
extern int timer_gettime(timer_t __timerid, itimerspec *__value) noexcept(true);
extern int timer_getoverrun(timer_t __timerid) noexcept(true);
extern int timespec_get(timespec *__ts, int __base) noexcept(true)
	__attribute((__nonnull__(1)));
extern int timespec_getres(timespec *__ts, int __base) noexcept(true);
extern int getdate_err;
extern tm *getdate(const char *__string);
extern int getdate_r(const char *__restrict__ __string,
		     tm *__restrict__ __resbufp);
}

extern "C" {
extern clock_t clock() noexcept(true);
extern void *memset(void *, int, size_t) noexcept(true);
extern void *memcpy(void *, const void *, size_t) noexcept(true);
}
extern "C" {
extern int abs(int a) noexcept(true);
extern long labs(long a) noexcept(true);
extern long long llabs(long long a) noexcept(true);
extern double fabs(double x) noexcept(true);
extern float fabsf(float x) noexcept(true);
extern inline int min(const int a, const int b);
extern inline unsigned umin(const unsigned a, const unsigned b);
extern inline long long llmin(const long long a, const long long b);
extern inline unsigned long long ullmin(const unsigned long long a,
					const unsigned long long b);
extern float fminf(float x, float y) noexcept(true);
extern double fmin(double x, double y) noexcept(true);
extern inline int max(const int a, const int b);
extern inline unsigned umax(const unsigned a, const unsigned b);
extern inline long long llmax(const long long a, const long long b);
extern inline unsigned long long ullmax(const unsigned long long a,
					const unsigned long long b);
extern float fmaxf(float x, float y) noexcept(true);
extern double fmax(double, double) noexcept(true);
extern double sin(double x) noexcept(true);
extern double cos(double x) noexcept(true);
extern void sincos(double x, double *sptr, double *cptr) noexcept(true);
extern void sincosf(float x, float *sptr, float *cptr) noexcept(true);
extern double tan(double x) noexcept(true);
extern double sqrt(double x) noexcept(true);
extern double rsqrt(double x);
extern float rsqrtf(float x);
extern double log2(double x) noexcept(true);
extern double exp2(double x) noexcept(true);
extern float exp2f(float x) noexcept(true);
extern double exp10(double x) noexcept(true);
extern float exp10f(float x) noexcept(true);
extern double expm1(double x) noexcept(true);
extern float expm1f(float x) noexcept(true);
extern float log2f(float x) noexcept(true);
extern double log10(double x) noexcept(true);
extern double log(double x) noexcept(true);
extern double log1p(double x) noexcept(true);
extern float log1pf(float x) noexcept(true);
extern double floor(double x) noexcept(true);
extern double exp(double x) noexcept(true);
extern double cosh(double x) noexcept(true);
extern double sinh(double x) noexcept(true);
extern double tanh(double x) noexcept(true);
extern double acosh(double x) noexcept(true);
extern float acoshf(float x) noexcept(true);
extern double asinh(double x) noexcept(true);
extern float asinhf(float x) noexcept(true);
extern double atanh(double x) noexcept(true);
extern float atanhf(float x) noexcept(true);
extern double ldexp(double x, int exp) noexcept(true);
extern float ldexpf(float x, int exp) noexcept(true);
extern double logb(double x) noexcept(true);
extern float logbf(float x) noexcept(true);
extern int ilogb(double x) noexcept(true);
extern int ilogbf(float x) noexcept(true);
extern double scalbn(double x, int n) noexcept(true);
extern float scalbnf(float x, int n) noexcept(true);
extern double scalbln(double x, long n) noexcept(true);
extern float scalblnf(float x, long n) noexcept(true);
extern double frexp(double x, int *nptr) noexcept(true);
extern float frexpf(float x, int *nptr) noexcept(true);
extern double round(double x) noexcept(true);
extern float roundf(float x) noexcept(true);
extern long lround(double x) noexcept(true);
extern long lroundf(float x) noexcept(true);
extern long long llround(double x) noexcept(true);
extern long long llroundf(float x) noexcept(true);
extern float rintf(float x) noexcept(true);
extern long lrint(double x) noexcept(true);
extern long lrintf(float x) noexcept(true);
extern long long llrint(double x) noexcept(true);
extern long long llrintf(float x) noexcept(true);
extern double nearbyint(double x) noexcept(true);
extern float nearbyintf(float x) noexcept(true);
extern double ceil(double x) noexcept(true);
extern double trunc(double x) noexcept(true);
extern float truncf(float x) noexcept(true);
extern double fdim(double x, double y) noexcept(true);
extern float fdimf(float x, float y) noexcept(true);
extern double atan2(double y, double x) noexcept(true);
extern double atan(double x) noexcept(true);
extern double acos(double x) noexcept(true);
extern double asin(double x) noexcept(true);
extern double hypot(double x, double y) noexcept(true);
extern float hypotf(float x, float y) noexcept(true);
extern double cbrt(double x) noexcept(true);
extern float cbrtf(float x) noexcept(true);
extern double rcbrt(double x);
extern float rcbrtf(float x);
extern double sinpi(double x);
extern float sinpif(float x);
extern double cospi(double x);
extern float cospif(float x);
extern void sincospi(double x, double *sptr, double *cptr);
extern void sincospif(float x, float *sptr, float *cptr);
extern double pow(double x, double y) noexcept(true);
extern double modf(double x, double *iptr) noexcept(true);
extern double fmod(double x, double y) noexcept(true);
extern double remainder(double x, double y) noexcept(true);
extern float remainderf(float x, float y) noexcept(true);
extern double remquo(double x, double y, int *quo) noexcept(true);
extern float remquof(float x, float y, int *quo) noexcept(true);
extern double j0(double x) noexcept(true);
extern float j0f(float x) noexcept(true);
extern double j1(double x) noexcept(true);
extern float j1f(float x) noexcept(true);
extern double jn(int n, double x) noexcept(true);
extern float jnf(int n, float x) noexcept(true);
extern double y0(double x) noexcept(true);
extern float y0f(float x) noexcept(true);
extern double y1(double x) noexcept(true);
extern float y1f(float x) noexcept(true);
extern double yn(int n, double x) noexcept(true);
extern float ynf(int n, float x) noexcept(true);
extern double erf(double x) noexcept(true);
extern float erff(float x) noexcept(true);
extern double erfinv(double x);
extern float erfinvf(float x);
extern double erfc(double x) noexcept(true);
extern float erfcf(float x) noexcept(true);
extern double lgamma(double x) noexcept(true);
extern double erfcinv(double x);
extern float erfcinvf(float x);
extern double normcdfinv(double x);
extern float normcdfinvf(float x);
extern double normcdf(double x);
extern float normcdff(float x);
extern double erfcx(double x);
extern float erfcxf(float x);
extern float lgammaf(float x) noexcept(true);
extern double tgamma(double x) noexcept(true);
extern float tgammaf(float x) noexcept(true);
extern double copysign(double x, double y) noexcept(true);
extern float copysignf(float x, float y) noexcept(true);
extern double nextafter(double x, double y) noexcept(true);
extern float nextafterf(float x, float y) noexcept(true);
extern double nan(const char *tagp) noexcept(true);
extern float nanf(const char *tagp) noexcept(true);
extern int __isinff(float) noexcept(true);
extern int __isnanf(float) noexcept(true);
extern int __finite(double) noexcept(true);
extern int __finitef(float) noexcept(true);
extern int __signbit(double) noexcept(true);
extern int __isnan(double) noexcept(true);
extern int __isinf(double) noexcept(true);
extern int __signbitf(float) noexcept(true);
extern double fma(double x, double y, double z) noexcept(true);
extern float fmaf(float x, float y, float z) noexcept(true);
extern int __signbitl(long double) noexcept(true);
extern int __finitel(long double) noexcept(true);
extern int __isinfl(long double) noexcept(true);
extern int __isnanl(long double) noexcept(true);
extern float acosf(float x) noexcept(true);
extern float asinf(float x) noexcept(true);
extern float atanf(float x) noexcept(true);
extern float atan2f(float y, float x) noexcept(true);
extern float cosf(float x) noexcept(true);
extern float sinf(float x) noexcept(true);
extern float tanf(float x) noexcept(true);
extern float coshf(float x) noexcept(true);
extern float sinhf(float x) noexcept(true);
extern float tanhf(float x) noexcept(true);
extern float logf(float x) noexcept(true);
extern float expf(float x) noexcept(true);
extern float log10f(float x) noexcept(true);
extern float modff(float x, float *iptr) noexcept(true);
extern float powf(float x, float y) noexcept(true);
extern float sqrtf(float x) noexcept(true);
extern float ceilf(float x) noexcept(true);
extern float floorf(float x) noexcept(true);
extern float fmodf(float x, float y) noexcept(true);
}

extern "C++" {
namespace std __attribute((__visibility__("default")))
{
	struct __true_type {};
	struct __false_type {};
	template <bool> struct __truth_type {
		typedef __false_type __type;
	};
	template <> struct __truth_type<true> {
		typedef __true_type __type;
	};
	template <class _Sp, class _Tp> struct __traitor {
		enum { __value = ((bool)_Sp::__value) || ((bool)_Tp::__value) };
		typedef typename __truth_type<__value>::__type __type;
	};
	template <class, class> struct __are_same {
		enum { __value };
		typedef __false_type __type;
	};
	template <class _Tp> struct __are_same<_Tp, _Tp> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <class _Tp> struct __is_void
	{
		enum { __value };
		typedef __false_type __type;
	};
	template <> struct __is_void<void>
	{
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <class _Tp> struct __is_integer {
		enum { __value };
		typedef __false_type __type;
	};
	template <> struct __is_integer<bool> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <> struct __is_integer<char> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <> struct __is_integer<signed char> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <> struct __is_integer<unsigned char> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <> struct __is_integer<wchar_t> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <> struct __is_integer<char16_t> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <> struct __is_integer<char32_t> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <> struct __is_integer<short> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <> struct __is_integer<unsigned short> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <> struct __is_integer<int> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <> struct __is_integer<unsigned> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <> struct __is_integer<long> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <> struct __is_integer<unsigned long> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <> struct __is_integer<long long> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <> struct __is_integer<unsigned long long> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <> struct __is_integer<__int128> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <> struct __is_integer<unsigned __int128> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <class _Tp> struct __is_floating {
		enum { __value };
		typedef __false_type __type;
	};
	template <> struct __is_floating<float> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <> struct __is_floating<double> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <> struct __is_floating<long double> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <class _Tp> struct __is_pointer
	{
		enum { __value };
		typedef __false_type __type;
	};
	template <class _Tp> struct __is_pointer<_Tp *>
	{
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <class _Tp>
	struct __is_arithmetic
		: public __traitor<__is_integer<_Tp>, __is_floating<_Tp>>{};
	template <class _Tp>
	struct __is_scalar
		: public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp>>{};
	template <class _Tp> struct __is_char {
		enum { __value };
		typedef __false_type __type;
	};
	template <> struct __is_char<char> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <> struct __is_char<wchar_t> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <class _Tp> struct __is_byte {
		enum { __value };
		typedef __false_type __type;
	};
	template <> struct __is_byte<char> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <> struct __is_byte<signed char> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <> struct __is_byte<unsigned char> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	enum class byte : unsigned char;
	template <> struct __is_byte<byte> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <class> struct iterator_traits;
	template <class _Tp> struct __is_nonvolatile_trivially_copyable {
		enum { __value = __is_trivially_copyable(_Tp) };
	};
	template <class _Tp>
	struct __is_nonvolatile_trivially_copyable<volatile _Tp> {
		enum { __value };
	};
	template <class _OutputIter, class _InputIter> struct __memcpyable {
		enum { __value };
	};
	template <class _Tp>
	struct __memcpyable<_Tp *, _Tp *>
		: public __is_nonvolatile_trivially_copyable<_Tp> {
	};
	template <class _Tp>
	struct __memcpyable<_Tp *, const _Tp *>
		: public __is_nonvolatile_trivially_copyable<_Tp> {
	};
	template <class _Iter1, class _Iter2> struct __memcmpable {
		enum { __value };
	};
	template <class _Tp>
	struct __memcmpable<_Tp *, _Tp *>
		: public __is_nonvolatile_trivially_copyable<_Tp> {
	};
	template <class _Tp>
	struct __memcmpable<const _Tp *, _Tp *>
		: public __is_nonvolatile_trivially_copyable<_Tp> {
	};
	template <class _Tp>
	struct __memcmpable<_Tp *, const _Tp *>
		: public __is_nonvolatile_trivially_copyable<_Tp> {
	};
	template <class _Tp, bool _TreatAsBytes = __is_byte<_Tp>::__value>
	struct __is_memcmp_ordered {
		static const bool __value = (((_Tp)(-1)) > ((_Tp)1));
	};
	template <class _Tp> struct __is_memcmp_ordered<_Tp, false> {
		static const bool __value = false;
	};
	template <class _Tp, class _Up, bool = sizeof(_Tp) == sizeof(_Up)>
	struct __is_memcmp_ordered_with {
		static const bool __value =
			(__is_memcmp_ordered<_Tp>::__value &&
			 __is_memcmp_ordered<_Up>::__value);
	};
	template <class _Tp, class _Up>
	struct __is_memcmp_ordered_with<_Tp, _Up, false> {
		static const bool __value = false;
	};
	template <> struct __is_memcmp_ordered_with<byte, byte, true> {
		static constexpr inline bool __value = true;
	};
	template <class _Tp, bool _SameSize>
	struct __is_memcmp_ordered_with<_Tp, byte, _SameSize> {
		static constexpr inline bool __value = false;
	};
	template <class _Up, bool _SameSize>
	struct __is_memcmp_ordered_with<byte, _Up, _SameSize> {
		static constexpr inline bool __value = false;
	};
	template <class _Tp> struct __is_move_iterator {
		enum { __value };
		typedef __false_type __type;
	};
	template <class _Iterator> inline _Iterator __miter_base(_Iterator __it)
	{
		return __it;
	}
} // namespace )
}
extern "C++" {
namespace __gnu_cxx __attribute((__visibility__("default")))
{
	template <bool, class> struct __enable_if {
	};
	template <class _Tp> struct __enable_if<true, _Tp> {
		typedef _Tp __type;
	};
	template <bool _Cond, class _Iftrue, class _Iffalse>
	struct __conditional_type {
		typedef _Iftrue __type;
	};
	template <class _Iftrue, class _Iffalse>
	struct __conditional_type<false, _Iftrue, _Iffalse> {
		typedef _Iffalse __type;
	};
	template <class _Tp> struct __add_unsigned {
	    private:
		typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp>
			__if_type;

	    public:
		typedef typename __enable_if<std::__is_integer<_Tp>::__value,
					     _Tp>::__type __type;
	};
	template <> struct __add_unsigned<char> {
		typedef unsigned char __type;
	};
	template <> struct __add_unsigned<signed char> {
		typedef unsigned char __type;
	};
	template <> struct __add_unsigned<short> {
		typedef unsigned short __type;
	};
	template <> struct __add_unsigned<int> {
		typedef unsigned __type;
	};
	template <> struct __add_unsigned<long> {
		typedef unsigned long __type;
	};
	template <> struct __add_unsigned<long long> {
		typedef unsigned long long __type;
	};
	template <> struct __add_unsigned<bool>;
	template <> struct __add_unsigned<wchar_t>;
	template <class _Tp> struct __remove_unsigned {
	    private:
		typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp>
			__if_type;

	    public:
		typedef typename __enable_if<std::__is_integer<_Tp>::__value,
					     _Tp>::__type __type;
	};
	template <> struct __remove_unsigned<char> {
		typedef signed char __type;
	};
	template <> struct __remove_unsigned<unsigned char> {
		typedef signed char __type;
	};
	template <> struct __remove_unsigned<unsigned short> {
		typedef short __type;
	};
	template <> struct __remove_unsigned<unsigned> {
		typedef int __type;
	};
	template <> struct __remove_unsigned<unsigned long> {
		typedef long __type;
	};
	template <> struct __remove_unsigned<unsigned long long> {
		typedef long long __type;
	};
	template <> struct __remove_unsigned<bool>;
	template <> struct __remove_unsigned<wchar_t>;
	template <class _Type> constexpr bool __is_null_pointer(_Type * __ptr)
	{
		return __ptr == 0;
	}
	template <class _Type> constexpr bool __is_null_pointer(_Type)
	{
		return false;
	}
	constexpr bool __is_null_pointer(std::nullptr_t)
	{
		return true;
	}
	template <class _Tp, bool = std::template __is_integer<_Tp>::__value>
	struct __promote {
		typedef double __type;
	};
	template <class _Tp> struct __promote<_Tp, false> {
	};
	template <> struct __promote<long double> {
		typedef long double __type;
	};
	template <> struct __promote<double> {
		typedef double __type;
	};
	template <> struct __promote<float> {
		typedef float __type;
	};
	template <class... _Tp>
	using __promoted_t =
		__decltype(((((typename __promote<_Tp>::__type)0) + ...)));
	template <class _Tp, class _Up>
	using __promote_2 = __promote<__promoted_t<_Tp, _Up>>;
	template <class _Tp, class _Up, class _Vp>
	using __promote_3 = __promote<__promoted_t<_Tp, _Up, _Vp>>;
	template <class _Tp, class _Up, class _Vp, class _Wp>
	using __promote_4 = __promote<__promoted_t<_Tp, _Up, _Vp, _Wp>>;
} // namespace )
}
extern "C" {
typedef float float_t;
typedef double double_t;
enum {
	FP_INT_UPWARD,
	FP_INT_DOWNWARD,
	FP_INT_TOWARDZERO,
	FP_INT_TONEARESTFROMZERO,
	FP_INT_TONEAREST
};
extern int __fpclassify(double __value) noexcept(true) __attribute((const));
extern int __signbit(double __value) noexcept(true) __attribute((const));
extern int __isinf(double __value) noexcept(true) __attribute((const));
extern int __finite(double __value) noexcept(true) __attribute((const));
extern int __isnan(double __value) noexcept(true) __attribute((const));
extern int __iseqsig(double __x, double __y) noexcept(true);
extern int __issignaling(double __value) noexcept(true) __attribute((const));
extern double acos(double __x) noexcept(true);
extern double __acos(double __x) noexcept(true);
extern double asin(double __x) noexcept(true);
extern double __asin(double __x) noexcept(true);
extern double atan(double __x) noexcept(true);
extern double __atan(double __x) noexcept(true);
extern double atan2(double __y, double __x) noexcept(true);
extern double __atan2(double __y, double __x) noexcept(true);
extern double cos(double __x) noexcept(true);
extern double __cos(double __x) noexcept(true);
extern double sin(double __x) noexcept(true);
extern double __sin(double __x) noexcept(true);
extern double tan(double __x) noexcept(true);
extern double __tan(double __x) noexcept(true);
extern double cosh(double __x) noexcept(true);
extern double __cosh(double __x) noexcept(true);
extern double sinh(double __x) noexcept(true);
extern double __sinh(double __x) noexcept(true);
extern double tanh(double __x) noexcept(true);
extern double __tanh(double __x) noexcept(true);
extern void sincos(double __x, double *__sinx, double *__cosx) noexcept(true);
extern void __sincos(double __x, double *__sinx, double *__cosx) noexcept(true);
extern double acosh(double __x) noexcept(true);
extern double __acosh(double __x) noexcept(true);
extern double asinh(double __x) noexcept(true);
extern double __asinh(double __x) noexcept(true);
extern double atanh(double __x) noexcept(true);
extern double __atanh(double __x) noexcept(true);
extern double exp(double __x) noexcept(true);
extern double __exp(double __x) noexcept(true);
extern double frexp(double __x, int *__exponent) noexcept(true);
extern double __frexp(double __x, int *__exponent) noexcept(true);
extern double ldexp(double __x, int __exponent) noexcept(true);
extern double __ldexp(double __x, int __exponent) noexcept(true);
extern double log(double __x) noexcept(true);
extern double __log(double __x) noexcept(true);
extern double log10(double __x) noexcept(true);
extern double __log10(double __x) noexcept(true);
extern double modf(double __x, double *__iptr) noexcept(true);
extern double __modf(double __x, double *__iptr) noexcept(true)
	__attribute((__nonnull__(2)));
extern double exp10(double __x) noexcept(true);
extern double __exp10(double __x) noexcept(true);
extern double expm1(double __x) noexcept(true);
extern double __expm1(double __x) noexcept(true);
extern double log1p(double __x) noexcept(true);
extern double __log1p(double __x) noexcept(true);
extern double logb(double __x) noexcept(true);
extern double __logb(double __x) noexcept(true);
extern double exp2(double __x) noexcept(true);
extern double __exp2(double __x) noexcept(true);
extern double log2(double __x) noexcept(true);
extern double __log2(double __x) noexcept(true);
extern double pow(double __x, double __y) noexcept(true);
extern double __pow(double __x, double __y) noexcept(true);
extern double sqrt(double __x) noexcept(true);
extern double __sqrt(double __x) noexcept(true);
extern double hypot(double __x, double __y) noexcept(true);
extern double __hypot(double __x, double __y) noexcept(true);
extern double cbrt(double __x) noexcept(true);
extern double __cbrt(double __x) noexcept(true);
extern double ceil(double __x) noexcept(true) __attribute((const));
extern double __ceil(double __x) noexcept(true) __attribute((const));
extern double fabs(double __x) noexcept(true) __attribute((const));
extern double __fabs(double __x) noexcept(true) __attribute((const));
extern double floor(double __x) noexcept(true) __attribute((const));
extern double __floor(double __x) noexcept(true) __attribute((const));
extern double fmod(double __x, double __y) noexcept(true);
extern double __fmod(double __x, double __y) noexcept(true);
extern int finite(double __value) noexcept(true) __attribute((const));
extern double drem(double __x, double __y) noexcept(true);
extern double __drem(double __x, double __y) noexcept(true);
extern double significand(double __x) noexcept(true);
extern double __significand(double __x) noexcept(true);
extern double copysign(double __x, double __y) noexcept(true)
	__attribute((const));
extern double __copysign(double __x, double __y) noexcept(true)
	__attribute((const));
extern double nan(const char *__tagb) noexcept(true);
extern double __nan(const char *__tagb) noexcept(true);
extern double j0(double) noexcept(true);
extern double __j0(double) noexcept(true);
extern double j1(double) noexcept(true);
extern double __j1(double) noexcept(true);
extern double jn(int, double) noexcept(true);
extern double __jn(int, double) noexcept(true);
extern double y0(double) noexcept(true);
extern double __y0(double) noexcept(true);
extern double y1(double) noexcept(true);
extern double __y1(double) noexcept(true);
extern double yn(int, double) noexcept(true);
extern double __yn(int, double) noexcept(true);
extern double erf(double) noexcept(true);
extern double __erf(double) noexcept(true);
extern double erfc(double) noexcept(true);
extern double __erfc(double) noexcept(true);
extern double lgamma(double) noexcept(true);
extern double __lgamma(double) noexcept(true);
extern double tgamma(double) noexcept(true);
extern double __tgamma(double) noexcept(true);
extern double gamma(double) noexcept(true);
extern double __gamma(double) noexcept(true);
extern double lgamma_r(double, int *__signgamp) noexcept(true);
extern double __lgamma_r(double, int *__signgamp) noexcept(true);
extern double rint(double __x) noexcept(true);
extern double __rint(double __x) noexcept(true);
extern double nextafter(double __x, double __y) noexcept(true);
extern double __nextafter(double __x, double __y) noexcept(true);
extern double nexttoward(double __x, long double __y) noexcept(true);
extern double __nexttoward(double __x, long double __y) noexcept(true);
extern double nextdown(double __x) noexcept(true);
extern double __nextdown(double __x) noexcept(true);
extern double nextup(double __x) noexcept(true);
extern double __nextup(double __x) noexcept(true);
extern double remainder(double __x, double __y) noexcept(true);
extern double __remainder(double __x, double __y) noexcept(true);
extern double scalbn(double __x, int __n) noexcept(true);
extern double __scalbn(double __x, int __n) noexcept(true);
extern int ilogb(double __x) noexcept(true);
extern int __ilogb(double __x) noexcept(true);
extern long llogb(double __x) noexcept(true);
extern long __llogb(double __x) noexcept(true);
extern double scalbln(double __x, long __n) noexcept(true);
extern double __scalbln(double __x, long __n) noexcept(true);
extern double nearbyint(double __x) noexcept(true);
extern double __nearbyint(double __x) noexcept(true);
extern double round(double __x) noexcept(true) __attribute((const));
extern double __round(double __x) noexcept(true) __attribute((const));
extern double trunc(double __x) noexcept(true) __attribute((const));
extern double __trunc(double __x) noexcept(true) __attribute((const));
extern double remquo(double __x, double __y, int *__quo) noexcept(true);
extern double __remquo(double __x, double __y, int *__quo) noexcept(true);
extern long lrint(double __x) noexcept(true);
extern long __lrint(double __x) noexcept(true);
__extension__ extern long long llrint(double __x) noexcept(true);
extern long long __llrint(double __x) noexcept(true);
extern long lround(double __x) noexcept(true);
extern long __lround(double __x) noexcept(true);
__extension__ extern long long llround(double __x) noexcept(true);
extern long long __llround(double __x) noexcept(true);
extern double fdim(double __x, double __y) noexcept(true);
extern double __fdim(double __x, double __y) noexcept(true);
extern double fmax(double __x, double __y) noexcept(true) __attribute((const));
extern double __fmax(double __x, double __y) noexcept(true)
	__attribute((const));
extern double fmin(double __x, double __y) noexcept(true) __attribute((const));
extern double __fmin(double __x, double __y) noexcept(true)
	__attribute((const));
extern double fma(double __x, double __y, double __z) noexcept(true);
extern double __fma(double __x, double __y, double __z) noexcept(true);
extern double roundeven(double __x) noexcept(true) __attribute((const));
extern double __roundeven(double __x) noexcept(true) __attribute((const));
extern __intmax_t fromfp(double __x, int __round,
			 unsigned __width) noexcept(true);
extern __intmax_t __fromfp(double __x, int __round,
			   unsigned __width) noexcept(true);
extern __uintmax_t ufromfp(double __x, int __round,
			   unsigned __width) noexcept(true);
extern __uintmax_t __ufromfp(double __x, int __round,
			     unsigned __width) noexcept(true);
extern __intmax_t fromfpx(double __x, int __round,
			  unsigned __width) noexcept(true);
extern __intmax_t __fromfpx(double __x, int __round,
			    unsigned __width) noexcept(true);
extern __uintmax_t ufromfpx(double __x, int __round,
			    unsigned __width) noexcept(true);
extern __uintmax_t __ufromfpx(double __x, int __round,
			      unsigned __width) noexcept(true);
extern int canonicalize(double *__cx, const double *__x) noexcept(true);
extern double fmaxmag(double __x, double __y) noexcept(true)
	__attribute((const));
extern double __fmaxmag(double __x, double __y) noexcept(true)
	__attribute((const));
extern double fminmag(double __x, double __y) noexcept(true)
	__attribute((const));
extern double __fminmag(double __x, double __y) noexcept(true)
	__attribute((const));
extern double fmaximum(double __x, double __y) noexcept(true)
	__attribute((const));
extern double __fmaximum(double __x, double __y) noexcept(true)
	__attribute((const));
extern double fminimum(double __x, double __y) noexcept(true)
	__attribute((const));
extern double __fminimum(double __x, double __y) noexcept(true)
	__attribute((const));
extern double fmaximum_num(double __x, double __y) noexcept(true)
	__attribute((const));
extern double __fmaximum_num(double __x, double __y) noexcept(true)
	__attribute((const));
extern double fminimum_num(double __x, double __y) noexcept(true)
	__attribute((const));
extern double __fminimum_num(double __x, double __y) noexcept(true)
	__attribute((const));
extern double fmaximum_mag(double __x, double __y) noexcept(true)
	__attribute((const));
extern double __fmaximum_mag(double __x, double __y) noexcept(true)
	__attribute((const));
extern double fminimum_mag(double __x, double __y) noexcept(true)
	__attribute((const));
extern double __fminimum_mag(double __x, double __y) noexcept(true)
	__attribute((const));
extern double fmaximum_mag_num(double __x, double __y) noexcept(true)
	__attribute((const));
extern double __fmaximum_mag_num(double __x, double __y) noexcept(true)
	__attribute((const));
extern double fminimum_mag_num(double __x, double __y) noexcept(true)
	__attribute((const));
extern double __fminimum_mag_num(double __x, double __y) noexcept(true)
	__attribute((const));
extern int totalorder(const double *__x, const double *__y) noexcept(true)
	__attribute((__pure__));
extern int totalordermag(const double *__x, const double *__y) noexcept(true)
	__attribute((__pure__));
extern double getpayload(const double *__x) noexcept(true);
extern double __getpayload(const double *__x) noexcept(true);
extern int setpayload(double *__x, double __payload) noexcept(true);
extern int setpayloadsig(double *__x, double __payload) noexcept(true);
extern double scalb(double __x, double __n) noexcept(true);
extern double __scalb(double __x, double __n) noexcept(true);
extern int __fpclassifyf(float __value) noexcept(true) __attribute((const));
extern int __signbitf(float __value) noexcept(true) __attribute((const));
extern int __isinff(float __value) noexcept(true) __attribute((const));
extern int __finitef(float __value) noexcept(true) __attribute((const));
extern int __isnanf(float __value) noexcept(true) __attribute((const));
extern int __iseqsigf(float __x, float __y) noexcept(true);
extern int __issignalingf(float __value) noexcept(true) __attribute((const));
extern float acosf(float __x) noexcept(true);
extern float __acosf(float __x) noexcept(true);
extern float asinf(float __x) noexcept(true);
extern float __asinf(float __x) noexcept(true);
extern float atanf(float __x) noexcept(true);
extern float __atanf(float __x) noexcept(true);
extern float atan2f(float __y, float __x) noexcept(true);
extern float __atan2f(float __y, float __x) noexcept(true);
extern float cosf(float __x) noexcept(true);
extern float sinf(float __x) noexcept(true);
extern float tanf(float __x) noexcept(true);
extern float coshf(float __x) noexcept(true);
extern float __coshf(float __x) noexcept(true);
extern float sinhf(float __x) noexcept(true);
extern float __sinhf(float __x) noexcept(true);
extern float tanhf(float __x) noexcept(true);
extern float __tanhf(float __x) noexcept(true);
extern void sincosf(float __x, float *__sinx, float *__cosx) noexcept(true);
extern float acoshf(float __x) noexcept(true);
extern float __acoshf(float __x) noexcept(true);
extern float asinhf(float __x) noexcept(true);
extern float __asinhf(float __x) noexcept(true);
extern float atanhf(float __x) noexcept(true);
extern float __atanhf(float __x) noexcept(true);
extern float expf(float __x) noexcept(true);
extern float frexpf(float __x, int *__exponent) noexcept(true);
extern float __frexpf(float __x, int *__exponent) noexcept(true);
extern float ldexpf(float __x, int __exponent) noexcept(true);
extern float __ldexpf(float __x, int __exponent) noexcept(true);
extern float logf(float __x) noexcept(true);
extern float log10f(float __x) noexcept(true);
extern float modff(float __x, float *__iptr) noexcept(true);
extern float __modff(float __x, float *__iptr) noexcept(true)
	__attribute((__nonnull__(2)));
extern float exp10f(float __x) noexcept(true);
extern float expm1f(float __x) noexcept(true);
extern float __expm1f(float __x) noexcept(true);
extern float log1pf(float __x) noexcept(true);
extern float __log1pf(float __x) noexcept(true);
extern float logbf(float __x) noexcept(true);
extern float __logbf(float __x) noexcept(true);
extern float exp2f(float __x) noexcept(true);
extern float __exp2f(float __x) noexcept(true);
extern float log2f(float __x) noexcept(true);
extern float powf(float __x, float __y) noexcept(true);
extern float sqrtf(float __x) noexcept(true);
extern float __sqrtf(float __x) noexcept(true);
extern float hypotf(float __x, float __y) noexcept(true);
extern float __hypotf(float __x, float __y) noexcept(true);
extern float cbrtf(float __x) noexcept(true);
extern float __cbrtf(float __x) noexcept(true);
extern float ceilf(float __x) noexcept(true) __attribute((const));
extern float __ceilf(float __x) noexcept(true) __attribute((const));
extern float fabsf(float __x) noexcept(true) __attribute((const));
extern float __fabsf(float __x) noexcept(true) __attribute((const));
extern float floorf(float __x) noexcept(true) __attribute((const));
extern float __floorf(float __x) noexcept(true) __attribute((const));
extern float fmodf(float __x, float __y) noexcept(true);
extern float __fmodf(float __x, float __y) noexcept(true);
extern int isinff(float __value) noexcept(true) __attribute((const));
extern int finitef(float __value) noexcept(true) __attribute((const));
extern float dremf(float __x, float __y) noexcept(true);
extern float __dremf(float __x, float __y) noexcept(true);
extern float significandf(float __x) noexcept(true);
extern float __significandf(float __x) noexcept(true);
extern float copysignf(float __x, float __y) noexcept(true)
	__attribute((const));
extern float __copysignf(float __x, float __y) noexcept(true)
	__attribute((const));
extern float nanf(const char *__tagb) noexcept(true);
extern float __nanf(const char *__tagb) noexcept(true);
extern int isnanf(float __value) noexcept(true) __attribute((const));
extern float j0f(float) noexcept(true);
extern float __j0f(float) noexcept(true);
extern float j1f(float) noexcept(true);
extern float __j1f(float) noexcept(true);
extern float jnf(int, float) noexcept(true);
extern float __jnf(int, float) noexcept(true);
extern float y0f(float) noexcept(true);
extern float __y0f(float) noexcept(true);
extern float y1f(float) noexcept(true);
extern float __y1f(float) noexcept(true);
extern float ynf(int, float) noexcept(true);
extern float __ynf(int, float) noexcept(true);
extern float erff(float) noexcept(true);
extern float __erff(float) noexcept(true);
extern float erfcf(float) noexcept(true);
extern float __erfcf(float) noexcept(true);
extern float lgammaf(float) noexcept(true);
extern float __lgammaf(float) noexcept(true);
extern float tgammaf(float) noexcept(true);
extern float __tgammaf(float) noexcept(true);
extern float gammaf(float) noexcept(true);
extern float __gammaf(float) noexcept(true);
extern float lgammaf_r(float, int *__signgamp) noexcept(true);
extern float __lgammaf_r(float, int *__signgamp) noexcept(true);
extern float rintf(float __x) noexcept(true);
extern float __rintf(float __x) noexcept(true);
extern float nextafterf(float __x, float __y) noexcept(true);
extern float __nextafterf(float __x, float __y) noexcept(true);
extern float nexttowardf(float __x, long double __y) noexcept(true);
extern float __nexttowardf(float __x, long double __y) noexcept(true);
extern float nextdownf(float __x) noexcept(true);
extern float __nextdownf(float __x) noexcept(true);
extern float nextupf(float __x) noexcept(true);
extern float __nextupf(float __x) noexcept(true);
extern float remainderf(float __x, float __y) noexcept(true);
extern float __remainderf(float __x, float __y) noexcept(true);
extern float scalbnf(float __x, int __n) noexcept(true);
extern float __scalbnf(float __x, int __n) noexcept(true);
extern int ilogbf(float __x) noexcept(true);
extern int __ilogbf(float __x) noexcept(true);
extern long llogbf(float __x) noexcept(true);
extern long __llogbf(float __x) noexcept(true);
extern float scalblnf(float __x, long __n) noexcept(true);
extern float __scalblnf(float __x, long __n) noexcept(true);
extern float nearbyintf(float __x) noexcept(true);
extern float __nearbyintf(float __x) noexcept(true);
extern float roundf(float __x) noexcept(true) __attribute((const));
extern float __roundf(float __x) noexcept(true) __attribute((const));
extern float truncf(float __x) noexcept(true) __attribute((const));
extern float __truncf(float __x) noexcept(true) __attribute((const));
extern float remquof(float __x, float __y, int *__quo) noexcept(true);
extern float __remquof(float __x, float __y, int *__quo) noexcept(true);
extern long lrintf(float __x) noexcept(true);
extern long __lrintf(float __x) noexcept(true);
__extension__ extern long long llrintf(float __x) noexcept(true);
extern long long __llrintf(float __x) noexcept(true);
extern long lroundf(float __x) noexcept(true);
extern long __lroundf(float __x) noexcept(true);
__extension__ extern long long llroundf(float __x) noexcept(true);
extern long long __llroundf(float __x) noexcept(true);
extern float fdimf(float __x, float __y) noexcept(true);
extern float __fdimf(float __x, float __y) noexcept(true);
extern float fmaxf(float __x, float __y) noexcept(true) __attribute((const));
extern float __fmaxf(float __x, float __y) noexcept(true) __attribute((const));
extern float fminf(float __x, float __y) noexcept(true) __attribute((const));
extern float __fminf(float __x, float __y) noexcept(true) __attribute((const));
extern float fmaf(float __x, float __y, float __z) noexcept(true);
extern float __fmaf(float __x, float __y, float __z) noexcept(true);
extern float roundevenf(float __x) noexcept(true) __attribute((const));
extern float __roundevenf(float __x) noexcept(true) __attribute((const));
extern __intmax_t fromfpf(float __x, int __round,
			  unsigned __width) noexcept(true);
extern __intmax_t __fromfpf(float __x, int __round,
			    unsigned __width) noexcept(true);
extern __uintmax_t ufromfpf(float __x, int __round,
			    unsigned __width) noexcept(true);
extern __uintmax_t __ufromfpf(float __x, int __round,
			      unsigned __width) noexcept(true);
extern __intmax_t fromfpxf(float __x, int __round,
			   unsigned __width) noexcept(true);
extern __intmax_t __fromfpxf(float __x, int __round,
			     unsigned __width) noexcept(true);
extern __uintmax_t ufromfpxf(float __x, int __round,
			     unsigned __width) noexcept(true);
extern __uintmax_t __ufromfpxf(float __x, int __round,
			       unsigned __width) noexcept(true);
extern int canonicalizef(float *__cx, const float *__x) noexcept(true);
extern float fmaxmagf(float __x, float __y) noexcept(true) __attribute((const));
extern float __fmaxmagf(float __x, float __y) noexcept(true)
	__attribute((const));
extern float fminmagf(float __x, float __y) noexcept(true) __attribute((const));
extern float __fminmagf(float __x, float __y) noexcept(true)
	__attribute((const));
extern float fmaximumf(float __x, float __y) noexcept(true)
	__attribute((const));
extern float __fmaximumf(float __x, float __y) noexcept(true)
	__attribute((const));
extern float fminimumf(float __x, float __y) noexcept(true)
	__attribute((const));
extern float __fminimumf(float __x, float __y) noexcept(true)
	__attribute((const));
extern float fmaximum_numf(float __x, float __y) noexcept(true)
	__attribute((const));
extern float __fmaximum_numf(float __x, float __y) noexcept(true)
	__attribute((const));
extern float fminimum_numf(float __x, float __y) noexcept(true)
	__attribute((const));
extern float __fminimum_numf(float __x, float __y) noexcept(true)
	__attribute((const));
extern float fmaximum_magf(float __x, float __y) noexcept(true)
	__attribute((const));
extern float __fmaximum_magf(float __x, float __y) noexcept(true)
	__attribute((const));
extern float fminimum_magf(float __x, float __y) noexcept(true)
	__attribute((const));
extern float __fminimum_magf(float __x, float __y) noexcept(true)
	__attribute((const));
extern float fmaximum_mag_numf(float __x, float __y) noexcept(true)
	__attribute((const));
extern float __fmaximum_mag_numf(float __x, float __y) noexcept(true)
	__attribute((const));
extern float fminimum_mag_numf(float __x, float __y) noexcept(true)
	__attribute((const));
extern float __fminimum_mag_numf(float __x, float __y) noexcept(true)
	__attribute((const));
extern int totalorderf(const float *__x, const float *__y) noexcept(true)
	__attribute((__pure__));
extern int totalordermagf(const float *__x, const float *__y) noexcept(true)
	__attribute((__pure__));
extern float getpayloadf(const float *__x) noexcept(true);
extern float __getpayloadf(const float *__x) noexcept(true);
extern int setpayloadf(float *__x, float __payload) noexcept(true);
extern int setpayloadsigf(float *__x, float __payload) noexcept(true);
extern float scalbf(float __x, float __n) noexcept(true);
extern float __scalbf(float __x, float __n) noexcept(true);
extern int __fpclassifyl(long double __value) noexcept(true)
	__attribute((const));
extern int __signbitl(long double __value) noexcept(true) __attribute((const));
extern int __isinfl(long double __value) noexcept(true) __attribute((const));
extern int __finitel(long double __value) noexcept(true) __attribute((const));
extern int __isnanl(long double __value) noexcept(true) __attribute((const));
extern int __iseqsigl(long double __x, long double __y) noexcept(true);
extern int __issignalingl(long double __value) noexcept(true)
	__attribute((const));
extern long double acosl(long double __x) noexcept(true);
extern long double __acosl(long double __x) noexcept(true);
extern long double asinl(long double __x) noexcept(true);
extern long double __asinl(long double __x) noexcept(true);
extern long double atanl(long double __x) noexcept(true);
extern long double __atanl(long double __x) noexcept(true);
extern long double atan2l(long double __y, long double __x) noexcept(true);
extern long double __atan2l(long double __y, long double __x) noexcept(true);
extern long double cosl(long double __x) noexcept(true);
extern long double __cosl(long double __x) noexcept(true);
extern long double sinl(long double __x) noexcept(true);
extern long double __sinl(long double __x) noexcept(true);
extern long double tanl(long double __x) noexcept(true);
extern long double __tanl(long double __x) noexcept(true);
extern long double coshl(long double __x) noexcept(true);
extern long double __coshl(long double __x) noexcept(true);
extern long double sinhl(long double __x) noexcept(true);
extern long double __sinhl(long double __x) noexcept(true);
extern long double tanhl(long double __x) noexcept(true);
extern long double __tanhl(long double __x) noexcept(true);
extern void sincosl(long double __x, long double *__sinx,
		    long double *__cosx) noexcept(true);
extern void __sincosl(long double __x, long double *__sinx,
		      long double *__cosx) noexcept(true);
extern long double acoshl(long double __x) noexcept(true);
extern long double __acoshl(long double __x) noexcept(true);
extern long double asinhl(long double __x) noexcept(true);
extern long double __asinhl(long double __x) noexcept(true);
extern long double atanhl(long double __x) noexcept(true);
extern long double __atanhl(long double __x) noexcept(true);
extern long double expl(long double __x) noexcept(true);
extern long double __expl(long double __x) noexcept(true);
extern long double frexpl(long double __x, int *__exponent) noexcept(true);
extern long double __frexpl(long double __x, int *__exponent) noexcept(true);
extern long double ldexpl(long double __x, int __exponent) noexcept(true);
extern long double __ldexpl(long double __x, int __exponent) noexcept(true);
extern long double logl(long double __x) noexcept(true);
extern long double __logl(long double __x) noexcept(true);
extern long double log10l(long double __x) noexcept(true);
extern long double __log10l(long double __x) noexcept(true);
extern long double modfl(long double __x, long double *__iptr) noexcept(true);
extern long double __modfl(long double __x, long double *__iptr) noexcept(true)
	__attribute((__nonnull__(2)));
extern long double exp10l(long double __x) noexcept(true);
extern long double __exp10l(long double __x) noexcept(true);
extern long double expm1l(long double __x) noexcept(true);
extern long double __expm1l(long double __x) noexcept(true);
extern long double log1pl(long double __x) noexcept(true);
extern long double __log1pl(long double __x) noexcept(true);
extern long double logbl(long double __x) noexcept(true);
extern long double __logbl(long double __x) noexcept(true);
extern long double exp2l(long double __x) noexcept(true);
extern long double __exp2l(long double __x) noexcept(true);
extern long double log2l(long double __x) noexcept(true);
extern long double __log2l(long double __x) noexcept(true);
extern long double powl(long double __x, long double __y) noexcept(true);
extern long double __powl(long double __x, long double __y) noexcept(true);
extern long double sqrtl(long double __x) noexcept(true);
extern long double __sqrtl(long double __x) noexcept(true);
extern long double hypotl(long double __x, long double __y) noexcept(true);
extern long double __hypotl(long double __x, long double __y) noexcept(true);
extern long double cbrtl(long double __x) noexcept(true);
extern long double __cbrtl(long double __x) noexcept(true);
extern long double ceill(long double __x) noexcept(true) __attribute((const));
extern long double __ceill(long double __x) noexcept(true) __attribute((const));
extern long double fabsl(long double __x) noexcept(true) __attribute((const));
extern long double __fabsl(long double __x) noexcept(true) __attribute((const));
extern long double floorl(long double __x) noexcept(true) __attribute((const));
extern long double __floorl(long double __x) noexcept(true)
	__attribute((const));
extern long double fmodl(long double __x, long double __y) noexcept(true);
extern long double __fmodl(long double __x, long double __y) noexcept(true);
extern int isinfl(long double __value) noexcept(true) __attribute((const));
extern int finitel(long double __value) noexcept(true) __attribute((const));
extern long double dreml(long double __x, long double __y) noexcept(true);
extern long double __dreml(long double __x, long double __y) noexcept(true);
extern long double significandl(long double __x) noexcept(true);
extern long double __significandl(long double __x) noexcept(true);
extern long double copysignl(long double __x, long double __y) noexcept(true)
	__attribute((const));
extern long double __copysignl(long double __x, long double __y) noexcept(true)
	__attribute((const));
extern long double nanl(const char *__tagb) noexcept(true);
extern long double __nanl(const char *__tagb) noexcept(true);
extern int isnanl(long double __value) noexcept(true) __attribute((const));
extern long double j0l(long double) noexcept(true);
extern long double __j0l(long double) noexcept(true);
extern long double j1l(long double) noexcept(true);
extern long double __j1l(long double) noexcept(true);
extern long double jnl(int, long double) noexcept(true);
extern long double __jnl(int, long double) noexcept(true);
extern long double y0l(long double) noexcept(true);
extern long double __y0l(long double) noexcept(true);
extern long double y1l(long double) noexcept(true);
extern long double __y1l(long double) noexcept(true);
extern long double ynl(int, long double) noexcept(true);
extern long double __ynl(int, long double) noexcept(true);
extern long double erfl(long double) noexcept(true);
extern long double __erfl(long double) noexcept(true);
extern long double erfcl(long double) noexcept(true);
extern long double __erfcl(long double) noexcept(true);
extern long double lgammal(long double) noexcept(true);
extern long double __lgammal(long double) noexcept(true);
extern long double tgammal(long double) noexcept(true);
extern long double __tgammal(long double) noexcept(true);
extern long double gammal(long double) noexcept(true);
extern long double __gammal(long double) noexcept(true);
extern long double lgammal_r(long double, int *__signgamp) noexcept(true);
extern long double __lgammal_r(long double, int *__signgamp) noexcept(true);
extern long double rintl(long double __x) noexcept(true);
extern long double __rintl(long double __x) noexcept(true);
extern long double nextafterl(long double __x, long double __y) noexcept(true);
extern long double __nextafterl(long double __x,
				long double __y) noexcept(true);
extern long double nexttowardl(long double __x, long double __y) noexcept(true);
extern long double __nexttowardl(long double __x,
				 long double __y) noexcept(true);
extern long double nextdownl(long double __x) noexcept(true);
extern long double __nextdownl(long double __x) noexcept(true);
extern long double nextupl(long double __x) noexcept(true);
extern long double __nextupl(long double __x) noexcept(true);
extern long double remainderl(long double __x, long double __y) noexcept(true);
extern long double __remainderl(long double __x,
				long double __y) noexcept(true);
extern long double scalbnl(long double __x, int __n) noexcept(true);
extern long double __scalbnl(long double __x, int __n) noexcept(true);
extern int ilogbl(long double __x) noexcept(true);
extern int __ilogbl(long double __x) noexcept(true);
extern long llogbl(long double __x) noexcept(true);
extern long __llogbl(long double __x) noexcept(true);
extern long double scalblnl(long double __x, long __n) noexcept(true);
extern long double __scalblnl(long double __x, long __n) noexcept(true);
extern long double nearbyintl(long double __x) noexcept(true);
extern long double __nearbyintl(long double __x) noexcept(true);
extern long double roundl(long double __x) noexcept(true) __attribute((const));
extern long double __roundl(long double __x) noexcept(true)
	__attribute((const));
extern long double truncl(long double __x) noexcept(true) __attribute((const));
extern long double __truncl(long double __x) noexcept(true)
	__attribute((const));
extern long double remquol(long double __x, long double __y,
			   int *__quo) noexcept(true);
extern long double __remquol(long double __x, long double __y,
			     int *__quo) noexcept(true);
extern long lrintl(long double __x) noexcept(true);
extern long __lrintl(long double __x) noexcept(true);
__extension__ extern long long llrintl(long double __x) noexcept(true);
extern long long __llrintl(long double __x) noexcept(true);
extern long lroundl(long double __x) noexcept(true);
extern long __lroundl(long double __x) noexcept(true);
__extension__ extern long long llroundl(long double __x) noexcept(true);
extern long long __llroundl(long double __x) noexcept(true);
extern long double fdiml(long double __x, long double __y) noexcept(true);
extern long double __fdiml(long double __x, long double __y) noexcept(true);
extern long double fmaxl(long double __x, long double __y) noexcept(true)
	__attribute((const));
extern long double __fmaxl(long double __x, long double __y) noexcept(true)
	__attribute((const));
extern long double fminl(long double __x, long double __y) noexcept(true)
	__attribute((const));
extern long double __fminl(long double __x, long double __y) noexcept(true)
	__attribute((const));
extern long double fmal(long double __x, long double __y,
			long double __z) noexcept(true);
extern long double __fmal(long double __x, long double __y,
			  long double __z) noexcept(true);
extern long double roundevenl(long double __x) noexcept(true)
	__attribute((const));
extern long double __roundevenl(long double __x) noexcept(true)
	__attribute((const));
extern __intmax_t fromfpl(long double __x, int __round,
			  unsigned __width) noexcept(true);
extern __intmax_t __fromfpl(long double __x, int __round,
			    unsigned __width) noexcept(true);
extern __uintmax_t ufromfpl(long double __x, int __round,
			    unsigned __width) noexcept(true);
extern __uintmax_t __ufromfpl(long double __x, int __round,
			      unsigned __width) noexcept(true);
extern __intmax_t fromfpxl(long double __x, int __round,
			   unsigned __width) noexcept(true);
extern __intmax_t __fromfpxl(long double __x, int __round,
			     unsigned __width) noexcept(true);
extern __uintmax_t ufromfpxl(long double __x, int __round,
			     unsigned __width) noexcept(true);
extern __uintmax_t __ufromfpxl(long double __x, int __round,
			       unsigned __width) noexcept(true);
extern int canonicalizel(long double *__cx,
			 const long double *__x) noexcept(true);
extern long double fmaxmagl(long double __x, long double __y) noexcept(true)
	__attribute((const));
extern long double __fmaxmagl(long double __x, long double __y) noexcept(true)
	__attribute((const));
extern long double fminmagl(long double __x, long double __y) noexcept(true)
	__attribute((const));
extern long double __fminmagl(long double __x, long double __y) noexcept(true)
	__attribute((const));
extern long double fmaximuml(long double __x, long double __y) noexcept(true)
	__attribute((const));
extern long double __fmaximuml(long double __x, long double __y) noexcept(true)
	__attribute((const));
extern long double fminimuml(long double __x, long double __y) noexcept(true)
	__attribute((const));
extern long double __fminimuml(long double __x, long double __y) noexcept(true)
	__attribute((const));
extern long double fmaximum_numl(long double __x,
				 long double __y) noexcept(true)
	__attribute((const));
extern long double __fmaximum_numl(long double __x,
				   long double __y) noexcept(true)
	__attribute((const));
extern long double fminimum_numl(long double __x,
				 long double __y) noexcept(true)
	__attribute((const));
extern long double __fminimum_numl(long double __x,
				   long double __y) noexcept(true)
	__attribute((const));
extern long double fmaximum_magl(long double __x,
				 long double __y) noexcept(true)
	__attribute((const));
extern long double __fmaximum_magl(long double __x,
				   long double __y) noexcept(true)
	__attribute((const));
extern long double fminimum_magl(long double __x,
				 long double __y) noexcept(true)
	__attribute((const));
extern long double __fminimum_magl(long double __x,
				   long double __y) noexcept(true)
	__attribute((const));
extern long double fmaximum_mag_numl(long double __x,
				     long double __y) noexcept(true)
	__attribute((const));
extern long double __fmaximum_mag_numl(long double __x,
				       long double __y) noexcept(true)
	__attribute((const));
extern long double fminimum_mag_numl(long double __x,
				     long double __y) noexcept(true)
	__attribute((const));
extern long double __fminimum_mag_numl(long double __x,
				       long double __y) noexcept(true)
	__attribute((const));
extern int totalorderl(const long double *__x,
		       const long double *__y) noexcept(true)
	__attribute((__pure__));
extern int totalordermagl(const long double *__x,
			  const long double *__y) noexcept(true)
	__attribute((__pure__));
extern long double getpayloadl(const long double *__x) noexcept(true);
extern long double __getpayloadl(const long double *__x) noexcept(true);
extern int setpayloadl(long double *__x, long double __payload) noexcept(true);
extern int setpayloadsigl(long double *__x,
			  long double __payload) noexcept(true);
extern long double scalbl(long double __x, long double __n) noexcept(true);
extern long double __scalbl(long double __x, long double __n) noexcept(true);
extern _Float32 acosf32(_Float32 __x) noexcept(true);
extern _Float32 __acosf32(_Float32 __x) noexcept(true);
extern _Float32 asinf32(_Float32 __x) noexcept(true);
extern _Float32 __asinf32(_Float32 __x) noexcept(true);
extern _Float32 atanf32(_Float32 __x) noexcept(true);
extern _Float32 __atanf32(_Float32 __x) noexcept(true);
extern _Float32 atan2f32(_Float32 __y, _Float32 __x) noexcept(true);
extern _Float32 __atan2f32(_Float32 __y, _Float32 __x) noexcept(true);
extern _Float32 cosf32(_Float32 __x) noexcept(true);
extern _Float32 __cosf32(_Float32 __x) noexcept(true);
extern _Float32 sinf32(_Float32 __x) noexcept(true);
extern _Float32 __sinf32(_Float32 __x) noexcept(true);
extern _Float32 tanf32(_Float32 __x) noexcept(true);
extern _Float32 __tanf32(_Float32 __x) noexcept(true);
extern _Float32 coshf32(_Float32 __x) noexcept(true);
extern _Float32 __coshf32(_Float32 __x) noexcept(true);
extern _Float32 sinhf32(_Float32 __x) noexcept(true);
extern _Float32 __sinhf32(_Float32 __x) noexcept(true);
extern _Float32 tanhf32(_Float32 __x) noexcept(true);
extern _Float32 __tanhf32(_Float32 __x) noexcept(true);
extern void sincosf32(_Float32 __x, _Float32 *__sinx,
		      _Float32 *__cosx) noexcept(true);
extern void __sincosf32(_Float32 __x, _Float32 *__sinx,
			_Float32 *__cosx) noexcept(true);
extern _Float32 acoshf32(_Float32 __x) noexcept(true);
extern _Float32 __acoshf32(_Float32 __x) noexcept(true);
extern _Float32 asinhf32(_Float32 __x) noexcept(true);
extern _Float32 __asinhf32(_Float32 __x) noexcept(true);
extern _Float32 atanhf32(_Float32 __x) noexcept(true);
extern _Float32 __atanhf32(_Float32 __x) noexcept(true);
extern _Float32 expf32(_Float32 __x) noexcept(true);
extern _Float32 __expf32(_Float32 __x) noexcept(true);
extern _Float32 frexpf32(_Float32 __x, int *__exponent) noexcept(true);
extern _Float32 __frexpf32(_Float32 __x, int *__exponent) noexcept(true);
extern _Float32 ldexpf32(_Float32 __x, int __exponent) noexcept(true);
extern _Float32 __ldexpf32(_Float32 __x, int __exponent) noexcept(true);
extern _Float32 logf32(_Float32 __x) noexcept(true);
extern _Float32 __logf32(_Float32 __x) noexcept(true);
extern _Float32 log10f32(_Float32 __x) noexcept(true);
extern _Float32 __log10f32(_Float32 __x) noexcept(true);
extern _Float32 modff32(_Float32 __x, _Float32 *__iptr) noexcept(true);
extern _Float32 __modff32(_Float32 __x, _Float32 *__iptr) noexcept(true)
	__attribute((__nonnull__(2)));
extern _Float32 exp10f32(_Float32 __x) noexcept(true);
extern _Float32 __exp10f32(_Float32 __x) noexcept(true);
extern _Float32 expm1f32(_Float32 __x) noexcept(true);
extern _Float32 __expm1f32(_Float32 __x) noexcept(true);
extern _Float32 log1pf32(_Float32 __x) noexcept(true);
extern _Float32 __log1pf32(_Float32 __x) noexcept(true);
extern _Float32 logbf32(_Float32 __x) noexcept(true);
extern _Float32 __logbf32(_Float32 __x) noexcept(true);
extern _Float32 exp2f32(_Float32 __x) noexcept(true);
extern _Float32 __exp2f32(_Float32 __x) noexcept(true);
extern _Float32 log2f32(_Float32 __x) noexcept(true);
extern _Float32 __log2f32(_Float32 __x) noexcept(true);
extern _Float32 powf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 __powf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 sqrtf32(_Float32 __x) noexcept(true);
extern _Float32 __sqrtf32(_Float32 __x) noexcept(true);
extern _Float32 hypotf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 __hypotf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 cbrtf32(_Float32 __x) noexcept(true);
extern _Float32 __cbrtf32(_Float32 __x) noexcept(true);
extern _Float32 ceilf32(_Float32 __x) noexcept(true) __attribute((const));
extern _Float32 __ceilf32(_Float32 __x) noexcept(true) __attribute((const));
extern _Float32 fabsf32(_Float32 __x) noexcept(true) __attribute((const));
extern _Float32 __fabsf32(_Float32 __x) noexcept(true) __attribute((const));
extern _Float32 floorf32(_Float32 __x) noexcept(true) __attribute((const));
extern _Float32 __floorf32(_Float32 __x) noexcept(true) __attribute((const));
extern _Float32 fmodf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 __fmodf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 copysignf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 __copysignf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 nanf32(const char *__tagb) noexcept(true);
extern _Float32 __nanf32(const char *__tagb) noexcept(true);
extern _Float32 j0f32(_Float32) noexcept(true);
extern _Float32 __j0f32(_Float32) noexcept(true);
extern _Float32 j1f32(_Float32) noexcept(true);
extern _Float32 __j1f32(_Float32) noexcept(true);
extern _Float32 jnf32(int, _Float32) noexcept(true);
extern _Float32 __jnf32(int, _Float32) noexcept(true);
extern _Float32 y0f32(_Float32) noexcept(true);
extern _Float32 __y0f32(_Float32) noexcept(true);
extern _Float32 y1f32(_Float32) noexcept(true);
extern _Float32 __y1f32(_Float32) noexcept(true);
extern _Float32 ynf32(int, _Float32) noexcept(true);
extern _Float32 __ynf32(int, _Float32) noexcept(true);
extern _Float32 erff32(_Float32) noexcept(true);
extern _Float32 __erff32(_Float32) noexcept(true);
extern _Float32 erfcf32(_Float32) noexcept(true);
extern _Float32 __erfcf32(_Float32) noexcept(true);
extern _Float32 lgammaf32(_Float32) noexcept(true);
extern _Float32 __lgammaf32(_Float32) noexcept(true);
extern _Float32 tgammaf32(_Float32) noexcept(true);
extern _Float32 __tgammaf32(_Float32) noexcept(true);
extern _Float32 lgammaf32_r(_Float32, int *__signgamp) noexcept(true);
extern _Float32 __lgammaf32_r(_Float32, int *__signgamp) noexcept(true);
extern _Float32 rintf32(_Float32 __x) noexcept(true);
extern _Float32 __rintf32(_Float32 __x) noexcept(true);
extern _Float32 nextafterf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 __nextafterf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 nextdownf32(_Float32 __x) noexcept(true);
extern _Float32 __nextdownf32(_Float32 __x) noexcept(true);
extern _Float32 nextupf32(_Float32 __x) noexcept(true);
extern _Float32 __nextupf32(_Float32 __x) noexcept(true);
extern _Float32 remainderf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 __remainderf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 scalbnf32(_Float32 __x, int __n) noexcept(true);
extern _Float32 __scalbnf32(_Float32 __x, int __n) noexcept(true);
extern int ilogbf32(_Float32 __x) noexcept(true);
extern int __ilogbf32(_Float32 __x) noexcept(true);
extern long llogbf32(_Float32 __x) noexcept(true);
extern long __llogbf32(_Float32 __x) noexcept(true);
extern _Float32 scalblnf32(_Float32 __x, long __n) noexcept(true);
extern _Float32 __scalblnf32(_Float32 __x, long __n) noexcept(true);
extern _Float32 nearbyintf32(_Float32 __x) noexcept(true);
extern _Float32 __nearbyintf32(_Float32 __x) noexcept(true);
extern _Float32 roundf32(_Float32 __x) noexcept(true) __attribute((const));
extern _Float32 __roundf32(_Float32 __x) noexcept(true) __attribute((const));
extern _Float32 truncf32(_Float32 __x) noexcept(true) __attribute((const));
extern _Float32 __truncf32(_Float32 __x) noexcept(true) __attribute((const));
extern _Float32 remquof32(_Float32 __x, _Float32 __y,
			  int *__quo) noexcept(true);
extern _Float32 __remquof32(_Float32 __x, _Float32 __y,
			    int *__quo) noexcept(true);
extern long lrintf32(_Float32 __x) noexcept(true);
extern long __lrintf32(_Float32 __x) noexcept(true);
__extension__ extern long long llrintf32(_Float32 __x) noexcept(true);
extern long long __llrintf32(_Float32 __x) noexcept(true);
extern long lroundf32(_Float32 __x) noexcept(true);
extern long __lroundf32(_Float32 __x) noexcept(true);
__extension__ extern long long llroundf32(_Float32 __x) noexcept(true);
extern long long __llroundf32(_Float32 __x) noexcept(true);
extern _Float32 fdimf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 __fdimf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 fmaxf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 __fmaxf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 fminf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 __fminf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 fmaf32(_Float32 __x, _Float32 __y, _Float32 __z) noexcept(true);
extern _Float32 __fmaf32(_Float32 __x, _Float32 __y,
			 _Float32 __z) noexcept(true);
extern _Float32 roundevenf32(_Float32 __x) noexcept(true) __attribute((const));
extern _Float32 __roundevenf32(_Float32 __x) noexcept(true)
	__attribute((const));
extern __intmax_t fromfpf32(_Float32 __x, int __round,
			    unsigned __width) noexcept(true);
extern __intmax_t __fromfpf32(_Float32 __x, int __round,
			      unsigned __width) noexcept(true);
extern __uintmax_t ufromfpf32(_Float32 __x, int __round,
			      unsigned __width) noexcept(true);
extern __uintmax_t __ufromfpf32(_Float32 __x, int __round,
				unsigned __width) noexcept(true);
extern __intmax_t fromfpxf32(_Float32 __x, int __round,
			     unsigned __width) noexcept(true);
extern __intmax_t __fromfpxf32(_Float32 __x, int __round,
			       unsigned __width) noexcept(true);
extern __uintmax_t ufromfpxf32(_Float32 __x, int __round,
			       unsigned __width) noexcept(true);
extern __uintmax_t __ufromfpxf32(_Float32 __x, int __round,
				 unsigned __width) noexcept(true);
extern int canonicalizef32(_Float32 *__cx, const _Float32 *__x) noexcept(true);
extern _Float32 fmaxmagf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 __fmaxmagf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 fminmagf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 __fminmagf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 fmaximumf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 __fmaximumf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 fminimumf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 __fminimumf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 fmaximum_numf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 __fmaximum_numf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 fminimum_numf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 __fminimum_numf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 fmaximum_magf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 __fmaximum_magf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 fminimum_magf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 __fminimum_magf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 fmaximum_mag_numf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 __fmaximum_mag_numf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 fminimum_mag_numf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern _Float32 __fminimum_mag_numf32(_Float32 __x, _Float32 __y) noexcept(true)
	__attribute((const));
extern int totalorderf32(const _Float32 *__x,
			 const _Float32 *__y) noexcept(true)
	__attribute((__pure__));
extern int totalordermagf32(const _Float32 *__x,
			    const _Float32 *__y) noexcept(true)
	__attribute((__pure__));
extern _Float32 getpayloadf32(const _Float32 *__x) noexcept(true);
extern _Float32 __getpayloadf32(const _Float32 *__x) noexcept(true);
extern int setpayloadf32(_Float32 *__x, _Float32 __payload) noexcept(true);
extern int setpayloadsigf32(_Float32 *__x, _Float32 __payload) noexcept(true);
extern _Float64 acosf64(_Float64 __x) noexcept(true);
extern _Float64 __acosf64(_Float64 __x) noexcept(true);
extern _Float64 asinf64(_Float64 __x) noexcept(true);
extern _Float64 __asinf64(_Float64 __x) noexcept(true);
extern _Float64 atanf64(_Float64 __x) noexcept(true);
extern _Float64 __atanf64(_Float64 __x) noexcept(true);
extern _Float64 atan2f64(_Float64 __y, _Float64 __x) noexcept(true);
extern _Float64 __atan2f64(_Float64 __y, _Float64 __x) noexcept(true);
extern _Float64 cosf64(_Float64 __x) noexcept(true);
extern _Float64 __cosf64(_Float64 __x) noexcept(true);
extern _Float64 sinf64(_Float64 __x) noexcept(true);
extern _Float64 __sinf64(_Float64 __x) noexcept(true);
extern _Float64 tanf64(_Float64 __x) noexcept(true);
extern _Float64 __tanf64(_Float64 __x) noexcept(true);
extern _Float64 coshf64(_Float64 __x) noexcept(true);
extern _Float64 __coshf64(_Float64 __x) noexcept(true);
extern _Float64 sinhf64(_Float64 __x) noexcept(true);
extern _Float64 __sinhf64(_Float64 __x) noexcept(true);
extern _Float64 tanhf64(_Float64 __x) noexcept(true);
extern _Float64 __tanhf64(_Float64 __x) noexcept(true);
extern void sincosf64(_Float64 __x, _Float64 *__sinx,
		      _Float64 *__cosx) noexcept(true);
extern void __sincosf64(_Float64 __x, _Float64 *__sinx,
			_Float64 *__cosx) noexcept(true);
extern _Float64 acoshf64(_Float64 __x) noexcept(true);
extern _Float64 __acoshf64(_Float64 __x) noexcept(true);
extern _Float64 asinhf64(_Float64 __x) noexcept(true);
extern _Float64 __asinhf64(_Float64 __x) noexcept(true);
extern _Float64 atanhf64(_Float64 __x) noexcept(true);
extern _Float64 __atanhf64(_Float64 __x) noexcept(true);
extern _Float64 expf64(_Float64 __x) noexcept(true);
extern _Float64 __expf64(_Float64 __x) noexcept(true);
extern _Float64 frexpf64(_Float64 __x, int *__exponent) noexcept(true);
extern _Float64 __frexpf64(_Float64 __x, int *__exponent) noexcept(true);
extern _Float64 ldexpf64(_Float64 __x, int __exponent) noexcept(true);
extern _Float64 __ldexpf64(_Float64 __x, int __exponent) noexcept(true);
extern _Float64 logf64(_Float64 __x) noexcept(true);
extern _Float64 __logf64(_Float64 __x) noexcept(true);
extern _Float64 log10f64(_Float64 __x) noexcept(true);
extern _Float64 __log10f64(_Float64 __x) noexcept(true);
extern _Float64 modff64(_Float64 __x, _Float64 *__iptr) noexcept(true);
extern _Float64 __modff64(_Float64 __x, _Float64 *__iptr) noexcept(true)
	__attribute((__nonnull__(2)));
extern _Float64 exp10f64(_Float64 __x) noexcept(true);
extern _Float64 __exp10f64(_Float64 __x) noexcept(true);
extern _Float64 expm1f64(_Float64 __x) noexcept(true);
extern _Float64 __expm1f64(_Float64 __x) noexcept(true);
extern _Float64 log1pf64(_Float64 __x) noexcept(true);
extern _Float64 __log1pf64(_Float64 __x) noexcept(true);
extern _Float64 logbf64(_Float64 __x) noexcept(true);
extern _Float64 __logbf64(_Float64 __x) noexcept(true);
extern _Float64 exp2f64(_Float64 __x) noexcept(true);
extern _Float64 __exp2f64(_Float64 __x) noexcept(true);
extern _Float64 log2f64(_Float64 __x) noexcept(true);
extern _Float64 __log2f64(_Float64 __x) noexcept(true);
extern _Float64 powf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 __powf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 sqrtf64(_Float64 __x) noexcept(true);
extern _Float64 __sqrtf64(_Float64 __x) noexcept(true);
extern _Float64 hypotf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 __hypotf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 cbrtf64(_Float64 __x) noexcept(true);
extern _Float64 __cbrtf64(_Float64 __x) noexcept(true);
extern _Float64 ceilf64(_Float64 __x) noexcept(true) __attribute((const));
extern _Float64 __ceilf64(_Float64 __x) noexcept(true) __attribute((const));
extern _Float64 fabsf64(_Float64 __x) noexcept(true) __attribute((const));
extern _Float64 __fabsf64(_Float64 __x) noexcept(true) __attribute((const));
extern _Float64 floorf64(_Float64 __x) noexcept(true) __attribute((const));
extern _Float64 __floorf64(_Float64 __x) noexcept(true) __attribute((const));
extern _Float64 fmodf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 __fmodf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 copysignf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 __copysignf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 nanf64(const char *__tagb) noexcept(true);
extern _Float64 __nanf64(const char *__tagb) noexcept(true);
extern _Float64 j0f64(_Float64) noexcept(true);
extern _Float64 __j0f64(_Float64) noexcept(true);
extern _Float64 j1f64(_Float64) noexcept(true);
extern _Float64 __j1f64(_Float64) noexcept(true);
extern _Float64 jnf64(int, _Float64) noexcept(true);
extern _Float64 __jnf64(int, _Float64) noexcept(true);
extern _Float64 y0f64(_Float64) noexcept(true);
extern _Float64 __y0f64(_Float64) noexcept(true);
extern _Float64 y1f64(_Float64) noexcept(true);
extern _Float64 __y1f64(_Float64) noexcept(true);
extern _Float64 ynf64(int, _Float64) noexcept(true);
extern _Float64 __ynf64(int, _Float64) noexcept(true);
extern _Float64 erff64(_Float64) noexcept(true);
extern _Float64 __erff64(_Float64) noexcept(true);
extern _Float64 erfcf64(_Float64) noexcept(true);
extern _Float64 __erfcf64(_Float64) noexcept(true);
extern _Float64 lgammaf64(_Float64) noexcept(true);
extern _Float64 __lgammaf64(_Float64) noexcept(true);
extern _Float64 tgammaf64(_Float64) noexcept(true);
extern _Float64 __tgammaf64(_Float64) noexcept(true);
extern _Float64 lgammaf64_r(_Float64, int *__signgamp) noexcept(true);
extern _Float64 __lgammaf64_r(_Float64, int *__signgamp) noexcept(true);
extern _Float64 rintf64(_Float64 __x) noexcept(true);
extern _Float64 __rintf64(_Float64 __x) noexcept(true);
extern _Float64 nextafterf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 __nextafterf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 nextdownf64(_Float64 __x) noexcept(true);
extern _Float64 __nextdownf64(_Float64 __x) noexcept(true);
extern _Float64 nextupf64(_Float64 __x) noexcept(true);
extern _Float64 __nextupf64(_Float64 __x) noexcept(true);
extern _Float64 remainderf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 __remainderf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 scalbnf64(_Float64 __x, int __n) noexcept(true);
extern _Float64 __scalbnf64(_Float64 __x, int __n) noexcept(true);
extern int ilogbf64(_Float64 __x) noexcept(true);
extern int __ilogbf64(_Float64 __x) noexcept(true);
extern long llogbf64(_Float64 __x) noexcept(true);
extern long __llogbf64(_Float64 __x) noexcept(true);
extern _Float64 scalblnf64(_Float64 __x, long __n) noexcept(true);
extern _Float64 __scalblnf64(_Float64 __x, long __n) noexcept(true);
extern _Float64 nearbyintf64(_Float64 __x) noexcept(true);
extern _Float64 __nearbyintf64(_Float64 __x) noexcept(true);
extern _Float64 roundf64(_Float64 __x) noexcept(true) __attribute((const));
extern _Float64 __roundf64(_Float64 __x) noexcept(true) __attribute((const));
extern _Float64 truncf64(_Float64 __x) noexcept(true) __attribute((const));
extern _Float64 __truncf64(_Float64 __x) noexcept(true) __attribute((const));
extern _Float64 remquof64(_Float64 __x, _Float64 __y,
			  int *__quo) noexcept(true);
extern _Float64 __remquof64(_Float64 __x, _Float64 __y,
			    int *__quo) noexcept(true);
extern long lrintf64(_Float64 __x) noexcept(true);
extern long __lrintf64(_Float64 __x) noexcept(true);
__extension__ extern long long llrintf64(_Float64 __x) noexcept(true);
extern long long __llrintf64(_Float64 __x) noexcept(true);
extern long lroundf64(_Float64 __x) noexcept(true);
extern long __lroundf64(_Float64 __x) noexcept(true);
__extension__ extern long long llroundf64(_Float64 __x) noexcept(true);
extern long long __llroundf64(_Float64 __x) noexcept(true);
extern _Float64 fdimf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 __fdimf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 fmaxf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 __fmaxf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 fminf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 __fminf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 fmaf64(_Float64 __x, _Float64 __y, _Float64 __z) noexcept(true);
extern _Float64 __fmaf64(_Float64 __x, _Float64 __y,
			 _Float64 __z) noexcept(true);
extern _Float64 roundevenf64(_Float64 __x) noexcept(true) __attribute((const));
extern _Float64 __roundevenf64(_Float64 __x) noexcept(true)
	__attribute((const));
extern __intmax_t fromfpf64(_Float64 __x, int __round,
			    unsigned __width) noexcept(true);
extern __intmax_t __fromfpf64(_Float64 __x, int __round,
			      unsigned __width) noexcept(true);
extern __uintmax_t ufromfpf64(_Float64 __x, int __round,
			      unsigned __width) noexcept(true);
extern __uintmax_t __ufromfpf64(_Float64 __x, int __round,
				unsigned __width) noexcept(true);
extern __intmax_t fromfpxf64(_Float64 __x, int __round,
			     unsigned __width) noexcept(true);
extern __intmax_t __fromfpxf64(_Float64 __x, int __round,
			       unsigned __width) noexcept(true);
extern __uintmax_t ufromfpxf64(_Float64 __x, int __round,
			       unsigned __width) noexcept(true);
extern __uintmax_t __ufromfpxf64(_Float64 __x, int __round,
				 unsigned __width) noexcept(true);
extern int canonicalizef64(_Float64 *__cx, const _Float64 *__x) noexcept(true);
extern _Float64 fmaxmagf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 __fmaxmagf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 fminmagf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 __fminmagf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 fmaximumf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 __fmaximumf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 fminimumf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 __fminimumf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 fmaximum_numf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 __fmaximum_numf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 fminimum_numf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 __fminimum_numf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 fmaximum_magf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 __fmaximum_magf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 fminimum_magf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 __fminimum_magf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 fmaximum_mag_numf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 __fmaximum_mag_numf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 fminimum_mag_numf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern _Float64 __fminimum_mag_numf64(_Float64 __x, _Float64 __y) noexcept(true)
	__attribute((const));
extern int totalorderf64(const _Float64 *__x,
			 const _Float64 *__y) noexcept(true)
	__attribute((__pure__));
extern int totalordermagf64(const _Float64 *__x,
			    const _Float64 *__y) noexcept(true)
	__attribute((__pure__));
extern _Float64 getpayloadf64(const _Float64 *__x) noexcept(true);
extern _Float64 __getpayloadf64(const _Float64 *__x) noexcept(true);
extern int setpayloadf64(_Float64 *__x, _Float64 __payload) noexcept(true);
extern int setpayloadsigf64(_Float64 *__x, _Float64 __payload) noexcept(true);
extern _Float32x acosf32x(_Float32x __x) noexcept(true);
extern _Float32x __acosf32x(_Float32x __x) noexcept(true);
extern _Float32x asinf32x(_Float32x __x) noexcept(true);
extern _Float32x __asinf32x(_Float32x __x) noexcept(true);
extern _Float32x atanf32x(_Float32x __x) noexcept(true);
extern _Float32x __atanf32x(_Float32x __x) noexcept(true);
extern _Float32x atan2f32x(_Float32x __y, _Float32x __x) noexcept(true);
extern _Float32x __atan2f32x(_Float32x __y, _Float32x __x) noexcept(true);
extern _Float32x cosf32x(_Float32x __x) noexcept(true);
extern _Float32x __cosf32x(_Float32x __x) noexcept(true);
extern _Float32x sinf32x(_Float32x __x) noexcept(true);
extern _Float32x __sinf32x(_Float32x __x) noexcept(true);
extern _Float32x tanf32x(_Float32x __x) noexcept(true);
extern _Float32x __tanf32x(_Float32x __x) noexcept(true);
extern _Float32x coshf32x(_Float32x __x) noexcept(true);
extern _Float32x __coshf32x(_Float32x __x) noexcept(true);
extern _Float32x sinhf32x(_Float32x __x) noexcept(true);
extern _Float32x __sinhf32x(_Float32x __x) noexcept(true);
extern _Float32x tanhf32x(_Float32x __x) noexcept(true);
extern _Float32x __tanhf32x(_Float32x __x) noexcept(true);
extern void sincosf32x(_Float32x __x, _Float32x *__sinx,
		       _Float32x *__cosx) noexcept(true);
extern void __sincosf32x(_Float32x __x, _Float32x *__sinx,
			 _Float32x *__cosx) noexcept(true);
extern _Float32x acoshf32x(_Float32x __x) noexcept(true);
extern _Float32x __acoshf32x(_Float32x __x) noexcept(true);
extern _Float32x asinhf32x(_Float32x __x) noexcept(true);
extern _Float32x __asinhf32x(_Float32x __x) noexcept(true);
extern _Float32x atanhf32x(_Float32x __x) noexcept(true);
extern _Float32x __atanhf32x(_Float32x __x) noexcept(true);
extern _Float32x expf32x(_Float32x __x) noexcept(true);
extern _Float32x __expf32x(_Float32x __x) noexcept(true);
extern _Float32x frexpf32x(_Float32x __x, int *__exponent) noexcept(true);
extern _Float32x __frexpf32x(_Float32x __x, int *__exponent) noexcept(true);
extern _Float32x ldexpf32x(_Float32x __x, int __exponent) noexcept(true);
extern _Float32x __ldexpf32x(_Float32x __x, int __exponent) noexcept(true);
extern _Float32x logf32x(_Float32x __x) noexcept(true);
extern _Float32x __logf32x(_Float32x __x) noexcept(true);
extern _Float32x log10f32x(_Float32x __x) noexcept(true);
extern _Float32x __log10f32x(_Float32x __x) noexcept(true);
extern _Float32x modff32x(_Float32x __x, _Float32x *__iptr) noexcept(true);
extern _Float32x __modff32x(_Float32x __x, _Float32x *__iptr) noexcept(true)
	__attribute((__nonnull__(2)));
extern _Float32x exp10f32x(_Float32x __x) noexcept(true);
extern _Float32x __exp10f32x(_Float32x __x) noexcept(true);
extern _Float32x expm1f32x(_Float32x __x) noexcept(true);
extern _Float32x __expm1f32x(_Float32x __x) noexcept(true);
extern _Float32x log1pf32x(_Float32x __x) noexcept(true);
extern _Float32x __log1pf32x(_Float32x __x) noexcept(true);
extern _Float32x logbf32x(_Float32x __x) noexcept(true);
extern _Float32x __logbf32x(_Float32x __x) noexcept(true);
extern _Float32x exp2f32x(_Float32x __x) noexcept(true);
extern _Float32x __exp2f32x(_Float32x __x) noexcept(true);
extern _Float32x log2f32x(_Float32x __x) noexcept(true);
extern _Float32x __log2f32x(_Float32x __x) noexcept(true);
extern _Float32x powf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x __powf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x sqrtf32x(_Float32x __x) noexcept(true);
extern _Float32x __sqrtf32x(_Float32x __x) noexcept(true);
extern _Float32x hypotf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x __hypotf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x cbrtf32x(_Float32x __x) noexcept(true);
extern _Float32x __cbrtf32x(_Float32x __x) noexcept(true);
extern _Float32x ceilf32x(_Float32x __x) noexcept(true) __attribute((const));
extern _Float32x __ceilf32x(_Float32x __x) noexcept(true) __attribute((const));
extern _Float32x fabsf32x(_Float32x __x) noexcept(true) __attribute((const));
extern _Float32x __fabsf32x(_Float32x __x) noexcept(true) __attribute((const));
extern _Float32x floorf32x(_Float32x __x) noexcept(true) __attribute((const));
extern _Float32x __floorf32x(_Float32x __x) noexcept(true) __attribute((const));
extern _Float32x fmodf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x __fmodf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x copysignf32x(_Float32x __x, _Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x __copysignf32x(_Float32x __x, _Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x nanf32x(const char *__tagb) noexcept(true);
extern _Float32x __nanf32x(const char *__tagb) noexcept(true);
extern _Float32x j0f32x(_Float32x) noexcept(true);
extern _Float32x __j0f32x(_Float32x) noexcept(true);
extern _Float32x j1f32x(_Float32x) noexcept(true);
extern _Float32x __j1f32x(_Float32x) noexcept(true);
extern _Float32x jnf32x(int, _Float32x) noexcept(true);
extern _Float32x __jnf32x(int, _Float32x) noexcept(true);
extern _Float32x y0f32x(_Float32x) noexcept(true);
extern _Float32x __y0f32x(_Float32x) noexcept(true);
extern _Float32x y1f32x(_Float32x) noexcept(true);
extern _Float32x __y1f32x(_Float32x) noexcept(true);
extern _Float32x ynf32x(int, _Float32x) noexcept(true);
extern _Float32x __ynf32x(int, _Float32x) noexcept(true);
extern _Float32x erff32x(_Float32x) noexcept(true);
extern _Float32x __erff32x(_Float32x) noexcept(true);
extern _Float32x erfcf32x(_Float32x) noexcept(true);
extern _Float32x __erfcf32x(_Float32x) noexcept(true);
extern _Float32x lgammaf32x(_Float32x) noexcept(true);
extern _Float32x __lgammaf32x(_Float32x) noexcept(true);
extern _Float32x tgammaf32x(_Float32x) noexcept(true);
extern _Float32x __tgammaf32x(_Float32x) noexcept(true);
extern _Float32x lgammaf32x_r(_Float32x, int *__signgamp) noexcept(true);
extern _Float32x __lgammaf32x_r(_Float32x, int *__signgamp) noexcept(true);
extern _Float32x rintf32x(_Float32x __x) noexcept(true);
extern _Float32x __rintf32x(_Float32x __x) noexcept(true);
extern _Float32x nextafterf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x __nextafterf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x nextdownf32x(_Float32x __x) noexcept(true);
extern _Float32x __nextdownf32x(_Float32x __x) noexcept(true);
extern _Float32x nextupf32x(_Float32x __x) noexcept(true);
extern _Float32x __nextupf32x(_Float32x __x) noexcept(true);
extern _Float32x remainderf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x __remainderf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x scalbnf32x(_Float32x __x, int __n) noexcept(true);
extern _Float32x __scalbnf32x(_Float32x __x, int __n) noexcept(true);
extern int ilogbf32x(_Float32x __x) noexcept(true);
extern int __ilogbf32x(_Float32x __x) noexcept(true);
extern long llogbf32x(_Float32x __x) noexcept(true);
extern long __llogbf32x(_Float32x __x) noexcept(true);
extern _Float32x scalblnf32x(_Float32x __x, long __n) noexcept(true);
extern _Float32x __scalblnf32x(_Float32x __x, long __n) noexcept(true);
extern _Float32x nearbyintf32x(_Float32x __x) noexcept(true);
extern _Float32x __nearbyintf32x(_Float32x __x) noexcept(true);
extern _Float32x roundf32x(_Float32x __x) noexcept(true) __attribute((const));
extern _Float32x __roundf32x(_Float32x __x) noexcept(true) __attribute((const));
extern _Float32x truncf32x(_Float32x __x) noexcept(true) __attribute((const));
extern _Float32x __truncf32x(_Float32x __x) noexcept(true) __attribute((const));
extern _Float32x remquof32x(_Float32x __x, _Float32x __y,
			    int *__quo) noexcept(true);
extern _Float32x __remquof32x(_Float32x __x, _Float32x __y,
			      int *__quo) noexcept(true);
extern long lrintf32x(_Float32x __x) noexcept(true);
extern long __lrintf32x(_Float32x __x) noexcept(true);
__extension__ extern long long llrintf32x(_Float32x __x) noexcept(true);
extern long long __llrintf32x(_Float32x __x) noexcept(true);
extern long lroundf32x(_Float32x __x) noexcept(true);
extern long __lroundf32x(_Float32x __x) noexcept(true);
__extension__ extern long long llroundf32x(_Float32x __x) noexcept(true);
extern long long __llroundf32x(_Float32x __x) noexcept(true);
extern _Float32x fdimf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x __fdimf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x fmaxf32x(_Float32x __x, _Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x __fmaxf32x(_Float32x __x, _Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x fminf32x(_Float32x __x, _Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x __fminf32x(_Float32x __x, _Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x fmaf32x(_Float32x __x, _Float32x __y,
			 _Float32x __z) noexcept(true);
extern _Float32x __fmaf32x(_Float32x __x, _Float32x __y,
			   _Float32x __z) noexcept(true);
extern _Float32x roundevenf32x(_Float32x __x) noexcept(true)
	__attribute((const));
extern _Float32x __roundevenf32x(_Float32x __x) noexcept(true)
	__attribute((const));
extern __intmax_t fromfpf32x(_Float32x __x, int __round,
			     unsigned __width) noexcept(true);
extern __intmax_t __fromfpf32x(_Float32x __x, int __round,
			       unsigned __width) noexcept(true);
extern __uintmax_t ufromfpf32x(_Float32x __x, int __round,
			       unsigned __width) noexcept(true);
extern __uintmax_t __ufromfpf32x(_Float32x __x, int __round,
				 unsigned __width) noexcept(true);
extern __intmax_t fromfpxf32x(_Float32x __x, int __round,
			      unsigned __width) noexcept(true);
extern __intmax_t __fromfpxf32x(_Float32x __x, int __round,
				unsigned __width) noexcept(true);
extern __uintmax_t ufromfpxf32x(_Float32x __x, int __round,
				unsigned __width) noexcept(true);
extern __uintmax_t __ufromfpxf32x(_Float32x __x, int __round,
				  unsigned __width) noexcept(true);
extern int canonicalizef32x(_Float32x *__cx,
			    const _Float32x *__x) noexcept(true);
extern _Float32x fmaxmagf32x(_Float32x __x, _Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x __fmaxmagf32x(_Float32x __x, _Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x fminmagf32x(_Float32x __x, _Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x __fminmagf32x(_Float32x __x, _Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x fmaximumf32x(_Float32x __x, _Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x __fmaximumf32x(_Float32x __x, _Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x fminimumf32x(_Float32x __x, _Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x __fminimumf32x(_Float32x __x, _Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x fmaximum_numf32x(_Float32x __x, _Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x __fmaximum_numf32x(_Float32x __x, _Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x fminimum_numf32x(_Float32x __x, _Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x __fminimum_numf32x(_Float32x __x, _Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x fmaximum_magf32x(_Float32x __x, _Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x __fmaximum_magf32x(_Float32x __x, _Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x fminimum_magf32x(_Float32x __x, _Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x __fminimum_magf32x(_Float32x __x, _Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x fmaximum_mag_numf32x(_Float32x __x,
				      _Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x __fmaximum_mag_numf32x(_Float32x __x,
					_Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x fminimum_mag_numf32x(_Float32x __x,
				      _Float32x __y) noexcept(true)
	__attribute((const));
extern _Float32x __fminimum_mag_numf32x(_Float32x __x,
					_Float32x __y) noexcept(true)
	__attribute((const));
extern int totalorderf32x(const _Float32x *__x,
			  const _Float32x *__y) noexcept(true)
	__attribute((__pure__));
extern int totalordermagf32x(const _Float32x *__x,
			     const _Float32x *__y) noexcept(true)
	__attribute((__pure__));
extern _Float32x getpayloadf32x(const _Float32x *__x) noexcept(true);
extern _Float32x __getpayloadf32x(const _Float32x *__x) noexcept(true);
extern int setpayloadf32x(_Float32x *__x, _Float32x __payload) noexcept(true);
extern int setpayloadsigf32x(_Float32x *__x,
			     _Float32x __payload) noexcept(true);
extern _Float64x acosf64x(_Float64x __x) noexcept(true);
extern _Float64x __acosf64x(_Float64x __x) noexcept(true);
extern _Float64x asinf64x(_Float64x __x) noexcept(true);
extern _Float64x __asinf64x(_Float64x __x) noexcept(true);
extern _Float64x atanf64x(_Float64x __x) noexcept(true);
extern _Float64x __atanf64x(_Float64x __x) noexcept(true);
extern _Float64x atan2f64x(_Float64x __y, _Float64x __x) noexcept(true);
extern _Float64x __atan2f64x(_Float64x __y, _Float64x __x) noexcept(true);
extern _Float64x cosf64x(_Float64x __x) noexcept(true);
extern _Float64x __cosf64x(_Float64x __x) noexcept(true);
extern _Float64x sinf64x(_Float64x __x) noexcept(true);
extern _Float64x __sinf64x(_Float64x __x) noexcept(true);
extern _Float64x tanf64x(_Float64x __x) noexcept(true);
extern _Float64x __tanf64x(_Float64x __x) noexcept(true);
extern _Float64x coshf64x(_Float64x __x) noexcept(true);
extern _Float64x __coshf64x(_Float64x __x) noexcept(true);
extern _Float64x sinhf64x(_Float64x __x) noexcept(true);
extern _Float64x __sinhf64x(_Float64x __x) noexcept(true);
extern _Float64x tanhf64x(_Float64x __x) noexcept(true);
extern _Float64x __tanhf64x(_Float64x __x) noexcept(true);
extern void sincosf64x(_Float64x __x, _Float64x *__sinx,
		       _Float64x *__cosx) noexcept(true);
extern void __sincosf64x(_Float64x __x, _Float64x *__sinx,
			 _Float64x *__cosx) noexcept(true);
extern _Float64x acoshf64x(_Float64x __x) noexcept(true);
extern _Float64x __acoshf64x(_Float64x __x) noexcept(true);
extern _Float64x asinhf64x(_Float64x __x) noexcept(true);
extern _Float64x __asinhf64x(_Float64x __x) noexcept(true);
extern _Float64x atanhf64x(_Float64x __x) noexcept(true);
extern _Float64x __atanhf64x(_Float64x __x) noexcept(true);
extern _Float64x expf64x(_Float64x __x) noexcept(true);
extern _Float64x __expf64x(_Float64x __x) noexcept(true);
extern _Float64x frexpf64x(_Float64x __x, int *__exponent) noexcept(true);
extern _Float64x __frexpf64x(_Float64x __x, int *__exponent) noexcept(true);
extern _Float64x ldexpf64x(_Float64x __x, int __exponent) noexcept(true);
extern _Float64x __ldexpf64x(_Float64x __x, int __exponent) noexcept(true);
extern _Float64x logf64x(_Float64x __x) noexcept(true);
extern _Float64x __logf64x(_Float64x __x) noexcept(true);
extern _Float64x log10f64x(_Float64x __x) noexcept(true);
extern _Float64x __log10f64x(_Float64x __x) noexcept(true);
extern _Float64x modff64x(_Float64x __x, _Float64x *__iptr) noexcept(true);
extern _Float64x __modff64x(_Float64x __x, _Float64x *__iptr) noexcept(true)
	__attribute((__nonnull__(2)));
extern _Float64x exp10f64x(_Float64x __x) noexcept(true);
extern _Float64x __exp10f64x(_Float64x __x) noexcept(true);
extern _Float64x expm1f64x(_Float64x __x) noexcept(true);
extern _Float64x __expm1f64x(_Float64x __x) noexcept(true);
extern _Float64x log1pf64x(_Float64x __x) noexcept(true);
extern _Float64x __log1pf64x(_Float64x __x) noexcept(true);
extern _Float64x logbf64x(_Float64x __x) noexcept(true);
extern _Float64x __logbf64x(_Float64x __x) noexcept(true);
extern _Float64x exp2f64x(_Float64x __x) noexcept(true);
extern _Float64x __exp2f64x(_Float64x __x) noexcept(true);
extern _Float64x log2f64x(_Float64x __x) noexcept(true);
extern _Float64x __log2f64x(_Float64x __x) noexcept(true);
extern _Float64x powf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x __powf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x sqrtf64x(_Float64x __x) noexcept(true);
extern _Float64x __sqrtf64x(_Float64x __x) noexcept(true);
extern _Float64x hypotf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x __hypotf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x cbrtf64x(_Float64x __x) noexcept(true);
extern _Float64x __cbrtf64x(_Float64x __x) noexcept(true);
extern _Float64x ceilf64x(_Float64x __x) noexcept(true) __attribute((const));
extern _Float64x __ceilf64x(_Float64x __x) noexcept(true) __attribute((const));
extern _Float64x fabsf64x(_Float64x __x) noexcept(true) __attribute((const));
extern _Float64x __fabsf64x(_Float64x __x) noexcept(true) __attribute((const));
extern _Float64x floorf64x(_Float64x __x) noexcept(true) __attribute((const));
extern _Float64x __floorf64x(_Float64x __x) noexcept(true) __attribute((const));
extern _Float64x fmodf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x __fmodf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x copysignf64x(_Float64x __x, _Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x __copysignf64x(_Float64x __x, _Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x nanf64x(const char *__tagb) noexcept(true);
extern _Float64x __nanf64x(const char *__tagb) noexcept(true);
extern _Float64x j0f64x(_Float64x) noexcept(true);
extern _Float64x __j0f64x(_Float64x) noexcept(true);
extern _Float64x j1f64x(_Float64x) noexcept(true);
extern _Float64x __j1f64x(_Float64x) noexcept(true);
extern _Float64x jnf64x(int, _Float64x) noexcept(true);
extern _Float64x __jnf64x(int, _Float64x) noexcept(true);
extern _Float64x y0f64x(_Float64x) noexcept(true);
extern _Float64x __y0f64x(_Float64x) noexcept(true);
extern _Float64x y1f64x(_Float64x) noexcept(true);
extern _Float64x __y1f64x(_Float64x) noexcept(true);
extern _Float64x ynf64x(int, _Float64x) noexcept(true);
extern _Float64x __ynf64x(int, _Float64x) noexcept(true);
extern _Float64x erff64x(_Float64x) noexcept(true);
extern _Float64x __erff64x(_Float64x) noexcept(true);
extern _Float64x erfcf64x(_Float64x) noexcept(true);
extern _Float64x __erfcf64x(_Float64x) noexcept(true);
extern _Float64x lgammaf64x(_Float64x) noexcept(true);
extern _Float64x __lgammaf64x(_Float64x) noexcept(true);
extern _Float64x tgammaf64x(_Float64x) noexcept(true);
extern _Float64x __tgammaf64x(_Float64x) noexcept(true);
extern _Float64x lgammaf64x_r(_Float64x, int *__signgamp) noexcept(true);
extern _Float64x __lgammaf64x_r(_Float64x, int *__signgamp) noexcept(true);
extern _Float64x rintf64x(_Float64x __x) noexcept(true);
extern _Float64x __rintf64x(_Float64x __x) noexcept(true);
extern _Float64x nextafterf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x __nextafterf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x nextdownf64x(_Float64x __x) noexcept(true);
extern _Float64x __nextdownf64x(_Float64x __x) noexcept(true);
extern _Float64x nextupf64x(_Float64x __x) noexcept(true);
extern _Float64x __nextupf64x(_Float64x __x) noexcept(true);
extern _Float64x remainderf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x __remainderf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x scalbnf64x(_Float64x __x, int __n) noexcept(true);
extern _Float64x __scalbnf64x(_Float64x __x, int __n) noexcept(true);
extern int ilogbf64x(_Float64x __x) noexcept(true);
extern int __ilogbf64x(_Float64x __x) noexcept(true);
extern long llogbf64x(_Float64x __x) noexcept(true);
extern long __llogbf64x(_Float64x __x) noexcept(true);
extern _Float64x scalblnf64x(_Float64x __x, long __n) noexcept(true);
extern _Float64x __scalblnf64x(_Float64x __x, long __n) noexcept(true);
extern _Float64x nearbyintf64x(_Float64x __x) noexcept(true);
extern _Float64x __nearbyintf64x(_Float64x __x) noexcept(true);
extern _Float64x roundf64x(_Float64x __x) noexcept(true) __attribute((const));
extern _Float64x __roundf64x(_Float64x __x) noexcept(true) __attribute((const));
extern _Float64x truncf64x(_Float64x __x) noexcept(true) __attribute((const));
extern _Float64x __truncf64x(_Float64x __x) noexcept(true) __attribute((const));
extern _Float64x remquof64x(_Float64x __x, _Float64x __y,
			    int *__quo) noexcept(true);
extern _Float64x __remquof64x(_Float64x __x, _Float64x __y,
			      int *__quo) noexcept(true);
extern long lrintf64x(_Float64x __x) noexcept(true);
extern long __lrintf64x(_Float64x __x) noexcept(true);
__extension__ extern long long llrintf64x(_Float64x __x) noexcept(true);
extern long long __llrintf64x(_Float64x __x) noexcept(true);
extern long lroundf64x(_Float64x __x) noexcept(true);
extern long __lroundf64x(_Float64x __x) noexcept(true);
__extension__ extern long long llroundf64x(_Float64x __x) noexcept(true);
extern long long __llroundf64x(_Float64x __x) noexcept(true);
extern _Float64x fdimf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x __fdimf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x fmaxf64x(_Float64x __x, _Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x __fmaxf64x(_Float64x __x, _Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x fminf64x(_Float64x __x, _Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x __fminf64x(_Float64x __x, _Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x fmaf64x(_Float64x __x, _Float64x __y,
			 _Float64x __z) noexcept(true);
extern _Float64x __fmaf64x(_Float64x __x, _Float64x __y,
			   _Float64x __z) noexcept(true);
extern _Float64x roundevenf64x(_Float64x __x) noexcept(true)
	__attribute((const));
extern _Float64x __roundevenf64x(_Float64x __x) noexcept(true)
	__attribute((const));
extern __intmax_t fromfpf64x(_Float64x __x, int __round,
			     unsigned __width) noexcept(true);
extern __intmax_t __fromfpf64x(_Float64x __x, int __round,
			       unsigned __width) noexcept(true);
extern __uintmax_t ufromfpf64x(_Float64x __x, int __round,
			       unsigned __width) noexcept(true);
extern __uintmax_t __ufromfpf64x(_Float64x __x, int __round,
				 unsigned __width) noexcept(true);
extern __intmax_t fromfpxf64x(_Float64x __x, int __round,
			      unsigned __width) noexcept(true);
extern __intmax_t __fromfpxf64x(_Float64x __x, int __round,
				unsigned __width) noexcept(true);
extern __uintmax_t ufromfpxf64x(_Float64x __x, int __round,
				unsigned __width) noexcept(true);
extern __uintmax_t __ufromfpxf64x(_Float64x __x, int __round,
				  unsigned __width) noexcept(true);
extern int canonicalizef64x(_Float64x *__cx,
			    const _Float64x *__x) noexcept(true);
extern _Float64x fmaxmagf64x(_Float64x __x, _Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x __fmaxmagf64x(_Float64x __x, _Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x fminmagf64x(_Float64x __x, _Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x __fminmagf64x(_Float64x __x, _Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x fmaximumf64x(_Float64x __x, _Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x __fmaximumf64x(_Float64x __x, _Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x fminimumf64x(_Float64x __x, _Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x __fminimumf64x(_Float64x __x, _Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x fmaximum_numf64x(_Float64x __x, _Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x __fmaximum_numf64x(_Float64x __x, _Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x fminimum_numf64x(_Float64x __x, _Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x __fminimum_numf64x(_Float64x __x, _Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x fmaximum_magf64x(_Float64x __x, _Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x __fmaximum_magf64x(_Float64x __x, _Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x fminimum_magf64x(_Float64x __x, _Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x __fminimum_magf64x(_Float64x __x, _Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x fmaximum_mag_numf64x(_Float64x __x,
				      _Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x __fmaximum_mag_numf64x(_Float64x __x,
					_Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x fminimum_mag_numf64x(_Float64x __x,
				      _Float64x __y) noexcept(true)
	__attribute((const));
extern _Float64x __fminimum_mag_numf64x(_Float64x __x,
					_Float64x __y) noexcept(true)
	__attribute((const));
extern int totalorderf64x(const _Float64x *__x,
			  const _Float64x *__y) noexcept(true)
	__attribute((__pure__));
extern int totalordermagf64x(const _Float64x *__x,
			     const _Float64x *__y) noexcept(true)
	__attribute((__pure__));
extern _Float64x getpayloadf64x(const _Float64x *__x) noexcept(true);
extern _Float64x __getpayloadf64x(const _Float64x *__x) noexcept(true);
extern int setpayloadf64x(_Float64x *__x, _Float64x __payload) noexcept(true);
extern int setpayloadsigf64x(_Float64x *__x,
			     _Float64x __payload) noexcept(true);
extern float fadd(double __x, double __y) noexcept(true);
extern float fdiv(double __x, double __y) noexcept(true);
extern float ffma(double __x, double __y, double __z) noexcept(true);
extern float fmul(double __x, double __y) noexcept(true);
extern float fsqrt(double __x) noexcept(true);
extern float fsub(double __x, double __y) noexcept(true);
extern float faddl(long double __x, long double __y) noexcept(true);
extern float fdivl(long double __x, long double __y) noexcept(true);
extern float ffmal(long double __x, long double __y,
		   long double __z) noexcept(true);
extern float fmull(long double __x, long double __y) noexcept(true);
extern float fsqrtl(long double __x) noexcept(true);
extern float fsubl(long double __x, long double __y) noexcept(true);
extern double daddl(long double __x, long double __y) noexcept(true);
extern double ddivl(long double __x, long double __y) noexcept(true);
extern double dfmal(long double __x, long double __y,
		    long double __z) noexcept(true);
extern double dmull(long double __x, long double __y) noexcept(true);
extern double dsqrtl(long double __x) noexcept(true);
extern double dsubl(long double __x, long double __y) noexcept(true);
extern _Float32 f32addf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32 f32divf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32 f32fmaf32x(_Float32x __x, _Float32x __y,
			   _Float32x __z) noexcept(true);
extern _Float32 f32mulf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32 f32sqrtf32x(_Float32x __x) noexcept(true);
extern _Float32 f32subf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32 f32addf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float32 f32divf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float32 f32fmaf64(_Float64 __x, _Float64 __y,
			  _Float64 __z) noexcept(true);
extern _Float32 f32mulf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float32 f32sqrtf64(_Float64 __x) noexcept(true);
extern _Float32 f32subf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float32 f32addf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float32 f32divf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float32 f32fmaf64x(_Float64x __x, _Float64x __y,
			   _Float64x __z) noexcept(true);
extern _Float32 f32mulf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float32 f32sqrtf64x(_Float64x __x) noexcept(true);
extern _Float32 f32subf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float32x f32xaddf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float32x f32xdivf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float32x f32xfmaf64(_Float64 __x, _Float64 __y,
			    _Float64 __z) noexcept(true);
extern _Float32x f32xmulf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float32x f32xsqrtf64(_Float64 __x) noexcept(true);
extern _Float32x f32xsubf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float32x f32xaddf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float32x f32xdivf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float32x f32xfmaf64x(_Float64x __x, _Float64x __y,
			     _Float64x __z) noexcept(true);
extern _Float32x f32xmulf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float32x f32xsqrtf64x(_Float64x __x) noexcept(true);
extern _Float32x f32xsubf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64 f64addf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64 f64divf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64 f64fmaf64x(_Float64x __x, _Float64x __y,
			   _Float64x __z) noexcept(true);
extern _Float64 f64mulf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64 f64sqrtf64x(_Float64x __x) noexcept(true);
extern _Float64 f64subf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern int signgam;
enum { FP_NAN, FP_INFINITE, FP_ZERO, FP_SUBNORMAL, FP_NORMAL };
extern int __iscanonicall(long double __x) noexcept(true) __attribute((const));
extern "C++" {
inline int iscanonical(float __val)
{
	return (((void)((__typeof__(__val))__val)), 1);
}
inline int iscanonical(double __val)
{
	return (((void)((__typeof__(__val))__val)), 1);
}
inline int iscanonical(long double __val)
{
	return __iscanonicall(__val);
}
}
extern "C++" {
inline int issignaling(float __val)
{
	return __issignalingf(__val);
}
inline int issignaling(double __val)
{
	return __issignaling(__val);
}
inline int issignaling(long double __val)
{
	return __issignalingl(__val);
}
}
extern "C++" {
template <class __T> inline bool iszero(__T __val)
{
	return __val == 0;
}
}
extern "C++" {
template <class> struct __iseqsig_type;
template <> struct __iseqsig_type<float> {
	static int __call(float __x, float __y) throw()
	{
		return __iseqsigf(__x, __y);
	}
};
template <> struct __iseqsig_type<double> {
	static int __call(double __x, double __y) throw()
	{
		return __iseqsig(__x, __y);
	}
};
template <> struct __iseqsig_type<long double> {
	static int __call(long double __x, long double __y) throw()
	{
		return __iseqsigl(__x, __y);
	}
};
template <class _T1, class _T2> inline int iseqsig(_T1 __x, _T2 __y) throw()
{
	typedef __decltype(((__x + __y) + (0.0F))) _T3;
	return __iseqsig_type<__decltype(((__x + __y) + (0.0F)))>::__call(__x,
									  __y);
}
}
}
extern "C++" {
namespace std __attribute((__visibility__("default")))
{
	using ::acos;
	constexpr float acos(float __x)
	{
		return __builtin_acosf(__x);
	}
	constexpr long double acos(long double __x)
	{
		return __builtin_acosl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	acos(_Tp __x)
	{
		return __builtin_acos(__x);
	}
	using ::asin;
	constexpr float asin(float __x)
	{
		return __builtin_asinf(__x);
	}
	constexpr long double asin(long double __x)
	{
		return __builtin_asinl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	asin(_Tp __x)
	{
		return __builtin_asin(__x);
	}
	using ::atan;
	constexpr float atan(float __x)
	{
		return __builtin_atanf(__x);
	}
	constexpr long double atan(long double __x)
	{
		return __builtin_atanl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	atan(_Tp __x)
	{
		return __builtin_atan(__x);
	}
	using ::atan2;
	constexpr float atan2(float __y, float __x)
	{
		return __builtin_atan2f(__y, __x);
	}
	constexpr long double atan2(long double __y, long double __x)
	{
		return __builtin_atan2l(__y, __x);
	}
	template <class _Tp, class _Up>
	constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type atan2(
		_Tp __y, _Up __x)
	{
		typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
		return atan2((__type)__y, (__type)__x);
	}
	using ::ceil;
	constexpr float ceil(float __x)
	{
		return __builtin_ceilf(__x);
	}
	constexpr long double ceil(long double __x)
	{
		return __builtin_ceill(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	ceil(_Tp __x)
	{
		return __builtin_ceil(__x);
	}
	using ::cos;
	constexpr float cos(float __x)
	{
		return __builtin_cosf(__x);
	}
	constexpr long double cos(long double __x)
	{
		return __builtin_cosl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	cos(_Tp __x)
	{
		return __builtin_cos(__x);
	}
	using ::cosh;
	constexpr float cosh(float __x)
	{
		return __builtin_coshf(__x);
	}
	constexpr long double cosh(long double __x)
	{
		return __builtin_coshl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	cosh(_Tp __x)
	{
		return __builtin_cosh(__x);
	}
	using ::exp;
	constexpr float exp(float __x)
	{
		return __builtin_expf(__x);
	}
	constexpr long double exp(long double __x)
	{
		return __builtin_expl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	exp(_Tp __x)
	{
		return __builtin_exp(__x);
	}
	using ::fabs;
	constexpr float fabs(float __x)
	{
		return __builtin_fabsf(__x);
	}
	constexpr long double fabs(long double __x)
	{
		return __builtin_fabsl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	fabs(_Tp __x)
	{
		return __builtin_fabs(__x);
	}
	using ::floor;
	constexpr float floor(float __x)
	{
		return __builtin_floorf(__x);
	}
	constexpr long double floor(long double __x)
	{
		return __builtin_floorl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	floor(_Tp __x)
	{
		return __builtin_floor(__x);
	}
	using ::fmod;
	constexpr float fmod(float __x, float __y)
	{
		return __builtin_fmodf(__x, __y);
	}
	constexpr long double fmod(long double __x, long double __y)
	{
		return __builtin_fmodl(__x, __y);
	}
	template <class _Tp, class _Up>
	constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type fmod(
		_Tp __x, _Up __y)
	{
		typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
		return fmod((__type)__x, (__type)__y);
	}
	using ::frexp;
	inline float frexp(float __x, int *__exp)
	{
		return __builtin_frexpf(__x, __exp);
	}
	inline long double frexp(long double __x, int *__exp)
	{
		return __builtin_frexpl(__x, __exp);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	frexp(_Tp __x, int *__exp)
	{
		return __builtin_frexp(__x, __exp);
	}
	using ::ldexp;
	constexpr float ldexp(float __x, int __exp)
	{
		return __builtin_ldexpf(__x, __exp);
	}
	constexpr long double ldexp(long double __x, int __exp)
	{
		return __builtin_ldexpl(__x, __exp);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	ldexp(_Tp __x, int __exp)
	{
		return __builtin_ldexp(__x, __exp);
	}
	using ::log;
	constexpr float log(float __x)
	{
		return __builtin_logf(__x);
	}
	constexpr long double log(long double __x)
	{
		return __builtin_logl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	log(_Tp __x)
	{
		return __builtin_log(__x);
	}
	using ::log10;
	constexpr float log10(float __x)
	{
		return __builtin_log10f(__x);
	}
	constexpr long double log10(long double __x)
	{
		return __builtin_log10l(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	log10(_Tp __x)
	{
		return __builtin_log10(__x);
	}
	using ::modf;
	inline float modf(float __x, float *__iptr)
	{
		return __builtin_modff(__x, __iptr);
	}
	inline long double modf(long double __x, long double *__iptr)
	{
		return __builtin_modfl(__x, __iptr);
	}
	using ::pow;
	constexpr float pow(float __x, float __y)
	{
		return __builtin_powf(__x, __y);
	}
	constexpr long double pow(long double __x, long double __y)
	{
		return __builtin_powl(__x, __y);
	}
	template <class _Tp, class _Up>
	constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type pow(_Tp __x,
									_Up __y)
	{
		typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
		return pow((__type)__x, (__type)__y);
	}
	using ::sin;
	constexpr float sin(float __x)
	{
		return __builtin_sinf(__x);
	}
	constexpr long double sin(long double __x)
	{
		return __builtin_sinl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	sin(_Tp __x)
	{
		return __builtin_sin(__x);
	}
	using ::sinh;
	constexpr float sinh(float __x)
	{
		return __builtin_sinhf(__x);
	}
	constexpr long double sinh(long double __x)
	{
		return __builtin_sinhl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	sinh(_Tp __x)
	{
		return __builtin_sinh(__x);
	}
	using ::sqrt;
	constexpr float sqrt(float __x)
	{
		return __builtin_sqrtf(__x);
	}
	constexpr long double sqrt(long double __x)
	{
		return __builtin_sqrtl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	sqrt(_Tp __x)
	{
		return __builtin_sqrt(__x);
	}
	using ::tan;
	constexpr float tan(float __x)
	{
		return __builtin_tanf(__x);
	}
	constexpr long double tan(long double __x)
	{
		return __builtin_tanl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	tan(_Tp __x)
	{
		return __builtin_tan(__x);
	}
	using ::tanh;
	constexpr float tanh(float __x)
	{
		return __builtin_tanhf(__x);
	}
	constexpr long double tanh(long double __x)
	{
		return __builtin_tanhl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	tanh(_Tp __x)
	{
		return __builtin_tanh(__x);
	}
	constexpr int fpclassify(float __x)
	{
		return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
	}
	constexpr int fpclassify(double __x)
	{
		return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
	}
	constexpr int fpclassify(long double __x)
	{
		return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  int>::__type
	fpclassify(_Tp __x)
	{
		return (__x != 0) ? 4 : 2;
	}
	constexpr bool isfinite(float __x)
	{
		return __builtin_isfinite(__x);
	}
	constexpr bool isfinite(double __x)
	{
		return __builtin_isfinite(__x);
	}
	constexpr bool isfinite(long double __x)
	{
		return __builtin_isfinite(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  bool>::__type
	isfinite(_Tp __x)
	{
		return true;
	}
	constexpr bool isinf(float __x)
	{
		return __builtin_isinf(__x);
	}
	constexpr bool isinf(double __x)
	{
		return __builtin_isinf(__x);
	}
	constexpr bool isinf(long double __x)
	{
		return __builtin_isinf(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  bool>::__type
	isinf(_Tp __x)
	{
		return false;
	}
	constexpr bool isnan(float __x)
	{
		return __builtin_isnan(__x);
	}
	constexpr bool isnan(double __x)
	{
		return __builtin_isnan(__x);
	}
	constexpr bool isnan(long double __x)
	{
		return __builtin_isnan(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  bool>::__type
	isnan(_Tp __x)
	{
		return false;
	}
	constexpr bool isnormal(float __x)
	{
		return __builtin_isnormal(__x);
	}
	constexpr bool isnormal(double __x)
	{
		return __builtin_isnormal(__x);
	}
	constexpr bool isnormal(long double __x)
	{
		return __builtin_isnormal(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  bool>::__type
	isnormal(_Tp __x)
	{
		return (__x != 0) ? true : false;
	}
	constexpr bool signbit(float __x)
	{
		return __builtin_signbit(__x);
	}
	constexpr bool signbit(double __x)
	{
		return __builtin_signbit(__x);
	}
	constexpr bool signbit(long double __x)
	{
		return __builtin_signbit(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  bool>::__type
	signbit(_Tp __x)
	{
		return (__x < 0) ? true : false;
	}
	constexpr bool isgreater(float __x, float __y)
	{
		return __builtin_isgreater(__x, __y);
	}
	constexpr bool isgreater(double __x, double __y)
	{
		return __builtin_isgreater(__x, __y);
	}
	constexpr bool isgreater(long double __x, long double __y)
	{
		return __builtin_isgreater(__x, __y);
	}
	template <class _Tp, class _Up>
	constexpr typename __gnu_cxx::__enable_if<
		__is_arithmetic<_Tp>::__value &&__is_arithmetic<_Up>::__value,
		bool>::__type
	isgreater(_Tp __x, _Up __y)
	{
		typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
		return __builtin_isgreater((__type)__x, (__type)__y);
	}
	constexpr bool isgreaterequal(float __x, float __y)
	{
		return __builtin_isgreaterequal(__x, __y);
	}
	constexpr bool isgreaterequal(double __x, double __y)
	{
		return __builtin_isgreaterequal(__x, __y);
	}
	constexpr bool isgreaterequal(long double __x, long double __y)
	{
		return __builtin_isgreaterequal(__x, __y);
	}
	template <class _Tp, class _Up>
	constexpr typename __gnu_cxx::__enable_if<
		__is_arithmetic<_Tp>::__value &&__is_arithmetic<_Up>::__value,
		bool>::__type
	isgreaterequal(_Tp __x, _Up __y)
	{
		typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
		return __builtin_isgreaterequal((__type)__x, (__type)__y);
	}
	constexpr bool isless(float __x, float __y)
	{
		return __builtin_isless(__x, __y);
	}
	constexpr bool isless(double __x, double __y)
	{
		return __builtin_isless(__x, __y);
	}
	constexpr bool isless(long double __x, long double __y)
	{
		return __builtin_isless(__x, __y);
	}
	template <class _Tp, class _Up>
	constexpr typename __gnu_cxx::__enable_if<
		__is_arithmetic<_Tp>::__value &&__is_arithmetic<_Up>::__value,
		bool>::__type
	isless(_Tp __x, _Up __y)
	{
		typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
		return __builtin_isless((__type)__x, (__type)__y);
	}
	constexpr bool islessequal(float __x, float __y)
	{
		return __builtin_islessequal(__x, __y);
	}
	constexpr bool islessequal(double __x, double __y)
	{
		return __builtin_islessequal(__x, __y);
	}
	constexpr bool islessequal(long double __x, long double __y)
	{
		return __builtin_islessequal(__x, __y);
	}
	template <class _Tp, class _Up>
	constexpr typename __gnu_cxx::__enable_if<
		__is_arithmetic<_Tp>::__value &&__is_arithmetic<_Up>::__value,
		bool>::__type
	islessequal(_Tp __x, _Up __y)
	{
		typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
		return __builtin_islessequal((__type)__x, (__type)__y);
	}
	constexpr bool islessgreater(float __x, float __y)
	{
		return __builtin_islessgreater(__x, __y);
	}
	constexpr bool islessgreater(double __x, double __y)
	{
		return __builtin_islessgreater(__x, __y);
	}
	constexpr bool islessgreater(long double __x, long double __y)
	{
		return __builtin_islessgreater(__x, __y);
	}
	template <class _Tp, class _Up>
	constexpr typename __gnu_cxx::__enable_if<
		__is_arithmetic<_Tp>::__value &&__is_arithmetic<_Up>::__value,
		bool>::__type
	islessgreater(_Tp __x, _Up __y)
	{
		typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
		return __builtin_islessgreater((__type)__x, (__type)__y);
	}
	constexpr bool isunordered(float __x, float __y)
	{
		return __builtin_isunordered(__x, __y);
	}
	constexpr bool isunordered(double __x, double __y)
	{
		return __builtin_isunordered(__x, __y);
	}
	constexpr bool isunordered(long double __x, long double __y)
	{
		return __builtin_isunordered(__x, __y);
	}
	template <class _Tp, class _Up>
	constexpr typename __gnu_cxx::__enable_if<
		__is_arithmetic<_Tp>::__value &&__is_arithmetic<_Up>::__value,
		bool>::__type
	isunordered(_Tp __x, _Up __y)
	{
		typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
		return __builtin_isunordered((__type)__x, (__type)__y);
	}
	using ::acosh;
	using ::acoshf;
	using ::acoshl;
	using ::asinh;
	using ::asinhf;
	using ::asinhl;
	using ::atanh;
	using ::atanhf;
	using ::atanhl;
	using ::cbrt;
	using ::cbrtf;
	using ::cbrtl;
	using ::copysign;
	using ::copysignf;
	using ::copysignl;
	using ::double_t;
	using ::erf;
	using ::erfc;
	using ::erfcf;
	using ::erfcl;
	using ::erff;
	using ::erfl;
	using ::exp2;
	using ::exp2f;
	using ::exp2l;
	using ::expm1;
	using ::expm1f;
	using ::expm1l;
	using ::fdim;
	using ::fdimf;
	using ::fdiml;
	using ::float_t;
	using ::fma;
	using ::fmaf;
	using ::fmal;
	using ::fmax;
	using ::fmaxf;
	using ::fmaxl;
	using ::fmin;
	using ::fminf;
	using ::fminl;
	using ::hypot;
	using ::hypotf;
	using ::hypotl;
	using ::ilogb;
	using ::ilogbf;
	using ::ilogbl;
	using ::lgamma;
	using ::lgammaf;
	using ::lgammal;
	using ::llrint;
	using ::llrintf;
	using ::llrintl;
	using ::llround;
	using ::llroundf;
	using ::llroundl;
	using ::log1p;
	using ::log1pf;
	using ::log1pl;
	using ::log2;
	using ::log2f;
	using ::log2l;
	using ::logb;
	using ::logbf;
	using ::logbl;
	using ::lrint;
	using ::lrintf;
	using ::lrintl;
	using ::lround;
	using ::lroundf;
	using ::lroundl;
	using ::nan;
	using ::nanf;
	using ::nanl;
	using ::nearbyint;
	using ::nearbyintf;
	using ::nearbyintl;
	using ::nextafter;
	using ::nextafterf;
	using ::nextafterl;
	using ::nexttoward;
	using ::nexttowardf;
	using ::nexttowardl;
	using ::remainder;
	using ::remainderf;
	using ::remainderl;
	using ::remquo;
	using ::remquof;
	using ::remquol;
	using ::rint;
	using ::rintf;
	using ::rintl;
	using ::round;
	using ::roundf;
	using ::roundl;
	using ::scalbln;
	using ::scalblnf;
	using ::scalblnl;
	using ::scalbn;
	using ::scalbnf;
	using ::scalbnl;
	using ::tgamma;
	using ::tgammaf;
	using ::tgammal;
	using ::trunc;
	using ::truncf;
	using ::truncl;
	constexpr float acosh(float __x)
	{
		return __builtin_acoshf(__x);
	}
	constexpr long double acosh(long double __x)
	{
		return __builtin_acoshl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	acosh(_Tp __x)
	{
		return __builtin_acosh(__x);
	}
	constexpr float asinh(float __x)
	{
		return __builtin_asinhf(__x);
	}
	constexpr long double asinh(long double __x)
	{
		return __builtin_asinhl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	asinh(_Tp __x)
	{
		return __builtin_asinh(__x);
	}
	constexpr float atanh(float __x)
	{
		return __builtin_atanhf(__x);
	}
	constexpr long double atanh(long double __x)
	{
		return __builtin_atanhl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	atanh(_Tp __x)
	{
		return __builtin_atanh(__x);
	}
	constexpr float cbrt(float __x)
	{
		return __builtin_cbrtf(__x);
	}
	constexpr long double cbrt(long double __x)
	{
		return __builtin_cbrtl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	cbrt(_Tp __x)
	{
		return __builtin_cbrt(__x);
	}
	constexpr float copysign(float __x, float __y)
	{
		return __builtin_copysignf(__x, __y);
	}
	constexpr long double copysign(long double __x, long double __y)
	{
		return __builtin_copysignl(__x, __y);
	}
	template <class _Tp, class _Up>
	constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type copysign(
		_Tp __x, _Up __y)
	{
		typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
		return copysign((__type)__x, (__type)__y);
	}
	constexpr float erf(float __x)
	{
		return __builtin_erff(__x);
	}
	constexpr long double erf(long double __x)
	{
		return __builtin_erfl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	erf(_Tp __x)
	{
		return __builtin_erf(__x);
	}
	constexpr float erfc(float __x)
	{
		return __builtin_erfcf(__x);
	}
	constexpr long double erfc(long double __x)
	{
		return __builtin_erfcl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	erfc(_Tp __x)
	{
		return __builtin_erfc(__x);
	}
	constexpr float exp2(float __x)
	{
		return __builtin_exp2f(__x);
	}
	constexpr long double exp2(long double __x)
	{
		return __builtin_exp2l(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	exp2(_Tp __x)
	{
		return __builtin_exp2(__x);
	}
	constexpr float expm1(float __x)
	{
		return __builtin_expm1f(__x);
	}
	constexpr long double expm1(long double __x)
	{
		return __builtin_expm1l(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	expm1(_Tp __x)
	{
		return __builtin_expm1(__x);
	}
	constexpr float fdim(float __x, float __y)
	{
		return __builtin_fdimf(__x, __y);
	}
	constexpr long double fdim(long double __x, long double __y)
	{
		return __builtin_fdiml(__x, __y);
	}
	template <class _Tp, class _Up>
	constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type fdim(
		_Tp __x, _Up __y)
	{
		typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
		return fdim((__type)__x, (__type)__y);
	}
	constexpr float fma(float __x, float __y, float __z)
	{
		return __builtin_fmaf(__x, __y, __z);
	}
	constexpr long double fma(long double __x, long double __y,
				  long double __z)
	{
		return __builtin_fmal(__x, __y, __z);
	}
	template <class _Tp, class _Up, class _Vp>
	constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type fma(
		_Tp __x, _Up __y, _Vp __z)
	{
		typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
			__type;
		return fma((__type)__x, (__type)__y, (__type)__z);
	}
	constexpr float fmax(float __x, float __y)
	{
		return __builtin_fmaxf(__x, __y);
	}
	constexpr long double fmax(long double __x, long double __y)
	{
		return __builtin_fmaxl(__x, __y);
	}
	template <class _Tp, class _Up>
	constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type fmax(
		_Tp __x, _Up __y)
	{
		typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
		return fmax((__type)__x, (__type)__y);
	}
	constexpr float fmin(float __x, float __y)
	{
		return __builtin_fminf(__x, __y);
	}
	constexpr long double fmin(long double __x, long double __y)
	{
		return __builtin_fminl(__x, __y);
	}
	template <class _Tp, class _Up>
	constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type fmin(
		_Tp __x, _Up __y)
	{
		typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
		return fmin((__type)__x, (__type)__y);
	}
	constexpr float hypot(float __x, float __y)
	{
		return __builtin_hypotf(__x, __y);
	}
	constexpr long double hypot(long double __x, long double __y)
	{
		return __builtin_hypotl(__x, __y);
	}
	template <class _Tp, class _Up>
	constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type hypot(
		_Tp __x, _Up __y)
	{
		typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
		return hypot((__type)__x, (__type)__y);
	}
	constexpr int ilogb(float __x)
	{
		return __builtin_ilogbf(__x);
	}
	constexpr int ilogb(long double __x)
	{
		return __builtin_ilogbl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  int>::__type
	ilogb(_Tp __x)
	{
		return __builtin_ilogb(__x);
	}
	constexpr float lgamma(float __x)
	{
		return __builtin_lgammaf(__x);
	}
	constexpr long double lgamma(long double __x)
	{
		return __builtin_lgammal(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	lgamma(_Tp __x)
	{
		return __builtin_lgamma(__x);
	}
	constexpr long long llrint(float __x)
	{
		return __builtin_llrintf(__x);
	}
	constexpr long long llrint(long double __x)
	{
		return __builtin_llrintl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  long long>::__type
	llrint(_Tp __x)
	{
		return __builtin_llrint(__x);
	}
	constexpr long long llround(float __x)
	{
		return __builtin_llroundf(__x);
	}
	constexpr long long llround(long double __x)
	{
		return __builtin_llroundl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  long long>::__type
	llround(_Tp __x)
	{
		return __builtin_llround(__x);
	}
	constexpr float log1p(float __x)
	{
		return __builtin_log1pf(__x);
	}
	constexpr long double log1p(long double __x)
	{
		return __builtin_log1pl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	log1p(_Tp __x)
	{
		return __builtin_log1p(__x);
	}
	constexpr float log2(float __x)
	{
		return __builtin_log2f(__x);
	}
	constexpr long double log2(long double __x)
	{
		return __builtin_log2l(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	log2(_Tp __x)
	{
		return __builtin_log2(__x);
	}
	constexpr float logb(float __x)
	{
		return __builtin_logbf(__x);
	}
	constexpr long double logb(long double __x)
	{
		return __builtin_logbl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	logb(_Tp __x)
	{
		return __builtin_logb(__x);
	}
	constexpr long lrint(float __x)
	{
		return __builtin_lrintf(__x);
	}
	constexpr long lrint(long double __x)
	{
		return __builtin_lrintl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  long>::__type
	lrint(_Tp __x)
	{
		return __builtin_lrint(__x);
	}
	constexpr long lround(float __x)
	{
		return __builtin_lroundf(__x);
	}
	constexpr long lround(long double __x)
	{
		return __builtin_lroundl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  long>::__type
	lround(_Tp __x)
	{
		return __builtin_lround(__x);
	}
	constexpr float nearbyint(float __x)
	{
		return __builtin_nearbyintf(__x);
	}
	constexpr long double nearbyint(long double __x)
	{
		return __builtin_nearbyintl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	nearbyint(_Tp __x)
	{
		return __builtin_nearbyint(__x);
	}
	constexpr float nextafter(float __x, float __y)
	{
		return __builtin_nextafterf(__x, __y);
	}
	constexpr long double nextafter(long double __x, long double __y)
	{
		return __builtin_nextafterl(__x, __y);
	}
	template <class _Tp, class _Up>
	constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type nextafter(
		_Tp __x, _Up __y)
	{
		typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
		return nextafter((__type)__x, (__type)__y);
	}
	constexpr float nexttoward(float __x, long double __y)
	{
		return __builtin_nexttowardf(__x, __y);
	}
	constexpr long double nexttoward(long double __x, long double __y)
	{
		return __builtin_nexttowardl(__x, __y);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	nexttoward(_Tp __x, long double __y)
	{
		return __builtin_nexttoward(__x, __y);
	}
	constexpr float remainder(float __x, float __y)
	{
		return __builtin_remainderf(__x, __y);
	}
	constexpr long double remainder(long double __x, long double __y)
	{
		return __builtin_remainderl(__x, __y);
	}
	template <class _Tp, class _Up>
	constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type remainder(
		_Tp __x, _Up __y)
	{
		typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
		return remainder((__type)__x, (__type)__y);
	}
	inline float remquo(float __x, float __y, int *__pquo)
	{
		return __builtin_remquof(__x, __y, __pquo);
	}
	inline long double remquo(long double __x, long double __y, int *__pquo)
	{
		return __builtin_remquol(__x, __y, __pquo);
	}
	template <class _Tp, class _Up>
	inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type remquo(
		_Tp __x, _Up __y, int *__pquo)
	{
		typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
		return remquo((__type)__x, (__type)__y, __pquo);
	}
	constexpr float rint(float __x)
	{
		return __builtin_rintf(__x);
	}
	constexpr long double rint(long double __x)
	{
		return __builtin_rintl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	rint(_Tp __x)
	{
		return __builtin_rint(__x);
	}
	constexpr float round(float __x)
	{
		return __builtin_roundf(__x);
	}
	constexpr long double round(long double __x)
	{
		return __builtin_roundl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	round(_Tp __x)
	{
		return __builtin_round(__x);
	}
	constexpr float scalbln(float __x, long __ex)
	{
		return __builtin_scalblnf(__x, __ex);
	}
	constexpr long double scalbln(long double __x, long __ex)
	{
		return __builtin_scalblnl(__x, __ex);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	scalbln(_Tp __x, long __ex)
	{
		return __builtin_scalbln(__x, __ex);
	}
	constexpr float scalbn(float __x, int __ex)
	{
		return __builtin_scalbnf(__x, __ex);
	}
	constexpr long double scalbn(long double __x, int __ex)
	{
		return __builtin_scalbnl(__x, __ex);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	scalbn(_Tp __x, int __ex)
	{
		return __builtin_scalbn(__x, __ex);
	}
	constexpr float tgamma(float __x)
	{
		return __builtin_tgammaf(__x);
	}
	constexpr long double tgamma(long double __x)
	{
		return __builtin_tgammal(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	tgamma(_Tp __x)
	{
		return __builtin_tgamma(__x);
	}
	constexpr float trunc(float __x)
	{
		return __builtin_truncf(__x);
	}
	constexpr long double trunc(long double __x)
	{
		return __builtin_truncl(__x);
	}
	template <class _Tp>
	constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
						  double>::__type
	trunc(_Tp __x)
	{
		return __builtin_trunc(__x);
	}
	template <class _Tp> inline _Tp __hypot3(_Tp __x, _Tp __y, _Tp __z)
	{
		__x = std::abs(__x);
		__y = std::abs(__y);
		__z = std::abs(__z);
		if (_Tp __a = (__x < __y) ? (__y < __z) ? __z : __y :
					    ((__x < __z) ? __z : __x)) {
			return __a * std::sqrt((((__x / __a) * (__x / __a)) +
						((__y / __a) * (__y / __a))) +
					       ((__z / __a) * (__z / __a)));
		} else {
			return {};
		}
	}
	inline float hypot(float __x, float __y, float __z)
	{
		return std::__hypot3<float>(__x, __y, __z);
	}
	inline double hypot(double __x, double __y, double __z)
	{
		return std::__hypot3<double>(__x, __y, __z);
	}
	inline long double hypot(long double __x, long double __y,
				 long double __z)
	{
		return std::__hypot3<long double>(__x, __y, __z);
	}
	template <class _Tp, class _Up, class _Vp>
	__gnu_cxx::__promoted_t<_Tp, _Up, _Vp> hypot(_Tp __x, _Up __y, _Vp __z)
	{
		using __type = __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>;
		return std::__hypot3<__gnu_cxx::__promoted_t<_Tp, _Up, _Vp>>(
			__x, __y, __z);
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	void __throw_bad_exception() __attribute((__noreturn__));
	void __throw_bad_alloc() __attribute((__noreturn__));
	void __throw_bad_array_new_length() __attribute((__noreturn__));
	void __throw_bad_cast() __attribute((__noreturn__));
	void __throw_bad_typeid() __attribute((__noreturn__));
	void __throw_logic_error(const char *) __attribute((__noreturn__));
	void __throw_domain_error(const char *) __attribute((__noreturn__));
	void __throw_invalid_argument(const char *) __attribute((__noreturn__));
	void __throw_length_error(const char *) __attribute((__noreturn__));
	void __throw_out_of_range(const char *) __attribute((__noreturn__));
	void __throw_out_of_range_fmt(const char *, ...)
		__attribute((__noreturn__))
		__attribute((__format__(__gnu_printf__, 1, 2)));
	void __throw_runtime_error(const char *) __attribute((__noreturn__));
	void __throw_range_error(const char *) __attribute((__noreturn__));
	void __throw_overflow_error(const char *) __attribute((__noreturn__));
	void __throw_underflow_error(const char *) __attribute((__noreturn__));
	void __throw_ios_failure(const char *) __attribute((__noreturn__));
	void __throw_ios_failure(const char *, int) __attribute((__noreturn__));
	void __throw_system_error(int) __attribute((__noreturn__));
	void __throw_future_error(int) __attribute((__noreturn__));
	void __throw_bad_function_call() __attribute((__noreturn__));
} // namespace )
namespace __gnu_cxx __attribute((__visibility__("default")))
{
	template <class _Tp>
	struct __is_integer_nonstrict : public std::__is_integer<_Tp> {
		using std::__is_integer<_Tp>::__value;
		enum { __width = (__value) ? sizeof(_Tp) * (8) : (0) };
	};
	template <class _Value> struct __numeric_traits_integer {
		static_assert((__is_integer_nonstrict<_Value>::__value),
			      "invalid specialization");
		static const bool __is_signed = (((_Value)(-1)) < 0);
		static const int __digits =
			(__is_integer_nonstrict<_Value>::__width - __is_signed);
		static const _Value __max =
			(__is_signed ? (((((_Value)1) << (__digits - 1)) - 1)
					<< 1) + 1 :
				       (~((_Value)0)));
		static const _Value __min =
			(__is_signed ? (-__max) - 1 : ((_Value)0));
	};
	template <class _Value>
	const _Value __numeric_traits_integer<_Value>::__min;
	template <class _Value>
	const _Value __numeric_traits_integer<_Value>::__max;
	template <class _Value>
	const bool __numeric_traits_integer<_Value>::__is_signed;
	template <class _Value>
	const int __numeric_traits_integer<_Value>::__digits;
	template <class _Tp> using __int_traits = __numeric_traits_integer<_Tp>;
	template <class _Value> struct __numeric_traits_floating {
		static const int __max_digits10 =
			((2) +
			 ((((std::template __are_same<_Value, float>::__value) ?
				    24 :
				    ((std::template __are_same<
					     _Value, double>::__value) ?
					     53 :
					     64)) *
			   643L) /
			  (2136)));
		static const bool __is_signed = true;
		static const int __digits10 =
			((std::template __are_same<_Value, float>::__value) ?
				 6 :
				 ((std::template __are_same<_Value,
							    double>::__value) ?
					  15 :
					  18));
		static const int __max_exponent10 =
			((std::template __are_same<_Value, float>::__value) ?
				 38 :
				 ((std::template __are_same<_Value,
							    double>::__value) ?
					  308 :
					  4932));
	};
	template <class _Value>
	const int __numeric_traits_floating<_Value>::__max_digits10;
	template <class _Value>
	const bool __numeric_traits_floating<_Value>::__is_signed;
	template <class _Value>
	const int __numeric_traits_floating<_Value>::__digits10;
	template <class _Value>
	const int __numeric_traits_floating<_Value>::__max_exponent10;
	template <class _Value>
	struct __numeric_traits : public __numeric_traits_integer<_Value> {
	};
	template <>
	struct __numeric_traits<float>
		: public __numeric_traits_floating<float> {
	};
	template <>
	struct __numeric_traits<double>
		: public __numeric_traits_floating<double> {
	};
	template <>
	struct __numeric_traits<long double>
		: public __numeric_traits_floating<long double> {
	};
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _Tp> class reference_wrapper;
	template <class _Tp, _Tp __v> struct integral_constant {
		static constexpr inline _Tp value = (__v);
		typedef _Tp value_type;
		typedef integral_constant type;
		constexpr operator value_type() const noexcept
		{
			return value;
		}
		constexpr value_type operator()() const noexcept
		{
			return value;
		}
	};
	using true_type = integral_constant<bool, true>;
	using false_type = integral_constant<bool, false>;
	template <bool __v>
	using __bool_constant = integral_constant<bool, __v>;
	template <bool __v> using bool_constant = integral_constant<bool, __v>;
	template <bool> struct __conditional {
		template <class _Tp, class> using type = _Tp;
	};
	template <> struct __conditional<false> {
		template <class, class _Up> using type = _Up;
	};
	template <bool _Cond, class _If, class _Else>
	using __conditional_t =
		typename __conditional<_Cond>::template type<_If, _Else>;
	template <class _Type> struct __type_identity {
		using type = _Type;
	};
	template <class _Tp>
	using __type_identity_t = typename __type_identity<_Tp>::type;
	template <class...> struct __or_;
	template <> struct __or_<> : public false_type {
	};
	template <class _B1> struct __or_<_B1> : public _B1 {
	};
	template <class _B1, class _B2>
	struct __or_<_B1, _B2> : public __conditional_t<_B1::value, _B1, _B2> {
	};
	template <class _B1, class _B2, class _B3, class... _Bn>
	struct __or_<_B1, _B2, _B3, _Bn...>
		: public __conditional_t<_B1::value, _B1,
					 std::__or_<_B2, _B3, _Bn...>> {
	};
	template <class...> struct __and_;
	template <> struct __and_<> : public true_type {
	};
	template <class _B1> struct __and_<_B1> : public _B1 {
	};
	template <class _B1, class _B2>
	struct __and_<_B1, _B2> : public __conditional_t<_B1::value, _B2, _B1> {
	};
	template <class _B1, class _B2, class _B3, class... _Bn>
	struct __and_<_B1, _B2, _B3, _Bn...>
		: public __conditional_t<_B1::value,
					 std::__and_<_B2, _B3, _Bn...>, _B1> {
	};
	template <class _Pp>
	struct __not_ : public __bool_constant<!((bool)_Pp::value)> {
	};
	template <class... _Bn>
	constexpr inline bool __or_v = (__or_<_Bn...>::value);
	template <class... _Bn>
	constexpr inline bool __and_v = (__and_<_Bn...>::value);
	template <class... _Bn> struct conjunction : public __and_<_Bn...> {
	};
	template <class... _Bn> struct disjunction : public __or_<_Bn...> {
	};
	template <class _Pp> struct negation : public __not_<_Pp> {
	};
	template <class... _Bn>
	constexpr inline bool conjunction_v = (conjunction<_Bn...>::value);
	template <class... _Bn>
	constexpr inline bool disjunction_v = (disjunction<_Bn...>::value);
	template <class _Pp>
	constexpr inline bool negation_v = (negation<_Pp>::value);
	template <class> struct is_reference;
	template <class> struct is_function;
	template <class> struct is_void;
	template <class> struct remove_cv;
	template <class> struct is_const;
	template <class> struct __is_array_unknown_bounds;
	template <class _Tp, size_t = sizeof(_Tp)>
	constexpr true_type __is_complete_or_unbounded(__type_identity<_Tp>)
	{
		return {};
	}
	template <class _TypeIdentity,
		  class _NestedType = typename _TypeIdentity::type>
	constexpr typename __or_<is_reference<_NestedType>,
				 is_function<_NestedType>, is_void<_NestedType>,
				 __is_array_unknown_bounds<_NestedType>>::type
	__is_complete_or_unbounded(_TypeIdentity)
	{
		return {};
	}
	template <class _Tp> struct __success_type {
		typedef _Tp type;
	};
	struct __failure_type {};
	template <class _Tp>
	using __remove_cv_t = typename remove_cv<_Tp>::type;
	template <class> struct __is_void_helper : public false_type {
	};
	template <> struct __is_void_helper<void> : public true_type {
	};
	template <class _Tp>
	struct is_void : public __is_void_helper<__remove_cv_t<_Tp>>::type {
	};
	template <class> struct __is_integral_helper : public false_type {
	};
	template <> struct __is_integral_helper<bool> : public true_type {
	};
	template <> struct __is_integral_helper<char> : public true_type {
	};
	template <>
	struct __is_integral_helper<signed char> : public true_type {
	};
	template <>
	struct __is_integral_helper<unsigned char> : public true_type {
	};
	template <> struct __is_integral_helper<wchar_t> : public true_type {
	};
	template <> struct __is_integral_helper<char16_t> : public true_type {
	};
	template <> struct __is_integral_helper<char32_t> : public true_type {
	};
	template <> struct __is_integral_helper<short> : public true_type {
	};
	template <>
	struct __is_integral_helper<unsigned short> : public true_type {
	};
	template <> struct __is_integral_helper<int> : public true_type {
	};
	template <> struct __is_integral_helper<unsigned> : public true_type {
	};
	template <> struct __is_integral_helper<long> : public true_type {
	};
	template <>
	struct __is_integral_helper<unsigned long> : public true_type {
	};
	template <> struct __is_integral_helper<long long> : public true_type {
	};
	template <>
	struct __is_integral_helper<unsigned long long> : public true_type {
	};
	template <> struct __is_integral_helper<__int128> : public true_type {
	};
	template <>
	struct __is_integral_helper<unsigned __int128> : public true_type {
	};
	template <class _Tp>
	struct is_integral
		: public __is_integral_helper<__remove_cv_t<_Tp>>::type {
	};
	template <class> struct __is_floating_point_helper : public false_type {
	};
	template <>
	struct __is_floating_point_helper<float> : public true_type {
	};
	template <>
	struct __is_floating_point_helper<double> : public true_type {
	};
	template <>
	struct __is_floating_point_helper<long double> : public true_type {
	};
	template <class _Tp>
	struct is_floating_point
		: public __is_floating_point_helper<__remove_cv_t<_Tp>>::type {
	};
	template <class> struct is_array : public false_type {
	};
	template <class _Tp, size_t _Size>
	struct is_array<_Tp[_Size]> : public true_type {
	};
	template <class _Tp> struct is_array<_Tp[]> : public true_type {
	};
	template <class> struct __is_pointer_helper : public false_type {
	};
	template <class _Tp>
	struct __is_pointer_helper<_Tp *> : public true_type {
	};
	template <class _Tp>
	struct is_pointer
		: public __is_pointer_helper<__remove_cv_t<_Tp>>::type {
	};
	template <class> struct is_lvalue_reference : public false_type {
	};
	template <class _Tp>
	struct is_lvalue_reference<_Tp &> : public true_type {
	};
	template <class> struct is_rvalue_reference : public false_type {
	};
	template <class _Tp>
	struct is_rvalue_reference<_Tp &&> : public true_type {
	};
	template <class>
	struct __is_member_object_pointer_helper : public false_type {
	};
	template <class _Tp, class _Cp>
	struct __is_member_object_pointer_helper<_Tp(_Cp::*)>
		: public __not_<is_function<_Tp>>::type {
	};
	template <class _Tp>
	struct is_member_object_pointer
		: public __is_member_object_pointer_helper<
			  __remove_cv_t<_Tp>>::type {
	};
	template <class>
	struct __is_member_function_pointer_helper : public false_type {
	};
	template <class _Tp, class _Cp>
	struct __is_member_function_pointer_helper<_Tp(_Cp::*)>
		: public is_function<_Tp>::type {
	};
	template <class _Tp>
	struct is_member_function_pointer
		: public __is_member_function_pointer_helper<
			  __remove_cv_t<_Tp>>::type {
	};
	template <class _Tp>
	struct is_enum : public integral_constant<bool, __is_enum(_Tp)> {
	};
	template <class _Tp>
	struct is_union : public integral_constant<bool, __is_union(_Tp)> {
	};
	template <class _Tp>
	struct is_class : public integral_constant<bool, __is_class(_Tp)> {
	};
	template <class _Tp>
	struct is_function
		: public __bool_constant<!is_const<const _Tp>::value> {
	};
	template <class _Tp> struct is_function<_Tp &> : public false_type {
	};
	template <class _Tp> struct is_function<_Tp &&> : public false_type {
	};
	template <class> struct __is_null_pointer_helper : public false_type {
	};
	template <>
	struct __is_null_pointer_helper<__decltype((nullptr))>
		: public true_type {
	};
	template <class _Tp>
	struct is_null_pointer
		: public __is_null_pointer_helper<__remove_cv_t<_Tp>>::type {
	};
	template <class _Tp>
	struct __is_nullptr_t : public is_null_pointer<_Tp> {
	} __attribute((__deprecated__("use \'std::is_null_pointer\' instead")));
	template <class _Tp>
	struct is_reference : public __or_<is_lvalue_reference<_Tp>,
					   is_rvalue_reference<_Tp>>::type {
	};
	template <class _Tp>
	struct is_arithmetic
		: public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type {
	};
	template <class _Tp>
	struct is_fundamental : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
					     is_null_pointer<_Tp>>::type {
	};
	template <class _Tp>
	struct is_object
		: public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
				      is_void<_Tp>>>::type {
	};
	template <class> struct is_member_pointer;
	template <class _Tp>
	struct is_scalar : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>,
					is_pointer<_Tp>, is_member_pointer<_Tp>,
					is_null_pointer<_Tp>>::type {
	};
	template <class _Tp>
	struct is_compound : public __not_<is_fundamental<_Tp>>::type {
	};
	template <class _Tp>
	struct __is_member_pointer_helper : public false_type {
	};
	template <class _Tp, class _Cp>
	struct __is_member_pointer_helper<_Tp(_Cp::*)> : public true_type {
	};
	template <class _Tp>
	struct is_member_pointer
		: public __is_member_pointer_helper<__remove_cv_t<_Tp>>::type {
	};
	template <class, class> struct is_same;
	template <class _Tp, class... _Types>
	using __is_one_of = __or_<is_same<_Tp, _Types>...>;
	template <class _Tp>
	using __is_signed_integer =
		__is_one_of<__remove_cv_t<_Tp>, signed char, signed short,
			    signed int, signed long, signed long long,
			    signed __int128>;
	template <class _Tp>
	using __is_unsigned_integer =
		__is_one_of<__remove_cv_t<_Tp>, unsigned char, unsigned short,
			    unsigned, unsigned long, unsigned long long,
			    unsigned __int128>;
	template <class _Tp>
	using __is_standard_integer =
		__or_<__is_signed_integer<_Tp>, __is_unsigned_integer<_Tp>>;
	template <class...> using __void_t = void;
	template <class _Tp, class = void>
	struct __is_referenceable : public false_type {
	};
	template <class _Tp>
	struct __is_referenceable<_Tp, __void_t<_Tp &>> : public true_type {
	};
	template <class> struct is_const : public false_type {
	};
	template <class _Tp> struct is_const<const _Tp> : public true_type {
	};
	template <class> struct is_volatile : public false_type {
	};
	template <class _Tp>
	struct is_volatile<volatile _Tp> : public true_type {
	};
	template <class _Tp>
	struct is_trivial : public integral_constant<bool, __is_trivial(_Tp)> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp>
	struct is_trivially_copyable
		: public integral_constant<bool, __is_trivially_copyable(_Tp)> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp>
	struct is_standard_layout
		: public integral_constant<bool, __is_standard_layout(_Tp)> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp>
	struct is_pod : public integral_constant<bool, __is_pod(_Tp)> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp>
	struct [[__deprecated__]] is_literal_type
		: public integral_constant<bool, __is_literal_type(_Tp)> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp>
	struct is_empty : public integral_constant<bool, __is_empty(_Tp)> {
	};
	template <class _Tp>
	struct is_polymorphic
		: public integral_constant<bool, __is_polymorphic(_Tp)> {
	};
	template <class _Tp>
	struct is_final : public integral_constant<bool, __is_final(_Tp)> {
	};
	template <class _Tp>
	struct is_abstract
		: public integral_constant<bool, __is_abstract(_Tp)> {
	};
	template <class _Tp, bool = is_arithmetic<_Tp>::value>
	struct __is_signed_helper : public false_type {
	};
	template <class _Tp>
	struct __is_signed_helper<_Tp, true>
		: public integral_constant<bool, ((_Tp)(-1)) < ((_Tp)0)> {
	};
	template <class _Tp>
	struct is_signed : public __is_signed_helper<_Tp>::type {
	};
	template <class _Tp>
	struct is_unsigned
		: public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>> {
	};
	template <class _Tp, class _Up = _Tp &&> _Up __declval(int);
	template <class _Tp> _Tp __declval(long);
	template <class _Tp>
	auto declval() noexcept->__decltype((__declval<_Tp>(0)));
	template <class, unsigned = 0U> struct extent;
	template <class> struct remove_all_extents;
	template <class _Tp>
	struct __is_array_known_bounds
		: public integral_constant<bool, (extent<_Tp>::value > 0)> {
	};
	template <class _Tp>
	struct __is_array_unknown_bounds
		: public __and_<is_array<_Tp>, __not_<extent<_Tp>>> {
	};
	struct __do_is_destructible_impl {
		template <class _Tp,
			  class = __decltype((declval<_Tp &>().~_Tp()))>
		static true_type __test(int);
		template <class> static false_type __test(...);
	};
	template <class _Tp>
	struct __is_destructible_impl : public __do_is_destructible_impl {
		typedef __decltype((__test<_Tp>(0))) type;
	};
	template <class _Tp,
		  bool = __or_<is_void<_Tp>, __is_array_unknown_bounds<_Tp>,
			       is_function<_Tp>>::value,
		  bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
	struct __is_destructible_safe;
	template <class _Tp>
	struct __is_destructible_safe<_Tp, false, false>
		: public __is_destructible_impl<
			  typename remove_all_extents<_Tp>::type>::type {
	};
	template <class _Tp>
	struct __is_destructible_safe<_Tp, true, false> : public false_type {
	};
	template <class _Tp>
	struct __is_destructible_safe<_Tp, false, true> : public true_type {
	};
	template <class _Tp>
	struct is_destructible : public __is_destructible_safe<_Tp>::type {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	struct __do_is_nt_destructible_impl {
		template <class _Tp>
		static __bool_constant<noexcept(declval<_Tp &>().~_Tp())>
		__test(int);
		template <class> static false_type __test(...);
	};
	template <class _Tp>
	struct __is_nt_destructible_impl : public __do_is_nt_destructible_impl {
		typedef __decltype((__test<_Tp>(0))) type;
	};
	template <class _Tp,
		  bool = __or_<is_void<_Tp>, __is_array_unknown_bounds<_Tp>,
			       is_function<_Tp>>::value,
		  bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
	struct __is_nt_destructible_safe;
	template <class _Tp>
	struct __is_nt_destructible_safe<_Tp, false, false>
		: public __is_nt_destructible_impl<
			  typename remove_all_extents<_Tp>::type>::type {
	};
	template <class _Tp>
	struct __is_nt_destructible_safe<_Tp, true, false> : public false_type {
	};
	template <class _Tp>
	struct __is_nt_destructible_safe<_Tp, false, true> : public true_type {
	};
	template <class _Tp>
	struct is_nothrow_destructible
		: public __is_nt_destructible_safe<_Tp>::type {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp, class... _Args>
	struct __is_constructible_impl
		: public __bool_constant<__is_constructible(_Tp, _Args...)> {
	};
	template <class _Tp, class... _Args>
	struct is_constructible
		: public __is_constructible_impl<_Tp, _Args...> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp>
	struct is_default_constructible
		: public __is_constructible_impl<_Tp>::type {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp, bool = __is_referenceable<_Tp>::value>
	struct __is_copy_constructible_impl;
	template <class _Tp>
	struct __is_copy_constructible_impl<_Tp, false> : public false_type {
	};
	template <class _Tp>
	struct __is_copy_constructible_impl<_Tp, true>
		: public __is_constructible_impl<_Tp, const _Tp &> {
	};
	template <class _Tp>
	struct is_copy_constructible
		: public __is_copy_constructible_impl<_Tp> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp, bool = __is_referenceable<_Tp>::value>
	struct __is_move_constructible_impl;
	template <class _Tp>
	struct __is_move_constructible_impl<_Tp, false> : public false_type {
	};
	template <class _Tp>
	struct __is_move_constructible_impl<_Tp, true>
		: public __is_constructible_impl<_Tp, _Tp &&> {
	};
	template <class _Tp>
	struct is_move_constructible
		: public __is_move_constructible_impl<_Tp> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp, class... _Args>
	using __is_nothrow_constructible_impl =
		__bool_constant<__is_nothrow_constructible(_Tp, _Args...)>;
	template <class _Tp, class... _Args>
	struct is_nothrow_constructible
		: public __is_nothrow_constructible_impl<_Tp, _Args...>::type {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp>
	struct is_nothrow_default_constructible
		: public __bool_constant<__is_nothrow_constructible(_Tp)> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp, bool = __is_referenceable<_Tp>::value>
	struct __is_nothrow_copy_constructible_impl;
	template <class _Tp>
	struct __is_nothrow_copy_constructible_impl<_Tp, false>
		: public false_type {
	};
	template <class _Tp>
	struct __is_nothrow_copy_constructible_impl<_Tp, true>
		: public __is_nothrow_constructible_impl<_Tp, const _Tp &> {
	};
	template <class _Tp>
	struct is_nothrow_copy_constructible
		: public __is_nothrow_copy_constructible_impl<_Tp>::type {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp, bool = __is_referenceable<_Tp>::value>
	struct __is_nothrow_move_constructible_impl;
	template <class _Tp>
	struct __is_nothrow_move_constructible_impl<_Tp, false>
		: public false_type {
	};
	template <class _Tp>
	struct __is_nothrow_move_constructible_impl<_Tp, true>
		: public __is_nothrow_constructible_impl<_Tp, _Tp &&> {
	};
	template <class _Tp>
	struct is_nothrow_move_constructible
		: public __is_nothrow_move_constructible_impl<_Tp>::type {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp, class _Up>
	struct is_assignable
		: public __bool_constant<__is_assignable(_Tp, _Up)> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp, bool = __is_referenceable<_Tp>::value>
	struct __is_copy_assignable_impl;
	template <class _Tp>
	struct __is_copy_assignable_impl<_Tp, false> : public false_type {
	};
	template <class _Tp>
	struct __is_copy_assignable_impl<_Tp, true>
		: public __bool_constant<__is_assignable(_Tp &, const _Tp &)> {
	};
	template <class _Tp>
	struct is_copy_assignable
		: public __is_copy_assignable_impl<_Tp>::type {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp, bool = __is_referenceable<_Tp>::value>
	struct __is_move_assignable_impl;
	template <class _Tp>
	struct __is_move_assignable_impl<_Tp, false> : public false_type {
	};
	template <class _Tp>
	struct __is_move_assignable_impl<_Tp, true>
		: public __bool_constant<__is_assignable(_Tp &, _Tp &&)> {
	};
	template <class _Tp>
	struct is_move_assignable
		: public __is_move_assignable_impl<_Tp>::type {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp, class _Up>
	using __is_nothrow_assignable_impl =
		__bool_constant<__is_nothrow_assignable(_Tp, _Up)>;
	template <class _Tp, class _Up>
	struct is_nothrow_assignable
		: public __is_nothrow_assignable_impl<_Tp, _Up> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp, bool = __is_referenceable<_Tp>::value>
	struct __is_nt_copy_assignable_impl;
	template <class _Tp>
	struct __is_nt_copy_assignable_impl<_Tp, false> : public false_type {
	};
	template <class _Tp>
	struct __is_nt_copy_assignable_impl<_Tp, true>
		: public __is_nothrow_assignable_impl<_Tp &, const _Tp &> {
	};
	template <class _Tp>
	struct is_nothrow_copy_assignable
		: public __is_nt_copy_assignable_impl<_Tp> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp, bool = __is_referenceable<_Tp>::value>
	struct __is_nt_move_assignable_impl;
	template <class _Tp>
	struct __is_nt_move_assignable_impl<_Tp, false> : public false_type {
	};
	template <class _Tp>
	struct __is_nt_move_assignable_impl<_Tp, true>
		: public __is_nothrow_assignable_impl<_Tp &, _Tp &&> {
	};
	template <class _Tp>
	struct is_nothrow_move_assignable
		: public __is_nt_move_assignable_impl<_Tp> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp, class... _Args>
	struct is_trivially_constructible
		: public __bool_constant<__is_trivially_constructible(
			  _Tp, _Args...)> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp>
	struct is_trivially_default_constructible
		: public __bool_constant<__is_trivially_constructible(_Tp)> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	struct __do_is_implicitly_default_constructible_impl {
		template <class _Tp> static void __helper(const _Tp &);
		template <class _Tp>
		static true_type
		__test(const _Tp &,
		       __decltype((__helper<const _Tp &>({}))) * = 0);
		static false_type __test(...);
	};
	template <class _Tp>
	struct __is_implicitly_default_constructible_impl
		: public __do_is_implicitly_default_constructible_impl {
		typedef __decltype((__test(declval<_Tp>()))) type;
	};
	template <class _Tp>
	struct __is_implicitly_default_constructible_safe
		: public __is_implicitly_default_constructible_impl<_Tp>::type {
	};
	template <class _Tp>
	struct __is_implicitly_default_constructible
		: public __and_<__is_constructible_impl<_Tp>,
				__is_implicitly_default_constructible_safe<_Tp>> {
	};
	template <class _Tp, bool = __is_referenceable<_Tp>::value>
	struct __is_trivially_copy_constructible_impl;
	template <class _Tp>
	struct __is_trivially_copy_constructible_impl<_Tp, false>
		: public false_type {
	};
	template <class _Tp>
	struct __is_trivially_copy_constructible_impl<_Tp, true>
		: public __and_<
			  __is_copy_constructible_impl<_Tp>,
			  integral_constant<bool, __is_trivially_constructible(
							  _Tp, const _Tp &)>> {
	};
	template <class _Tp>
	struct is_trivially_copy_constructible
		: public __is_trivially_copy_constructible_impl<_Tp> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp, bool = __is_referenceable<_Tp>::value>
	struct __is_trivially_move_constructible_impl;
	template <class _Tp>
	struct __is_trivially_move_constructible_impl<_Tp, false>
		: public false_type {
	};
	template <class _Tp>
	struct __is_trivially_move_constructible_impl<_Tp, true>
		: public __and_<
			  __is_move_constructible_impl<_Tp>,
			  integral_constant<bool, __is_trivially_constructible(
							  _Tp, _Tp &&)>> {
	};
	template <class _Tp>
	struct is_trivially_move_constructible
		: public __is_trivially_move_constructible_impl<_Tp> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp, class _Up>
	struct is_trivially_assignable
		: public __bool_constant<__is_trivially_assignable(_Tp, _Up)> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp, bool = __is_referenceable<_Tp>::value>
	struct __is_trivially_copy_assignable_impl;
	template <class _Tp>
	struct __is_trivially_copy_assignable_impl<_Tp, false>
		: public false_type {
	};
	template <class _Tp>
	struct __is_trivially_copy_assignable_impl<_Tp, true>
		: public __bool_constant<__is_trivially_assignable(
			  _Tp &, const _Tp &)> {
	};
	template <class _Tp>
	struct is_trivially_copy_assignable
		: public __is_trivially_copy_assignable_impl<_Tp> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp, bool = __is_referenceable<_Tp>::value>
	struct __is_trivially_move_assignable_impl;
	template <class _Tp>
	struct __is_trivially_move_assignable_impl<_Tp, false>
		: public false_type {
	};
	template <class _Tp>
	struct __is_trivially_move_assignable_impl<_Tp, true>
		: public __bool_constant<__is_trivially_assignable(_Tp &,
								   _Tp &&)> {
	};
	template <class _Tp>
	struct is_trivially_move_assignable
		: public __is_trivially_move_assignable_impl<_Tp> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp>
	struct is_trivially_destructible
		: public __and_<__is_destructible_safe<_Tp>,
				__bool_constant<__has_trivial_destructor(_Tp)>> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp>
	struct has_virtual_destructor
		: public integral_constant<bool, __has_virtual_destructor(_Tp)> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp>
	struct alignment_of
		: public integral_constant<unsigned long, __alignof__(_Tp)> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class>
	struct rank : public integral_constant<unsigned long, 0UL> {
	};
	template <class _Tp, size_t _Size>
	struct rank<_Tp[_Size]>
		: public integral_constant<unsigned long,
					   1 + std::rank<_Tp>::value> {
	};
	template <class _Tp>
	struct rank<_Tp[]>
		: public integral_constant<unsigned long,
					   1 + std::rank<_Tp>::value> {
	};
	template <class, unsigned _Uint>
	struct extent : public integral_constant<unsigned long, 0UL> {
	};
	template <class _Tp, unsigned _Uint, size_t _Size>
	struct extent<_Tp[_Size], _Uint>
		: public integral_constant<
			  unsigned long,
			  (_Uint == (0)) ? _Size :
					   std::extent<_Tp, _Uint - (1)>::value> {
	};
	template <class _Tp, unsigned _Uint>
	struct extent<_Tp[], _Uint>
		: public integral_constant<
			  unsigned long,
			  (_Uint == (0)) ? 0 :
					   std::extent<_Tp, _Uint - (1)>::value> {
	};
	template <class _Tp, class _Up>
	struct is_same : public integral_constant<bool, __is_same(_Tp, _Up)> {
	};
	template <class _Base, class _Derived>
	struct is_base_of
		: public integral_constant<bool, __is_base_of(_Base, _Derived)> {
	};
	template <class _From, class _To,
		  bool = __or_<is_void<_From>, is_function<_To>,
			       is_array<_To>>::value>
	struct __is_convertible_helper {
		typedef typename is_void<_To>::type type;
	};
	template <class _From, class _To>
	class __is_convertible_helper<_From, _To, false> {
		template <class _To1> static void __test_aux(_To1) noexcept;
		template <class _From1, class _To1,
			  class = __decltype((
				  __test_aux<_To1>(std::declval<_From1>())))>
		static true_type __test(int);
		template <class, class> static false_type __test(...);

	    public:
		typedef __decltype((__test<_From, _To>(0))) type;
	};
	template <class _From, class _To>
	struct is_convertible
		: public __is_convertible_helper<_From, _To>::type {
	};
	template <class _ToElementType, class _FromElementType>
	using __is_array_convertible =
		is_convertible<_FromElementType(*)[], _ToElementType(*)[]>;
	template <class _From, class _To,
		  bool = __or_<is_void<_From>, is_function<_To>,
			       is_array<_To>>::value>
	struct __is_nt_convertible_helper : public is_void<_To> {
	};
	template <class _From, class _To>
	class __is_nt_convertible_helper<_From, _To, false> {
		template <class _To1> static void __test_aux(_To1) noexcept;
		template <class _From1, class _To1>
		static __bool_constant<
			noexcept(__test_aux<_To1>(std::declval<_From1>()))>
		__test(int);
		template <class, class> static false_type __test(...);

	    public:
		using type = __decltype((__test<_From, _To>(0)));
	};
	template <class _From, class _To>
	struct __is_nothrow_convertible
		: public __is_nt_convertible_helper<_From, _To>::type {
	};
	template <class _Tp> struct remove_const {
		typedef _Tp type;
	};
	template <class _Tp> struct remove_const<const _Tp> {
		typedef _Tp type;
	};
	template <class _Tp> struct remove_volatile {
		typedef _Tp type;
	};
	template <class _Tp> struct remove_volatile<volatile _Tp> {
		typedef _Tp type;
	};
	template <class _Tp> struct remove_cv {
		using type = _Tp;
	};
	template <class _Tp> struct remove_cv<const _Tp> {
		using type = _Tp;
	};
	template <class _Tp> struct remove_cv<volatile _Tp> {
		using type = _Tp;
	};
	template <class _Tp> struct remove_cv<const volatile _Tp> {
		using type = _Tp;
	};
	template <class _Tp> struct add_const {
		typedef const _Tp type;
	};
	template <class _Tp> struct add_volatile {
		typedef volatile _Tp type;
	};
	template <class _Tp> struct add_cv {
		typedef typename add_const<
			typename add_volatile<_Tp>::type>::type type;
	};
	template <class _Tp>
	using remove_const_t = typename remove_const<_Tp>::type;
	template <class _Tp>
	using remove_volatile_t = typename remove_volatile<_Tp>::type;
	template <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;
	template <class _Tp> using add_const_t = typename add_const<_Tp>::type;
	template <class _Tp>
	using add_volatile_t = typename add_volatile<_Tp>::type;
	template <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;
	template <class _Tp> struct remove_reference {
		typedef _Tp type;
	};
	template <class _Tp> struct remove_reference<_Tp &> {
		typedef _Tp type;
	};
	template <class _Tp> struct remove_reference<_Tp &&> {
		typedef _Tp type;
	};
	template <class _Tp, bool = __is_referenceable<_Tp>::value>
	struct __add_lvalue_reference_helper {
		typedef _Tp type;
	};
	template <class _Tp> struct __add_lvalue_reference_helper<_Tp, true> {
		typedef _Tp &type;
	};
	template <class _Tp>
	struct add_lvalue_reference
		: public __add_lvalue_reference_helper<_Tp> {
	};
	template <class _Tp, bool = __is_referenceable<_Tp>::value>
	struct __add_rvalue_reference_helper {
		typedef _Tp type;
	};
	template <class _Tp> struct __add_rvalue_reference_helper<_Tp, true> {
		typedef _Tp &&type;
	};
	template <class _Tp>
	struct add_rvalue_reference
		: public __add_rvalue_reference_helper<_Tp> {
	};
	template <class _Tp>
	using remove_reference_t = typename remove_reference<_Tp>::type;
	template <class _Tp>
	using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;
	template <class _Tp>
	using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;
	template <class _Unqualified, bool _IsConst, bool _IsVol>
	struct __cv_selector;
	template <class _Unqualified>
	struct __cv_selector<_Unqualified, false, false> {
		typedef _Unqualified __type;
	};
	template <class _Unqualified>
	struct __cv_selector<_Unqualified, false, true> {
		typedef volatile _Unqualified __type;
	};
	template <class _Unqualified>
	struct __cv_selector<_Unqualified, true, false> {
		typedef const _Unqualified __type;
	};
	template <class _Unqualified>
	struct __cv_selector<_Unqualified, true, true> {
		typedef const volatile _Unqualified __type;
	};
	template <class _Qualified, class _Unqualified,
		  bool _IsConst = is_const<_Qualified>::value,
		  bool _IsVol = is_volatile<_Qualified>::value>
	class __match_cv_qualifiers {
		typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

	    public:
		typedef typename __cv_selector<_Unqualified, _IsConst,
					       _IsVol>::__type __type;
	};
	template <class _Tp> struct __make_unsigned {
		typedef _Tp __type;
	};
	template <> struct __make_unsigned<char> {
		typedef unsigned char __type;
	};
	template <> struct __make_unsigned<signed char> {
		typedef unsigned char __type;
	};
	template <> struct __make_unsigned<short> {
		typedef unsigned short __type;
	};
	template <> struct __make_unsigned<int> {
		typedef unsigned __type;
	};
	template <> struct __make_unsigned<long> {
		typedef unsigned long __type;
	};
	template <> struct __make_unsigned<long long> {
		typedef unsigned long long __type;
	};
	template <> struct __make_unsigned<__int128> {
		typedef unsigned __int128 __type;
	};
	template <class _Tp, bool _IsInt = is_integral<_Tp>::value,
		  bool _IsEnum = is_enum<_Tp>::value>
	class __make_unsigned_selector;
	template <class _Tp> class __make_unsigned_selector<_Tp, true, false> {
		using __unsigned_type =
			typename __make_unsigned<__remove_cv_t<_Tp>>::__type;

	    public:
		using __type =
			typename __match_cv_qualifiers<_Tp,
						       __unsigned_type>::__type;
	};
	class __make_unsigned_selector_base {
	    protected:
		template <class...> struct _List {
		};
		template <class _Tp, class... _Up>
		struct _List<_Tp, _Up...>
			: public __make_unsigned_selector_base::template _List<
				  _Up...> {
			static constexpr inline std::size_t __size =
				sizeof(_Tp);
		};
		template <size_t _Sz, class _Tp, bool = _Sz <= _Tp::__size>
		struct __select;
		template <size_t _Sz, class _Uint, class... _UInts>
		struct __select<_Sz, _List<_Uint, _UInts...>, true> {
			using __type = _Uint;
		};
		template <size_t _Sz, class _Uint, class... _UInts>
		struct __select<_Sz, _List<_Uint, _UInts...>, false>
			: public __make_unsigned_selector_base::
				  template __select<_Sz, _List<_UInts...>> {
		};
	};
	template <class _Tp>
	class __make_unsigned_selector<_Tp, false, true>
		: private __make_unsigned_selector_base {
		using _UInts = _List<unsigned char, unsigned short, unsigned,
				     unsigned long, unsigned long long>;
		using __unsigned_type = typename __select<
			sizeof(_Tp),
			_List<unsigned char, unsigned short, unsigned,
			      unsigned long, unsigned long long>>::__type;

	    public:
		using __type =
			typename __match_cv_qualifiers<_Tp,
						       __unsigned_type>::__type;
	};
	template <> struct __make_unsigned<wchar_t> {
		using __type =
			__make_unsigned_selector<wchar_t, false, true>::__type;
	};
	template <> struct __make_unsigned<char16_t> {
		using __type =
			__make_unsigned_selector<char16_t, false, true>::__type;
	};
	template <> struct __make_unsigned<char32_t> {
		using __type =
			__make_unsigned_selector<char32_t, false, true>::__type;
	};
	template <class _Tp> struct make_unsigned {
		typedef typename __make_unsigned_selector<_Tp>::__type type;
	};
	template <> struct make_unsigned<bool>;
	template <class _Tp> struct __make_signed {
		typedef _Tp __type;
	};
	template <> struct __make_signed<char> {
		typedef signed char __type;
	};
	template <> struct __make_signed<unsigned char> {
		typedef signed char __type;
	};
	template <> struct __make_signed<unsigned short> {
		typedef signed short __type;
	};
	template <> struct __make_signed<unsigned> {
		typedef signed int __type;
	};
	template <> struct __make_signed<unsigned long> {
		typedef signed long __type;
	};
	template <> struct __make_signed<unsigned long long> {
		typedef signed long long __type;
	};
	template <> struct __make_signed<unsigned __int128> {
		typedef __int128 __type;
	};
	template <class _Tp, bool _IsInt = is_integral<_Tp>::value,
		  bool _IsEnum = is_enum<_Tp>::value>
	class __make_signed_selector;
	template <class _Tp> class __make_signed_selector<_Tp, true, false> {
		using __signed_type =
			typename __make_signed<__remove_cv_t<_Tp>>::__type;

	    public:
		using __type =
			typename __match_cv_qualifiers<_Tp,
						       __signed_type>::__type;
	};
	template <class _Tp> class __make_signed_selector<_Tp, false, true> {
		typedef typename __make_unsigned_selector<_Tp>::__type
			__unsigned_type;

	    public:
		typedef typename std::__make_signed_selector<
			__unsigned_type>::__type __type;
	};
	template <> struct __make_signed<wchar_t> {
		using __type =
			__make_signed_selector<wchar_t, false, true>::__type;
	};
	template <> struct __make_signed<char16_t> {
		using __type =
			__make_signed_selector<char16_t, false, true>::__type;
	};
	template <> struct __make_signed<char32_t> {
		using __type =
			__make_signed_selector<char32_t, false, true>::__type;
	};
	template <class _Tp> struct make_signed {
		typedef typename __make_signed_selector<_Tp>::__type type;
	};
	template <> struct make_signed<bool>;
	template <class _Tp>
	using make_signed_t = typename make_signed<_Tp>::type;
	template <class _Tp>
	using make_unsigned_t = typename make_unsigned<_Tp>::type;
	template <class _Tp> struct remove_extent {
		typedef _Tp type;
	};
	template <class _Tp, size_t _Size> struct remove_extent<_Tp[_Size]> {
		typedef _Tp type;
	};
	template <class _Tp> struct remove_extent<_Tp[]> {
		typedef _Tp type;
	};
	template <class _Tp> struct remove_all_extents {
		typedef _Tp type;
	};
	template <class _Tp, size_t _Size>
	struct remove_all_extents<_Tp[_Size]> {
		typedef typename std::remove_all_extents<_Tp>::type type;
	};
	template <class _Tp> struct remove_all_extents<_Tp[]> {
		typedef typename std::remove_all_extents<_Tp>::type type;
	};
	template <class _Tp>
	using remove_extent_t = typename remove_extent<_Tp>::type;
	template <class _Tp>
	using remove_all_extents_t = typename remove_all_extents<_Tp>::type;
	template <class _Tp, class> struct __remove_pointer_helper {
		typedef _Tp type;
	};
	template <class _Tp, class _Up>
	struct __remove_pointer_helper<_Tp, _Up *> {
		typedef _Up type;
	};
	template <class _Tp>
	struct remove_pointer
		: public __remove_pointer_helper<_Tp, __remove_cv_t<_Tp>> {
	};
	template <class _Tp,
		  bool = __or_<__is_referenceable<_Tp>, is_void<_Tp>>::value>
	struct __add_pointer_helper {
		typedef _Tp type;
	};
	template <class _Tp> struct __add_pointer_helper<_Tp, true> {
		typedef typename remove_reference<_Tp>::type *type;
	};
	template <class _Tp>
	struct add_pointer : public __add_pointer_helper<_Tp> {
	};
	template <class _Tp>
	using remove_pointer_t = typename remove_pointer<_Tp>::type;
	template <class _Tp>
	using add_pointer_t = typename add_pointer<_Tp>::type;
	template <size_t _Len> struct __aligned_storage_msa {
		union __type {
			unsigned char __data[_Len];
			struct __attribute((__aligned__)) {
			} __align;
		};
	};
	template <size_t _Len,
		  size_t _Align = __alignof__(
			  typename __aligned_storage_msa<_Len>::__type)>
	struct aligned_storage {
		union type {
			unsigned char __data[_Len];
			struct __attribute((__aligned__(_Align))) {
			} __align;
		};
	};
	template <class... _Types> struct __strictest_alignment {
		static const size_t _S_alignment = (0);
		static const size_t _S_size = (0);
	};
	template <class _Tp, class... _Types>
	struct __strictest_alignment<_Tp, _Types...> {
		static const size_t _S_alignment =
			((__alignof__(_Tp) >
			  __strictest_alignment<_Types...>::_S_alignment) ?
				 __alignof__(_Tp) :
				 __strictest_alignment<_Types...>::_S_alignment);
		static const size_t _S_size =
			((sizeof(_Tp) >
			  __strictest_alignment<_Types...>::_S_size) ?
				 sizeof(_Tp) :
				 __strictest_alignment<_Types...>::_S_size);
	};
	template <size_t _Len, class... _Types> struct aligned_union {
		static_assert((sizeof...(_Types) != (0)),
			      "At least one type is required");

	    private:
		using __strictest = __strictest_alignment<_Types...>;
		static const size_t _S_len =
			((_Len > __strictest::_S_size) ? _Len :
							 __strictest::_S_size);

	    public:
		static const size_t alignment_value =
			(__strictest::_S_alignment);
		typedef typename aligned_storage<_S_len, alignment_value>::type
			type;
	};
	template <size_t _Len, class... _Types>
	const size_t aligned_union<_Len, _Types...>::alignment_value;
	template <class _Up, bool _IsArray = is_array<_Up>::value,
		  bool _IsFunction = is_function<_Up>::value>
	struct __decay_selector;
	template <class _Up> struct __decay_selector<_Up, false, false> {
		typedef __remove_cv_t<_Up> __type;
	};
	template <class _Up> struct __decay_selector<_Up, true, false> {
		typedef typename remove_extent<_Up>::type *__type;
	};
	template <class _Up> struct __decay_selector<_Up, false, true> {
		typedef typename add_pointer<_Up>::type __type;
	};
	template <class _Tp> class decay {
		typedef typename remove_reference<_Tp>::type __remove_type;

	    public:
		typedef typename __decay_selector<__remove_type>::__type type;
	};
	template <class _Tp> struct __strip_reference_wrapper {
		typedef _Tp __type;
	};
	template <class _Tp>
	struct __strip_reference_wrapper<reference_wrapper<_Tp>> {
		typedef _Tp &__type;
	};
	template <class _Tp> using __decay_t = typename decay<_Tp>::type;
	template <class _Tp>
	using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;
	template <bool, class _Tp = void> struct enable_if {
	};
	template <class _Tp> struct enable_if<true, _Tp> {
		typedef _Tp type;
	};
	template <bool _Cond, class _Tp = void>
	using __enable_if_t = typename enable_if<_Cond, _Tp>::type;
	template <class... _Cond>
	using _Require = __enable_if_t<__and_<_Cond...>::value>;
	template <class _Tp>
	using __remove_cvref_t =
		typename remove_cv<typename remove_reference<_Tp>::type>::type;
	template <bool _Cond, class _Iftrue, class _Iffalse>
	struct conditional {
		typedef _Iftrue type;
	};
	template <class _Iftrue, class _Iffalse>
	struct conditional<false, _Iftrue, _Iffalse> {
		typedef _Iffalse type;
	};
	template <class... _Tp> struct common_type;
	struct __do_common_type_impl {
		template <class _Tp, class _Up>
		using __cond_t = __decltype((true ? std::declval<_Tp>() :
						    std::declval<_Up>()));
		template <class _Tp, class _Up>
		static __success_type<__decay_t<__cond_t<_Tp, _Up>>>
		_S_test(int);
		template <class, class> static __failure_type _S_test_2(...);
		template <class _Tp, class _Up>
		static __decltype((_S_test_2<_Tp, _Up>(0))) _S_test(...);
	};
	template <> struct common_type<> {
	};
	template <class _Tp0>
	struct common_type<_Tp0> : public std::common_type<_Tp0, _Tp0> {
	};
	template <class _Tp1, class _Tp2, class _Dp1 = __decay_t<_Tp1>,
		  class _Dp2 = __decay_t<_Tp2>>
	struct __common_type_impl {
		using type = common_type<_Dp1, _Dp2>;
	};
	template <class _Tp1, class _Tp2>
	struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2>
		: private __do_common_type_impl {
		using type = __decltype((_S_test<_Tp1, _Tp2>(0)));
	};
	template <class _Tp1, class _Tp2>
	struct common_type<_Tp1, _Tp2>
		: public __common_type_impl<_Tp1, _Tp2>::type {
	};
	template <class...> struct __common_type_pack {
	};
	template <class, class, class = void> struct __common_type_fold;
	template <class _Tp1, class _Tp2, class... _Rp>
	struct common_type<_Tp1, _Tp2, _Rp...>
		: public __common_type_fold<std::common_type<_Tp1, _Tp2>,
					    __common_type_pack<_Rp...>> {
	};
	template <class _CTp, class... _Rp>
	struct __common_type_fold<_CTp, __common_type_pack<_Rp...>,
				  __void_t<typename _CTp::type>>
		: public common_type<typename _CTp::type, _Rp...> {
	};
	template <class _CTp, class _Rp>
	struct __common_type_fold<_CTp, _Rp, void> {
	};
	template <class _Tp, bool = is_enum<_Tp>::value>
	struct __underlying_type_impl {
		using type = __underlying_type(_Tp);
	};
	template <class _Tp> struct __underlying_type_impl<_Tp, false> {
	};
	template <class _Tp>
	struct underlying_type : public __underlying_type_impl<_Tp> {
	};
	template <class _Tp> struct __declval_protector {
		static const bool __stop = false;
	};
	template <class _Tp>
	auto declval() noexcept->__decltype((__declval<_Tp>(0)))
	{
		static_assert((__declval_protector<_Tp>::__stop),
			      "declval() must not be used!");
		return __declval<_Tp>(0);
	}
	template <class _Signature> struct result_of;
	struct __invoke_memfun_ref {};
	struct __invoke_memfun_deref {};
	struct __invoke_memobj_ref {};
	struct __invoke_memobj_deref {};
	struct __invoke_other {};
	template <class _Tp, class _Tag>
	struct __result_of_success : public __success_type<_Tp> {
		using __invoke_type = _Tag;
	};
	struct __result_of_memfun_ref_impl {
		template <class _Fp, class _Tp1, class... _Args>
		static __result_of_success<__decltype(((std::declval<_Tp1>().*
							std::declval<_Fp>())(
						   std::declval<_Args>()...))),
					   __invoke_memfun_ref>
		_S_test(int);
		template <class...> static __failure_type _S_test(...);
	};
	template <class _MemPtr, class _Arg, class... _Args>
	struct __result_of_memfun_ref : private __result_of_memfun_ref_impl {
		typedef __decltype((_S_test<_MemPtr, _Arg, _Args...>(0))) type;
	};
	struct __result_of_memfun_deref_impl {
		template <class _Fp, class _Tp1, class... _Args>
		static __result_of_success<__decltype((((*std::declval<_Tp1>()).*
							std::declval<_Fp>())(
						   std::declval<_Args>()...))),
					   __invoke_memfun_deref>
		_S_test(int);
		template <class...> static __failure_type _S_test(...);
	};
	template <class _MemPtr, class _Arg, class... _Args>
	struct __result_of_memfun_deref
		: private __result_of_memfun_deref_impl {
		typedef __decltype((_S_test<_MemPtr, _Arg, _Args...>(0))) type;
	};
	struct __result_of_memobj_ref_impl {
		template <class _Fp, class _Tp1>
		static __result_of_success<__decltype((std::declval<_Tp1>().*
						       std::declval<_Fp>())),
					   __invoke_memobj_ref>
		_S_test(int);
		template <class, class> static __failure_type _S_test(...);
	};
	template <class _MemPtr, class _Arg>
	struct __result_of_memobj_ref : private __result_of_memobj_ref_impl {
		typedef __decltype((_S_test<_MemPtr, _Arg>(0))) type;
	};
	struct __result_of_memobj_deref_impl {
		template <class _Fp, class _Tp1>
		static __result_of_success<__decltype(((*std::declval<_Tp1>()).*
						       std::declval<_Fp>())),
					   __invoke_memobj_deref>
		_S_test(int);
		template <class, class> static __failure_type _S_test(...);
	};
	template <class _MemPtr, class _Arg>
	struct __result_of_memobj_deref
		: private __result_of_memobj_deref_impl {
		typedef __decltype((_S_test<_MemPtr, _Arg>(0))) type;
	};
	template <class _MemPtr, class _Arg> struct __result_of_memobj;
	template <class _Res, class _Class, class _Arg>
	struct __result_of_memobj<_Res(_Class::*), _Arg> {
		typedef __remove_cvref_t<_Arg> _Argval;
		typedef _Res(_Class::*_MemPtr);
		typedef typename __conditional_t<
			__or_<is_same<_Argval, _Class>,
			      is_base_of<_Class, _Argval>>::value,
			__result_of_memobj_ref<_MemPtr, _Arg>,
			__result_of_memobj_deref<_MemPtr, _Arg>>::type type;
	};
	template <class _MemPtr, class _Arg, class... _Args>
	struct __result_of_memfun;
	template <class _Res, class _Class, class _Arg, class... _Args>
	struct __result_of_memfun<_Res(_Class::*), _Arg, _Args...> {
		typedef typename remove_reference<_Arg>::type _Argval;
		typedef _Res(_Class::*_MemPtr);
		typedef typename __conditional_t<
			is_base_of<_Class, _Argval>::value,
			__result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
			__result_of_memfun_deref<_MemPtr, _Arg, _Args...>>::type
			type;
	};
	template <class _Tp, class _Up = __remove_cvref_t<_Tp>>
	struct __inv_unwrap {
		using type = _Tp;
	};
	template <class _Tp, class _Up>
	struct __inv_unwrap<_Tp, reference_wrapper<_Up>> {
		using type = _Up &;
	};
	template <bool, bool, class _Functor, class... _ArgTypes>
	struct __result_of_impl {
		typedef __failure_type type;
	};
	template <class _MemPtr, class _Arg>
	struct __result_of_impl<true, false, _MemPtr, _Arg>
		: public __result_of_memobj<__decay_t<_MemPtr>,
					    typename __inv_unwrap<_Arg>::type> {
	};
	template <class _MemPtr, class _Arg, class... _Args>
	struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
		: public __result_of_memfun<__decay_t<_MemPtr>,
					    typename __inv_unwrap<_Arg>::type,
					    _Args...> {
	};
	struct __result_of_other_impl {
		template <class _Fn, class... _Args>
		static __result_of_success<__decltype((std::declval<_Fn>()(
						   std::declval<_Args>()...))),
					   __invoke_other>
		_S_test(int);
		template <class...> static __failure_type _S_test(...);
	};
	template <class _Functor, class... _ArgTypes>
	struct __result_of_impl<false, false, _Functor, _ArgTypes...>
		: private __result_of_other_impl {
		typedef __decltype((_S_test<_Functor, _ArgTypes...>(0))) type;
	};
	template <class _Functor, class... _ArgTypes>
	struct __invoke_result
		: public __result_of_impl<
			  is_member_object_pointer<typename remove_reference<
				  _Functor>::type>::value,
			  is_member_function_pointer<typename remove_reference<
				  _Functor>::type>::value,
			  _Functor, _ArgTypes...>::type {
	};
	template <class _Functor, class... _ArgTypes>
	struct result_of<_Functor(_ArgTypes...)>
		: public __invoke_result<_Functor, _ArgTypes...> {
	} __attribute((__deprecated__("use \'std::invoke_result\' instead")));
	template <size_t _Len,
		  size_t _Align = __alignof__(
			  typename __aligned_storage_msa<_Len>::__type)>
	using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
	template <size_t _Len, class... _Types>
	using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
	template <class _Tp> using decay_t = typename decay<_Tp>::type;
	template <bool _Cond, class _Tp = void>
	using enable_if_t = typename enable_if<_Cond, _Tp>::type;
	template <bool _Cond, class _Iftrue, class _Iffalse>
	using conditional_t =
		typename conditional<_Cond, _Iftrue, _Iffalse>::type;
	template <class... _Tp>
	using common_type_t = typename common_type<_Tp...>::type;
	template <class _Tp>
	using underlying_type_t = typename underlying_type<_Tp>::type;
	template <class _Tp> using result_of_t = typename result_of<_Tp>::type;
	template <class...> using void_t = void;
	template <class _Default, class _AlwaysVoid,
		  template <class...> class _Op, class... _Args>
	struct __detector {
		using value_t = false_type;
		using type = _Default;
	};
	template <class _Default, template <class...> class _Op, class... _Args>
	struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...> {
		using value_t = true_type;
		using type = _Op<_Args...>;
	};
	template <class _Default, template <class...> class _Op, class... _Args>
	using __detected_or = __detector<_Default, void, _Op, _Args...>;
	template <class _Default, template <class...> class _Op, class... _Args>
	using __detected_or_t =
		typename __detected_or<_Default, _Op, _Args...>::type;
	template <class _Tp> struct __is_swappable;
	template <class _Tp> struct __is_nothrow_swappable;
	template <class> struct __is_tuple_like_impl : public false_type {
	};
	template <class _Tp>
	struct __is_tuple_like
		: public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type {
	};
	template <class _Tp>
	inline _Require<__not_<__is_tuple_like<_Tp>>,
			is_move_constructible<_Tp>, is_move_assignable<_Tp>>
	swap(_Tp &,
	     _Tp &) noexcept(__and_<is_nothrow_move_constructible<_Tp>,
				    is_nothrow_move_assignable<_Tp>>::value);
	template <class _Tp, size_t _Nm>
	inline __enable_if_t<__is_swappable<_Tp>::value> swap(
		_Tp(&__a)[_Nm],
		_Tp(&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::value);
	namespace __swappable_details
	{
	using std::swap;
	struct __do_is_swappable_impl {
		template <class _Tp,
			  class = __decltype((swap(std::declval<_Tp &>(),
						   std::declval<_Tp &>())))>
		static true_type __test(int);
		template <class> static false_type __test(...);
	};
	struct __do_is_nothrow_swappable_impl {
		template <class _Tp>
		static __bool_constant<noexcept(swap(std::declval<_Tp &>(),
						     std::declval<_Tp &>()))>
		__test(int);
		template <class> static false_type __test(...);
	};
	} // namespace __swappable_details
	template <class _Tp>
	struct __is_swappable_impl
		: public __swappable_details::__do_is_swappable_impl {
		typedef __decltype((__test<_Tp>(0))) type;
	};
	template <class _Tp>
	struct __is_nothrow_swappable_impl
		: public __swappable_details::__do_is_nothrow_swappable_impl {
		typedef __decltype((__test<_Tp>(0))) type;
	};
	template <class _Tp>
	struct __is_swappable : public __is_swappable_impl<_Tp>::type {
	};
	template <class _Tp>
	struct __is_nothrow_swappable
		: public __is_nothrow_swappable_impl<_Tp>::type {
	};
	template <class _Tp>
	struct is_swappable : public __is_swappable_impl<_Tp>::type {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp>
	struct is_nothrow_swappable
		: public __is_nothrow_swappable_impl<_Tp>::type {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp>
	constexpr inline bool is_swappable_v = (is_swappable<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_nothrow_swappable_v =
		(is_nothrow_swappable<_Tp>::value);
	namespace __swappable_with_details
	{
	using std::swap;
	struct __do_is_swappable_with_impl {
		template <class _Tp, class _Up,
			  class = __decltype((swap(std::declval<_Tp>(),
						   std::declval<_Up>()))),
			  class = __decltype((swap(std::declval<_Up>(),
						   std::declval<_Tp>())))>
		static true_type __test(int);
		template <class, class> static false_type __test(...);
	};
	struct __do_is_nothrow_swappable_with_impl {
		template <class _Tp, class _Up>
		static __bool_constant<
			noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()))
				&&noexcept(swap(std::declval<_Up>(),
						std::declval<_Tp>()))>
		__test(int);
		template <class, class> static false_type __test(...);
	};
	} // namespace __swappable_with_details
	template <class _Tp, class _Up>
	struct __is_swappable_with_impl
		: public __swappable_with_details::__do_is_swappable_with_impl {
		typedef __decltype((__test<_Tp, _Up>(0))) type;
	};
	template <class _Tp>
	struct __is_swappable_with_impl<_Tp &, _Tp &>
		: public __swappable_details::__do_is_swappable_impl {
		typedef __decltype((__test<_Tp &>(0))) type;
	};
	template <class _Tp, class _Up>
	struct __is_nothrow_swappable_with_impl
		: public __swappable_with_details::
			  __do_is_nothrow_swappable_with_impl {
		typedef __decltype((__test<_Tp, _Up>(0))) type;
	};
	template <class _Tp>
	struct __is_nothrow_swappable_with_impl<_Tp &, _Tp &>
		: public __swappable_details::__do_is_nothrow_swappable_impl {
		typedef __decltype((__test<_Tp &>(0))) type;
	};
	template <class _Tp, class _Up>
	struct is_swappable_with
		: public __is_swappable_with_impl<_Tp, _Up>::type {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"first template argument must be a complete class or an unbounded array");
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Up>{})),
			"second template argument must be a complete class or an unbounded array");
	};
	template <class _Tp, class _Up>
	struct is_nothrow_swappable_with
		: public __is_nothrow_swappable_with_impl<_Tp, _Up>::type {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"first template argument must be a complete class or an unbounded array");
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Up>{})),
			"second template argument must be a complete class or an unbounded array");
	};
	template <class _Tp, class _Up>
	constexpr inline bool is_swappable_with_v =
		(is_swappable_with<_Tp, _Up>::value);
	template <class _Tp, class _Up>
	constexpr inline bool is_nothrow_swappable_with_v =
		(is_nothrow_swappable_with<_Tp, _Up>::value);
	template <class _Result, class _Ret, bool = is_void<_Ret>::value,
		  class = void>
	struct __is_invocable_impl : public false_type {
	};
	template <class _Result, class _Ret>
	struct __is_invocable_impl<_Result, _Ret, true,
				   __void_t<typename _Result::type>>
		: public true_type {
	};
	template <class _Result, class _Ret>
	struct __is_invocable_impl<_Result, _Ret, false,
				   __void_t<typename _Result::type>> {
	    private:
		static typename _Result::type _S_get();
		template <class _Tp> static void _S_conv(_Tp);
		template <class _Tp,
			  class = __decltype((_S_conv<_Tp>((_S_get)())))>
		static true_type _S_test(int);
		template <class _Tp> static false_type _S_test(...);

	    public:
		using type = __decltype((_S_test<_Ret>(1)));
	};
	template <class _Fn, class... _ArgTypes>
	struct __is_invocable
		: public __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>,
					     void>::type {
	};
	template <class _Fn, class _Tp, class... _Args>
	constexpr bool __call_is_nt(__invoke_memfun_ref)
	{
		using _Up = typename __inv_unwrap<_Tp>::type;
		return noexcept(
			(std::declval<typename __inv_unwrap<_Tp>::type>().*
			 std::declval<_Fn>())(std::declval<_Args>()...));
	}
	template <class _Fn, class _Tp, class... _Args>
	constexpr bool __call_is_nt(__invoke_memfun_deref)
	{
		return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
			std::declval<_Args>()...));
	}
	template <class _Fn, class _Tp>
	constexpr bool __call_is_nt(__invoke_memobj_ref)
	{
		using _Up = typename __inv_unwrap<_Tp>::type;
		return noexcept(
			(std::declval<typename __inv_unwrap<_Tp>::type>().*
			 std::declval<_Fn>()));
	}
	template <class _Fn, class _Tp>
	constexpr bool __call_is_nt(__invoke_memobj_deref)
	{
		return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>()));
	}
	template <class _Fn, class... _Args>
	constexpr bool __call_is_nt(__invoke_other)
	{
		return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
	}
	template <class _Result, class _Fn, class... _Args>
	struct __call_is_nothrow
		: public __bool_constant<std::__call_is_nt<_Fn, _Args...>(
			  typename _Result::__invoke_type{})> {
	};
	template <class _Fn, class... _Args>
	using __call_is_nothrow_ =
		__call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;
	template <class _Fn, class... _Args>
	struct __is_nothrow_invocable
		: public __and_<__is_invocable<_Fn, _Args...>,
				__call_is_nothrow_<_Fn, _Args...>>::type {
	};
	struct __nonesuchbase {};
	struct __nonesuch : private __nonesuchbase {
		~__nonesuch() = delete;
		__nonesuch(const __nonesuch &) = delete;
		void operator=(const __nonesuch &) = delete;
	};
	template <class _Functor, class... _ArgTypes>
	struct invoke_result : public __invoke_result<_Functor, _ArgTypes...> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Functor>{})),
			"_Functor must be a complete class or an unbounded array");
		static_assert(
			((std::__is_complete_or_unbounded(
				  __type_identity<_ArgTypes>{}) &&
			  ...)),
			"each argument type must be a complete class or an unbounded array");
	};
	template <class _Fn, class... _Args>
	using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;
	template <class _Fn, class... _ArgTypes>
	struct is_invocable
		: public __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>,
					     void>::type {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Fn>{})),
			"_Fn must be a complete class or an unbounded array");
		static_assert(
			((std::__is_complete_or_unbounded(
				  __type_identity<_ArgTypes>{}) &&
			  ...)),
			"each argument type must be a complete class or an unbounded array");
	};
	template <class _Ret, class _Fn, class... _ArgTypes>
	struct is_invocable_r
		: public __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>,
					     _Ret>::type {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Fn>{})),
			"_Fn must be a complete class or an unbounded array");
		static_assert(
			((std::__is_complete_or_unbounded(
				  __type_identity<_ArgTypes>{}) &&
			  ...)),
			"each argument type must be a complete class or an unbounded array");
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Ret>{})),
			"_Ret must be a complete class or an unbounded array");
	};
	template <class _Fn, class... _ArgTypes>
	struct is_nothrow_invocable
		: public __and_<__is_invocable_impl<
					__invoke_result<_Fn, _ArgTypes...>, void>,
				__call_is_nothrow_<_Fn, _ArgTypes...>>::type {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Fn>{})),
			"_Fn must be a complete class or an unbounded array");
		static_assert(
			((std::__is_complete_or_unbounded(
				  __type_identity<_ArgTypes>{}) &&
			  ...)),
			"each argument type must be a complete class or an unbounded array");
	};
	template <class _Result, class _Ret, class = void>
	struct __is_nt_invocable_impl : public false_type {
	};
	template <class _Result, class _Ret>
	struct __is_nt_invocable_impl<_Result, _Ret,
				      __void_t<typename _Result::type>>
		: public __or_<is_void<_Ret>,
			       __is_nothrow_convertible<typename _Result::type,
							_Ret>> {
	};
	template <class _Ret, class _Fn, class... _ArgTypes>
	struct is_nothrow_invocable_r
		: public __and_<__is_nt_invocable_impl<
					__invoke_result<_Fn, _ArgTypes...>, _Ret>,
				__call_is_nothrow_<_Fn, _ArgTypes...>>::type {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Fn>{})),
			"_Fn must be a complete class or an unbounded array");
		static_assert(
			((std::__is_complete_or_unbounded(
				  __type_identity<_ArgTypes>{}) &&
			  ...)),
			"each argument type must be a complete class or an unbounded array");
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Ret>{})),
			"_Ret must be a complete class or an unbounded array");
	};
	template <class _Tp>
	constexpr inline bool is_void_v = (is_void<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_null_pointer_v = (is_null_pointer<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_integral_v = (is_integral<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_floating_point_v =
		(is_floating_point<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_array_v = (is_array<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_pointer_v = (is_pointer<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_lvalue_reference_v =
		(is_lvalue_reference<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_rvalue_reference_v =
		(is_rvalue_reference<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_member_object_pointer_v =
		(is_member_object_pointer<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_member_function_pointer_v =
		(is_member_function_pointer<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_enum_v = (is_enum<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_union_v = (is_union<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_class_v = (is_class<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_function_v = (is_function<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_reference_v = (is_reference<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_arithmetic_v = (is_arithmetic<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_fundamental_v = (is_fundamental<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_object_v = (is_object<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_scalar_v = (is_scalar<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_compound_v = (is_compound<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_member_pointer_v =
		(is_member_pointer<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_const_v = (is_const<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_volatile_v = (is_volatile<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_trivial_v = (is_trivial<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_trivially_copyable_v =
		(is_trivially_copyable<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_standard_layout_v =
		(is_standard_layout<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_pod_v = (is_pod<_Tp>::value);
	template <class _Tp>
	[[__deprecated__]] constexpr inline bool is_literal_type_v =
		(is_literal_type<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_empty_v = (is_empty<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_polymorphic_v = (is_polymorphic<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_abstract_v = (is_abstract<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_final_v = (is_final<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_signed_v = (is_signed<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_unsigned_v = (is_unsigned<_Tp>::value);
	template <class _Tp, class... _Args>
	constexpr inline bool is_constructible_v =
		(is_constructible<_Tp, _Args...>::value);
	template <class _Tp>
	constexpr inline bool is_default_constructible_v =
		(is_default_constructible<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_copy_constructible_v =
		(is_copy_constructible<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_move_constructible_v =
		(is_move_constructible<_Tp>::value);
	template <class _Tp, class _Up>
	constexpr inline bool is_assignable_v =
		(is_assignable<_Tp, _Up>::value);
	template <class _Tp>
	constexpr inline bool is_copy_assignable_v =
		(is_copy_assignable<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_move_assignable_v =
		(is_move_assignable<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_destructible_v = (is_destructible<_Tp>::value);
	template <class _Tp, class... _Args>
	constexpr inline bool is_trivially_constructible_v =
		(is_trivially_constructible<_Tp, _Args...>::value);
	template <class _Tp>
	constexpr inline bool is_trivially_default_constructible_v =
		(is_trivially_default_constructible<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_trivially_copy_constructible_v =
		(is_trivially_copy_constructible<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_trivially_move_constructible_v =
		(is_trivially_move_constructible<_Tp>::value);
	template <class _Tp, class _Up>
	constexpr inline bool is_trivially_assignable_v =
		(is_trivially_assignable<_Tp, _Up>::value);
	template <class _Tp>
	constexpr inline bool is_trivially_copy_assignable_v =
		(is_trivially_copy_assignable<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_trivially_move_assignable_v =
		(is_trivially_move_assignable<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_trivially_destructible_v =
		(is_trivially_destructible<_Tp>::value);
	template <class _Tp, class... _Args>
	constexpr inline bool is_nothrow_constructible_v =
		(is_nothrow_constructible<_Tp, _Args...>::value);
	template <class _Tp>
	constexpr inline bool is_nothrow_default_constructible_v =
		(is_nothrow_default_constructible<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_nothrow_copy_constructible_v =
		(is_nothrow_copy_constructible<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_nothrow_move_constructible_v =
		(is_nothrow_move_constructible<_Tp>::value);
	template <class _Tp, class _Up>
	constexpr inline bool is_nothrow_assignable_v =
		(is_nothrow_assignable<_Tp, _Up>::value);
	template <class _Tp>
	constexpr inline bool is_nothrow_copy_assignable_v =
		(is_nothrow_copy_assignable<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_nothrow_move_assignable_v =
		(is_nothrow_move_assignable<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_nothrow_destructible_v =
		(is_nothrow_destructible<_Tp>::value);
	template <class _Tp>
	constexpr inline bool has_virtual_destructor_v =
		(has_virtual_destructor<_Tp>::value);
	template <class _Tp>
	constexpr inline size_t alignment_of_v = (alignment_of<_Tp>::value);
	template <class _Tp>
	constexpr inline size_t rank_v = (rank<_Tp>::value);
	template <class _Tp, unsigned _Idx = 0U>
	constexpr inline size_t extent_v = (extent<_Tp, _Idx>::value);
	template <class _Tp, class _Up>
	constexpr inline bool is_same_v = __is_same(_Tp, _Up);
	template <class _Base, class _Derived>
	constexpr inline bool is_base_of_v =
		(is_base_of<_Base, _Derived>::value);
	template <class _From, class _To>
	constexpr inline bool is_convertible_v =
		(is_convertible<_From, _To>::value);
	template <class _Fn, class... _Args>
	constexpr inline bool is_invocable_v =
		(is_invocable<_Fn, _Args...>::value);
	template <class _Fn, class... _Args>
	constexpr inline bool is_nothrow_invocable_v =
		(is_nothrow_invocable<_Fn, _Args...>::value);
	template <class _Ret, class _Fn, class... _Args>
	constexpr inline bool is_invocable_r_v =
		(is_invocable_r<_Ret, _Fn, _Args...>::value);
	template <class _Ret, class _Fn, class... _Args>
	constexpr inline bool is_nothrow_invocable_r_v =
		(is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value);
	template <class _Tp>
	struct has_unique_object_representations
		: public bool_constant<__has_unique_object_representations(
			  remove_cv_t<remove_all_extents_t<_Tp>>)> {
		static_assert(
			(std::__is_complete_or_unbounded(
				__type_identity<_Tp>{})),
			"template argument must be a complete class or an unbounded array");
	};
	template <class _Tp>
	constexpr inline bool has_unique_object_representations_v =
		(has_unique_object_representations<_Tp>::value);
	template <class _Tp>
	struct is_aggregate
		: public bool_constant<__is_aggregate(remove_cv_t<_Tp>)> {
	};
	template <class _Tp>
	constexpr inline bool is_aggregate_v = (is_aggregate<_Tp>::value);
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _Tp> constexpr _Tp *__addressof(_Tp & __r) noexcept
	{
		return __builtin_addressof(__r);
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _Tp>
	[[__nodiscard__]] constexpr _Tp &&forward(
		typename remove_reference<_Tp>::type & __t) noexcept
	{
		return static_cast<_Tp &&>(__t);
	}
	template <class _Tp>
	[[__nodiscard__]] constexpr _Tp &&forward(
		typename remove_reference<_Tp>::type && __t) noexcept
	{
		static_assert(
			(!std::template is_lvalue_reference<_Tp>::value),
			"std::forward must not be used to convert an rvalue to an lvalue");
		return static_cast<_Tp &&>(__t);
	}
	template <class _Tp>
	[[__nodiscard__]] constexpr typename remove_reference<_Tp>::type &&move(
		_Tp && __t) noexcept
	{
		return static_cast<typename remove_reference<_Tp>::type &&>(
			__t);
	}
	template <class _Tp>
	struct __move_if_noexcept_cond
		: public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
				is_copy_constructible<_Tp>>::type {
	};
	template <class _Tp>
	[[__nodiscard__]] constexpr __conditional_t<
		__move_if_noexcept_cond<_Tp>::value, const _Tp &, _Tp &&>
	move_if_noexcept(_Tp & __x) noexcept
	{
		return std::move(__x);
	}
	template <class _Tp>
	[[__nodiscard__]] constexpr _Tp *addressof(_Tp & __r) noexcept
	{
		return std::__addressof(__r);
	}
	template <typename _Tp> const _Tp *addressof(const _Tp &&) = delete;
	template <class _Tp, class _Up = _Tp>
	inline _Tp __exchange(_Tp & __obj, _Up && __new_val)
	{
		_Tp __old_val = std::move(__obj);
		__obj = std::forward<_Up>(__new_val);
		return __old_val;
	}
	template <class _Tp>
	inline typename enable_if<
		__and_<__not_<__is_tuple_like<_Tp>>, is_move_constructible<_Tp>,
		       is_move_assignable<_Tp>>::value>::type
	swap(_Tp & __a,
	     _Tp & __b) noexcept(__and_<is_nothrow_move_constructible<_Tp>,
					is_nothrow_move_assignable<_Tp>>::value)
	{
		_Tp __tmp = std::move(__a);
		__a = std::move(__b);
		__b = std::move(__tmp);
	}
	template <class _Tp, size_t _Nm>
	inline typename enable_if<__is_swappable<_Tp>::value>::type swap(
		_Tp(&__a)[_Nm],
		_Tp(&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::value)
	{
		for (size_t __n = (0); __n < _Nm; ++__n) {
			swap(__a[__n], __b[__n]);
		}
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _Tp> struct tuple_size;
	template <class _Tp, class _Up = typename remove_cv<_Tp>::type,
		  class = typename enable_if<is_same<_Tp, _Up>::value>::type,
		  size_t = tuple_size<_Tp>::value>
	using __enable_if_has_tuple_size = _Tp;
	template <class _Tp>
	struct tuple_size<const __enable_if_has_tuple_size<_Tp>>
		: public std::tuple_size<_Tp> {
	};
	template <class _Tp>
	struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>>
		: public std::tuple_size<_Tp> {
	};
	template <class _Tp>
	struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>>
		: public std::tuple_size<_Tp> {
	};
	template <class _Tp>
	constexpr inline size_t tuple_size_v = (tuple_size<_Tp>::value);
	template <size_t __i, class _Tp> struct tuple_element;
	template <size_t __i, class _Tp>
	using __tuple_element_t = typename tuple_element<__i, _Tp>::type;
	template <size_t __i, class _Tp> struct tuple_element<__i, const _Tp> {
		typedef typename add_const<__tuple_element_t<__i, _Tp>>::type
			type;
	};
	template <size_t __i, class _Tp>
	struct tuple_element<__i, volatile _Tp> {
		typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type
			type;
	};
	template <size_t __i, class _Tp>
	struct tuple_element<__i, const volatile _Tp> {
		typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
	};
	template <class _Tp, class... _Types>
	constexpr size_t __find_uniq_type_in_pack()
	{
		constexpr size_t __sz = sizeof...(_Types);
		constexpr bool __found[__sz] = { __is_same(_Tp, _Types)... };
		size_t __n = __sz;
		for (size_t __i = (0); __i < __sz; ++__i) {
			if (__found[__i]) {
				if (__n < __sz) {
					return __sz;
				}
				__n = __i;
			}
		}
		return __n;
	}
	template <size_t __i, class _Tp>
	using tuple_element_t = typename tuple_element<__i, _Tp>::type;
	template <size_t... _Indexes> struct _Index_tuple {
	};
	template <size_t _Num> struct _Build_index_tuple {
		using __type = _Index_tuple<__integer_pack(_Num)...>;
	};
	template <class _Tp, _Tp... _Idx> struct integer_sequence {
		typedef _Tp value_type;
		static constexpr size_t size() noexcept
		{
			return sizeof...(_Idx);
		}
	};
	template <class _Tp, _Tp _Num>
	using make_integer_sequence =
		integer_sequence<_Tp, __integer_pack(_Num)...>;
	template <size_t... _Idx>
	using index_sequence = integer_sequence<unsigned long, _Idx...>;
	template <size_t _Num>
	using make_index_sequence = make_integer_sequence<unsigned long, _Num>;
	template <class... _Types>
	using index_sequence_for = make_index_sequence<sizeof...(_Types)>;
	struct in_place_t {
		explicit in_place_t() = default;
	};
	constexpr inline in_place_t in_place{};
	template <class _Tp> struct in_place_type_t {
		explicit in_place_type_t() = default;
	};
	template <class _Tp>
	constexpr inline in_place_type_t<_Tp> in_place_type{};
	template <size_t _Idx> struct in_place_index_t {
		explicit in_place_index_t() = default;
	};
	template <size_t _Idx>
	constexpr inline in_place_index_t<_Idx> in_place_index{};
	template <class> constexpr inline bool __is_in_place_type_v = false;
	template <class _Tp>
	constexpr inline bool __is_in_place_type_v<in_place_type_t<_Tp>> = true;
	template <class _Tp>
	using __is_in_place_type = bool_constant<__is_in_place_type_v<_Tp>>;
	template <size_t _Np, class... _Types> struct _Nth_type {
	};
	template <class _Tp0, class... _Rest>
	struct _Nth_type<0, _Tp0, _Rest...> {
		using type = _Tp0;
	};
	template <class _Tp0, class _Tp1, class... _Rest>
	struct _Nth_type<1, _Tp0, _Tp1, _Rest...> {
		using type = _Tp1;
	};
	template <class _Tp0, class _Tp1, class _Tp2, class... _Rest>
	struct _Nth_type<2, _Tp0, _Tp1, _Tp2, _Rest...> {
		using type = _Tp2;
	};
	template <size_t _Np, class _Tp0, class _Tp1, class _Tp2, class... _Rest>
	struct _Nth_type<_Np, _Tp0, _Tp1, _Tp2, _Rest...>
		: public std::_Nth_type<_Np - (3), _Rest...> {
	};
	template <class _Tp0, class _Tp1, class... _Rest>
	struct _Nth_type<0, _Tp0, _Tp1, _Rest...> {
		using type = _Tp0;
	};
	template <class _Tp0, class _Tp1, class _Tp2, class... _Rest>
	struct _Nth_type<0, _Tp0, _Tp1, _Tp2, _Rest...> {
		using type = _Tp0;
	};
	template <class _Tp0, class _Tp1, class _Tp2, class... _Rest>
	struct _Nth_type<1, _Tp0, _Tp1, _Tp2, _Rest...> {
		using type = _Tp1;
	};
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	struct piecewise_construct_t {
		explicit piecewise_construct_t() = default;
	};
	constexpr inline piecewise_construct_t piecewise_construct =
		piecewise_construct_t();
	template <class...> class tuple;
	template <size_t...> struct _Index_tuple;
	template <bool, class _T1, class _T2> struct _PCC {
		template <class _U1, class _U2>
		static constexpr bool _ConstructiblePair()
		{
			return __and_<is_constructible<_T1, const _U1 &>,
				      is_constructible<_T2, const _U2 &>>::value;
		}
		template <class _U1, class _U2>
		static constexpr bool _ImplicitlyConvertiblePair()
		{
			return __and_<is_convertible<const _U1 &, _T1>,
				      is_convertible<const _U2 &, _T2>>::value;
		}
		template <class _U1, class _U2>
		static constexpr bool _MoveConstructiblePair()
		{
			return __and_<is_constructible<_T1, _U1 &&>,
				      is_constructible<_T2, _U2 &&>>::value;
		}
		template <class _U1, class _U2>
		static constexpr bool _ImplicitlyMoveConvertiblePair()
		{
			return __and_<is_convertible<_U1 &&, _T1>,
				      is_convertible<_U2 &&, _T2>>::value;
		}
	};
	template <class _T1, class _T2> struct _PCC<false, _T1, _T2> {
		template <class _U1, class _U2>
		static constexpr bool _ConstructiblePair()
		{
			return false;
		}
		template <class _U1, class _U2>
		static constexpr bool _ImplicitlyConvertiblePair()
		{
			return false;
		}
		template <class _U1, class _U2>
		static constexpr bool _MoveConstructiblePair()
		{
			return false;
		}
		template <class _U1, class _U2>
		static constexpr bool _ImplicitlyMoveConvertiblePair()
		{
			return false;
		}
	};
	template <class _U1, class _U2> class __pair_base {
		template <class _T1, class _T2> friend struct pair;
		__pair_base() = default;
		~__pair_base() = default;
		__pair_base(const __pair_base &) = default;
		__pair_base &operator=(const __pair_base &) = delete;
	};
	template <class _T1, class _T2>
	struct pair : public __pair_base<_T1, _T2> {
		typedef _T1 first_type;
		typedef _T2 second_type;
		_T1 first;
		_T2 second;
		constexpr pair(const pair &) = default;
		constexpr pair(pair &&) = default;
		template <class... _Args1, class... _Args2>
		pair(std::piecewise_construct_t, tuple<_Args1...>,
		     tuple<_Args2...>);
		void swap(pair &__p) noexcept(
			__and_<__is_nothrow_swappable<_T1>,
			       __is_nothrow_swappable<_T2>>::value)
		{
			using std::swap;
			swap(first, __p.first);
			swap(second, __p.second);
		}

	    private:
		template <class... _Args1, std::size_t... _Indexes1,
			  class... _Args2, std::size_t... _Indexes2>
		pair(tuple<_Args1...> &, tuple<_Args2...> &,
		     _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

	    public:
		template <
			class _U1 = _T1, class _U2 = _T2,
			typename enable_if<
				__and_<__is_implicitly_default_constructible<_U1>,
				       __is_implicitly_default_constructible<
					       _U2>>::value,
				bool>::type = true>
		constexpr pair() : first(), second()
		{
		}
		template <
			class _U1 = _T1, class _U2 = _T2,
			typename enable_if<
				__and_<is_default_constructible<_U1>,
				       is_default_constructible<_U2>,
				       __not_<__and_<
					       __is_implicitly_default_constructible<
						       _U1>,
					       __is_implicitly_default_constructible<
						       _U2>>>>::value,
				bool>::type = false>
		constexpr explicit pair() : first(), second()
		{
		}
		using _PCCP = _PCC<true, _T1, _T2>;
		template <
			class _U1 = _T1, class _U2 = _T2,
			typename enable_if<
				_PCC<true, _T1, _T2>::template _ConstructiblePair<
					_U1, _U2>() &&
					_PCC<true, _T1, _T2>::
						template _ImplicitlyConvertiblePair<
							_U1, _U2>(),
				bool>::type = true>
		constexpr pair(const _T1 &__a, const _T2 &__b)
			: first(__a), second(__b)
		{
		}
		template <
			class _U1 = _T1, class _U2 = _T2,
			typename enable_if<
				_PCC<true, _T1, _T2>::template _ConstructiblePair<
					_U1, _U2>() &&
					(!_PCC<true, _T1, _T2>::
						 template _ImplicitlyConvertiblePair<
							 _U1, _U2>()),
				bool>::type = false>
		constexpr explicit pair(const _T1 &__a, const _T2 &__b)
			: first(__a), second(__b)
		{
		}
		template <class _U1, class _U2>
		using _PCCFP = _PCC<(!is_same<_T1, _U1>::value) ||
					    (!is_same<_T2, _U2>::value),
				    _T1, _T2>;
		template <
			class _U1, class _U2,
			typename enable_if<
				_PCC<(!is_same<_T1, _U1>::value) ||
					     (!is_same<_T2, _U2>::value),
				     _T1,
				     _T2>::template _ConstructiblePair<_U1,
								       _U2>() &&
					_PCC<(!is_same<_T1, _U1>::value) ||
						     (!is_same<_T2, _U2>::value),
					     _T1, _T2>::
						template _ImplicitlyConvertiblePair<
							_U1, _U2>(),
				bool>::type = true>
		constexpr pair(const pair<_U1, _U2> &__p)
			: first((__p.first)), second((__p.second))
		{
		}
		template <
			class _U1, class _U2,
			typename enable_if<
				_PCC<(!is_same<_T1, _U1>::value) ||
					     (!is_same<_T2, _U2>::value),
				     _T1,
				     _T2>::template _ConstructiblePair<_U1,
								       _U2>() &&
					(!_PCC<(!is_same<_T1, _U1>::value) ||
						       (!is_same<_T2, _U2>::value),
					       _T1, _T2>::
						 template _ImplicitlyConvertiblePair<
							 _U1, _U2>()),
				bool>::type = false>
		constexpr explicit pair(const pair<_U1, _U2> &__p)
			: first((__p.first)), second((__p.second))
		{
		}

	    private:
		struct __zero_as_null_pointer_constant {
			__zero_as_null_pointer_constant(
				int(__zero_as_null_pointer_constant::*))
			{
			}
			template <typename _Tp,
				  typename = __enable_if_t<
					  is_null_pointer<_Tp>::value>>
			__zero_as_null_pointer_constant(_Tp) = delete;
		};

	    public:
		template <
			class _U1,
			std::__enable_if_t<
				__and_<__not_<is_reference<_U1>>, is_pointer<_T2>,
				       is_constructible<_T1, _U1>,
				       __not_<is_constructible<_T1, const _U1 &>>,
				       is_convertible<_U1, _T1>>::value,
				bool> = true>
		__attribute((__deprecated__("use \'nullptr\' instead of \'0\' to initialize std::pair of move-only type and pointer"))) constexpr pair(
			_U1 &&__x, __zero_as_null_pointer_constant, ...)
			: first(std::forward<_U1>(__x)), second(nullptr)
		{
		}
		template <
			class _U1,
			std::__enable_if_t<
				__and_<__not_<is_reference<_U1>>, is_pointer<_T2>,
				       is_constructible<_T1, _U1>,
				       __not_<is_constructible<_T1, const _U1 &>>,
				       __not_<is_convertible<_U1, _T1>>>::value,
				bool> = false>
		__attribute((__deprecated__("use \'nullptr\' instead of \'0\' to initialize std::pair of move-only type and pointer"))) constexpr explicit pair(
			_U1 &&__x, __zero_as_null_pointer_constant, ...)
			: first(std::forward<_U1>(__x)), second(nullptr)
		{
		}
		template <
			class _U2,
			std::__enable_if_t<
				__and_<is_pointer<_T1>, __not_<is_reference<_U2>>,
				       is_constructible<_T2, _U2>,
				       __not_<is_constructible<_T2, const _U2 &>>,
				       is_convertible<_U2, _T2>>::value,
				bool> = true>
		__attribute((__deprecated__("use \'nullptr\' instead of \'0\' to initialize std::pair of move-only type and pointer"))) constexpr pair(
			__zero_as_null_pointer_constant, _U2 &&__y, ...)
			: first(nullptr), second(std::forward<_U2>(__y))
		{
		}
		template <
			class _U2,
			std::__enable_if_t<
				__and_<is_pointer<_T1>, __not_<is_reference<_U2>>,
				       is_constructible<_T2, _U2>,
				       __not_<is_constructible<_T2, const _U2 &>>,
				       __not_<is_convertible<_U2, _T2>>>::value,
				bool> = false>
		__attribute((__deprecated__("use \'nullptr\' instead of \'0\' to initialize std::pair of move-only type and pointer"))) constexpr explicit pair(
			__zero_as_null_pointer_constant, _U2 &&__y, ...)
			: first(nullptr), second(std::forward<_U2>(__y))
		{
		}
		template <
			class _U1, class _U2,
			typename enable_if<
				_PCC<true, _T1, _T2>::
						template _MoveConstructiblePair<
							_U1, _U2>() &&
					_PCC<true, _T1, _T2>::
						template _ImplicitlyMoveConvertiblePair<
							_U1, _U2>(),
				bool>::type = true>
		constexpr pair(_U1 &&__x, _U2 &&__y)
			: first(std::forward<_U1>(__x)),
			  second(std::forward<_U2>(__y))
		{
		}
		template <
			class _U1, class _U2,
			typename enable_if<
				_PCC<true, _T1, _T2>::
						template _MoveConstructiblePair<
							_U1, _U2>() &&
					(!_PCC<true, _T1, _T2>::
						 template _ImplicitlyMoveConvertiblePair<
							 _U1, _U2>()),
				bool>::type = false>
		constexpr explicit pair(_U1 &&__x, _U2 &&__y)
			: first(std::forward<_U1>(__x)),
			  second(std::forward<_U2>(__y))
		{
		}
		template <
			class _U1, class _U2,
			typename enable_if<
				_PCC<(!is_same<_T1, _U1>::value) ||
					     (!is_same<_T2, _U2>::value),
				     _T1, _T2>::
						template _MoveConstructiblePair<
							_U1, _U2>() &&
					_PCC<(!is_same<_T1, _U1>::value) ||
						     (!is_same<_T2, _U2>::value),
					     _T1, _T2>::
						template _ImplicitlyMoveConvertiblePair<
							_U1, _U2>(),
				bool>::type = true>
		constexpr pair(pair<_U1, _U2> &&__p)
			: first(std::forward<_U1>((__p.first))),
			  second(std::forward<_U2>((__p.second)))
		{
		}
		template <
			class _U1, class _U2,
			typename enable_if<
				_PCC<(!is_same<_T1, _U1>::value) ||
					     (!is_same<_T2, _U2>::value),
				     _T1, _T2>::
						template _MoveConstructiblePair<
							_U1, _U2>() &&
					(!_PCC<(!is_same<_T1, _U1>::value) ||
						       (!is_same<_T2, _U2>::value),
					       _T1, _T2>::
						 template _ImplicitlyMoveConvertiblePair<
							 _U1, _U2>()),
				bool>::type = false>
		constexpr explicit pair(pair<_U1, _U2> &&__p)
			: first(std::forward<_U1>((__p.first))),
			  second(std::forward<_U2>((__p.second)))
		{
		}
		pair &operator=(std::__conditional_t<
				__and_<is_copy_assignable<_T1>,
				       is_copy_assignable<_T2>>::value,
				const pair &, const std::__nonesuch &>
					__p)
		{
			(first) = (__p.first);
			(second) = (__p.second);
			return *this;
		}
		pair &operator=(
			std::__conditional_t<
				__and_<is_move_assignable<_T1>,
				       is_move_assignable<_T2>>::value,
				pair &&, std::__nonesuch &&>
				__p) noexcept(__and_<is_nothrow_move_assignable<_T1>,
						     is_nothrow_move_assignable<
							     _T2>>::value)
		{
			(first) = std::forward<first_type>((__p.first));
			(second) = std::forward<second_type>((__p.second));
			return *this;
		}
		template <class _U1, class _U2>
		typename enable_if<
			__and_<is_assignable<_T1 &, const _U1 &>,
			       is_assignable<_T2 &, const _U2 &>>::value,
			pair &>::type
		operator=(const pair<_U1, _U2> &__p)
		{
			(first) = (__p.first);
			(second) = (__p.second);
			return *this;
		}
		template <class _U1, class _U2>
		typename enable_if<__and_<is_assignable<_T1 &, _U1 &&>,
					  is_assignable<_T2 &, _U2 &&>>::value,
				   pair &>::type
		operator=(pair<_U1, _U2> &&__p)
		{
			(first) = std::forward<_U1>((__p.first));
			(second) = std::forward<_U2>((__p.second));
			return *this;
		}
	};
	template <class _T1, class _T2> pair(_T1, _T2) -> pair<_T1, _T2>;
	template <class _T1, class _T2>
	constexpr bool operator==(const pair<_T1, _T2> &__x,
				  const pair<_T1, _T2> &__y)
	{
		return ((__x.first) == (__y.first)) &&
		       ((__x.second) == (__y.second));
	}
	template <class _T1, class _T2>
	constexpr bool operator<(const pair<_T1, _T2> &__x,
				 const pair<_T1, _T2> &__y)
	{
		return ((__x.first) < (__y.first)) ||
		       ((!((__y.first) < (__x.first))) &&
			((__x.second) < (__y.second)));
	}
	template <class _T1, class _T2>
	constexpr bool operator!=(const pair<_T1, _T2> &__x,
				  const pair<_T1, _T2> &__y)
	{
		return !(__x == __y);
	}
	template <class _T1, class _T2>
	constexpr bool operator>(const pair<_T1, _T2> &__x,
				 const pair<_T1, _T2> &__y)
	{
		return __y < __x;
	}
	template <class _T1, class _T2>
	constexpr bool operator<=(const pair<_T1, _T2> &__x,
				  const pair<_T1, _T2> &__y)
	{
		return !(__y < __x);
	}
	template <class _T1, class _T2>
	constexpr bool operator>=(const pair<_T1, _T2> &__x,
				  const pair<_T1, _T2> &__y)
	{
		return !(__x < __y);
	}
	template <class _T1, class _T2>
	inline typename enable_if<
		__and_<__is_swappable<_T1>, __is_swappable<_T2>>::value>::type
	swap(pair<_T1, _T2> & __x,
	     pair<_T1, _T2> & __y) noexcept(noexcept(__x.swap(__y)))
	{
		__x.swap(__y);
	}
	template <typename _T1, typename _T2>
	typename enable_if<
		!__and_<__is_swappable<_T1>, __is_swappable<_T2>>::value>::type
	swap(pair<_T1, _T2> &, pair<_T1, _T2> &) = delete;
	template <class _T1, class _T2>
	constexpr pair<typename __decay_and_strip<_T1>::__type,
		       typename __decay_and_strip<_T2>::__type>
	make_pair(_T1 && __x, _T2 && __y)
	{
		typedef typename __decay_and_strip<_T1>::__type __ds_type1;
		typedef typename __decay_and_strip<_T2>::__type __ds_type2;
		typedef pair<typename __decay_and_strip<_T1>::__type,
			     typename __decay_and_strip<_T2>::__type>
			__pair_type;
		return __pair_type(std::forward<_T1>(__x),
				   std::forward<_T2>(__y));
	}
	template <class _T1, class _T2>
	struct __is_tuple_like_impl<pair<_T1, _T2>> : public true_type {
	};
	template <class _Tp1, class _Tp2>
	struct tuple_size<pair<_Tp1, _Tp2>>
		: public integral_constant<unsigned long, 2UL> {
	};
	template <class _Tp1, class _Tp2>
	struct tuple_element<0, pair<_Tp1, _Tp2>> {
		typedef _Tp1 type;
	};
	template <class _Tp1, class _Tp2>
	struct tuple_element<1, pair<_Tp1, _Tp2>> {
		typedef _Tp2 type;
	};
	template <class _Tp1, class _Tp2>
	constexpr inline size_t tuple_size_v<pair<_Tp1, _Tp2>> = (2);
	template <class _Tp1, class _Tp2>
	constexpr inline size_t tuple_size_v<const pair<_Tp1, _Tp2>> = (2);
	template <class _Tp> constexpr inline bool __is_pair = false;
	template <class _Tp, class _Up>
	constexpr inline bool __is_pair<pair<_Tp, _Up>> = true;
	template <class _Tp, class _Up>
	constexpr inline bool __is_pair<const pair<_Tp, _Up>> = true;
	template <size_t _Int> struct __pair_get;
	template <> struct __pair_get<0UL> {
		template <class _Tp1, class _Tp2>
		static constexpr _Tp1 &__get(pair<_Tp1, _Tp2> &__pair) noexcept
		{
			return __pair.first;
		}
		template <class _Tp1, class _Tp2>
		static constexpr _Tp1 &&
		__move_get(pair<_Tp1, _Tp2> &&__pair) noexcept
		{
			return std::forward<_Tp1>((__pair.first));
		}
		template <class _Tp1, class _Tp2>
		static constexpr const _Tp1 &
		__const_get(const pair<_Tp1, _Tp2> &__pair) noexcept
		{
			return __pair.first;
		}
		template <class _Tp1, class _Tp2>
		static constexpr const _Tp1 &&
		__const_move_get(const pair<_Tp1, _Tp2> &&__pair) noexcept
		{
			return std::forward<const _Tp1>((__pair.first));
		}
	};
	template <> struct __pair_get<1UL> {
		template <class _Tp1, class _Tp2>
		static constexpr _Tp2 &__get(pair<_Tp1, _Tp2> &__pair) noexcept
		{
			return __pair.second;
		}
		template <class _Tp1, class _Tp2>
		static constexpr _Tp2 &&
		__move_get(pair<_Tp1, _Tp2> &&__pair) noexcept
		{
			return std::forward<_Tp2>((__pair.second));
		}
		template <class _Tp1, class _Tp2>
		static constexpr const _Tp2 &
		__const_get(const pair<_Tp1, _Tp2> &__pair) noexcept
		{
			return __pair.second;
		}
		template <class _Tp1, class _Tp2>
		static constexpr const _Tp2 &&
		__const_move_get(const pair<_Tp1, _Tp2> &&__pair) noexcept
		{
			return std::forward<const _Tp2>((__pair.second));
		}
	};
	template <size_t _Int, class _Tp1, class _Tp2>
	constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type &get(
		pair<_Tp1, _Tp2> & __in) noexcept
	{
		return __pair_get<_Int>::__get(__in);
	}
	template <size_t _Int, class _Tp1, class _Tp2>
	constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type &&get(
		pair<_Tp1, _Tp2> && __in) noexcept
	{
		return __pair_get<_Int>::__move_get(std::move(__in));
	}
	template <size_t _Int, class _Tp1, class _Tp2>
	constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type &
	get(const pair<_Tp1, _Tp2> &__in) noexcept
	{
		return __pair_get<_Int>::__const_get(__in);
	}
	template <size_t _Int, class _Tp1, class _Tp2>
	constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type &&
	get(const pair<_Tp1, _Tp2> &&__in) noexcept
	{
		return __pair_get<_Int>::__const_move_get(std::move(__in));
	}
	template <class _Tp, class _Up>
	constexpr _Tp &get(pair<_Tp, _Up> & __p) noexcept
	{
		return __p.first;
	}
	template <class _Tp, class _Up>
	constexpr const _Tp &get(const pair<_Tp, _Up> &__p) noexcept
	{
		return __p.first;
	}
	template <class _Tp, class _Up>
	constexpr _Tp &&get(pair<_Tp, _Up> && __p) noexcept
	{
		return std::move((__p.first));
	}
	template <class _Tp, class _Up>
	constexpr const _Tp &&get(const pair<_Tp, _Up> &&__p) noexcept
	{
		return std::move((__p.first));
	}
	template <class _Tp, class _Up>
	constexpr _Tp &get(pair<_Up, _Tp> & __p) noexcept
	{
		return __p.second;
	}
	template <class _Tp, class _Up>
	constexpr const _Tp &get(const pair<_Up, _Tp> &__p) noexcept
	{
		return __p.second;
	}
	template <class _Tp, class _Up>
	constexpr _Tp &&get(pair<_Up, _Tp> && __p) noexcept
	{
		return std::move((__p.second));
	}
	template <class _Tp, class _Up>
	constexpr const _Tp &&get(const pair<_Up, _Tp> &&__p) noexcept
	{
		return std::move((__p.second));
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	struct input_iterator_tag {};
	struct output_iterator_tag {};
	struct forward_iterator_tag : public input_iterator_tag {};
	struct bidirectional_iterator_tag : public forward_iterator_tag {};
	struct random_access_iterator_tag : public bidirectional_iterator_tag {
	};
	template <class _Category, class _Tp, class _Distance = ptrdiff_t,
		  class _Pointer = _Tp *, class _Reference = _Tp &>
	struct [[__deprecated__]] iterator {
		typedef _Category iterator_category;
		typedef _Tp value_type;
		typedef _Distance difference_type;
		typedef _Pointer pointer;
		typedef _Reference reference;
	};
	template <class _Iterator> struct iterator_traits;
	template <class _Iterator, class = __void_t<>>
	struct __iterator_traits {
	};
	template <class _Iterator>
	struct __iterator_traits<_Iterator,
				 __void_t<typename _Iterator::iterator_category,
					  typename _Iterator::value_type,
					  typename _Iterator::difference_type,
					  typename _Iterator::pointer,
					  typename _Iterator::reference>> {
		typedef typename _Iterator::iterator_category iterator_category;
		typedef typename _Iterator::value_type value_type;
		typedef typename _Iterator::difference_type difference_type;
		typedef typename _Iterator::pointer pointer;
		typedef typename _Iterator::reference reference;
	};
	template <class _Iterator>
	struct iterator_traits : public __iterator_traits<_Iterator> {
	};
	template <class _Tp> struct iterator_traits<_Tp *> {
		typedef random_access_iterator_tag iterator_category;
		typedef _Tp value_type;
		typedef ptrdiff_t difference_type;
		typedef _Tp *pointer;
		typedef _Tp &reference;
	};
	template <class _Tp> struct iterator_traits<const _Tp *> {
		typedef random_access_iterator_tag iterator_category;
		typedef _Tp value_type;
		typedef ptrdiff_t difference_type;
		typedef const _Tp *pointer;
		typedef const _Tp &reference;
	};
	template <class _Iter>
	constexpr typename iterator_traits<_Iter>::iterator_category
	__iterator_category(const _Iter &)
	{
		return typename iterator_traits<_Iter>::iterator_category();
	}
	template <class _Iter>
	using __iterator_category_t =
		typename iterator_traits<_Iter>::iterator_category;
	template <class _InIter>
	using _RequireInputIter =
		__enable_if_t<is_convertible<__iterator_category_t<_InIter>,
					     input_iterator_tag>::value>;
	template <class _It, class _Cat = __iterator_category_t<_It>>
	struct __is_random_access_iter
		: public is_base_of<random_access_iterator_tag, _Cat> {
		typedef is_base_of<std::random_access_iterator_tag, _Cat> _Base;
		enum {
			__value = is_base_of<std::random_access_iterator_tag,
					     _Cat>::value
		};
	};
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class> struct _List_iterator;
	template <class> struct _List_const_iterator;
	template <class _InputIterator>
	constexpr typename iterator_traits<_InputIterator>::difference_type
	__distance(_InputIterator __first, _InputIterator __last,
		   input_iterator_tag)
	{
		typename iterator_traits<_InputIterator>::difference_type __n =
			(0);
		while (__first != __last) {
			++__first;
			++__n;
		}
		return __n;
	}
	template <class _RandomAccessIterator>
	constexpr
		typename iterator_traits<_RandomAccessIterator>::difference_type
		__distance(_RandomAccessIterator __first,
			   _RandomAccessIterator __last,
			   random_access_iterator_tag)
	{
		return __last - __first;
	}
	template <class _Tp>
	ptrdiff_t __distance(_List_iterator<_Tp>, _List_iterator<_Tp>,
			     input_iterator_tag);
	template <class _Tp>
	ptrdiff_t __distance(_List_const_iterator<_Tp>,
			     _List_const_iterator<_Tp>, input_iterator_tag);
	template <typename _OutputIterator>
	void __distance(_OutputIterator, _OutputIterator, output_iterator_tag) =
		delete;
	template <class _InputIterator>
	[[__nodiscard__]] constexpr
		typename iterator_traits<_InputIterator>::difference_type
		distance(_InputIterator __first, _InputIterator __last)
	{
		return std::__distance(__first, __last,
				       std::__iterator_category(__first));
	}
	template <class _InputIterator, class _Distance>
	constexpr void __advance(_InputIterator & __i, _Distance __n,
				 input_iterator_tag)
	{
		do {
			if (std::__is_constant_evaluated() &&
			    (!((bool)(__n >= 0)))) {
				__builtin_unreachable();
			}
		} while (false);
		while (__n--) {
			++__i;
		}
	}
	template <class _BidirectionalIterator, class _Distance>
	constexpr void __advance(_BidirectionalIterator & __i, _Distance __n,
				 bidirectional_iterator_tag)
	{
		if (__n > 0) {
			while (__n--) {
				++__i;
			}
		} else {
			while (__n++) {
				--__i;
			}
		}
	}
	template <class _RandomAccessIterator, class _Distance>
	constexpr void __advance(_RandomAccessIterator & __i, _Distance __n,
				 random_access_iterator_tag)
	{
		if (__builtin_constant_p(__n) && (__n == 1)) {
			++__i;
		} else {
			if (__builtin_constant_p(__n) && (__n == (-1))) {
				--__i;
			} else {
				__i += __n;
			}
		}
	}
	template <typename _OutputIterator, typename _Distance>
	void __advance(_OutputIterator &, _Distance, output_iterator_tag) =
		delete;
	template <class _InputIterator, class _Distance>
	constexpr void advance(_InputIterator & __i, _Distance __n)
	{
		typename iterator_traits<_InputIterator>::difference_type __d =
			__n;
		std::__advance(__i, __d, std::__iterator_category(__i));
	}
	template <class _InputIterator>
	[[__nodiscard__]] constexpr _InputIterator next(
		_InputIterator __x,
		typename iterator_traits<_InputIterator>::difference_type __n =
			1)
	{
		std::advance(__x, __n);
		return __x;
	}
	template <class _BidirectionalIterator>
	[[__nodiscard__]] constexpr _BidirectionalIterator prev(
		_BidirectionalIterator __x,
		typename iterator_traits<_BidirectionalIterator>::difference_type
			__n = 1)
	{
		std::advance(__x, -__n);
		return __x;
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	class __undefined;
	template <class _Tp> struct __get_first_arg {
		using type = __undefined;
	};
	template <template <class, class...> class _SomeTemplate, class _Tp,
		  class... _Types>
	struct __get_first_arg<_SomeTemplate<_Tp, _Types...>> {
		using type = _Tp;
	};
	template <class _Tp, class _Up> struct __replace_first_arg {
	};
	template <template <class, class...> class _SomeTemplate, class _Up,
		  class _Tp, class... _Types>
	struct __replace_first_arg<_SomeTemplate<_Tp, _Types...>, _Up> {
		using type = _SomeTemplate<_Up, _Types...>;
	};
	template <class _Ptr, class = void>
	struct __ptr_traits_elem : public __get_first_arg<_Ptr> {
	};
	template <class _Ptr>
	struct __ptr_traits_elem<_Ptr, __void_t<typename _Ptr::element_type>> {
		using type = typename _Ptr::element_type;
	};
	template <class _Ptr>
	using __ptr_traits_elem_t = typename __ptr_traits_elem<_Ptr>::type;
	template <class _Ptr, class _Elt, bool = is_void<_Elt>::value>
	struct __ptr_traits_ptr_to {
		using pointer = _Ptr;
		using element_type = _Elt;
		static pointer pointer_to(element_type &__e)
		{
			return pointer::pointer_to(__e);
		}
	};
	template <class _Ptr, class _Elt>
	struct __ptr_traits_ptr_to<_Ptr, _Elt, true> {
	};
	template <class _Tp> struct __ptr_traits_ptr_to<_Tp *, _Tp, false> {
		using pointer = _Tp *;
		using element_type = _Tp;
		static pointer pointer_to(element_type &__r) noexcept
		{
			return std::addressof(__r);
		}
	};
	template <class _Ptr, class _Elt>
	struct __ptr_traits_impl : public __ptr_traits_ptr_to<_Ptr, _Elt> {
	    private:
		template <class _Tp, class = void> struct __difference {
			using type = std::ptrdiff_t;
		};
		template <class _Tp>
		struct __difference<
			_Tp, std::__void_t<typename _Tp::difference_type>> {
			using type = typename _Tp::difference_type;
		};
		template <class _Tp, class _Up, class = void>
		struct __rebind : public __replace_first_arg<_Tp, _Up> {
		};
		template <class _Tp, class _Up>
		struct __rebind<
			_Tp, _Up,
			std::__void_t<typename _Tp::template rebind<_Up>>> {
			using type = typename _Tp::template rebind<_Up>;
		};

	    public:
		using pointer = _Ptr;
		using element_type = _Elt;
		using difference_type = typename __difference<_Ptr>::type;
		template <class _Up>
		using rebind = typename __rebind<_Ptr, _Up>::type;
	};
	template <class _Ptr> struct __ptr_traits_impl<_Ptr, __undefined> {
	};
	template <class _Ptr>
	struct pointer_traits
		: public __ptr_traits_impl<_Ptr, __ptr_traits_elem_t<_Ptr>> {
	};
	template <class _Tp>
	struct pointer_traits<_Tp *> : public __ptr_traits_ptr_to<_Tp *, _Tp> {
		typedef _Tp *pointer;
		typedef _Tp element_type;
		typedef std::ptrdiff_t difference_type;
		template <class _Up> using rebind = _Up *;
	};
	template <class _Ptr, class _Tp>
	using __ptr_rebind =
		typename pointer_traits<_Ptr>::template rebind<_Tp>;
	template <class _Tp> constexpr _Tp *__to_address(_Tp * __ptr) noexcept
	{
		static_assert((!std::template is_function<_Tp>::value),
			      "not a function pointer");
		return __ptr;
	}
	template <class _Ptr>
	constexpr typename pointer_traits<_Ptr>::element_type *__to_address(
		const _Ptr &__ptr)
	{
		return std::__to_address(__ptr.operator->());
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _Iterator>
	class reverse_iterator
		: public iterator<
			  typename iterator_traits<_Iterator>::iterator_category,
			  typename iterator_traits<_Iterator>::value_type,
			  typename iterator_traits<_Iterator>::difference_type,
			  typename iterator_traits<_Iterator>::pointer,
			  typename iterator_traits<_Iterator>::reference> {
		template <class _Iter> friend class reverse_iterator;

	    protected:
		_Iterator current;
		typedef iterator_traits<_Iterator> __traits_type;

	    public:
		typedef _Iterator iterator_type;
		typedef typename iterator_traits<_Iterator>::pointer pointer;
		typedef typename iterator_traits<_Iterator>::difference_type
			difference_type;
		typedef typename iterator_traits<_Iterator>::reference reference;
		constexpr reverse_iterator() noexcept(noexcept((_Iterator())))
			: current()
		{
		}
		constexpr explicit reverse_iterator(iterator_type __x) noexcept(
			noexcept(((_Iterator)__x)))
			: current(__x)
		{
		}
		constexpr reverse_iterator(const reverse_iterator &__x) noexcept(
			noexcept(((_Iterator)(__x.current))))
			: current(__x.current)
		{
		}
		reverse_iterator &operator=(const reverse_iterator &) = default;
		template <class _Iter>
		constexpr reverse_iterator(
			const reverse_iterator<_Iter> &
				__x) noexcept(noexcept(((_Iterator)(__x.current))))
			: current((__x.current))
		{
		}
		template <class _Iter>
		constexpr reverse_iterator &
		operator=(const reverse_iterator<_Iter> &__x) noexcept(
			noexcept(((current) = (__x.current))))
		{
			(current) = (__x.current);
			return *this;
		}
		[[__nodiscard__]] constexpr iterator_type base() const
			noexcept(noexcept(((_Iterator)(current))))
		{
			return current;
		}
		[[__nodiscard__]] constexpr reference operator*() const
		{
			_Iterator __tmp = current;
			return *(--__tmp);
		}
		[[__nodiscard__]] constexpr pointer operator->() const
		{
			_Iterator __tmp = current;
			--__tmp;
			return _S_to_pointer(__tmp);
		}
		constexpr reverse_iterator &operator++()
		{
			--(current);
			return *this;
		}
		constexpr reverse_iterator operator++(int)
		{
			reverse_iterator __tmp = *this;
			--(current);
			return __tmp;
		}
		constexpr reverse_iterator &operator--()
		{
			++(current);
			return *this;
		}
		constexpr reverse_iterator operator--(int)
		{
			reverse_iterator __tmp = *this;
			++(current);
			return __tmp;
		}
		[[__nodiscard__]] constexpr reverse_iterator
		operator+(difference_type __n) const
		{
			return ((reverse_iterator)((current)-__n));
		}
		constexpr reverse_iterator &operator+=(difference_type __n)
		{
			(current) -= __n;
			return *this;
		}
		[[__nodiscard__]] constexpr reverse_iterator
		operator-(difference_type __n) const
		{
			return ((reverse_iterator)((current) + __n));
		}
		constexpr reverse_iterator &operator-=(difference_type __n)
		{
			(current) += __n;
			return *this;
		}
		[[__nodiscard__]] constexpr reference
		operator[](difference_type __n) const
		{
			return *((*this) + __n);
		}

	    private:
		template <class _Tp>
		static constexpr _Tp *_S_to_pointer(_Tp *__p)
		{
			return __p;
		}
		template <class _Tp>
		static constexpr pointer _S_to_pointer(_Tp __t)
		{
			return __t.operator->();
		}
	};
	template <class _Iterator>
	[[__nodiscard__]] constexpr bool operator==(
		const reverse_iterator<_Iterator> &__x,
		const reverse_iterator<_Iterator> &__y)
	{
		return __x.base() == __y.base();
	}
	template <class _Iterator>
	[[__nodiscard__]] constexpr bool operator<(
		const reverse_iterator<_Iterator> &__x,
		const reverse_iterator<_Iterator> &__y)
	{
		return __y.base() < __x.base();
	}
	template <class _Iterator>
	[[__nodiscard__]] constexpr bool operator!=(
		const reverse_iterator<_Iterator> &__x,
		const reverse_iterator<_Iterator> &__y)
	{
		return !(__x == __y);
	}
	template <class _Iterator>
	[[__nodiscard__]] constexpr bool operator>(
		const reverse_iterator<_Iterator> &__x,
		const reverse_iterator<_Iterator> &__y)
	{
		return __y < __x;
	}
	template <class _Iterator>
	[[__nodiscard__]] constexpr bool operator<=(
		const reverse_iterator<_Iterator> &__x,
		const reverse_iterator<_Iterator> &__y)
	{
		return !(__y < __x);
	}
	template <class _Iterator>
	[[__nodiscard__]] constexpr bool operator>=(
		const reverse_iterator<_Iterator> &__x,
		const reverse_iterator<_Iterator> &__y)
	{
		return !(__x < __y);
	}
	template <class _IteratorL, class _IteratorR>
	[[__nodiscard__]] constexpr bool operator==(
		const reverse_iterator<_IteratorL> &__x,
		const reverse_iterator<_IteratorR> &__y)
	{
		return __x.base() == __y.base();
	}
	template <class _IteratorL, class _IteratorR>
	[[__nodiscard__]] constexpr bool operator<(
		const reverse_iterator<_IteratorL> &__x,
		const reverse_iterator<_IteratorR> &__y)
	{
		return __x.base() > __y.base();
	}
	template <class _IteratorL, class _IteratorR>
	[[__nodiscard__]] constexpr bool operator!=(
		const reverse_iterator<_IteratorL> &__x,
		const reverse_iterator<_IteratorR> &__y)
	{
		return __x.base() != __y.base();
	}
	template <class _IteratorL, class _IteratorR>
	[[__nodiscard__]] constexpr bool operator>(
		const reverse_iterator<_IteratorL> &__x,
		const reverse_iterator<_IteratorR> &__y)
	{
		return __x.base() < __y.base();
	}
	template <class _IteratorL, class _IteratorR>
	constexpr bool operator<=(const reverse_iterator<_IteratorL> &__x,
				  const reverse_iterator<_IteratorR> &__y)
	{
		return __x.base() >= __y.base();
	}
	template <class _IteratorL, class _IteratorR>
	[[__nodiscard__]] constexpr bool operator>=(
		const reverse_iterator<_IteratorL> &__x,
		const reverse_iterator<_IteratorR> &__y)
	{
		return __x.base() <= __y.base();
	}
	template <class _IteratorL, class _IteratorR>
	[[__nodiscard__]] constexpr auto operator-(
		const reverse_iterator<_IteratorL> &__x,
		const reverse_iterator<_IteratorR> &__y)
		->__decltype((__y.base() - __x.base()))
	{
		return __y.base() - __x.base();
	}
	template <class _Iterator>
	[[__nodiscard__]] constexpr reverse_iterator<_Iterator> operator+(
		typename reverse_iterator<_Iterator>::difference_type __n,
		const reverse_iterator<_Iterator> &__x)
	{
		return ((reverse_iterator<_Iterator>)(__x.base() - __n));
	}
	template <class _Iterator>
	constexpr reverse_iterator<_Iterator> __make_reverse_iterator(
		_Iterator __i)
	{
		return ((reverse_iterator<_Iterator>)(__i));
	}
	template <class _Iterator>
	[[__nodiscard__]] constexpr reverse_iterator<_Iterator>
	make_reverse_iterator(_Iterator __i)
	{
		return ((reverse_iterator<_Iterator>)(__i));
	}
	template <class _Iterator>
	auto __niter_base(reverse_iterator<_Iterator> __it)
		->__decltype((
			__make_reverse_iterator(__niter_base(__it.base()))))
	{
		return __make_reverse_iterator(__niter_base(__it.base()));
	}
	template <class _Iterator>
	struct __is_move_iterator<reverse_iterator<_Iterator>>
		: public std::__is_move_iterator<_Iterator> {
	};
	template <class _Iterator>
	auto __miter_base(reverse_iterator<_Iterator> __it)
		->__decltype((
			__make_reverse_iterator(__miter_base(__it.base()))))
	{
		return __make_reverse_iterator(__miter_base(__it.base()));
	}
	template <class _Container>
	class back_insert_iterator
		: public iterator<output_iterator_tag, void, void, void, void> {
	    protected:
		_Container *container;

	    public:
		typedef _Container container_type;
		explicit back_insert_iterator(_Container &__x)
			: container(std::__addressof(__x))
		{
		}
		back_insert_iterator &
		operator=(const typename _Container::value_type &__value)
		{
			(container)->push_back(__value);
			return *this;
		}
		back_insert_iterator &
		operator=(typename _Container::value_type &&__value)
		{
			(container)->push_back(std::move(__value));
			return *this;
		}
		[[__nodiscard__]] back_insert_iterator &operator*()
		{
			return *this;
		}
		back_insert_iterator &operator++()
		{
			return *this;
		}
		back_insert_iterator operator++(int)
		{
			return *this;
		}
	};
	template <class _Container>
	[[__nodiscard__]] inline back_insert_iterator<_Container> back_inserter(
		_Container & __x)
	{
		return ((back_insert_iterator<_Container>)(__x));
	}
	template <class _Container>
	class front_insert_iterator
		: public iterator<output_iterator_tag, void, void, void, void> {
	    protected:
		_Container *container;

	    public:
		typedef _Container container_type;
		explicit front_insert_iterator(_Container &__x)
			: container(std::__addressof(__x))
		{
		}
		front_insert_iterator &
		operator=(const typename _Container::value_type &__value)
		{
			(container)->push_front(__value);
			return *this;
		}
		front_insert_iterator &
		operator=(typename _Container::value_type &&__value)
		{
			(container)->push_front(std::move(__value));
			return *this;
		}
		[[__nodiscard__]] front_insert_iterator &operator*()
		{
			return *this;
		}
		front_insert_iterator &operator++()
		{
			return *this;
		}
		front_insert_iterator operator++(int)
		{
			return *this;
		}
	};
	template <class _Container>
	[[__nodiscard__]] inline front_insert_iterator<_Container>
	front_inserter(_Container & __x)
	{
		return ((front_insert_iterator<_Container>)(__x));
	}
	template <class _Container>
	class insert_iterator
		: public iterator<output_iterator_tag, void, void, void, void> {
		typedef typename _Container::iterator _Iter;

	    protected:
		_Container *container;
		_Iter iter;

	    public:
		typedef _Container container_type;
		insert_iterator(_Container &__x, _Iter __i)
			: container(std::__addressof(__x)), iter(__i)
		{
		}
		insert_iterator &
		operator=(const typename _Container::value_type &__value)
		{
			(iter) = (container)->insert(iter, __value);
			++(iter);
			return *this;
		}
		insert_iterator &
		operator=(typename _Container::value_type &&__value)
		{
			(iter) = (container)->insert(iter, std::move(__value));
			++(iter);
			return *this;
		}
		[[__nodiscard__]] insert_iterator &operator*()
		{
			return *this;
		}
		insert_iterator &operator++()
		{
			return *this;
		}
		insert_iterator &operator++(int)
		{
			return *this;
		}
	};
	template <class _Container>
	[[__nodiscard__]] inline insert_iterator<_Container> inserter(
		_Container & __x, typename _Container::iterator __i)
	{
		return insert_iterator<_Container>(__x, __i);
	}
} // namespace )
namespace __gnu_cxx __attribute((__visibility__("default")))
{
	template <class _Iterator, class _Container> class __normal_iterator {
	    protected:
		_Iterator _M_current;
		typedef std::iterator_traits<_Iterator> __traits_type;
		template <class _Iter>
		using __convertible_from = std::__enable_if_t<
			std::is_convertible<_Iter, _Iterator>::value>;

	    public:
		typedef _Iterator iterator_type;
		typedef typename std::iterator_traits<
			_Iterator>::iterator_category iterator_category;
		typedef typename std::iterator_traits<_Iterator>::value_type
			value_type;
		typedef typename std::iterator_traits<_Iterator>::difference_type
			difference_type;
		typedef typename std::iterator_traits<_Iterator>::reference
			reference;
		typedef typename std::iterator_traits<_Iterator>::pointer
			pointer;
		constexpr __normal_iterator() noexcept : _M_current(_Iterator())
		{
		}
		explicit __normal_iterator(const _Iterator &__i) noexcept
			: _M_current(__i)
		{
		}
		template <class _Iter, class = __convertible_from<_Iter>>
		__normal_iterator(const __normal_iterator<_Iter, _Container>
					  &__i) noexcept
			: _M_current(__i.base())
		{
		}
		reference operator*() const noexcept
		{
			return *(_M_current);
		}
		pointer operator->() const noexcept
		{
			return _M_current;
		}
		__normal_iterator &operator++() noexcept
		{
			++(_M_current);
			return *this;
		}
		__normal_iterator operator++(int) noexcept
		{
			return ((__normal_iterator)((_M_current)++));
		}
		__normal_iterator &operator--() noexcept
		{
			--(_M_current);
			return *this;
		}
		__normal_iterator operator--(int) noexcept
		{
			return ((__normal_iterator)((_M_current)--));
		}
		reference operator[](difference_type __n) const noexcept
		{
			return (_M_current)[__n];
		}
		__normal_iterator &operator+=(difference_type __n) noexcept
		{
			(_M_current) += __n;
			return *this;
		}
		__normal_iterator operator+(difference_type __n) const noexcept
		{
			return ((__normal_iterator)((_M_current) + __n));
		}
		__normal_iterator &operator-=(difference_type __n) noexcept
		{
			(_M_current) -= __n;
			return *this;
		}
		__normal_iterator operator-(difference_type __n) const noexcept
		{
			return ((__normal_iterator)((_M_current)-__n));
		}
		const _Iterator &base() const noexcept
		{
			return _M_current;
		}
	};
	template <class _IteratorL, class _IteratorR, class _Container>
	[[__nodiscard__]] inline bool operator==(
		const __normal_iterator<_IteratorL, _Container> &__lhs,
		const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept
	{
		return __lhs.base() == __rhs.base();
	}
	template <class _Iterator, class _Container>
	[[__nodiscard__]] inline bool operator==(
		const __normal_iterator<_Iterator, _Container> &__lhs,
		const __normal_iterator<_Iterator, _Container> &__rhs) noexcept
	{
		return __lhs.base() == __rhs.base();
	}
	template <class _IteratorL, class _IteratorR, class _Container>
	[[__nodiscard__]] inline bool operator!=(
		const __normal_iterator<_IteratorL, _Container> &__lhs,
		const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept
	{
		return __lhs.base() != __rhs.base();
	}
	template <class _Iterator, class _Container>
	[[__nodiscard__]] inline bool operator!=(
		const __normal_iterator<_Iterator, _Container> &__lhs,
		const __normal_iterator<_Iterator, _Container> &__rhs) noexcept
	{
		return __lhs.base() != __rhs.base();
	}
	template <class _IteratorL, class _IteratorR, class _Container>
	[[__nodiscard__]] inline bool operator<(
		const __normal_iterator<_IteratorL, _Container> &__lhs,
		const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept
	{
		return __lhs.base() < __rhs.base();
	}
	template <class _Iterator, class _Container>
	[[__nodiscard__]] inline bool operator<(
		const __normal_iterator<_Iterator, _Container> &__lhs,
		const __normal_iterator<_Iterator, _Container> &__rhs) noexcept
	{
		return __lhs.base() < __rhs.base();
	}
	template <class _IteratorL, class _IteratorR, class _Container>
	[[__nodiscard__]] inline bool operator>(
		const __normal_iterator<_IteratorL, _Container> &__lhs,
		const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept
	{
		return __lhs.base() > __rhs.base();
	}
	template <class _Iterator, class _Container>
	[[__nodiscard__]] inline bool operator>(
		const __normal_iterator<_Iterator, _Container> &__lhs,
		const __normal_iterator<_Iterator, _Container> &__rhs) noexcept
	{
		return __lhs.base() > __rhs.base();
	}
	template <class _IteratorL, class _IteratorR, class _Container>
	[[__nodiscard__]] inline bool operator<=(
		const __normal_iterator<_IteratorL, _Container> &__lhs,
		const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept
	{
		return __lhs.base() <= __rhs.base();
	}
	template <class _Iterator, class _Container>
	[[__nodiscard__]] inline bool operator<=(
		const __normal_iterator<_Iterator, _Container> &__lhs,
		const __normal_iterator<_Iterator, _Container> &__rhs) noexcept
	{
		return __lhs.base() <= __rhs.base();
	}
	template <class _IteratorL, class _IteratorR, class _Container>
	[[__nodiscard__]] inline bool operator>=(
		const __normal_iterator<_IteratorL, _Container> &__lhs,
		const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept
	{
		return __lhs.base() >= __rhs.base();
	}
	template <class _Iterator, class _Container>
	[[__nodiscard__]] inline bool operator>=(
		const __normal_iterator<_Iterator, _Container> &__lhs,
		const __normal_iterator<_Iterator, _Container> &__rhs) noexcept
	{
		return __lhs.base() >= __rhs.base();
	}
	template <class _IteratorL, class _IteratorR, class _Container>
	[[__nodiscard__]] inline auto operator-(
		const __normal_iterator<_IteratorL, _Container> &__lhs,
		const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept
		->__decltype((__lhs.base() - __rhs.base()))
	{
		return __lhs.base() - __rhs.base();
	}
	template <class _Iterator, class _Container>
	[[__nodiscard__]] inline
		typename __normal_iterator<_Iterator, _Container>::difference_type
		operator-(const __normal_iterator<_Iterator, _Container> &__lhs,
			  const __normal_iterator<_Iterator, _Container>
				  &__rhs) noexcept
	{
		return __lhs.base() - __rhs.base();
	}
	template <class _Iterator, class _Container>
	[[__nodiscard__]] inline __normal_iterator<_Iterator, _Container>
	operator+(typename __normal_iterator<_Iterator,
					     _Container>::difference_type __n,
		  const __normal_iterator<_Iterator, _Container> &__i) noexcept
	{
		return ((__normal_iterator<_Iterator, _Container>)(__i.base() +
								   __n));
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _Iterator, class _Container>
	_Iterator
	__niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it) noexcept(
		std::template is_nothrow_copy_constructible<_Iterator>::value)
	{
		return __it.base();
	}
	template <class _Iterator, class _Container>
	constexpr auto __to_address(
		const __gnu_cxx::__normal_iterator<_Iterator, _Container>
			&__it) noexcept
		->__decltype((std::__to_address(__it.base())))
	{
		return std::__to_address(__it.base());
	}
	namespace __detail
	{
	}
	template <class _Iterator> class move_iterator {
		_Iterator _M_current;
		using __traits_type = iterator_traits<_Iterator>;
		using __base_ref =
			typename iterator_traits<_Iterator>::reference;
		template <class _Iter2> friend class move_iterator;

	    public:
		using iterator_type = _Iterator;
		typedef typename iterator_traits<_Iterator>::iterator_category
			iterator_category;
		typedef typename iterator_traits<_Iterator>::value_type
			value_type;
		typedef typename iterator_traits<_Iterator>::difference_type
			difference_type;
		typedef _Iterator pointer;
		using reference = __conditional_t<
			is_reference<__base_ref>::value,
			typename remove_reference<__base_ref>::type &&,
			__base_ref>;
		constexpr move_iterator() : _M_current()
		{
		}
		constexpr explicit move_iterator(iterator_type __i)
			: _M_current(std::move(__i))
		{
		}
		template <class _Iter>
		constexpr move_iterator(const move_iterator<_Iter> &__i)
			: _M_current((__i._M_current))
		{
		}
		template <class _Iter>
		constexpr move_iterator &
		operator=(const move_iterator<_Iter> &__i)
		{
			(_M_current) = (__i._M_current);
			return *this;
		}
		[[__nodiscard__]] constexpr iterator_type base() const
		{
			return _M_current;
		}
		[[__nodiscard__]] constexpr reference operator*() const
		{
			return static_cast<reference>(*(_M_current));
		}
		[[__nodiscard__]] constexpr pointer operator->() const
		{
			return _M_current;
		}
		constexpr move_iterator &operator++()
		{
			++(_M_current);
			return *this;
		}
		constexpr move_iterator operator++(int)
		{
			move_iterator __tmp = *this;
			++(_M_current);
			return __tmp;
		}
		constexpr move_iterator &operator--()
		{
			--(_M_current);
			return *this;
		}
		constexpr move_iterator operator--(int)
		{
			move_iterator __tmp = *this;
			--(_M_current);
			return __tmp;
		}
		[[__nodiscard__]] constexpr move_iterator
		operator+(difference_type __n) const
		{
			return ((move_iterator)((_M_current) + __n));
		}
		constexpr move_iterator &operator+=(difference_type __n)
		{
			(_M_current) += __n;
			return *this;
		}
		[[__nodiscard__]] constexpr move_iterator
		operator-(difference_type __n) const
		{
			return ((move_iterator)((_M_current)-__n));
		}
		constexpr move_iterator &operator-=(difference_type __n)
		{
			(_M_current) -= __n;
			return *this;
		}
		[[__nodiscard__]] constexpr reference
		operator[](difference_type __n) const
		{
			return std::move((_M_current)[__n]);
		}
	};
	template <class _IteratorL, class _IteratorR>
	[[__nodiscard__]] constexpr bool operator==(
		const move_iterator<_IteratorL> &__x,
		const move_iterator<_IteratorR> &__y)
	{
		return __x.base() == __y.base();
	}
	template <class _IteratorL, class _IteratorR>
	[[__nodiscard__]] constexpr bool operator!=(
		const move_iterator<_IteratorL> &__x,
		const move_iterator<_IteratorR> &__y)
	{
		return !(__x == __y);
	}
	template <class _IteratorL, class _IteratorR>
	[[__nodiscard__]] constexpr bool operator<(
		const move_iterator<_IteratorL> &__x,
		const move_iterator<_IteratorR> &__y)
	{
		return __x.base() < __y.base();
	}
	template <class _IteratorL, class _IteratorR>
	[[__nodiscard__]] constexpr bool operator<=(
		const move_iterator<_IteratorL> &__x,
		const move_iterator<_IteratorR> &__y)
	{
		return !(__y < __x);
	}
	template <class _IteratorL, class _IteratorR>
	[[__nodiscard__]] constexpr bool operator>(
		const move_iterator<_IteratorL> &__x,
		const move_iterator<_IteratorR> &__y)
	{
		return __y < __x;
	}
	template <class _IteratorL, class _IteratorR>
	[[__nodiscard__]] constexpr bool operator>=(
		const move_iterator<_IteratorL> &__x,
		const move_iterator<_IteratorR> &__y)
	{
		return !(__x < __y);
	}
	template <class _Iterator>
	[[__nodiscard__]] constexpr bool operator==(
		const move_iterator<_Iterator> &__x,
		const move_iterator<_Iterator> &__y)
	{
		return __x.base() == __y.base();
	}
	template <class _Iterator>
	[[__nodiscard__]] constexpr bool operator!=(
		const move_iterator<_Iterator> &__x,
		const move_iterator<_Iterator> &__y)
	{
		return !(__x == __y);
	}
	template <class _Iterator>
	[[__nodiscard__]] constexpr bool operator<(
		const move_iterator<_Iterator> &__x,
		const move_iterator<_Iterator> &__y)
	{
		return __x.base() < __y.base();
	}
	template <class _Iterator>
	[[__nodiscard__]] constexpr bool operator<=(
		const move_iterator<_Iterator> &__x,
		const move_iterator<_Iterator> &__y)
	{
		return !(__y < __x);
	}
	template <class _Iterator>
	[[__nodiscard__]] constexpr bool operator>(
		const move_iterator<_Iterator> &__x,
		const move_iterator<_Iterator> &__y)
	{
		return __y < __x;
	}
	template <class _Iterator>
	[[__nodiscard__]] constexpr bool operator>=(
		const move_iterator<_Iterator> &__x,
		const move_iterator<_Iterator> &__y)
	{
		return !(__x < __y);
	}
	template <class _IteratorL, class _IteratorR>
	[[__nodiscard__]] constexpr auto operator-(
		const move_iterator<_IteratorL> &__x,
		const move_iterator<_IteratorR> &__y)
		->__decltype((__x.base() - __y.base()))
	{
		return __x.base() - __y.base();
	}
	template <class _Iterator>
	[[__nodiscard__]] constexpr move_iterator<_Iterator> operator+(
		typename move_iterator<_Iterator>::difference_type __n,
		const move_iterator<_Iterator> &__x)
	{
		return __x + __n;
	}
	template <class _Iterator>
	[[__nodiscard__]] constexpr move_iterator<_Iterator> make_move_iterator(
		_Iterator __i)
	{
		return ((move_iterator<_Iterator>)(std::move(__i)));
	}
	template <class _Iterator,
		  class _ReturnType = __conditional_t<
			  __move_if_noexcept_cond<typename iterator_traits<
				  _Iterator>::value_type>::value,
			  _Iterator, move_iterator<_Iterator>>>
	constexpr _ReturnType __make_move_if_noexcept_iterator(_Iterator __i)
	{
		return (_ReturnType)__i;
	}
	template <class _Tp,
		  class _ReturnType =
			  __conditional_t<__move_if_noexcept_cond<_Tp>::value,
					  const _Tp *, move_iterator<_Tp *>>>
	constexpr _ReturnType __make_move_if_noexcept_iterator(_Tp * __i)
	{
		return (_ReturnType)__i;
	}
	template <class _Iterator>
	auto __niter_base(move_iterator<_Iterator> __it)
		->__decltype((make_move_iterator(__niter_base(__it.base()))))
	{
		return make_move_iterator(__niter_base(__it.base()));
	}
	template <class _Iterator>
	struct __is_move_iterator<move_iterator<_Iterator>> {
		enum { __value = 1 };
		typedef __true_type __type;
	};
	template <class _Iterator>
	auto __miter_base(move_iterator<_Iterator> __it)
		->__decltype((__miter_base(__it.base())))
	{
		return __miter_base(__it.base());
	}
	template <class _InputIterator>
	using __iter_key_t = remove_const_t<typename iterator_traits<
		_InputIterator>::value_type::first_type>;
	template <class _InputIterator>
	using __iter_val_t =
		typename iterator_traits<_InputIterator>::value_type::second_type;
	template <class _T1, class _T2> struct pair;
	template <class _InputIterator>
	using __iter_to_alloc_t =
		pair<add_const_t<__iter_key_t<_InputIterator>>,
		     __iter_val_t<_InputIterator>>;
} // namespace )
namespace std
{
namespace __debug
{
}
} // namespace std
namespace __gnu_debug
{
using namespace std::__debug;
template <class _Ite, class _Seq, class _Cat> struct _Safe_iterator;
} // namespace __gnu_debug
namespace __gnu_cxx
{
namespace __ops
{
struct _Iter_less_iter {
	template <class _Iterator1, class _Iterator2>
	constexpr bool operator()(_Iterator1 __it1, _Iterator2 __it2) const
	{
		return (*__it1) < (*__it2);
	}
};
constexpr _Iter_less_iter __iter_less_iter()
{
	return _Iter_less_iter();
}
struct _Iter_less_val {
	constexpr _Iter_less_val() = default;
	explicit _Iter_less_val(_Iter_less_iter)
	{
	}
	template <class _Iterator, class _Value>
	bool operator()(_Iterator __it, _Value &__val) const
	{
		return (*__it) < __val;
	}
};
inline _Iter_less_val __iter_less_val()
{
	return _Iter_less_val();
}
inline _Iter_less_val __iter_comp_val(_Iter_less_iter)
{
	return _Iter_less_val();
}
struct _Val_less_iter {
	constexpr _Val_less_iter() = default;
	explicit _Val_less_iter(_Iter_less_iter)
	{
	}
	template <class _Value, class _Iterator>
	bool operator()(_Value &__val, _Iterator __it) const
	{
		return __val < (*__it);
	}
};
inline _Val_less_iter __val_less_iter()
{
	return _Val_less_iter();
}
inline _Val_less_iter __val_comp_iter(_Iter_less_iter)
{
	return _Val_less_iter();
}
struct _Iter_equal_to_iter {
	template <class _Iterator1, class _Iterator2>
	bool operator()(_Iterator1 __it1, _Iterator2 __it2) const
	{
		return (*__it1) == (*__it2);
	}
};
inline _Iter_equal_to_iter __iter_equal_to_iter()
{
	return _Iter_equal_to_iter();
}
struct _Iter_equal_to_val {
	template <class _Iterator, class _Value>
	bool operator()(_Iterator __it, _Value &__val) const
	{
		return (*__it) == __val;
	}
};
inline _Iter_equal_to_val __iter_equal_to_val()
{
	return _Iter_equal_to_val();
}
inline _Iter_equal_to_val __iter_comp_val(_Iter_equal_to_iter)
{
	return _Iter_equal_to_val();
}
template <class _Compare> struct _Iter_comp_iter {
	_Compare _M_comp;
	constexpr explicit _Iter_comp_iter(_Compare __comp)
		: _M_comp(std::move(__comp))
	{
	}
	template <class _Iterator1, class _Iterator2>
	constexpr bool operator()(_Iterator1 __it1, _Iterator2 __it2)
	{
		return (bool)(_M_comp)(*__it1, *__it2);
	}
};
template <class _Compare>
constexpr _Iter_comp_iter<_Compare> __iter_comp_iter(_Compare __comp)
{
	return ((_Iter_comp_iter<_Compare>)(std::move(__comp)));
}
template <class _Compare> struct _Iter_comp_val {
	_Compare _M_comp;
	explicit _Iter_comp_val(_Compare __comp) : _M_comp(std::move(__comp))
	{
	}
	explicit _Iter_comp_val(const _Iter_comp_iter<_Compare> &__comp)
		: _M_comp((__comp._M_comp))
	{
	}
	explicit _Iter_comp_val(_Iter_comp_iter<_Compare> &&__comp)
		: _M_comp(std::move((__comp._M_comp)))
	{
	}
	template <class _Iterator, class _Value>
	bool operator()(_Iterator __it, _Value &__val)
	{
		return (bool)(_M_comp)(*__it, __val);
	}
};
template <class _Compare>
inline _Iter_comp_val<_Compare> __iter_comp_val(_Compare __comp)
{
	return ((_Iter_comp_val<_Compare>)(std::move(__comp)));
}
template <class _Compare>
inline _Iter_comp_val<_Compare>
__iter_comp_val(_Iter_comp_iter<_Compare> __comp)
{
	return ((_Iter_comp_val<_Compare>)(std::move(__comp)));
}
template <class _Compare> struct _Val_comp_iter {
	_Compare _M_comp;
	explicit _Val_comp_iter(_Compare __comp) : _M_comp(std::move(__comp))
	{
	}
	explicit _Val_comp_iter(const _Iter_comp_iter<_Compare> &__comp)
		: _M_comp((__comp._M_comp))
	{
	}
	explicit _Val_comp_iter(_Iter_comp_iter<_Compare> &&__comp)
		: _M_comp(std::move((__comp._M_comp)))
	{
	}
	template <class _Value, class _Iterator>
	bool operator()(_Value &__val, _Iterator __it)
	{
		return (bool)(_M_comp)(__val, *__it);
	}
};
template <class _Compare>
inline _Val_comp_iter<_Compare> __val_comp_iter(_Compare __comp)
{
	return ((_Val_comp_iter<_Compare>)(std::move(__comp)));
}
template <class _Compare>
inline _Val_comp_iter<_Compare>
__val_comp_iter(_Iter_comp_iter<_Compare> __comp)
{
	return ((_Val_comp_iter<_Compare>)(std::move(__comp)));
}
template <class _Value> struct _Iter_equals_val {
	_Value &_M_value;
	explicit _Iter_equals_val(_Value &__value) : _M_value(__value)
	{
	}
	template <class _Iterator> bool operator()(_Iterator __it)
	{
		return (*__it) == (_M_value);
	}
};
template <class _Value>
inline _Iter_equals_val<_Value> __iter_equals_val(_Value &__val)
{
	return ((_Iter_equals_val<_Value>)(__val));
}
template <class _Iterator1> struct _Iter_equals_iter {
	_Iterator1 _M_it1;
	explicit _Iter_equals_iter(_Iterator1 __it1) : _M_it1(__it1)
	{
	}
	template <class _Iterator2> bool operator()(_Iterator2 __it2)
	{
		return (*__it2) == (*(_M_it1));
	}
};
template <class _Iterator>
inline _Iter_equals_iter<_Iterator> __iter_comp_iter(_Iter_equal_to_iter,
						     _Iterator __it)
{
	return ((_Iter_equals_iter<_Iterator>)(__it));
}
template <class _Predicate> struct _Iter_pred {
	_Predicate _M_pred;
	explicit _Iter_pred(_Predicate __pred) : _M_pred(std::move(__pred))
	{
	}
	template <class _Iterator> bool operator()(_Iterator __it)
	{
		return (bool)(_M_pred)(*__it);
	}
};
template <class _Predicate>
inline _Iter_pred<_Predicate> __pred_iter(_Predicate __pred)
{
	return ((_Iter_pred<_Predicate>)(std::move(__pred)));
}
template <class _Compare, class _Value> struct _Iter_comp_to_val {
	_Compare _M_comp;
	_Value &_M_value;
	_Iter_comp_to_val(_Compare __comp, _Value &__value)
		: _M_comp(std::move(__comp)), _M_value(__value)
	{
	}
	template <class _Iterator> bool operator()(_Iterator __it)
	{
		return (bool)(_M_comp)(*__it, _M_value);
	}
};
template <class _Compare, class _Value>
_Iter_comp_to_val<_Compare, _Value> __iter_comp_val(_Compare __comp,
						    _Value &__val)
{
	return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
}
template <class _Compare, class _Iterator1> struct _Iter_comp_to_iter {
	_Compare _M_comp;
	_Iterator1 _M_it1;
	_Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
		: _M_comp(std::move(__comp)), _M_it1(__it1)
	{
	}
	template <class _Iterator2> bool operator()(_Iterator2 __it2)
	{
		return (bool)(_M_comp)(*__it2, *(_M_it1));
	}
};
template <class _Compare, class _Iterator>
inline _Iter_comp_to_iter<_Compare, _Iterator>
__iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
{
	return _Iter_comp_to_iter<_Compare, _Iterator>(
		std::move((__comp._M_comp)), __it);
}
template <class _Predicate> struct _Iter_negate {
	_Predicate _M_pred;
	explicit _Iter_negate(_Predicate __pred) : _M_pred(std::move(__pred))
	{
	}
	template <class _Iterator> bool operator()(_Iterator __it)
	{
		return !((bool)(_M_pred)(*__it));
	}
};
template <class _Predicate>
inline _Iter_negate<_Predicate> __negate(_Iter_pred<_Predicate> __pred)
{
	return ((_Iter_negate<_Predicate>)(std::move((__pred._M_pred))));
}
} // namespace __ops
} // namespace __gnu_cxx
namespace std __attribute((__visibility__("default")))
{
	template <class _Tp, class _Up>
	constexpr int __memcmp(const _Tp *__first1, const _Up *__first2,
			       size_t __num)
	{
		static_assert((sizeof(_Tp) == sizeof(_Up)),
			      "can be compared with memcmp");
		return __builtin_memcmp(__first1, __first2,
					sizeof(_Tp) * __num);
	}
	template <class _ForwardIterator1, class _ForwardIterator2>
	inline void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
	{
		swap(*__a, *__b);
	}
	template <class _ForwardIterator1, class _ForwardIterator2>
	_ForwardIterator2 swap_ranges(_ForwardIterator1 __first1,
				      _ForwardIterator1 __last1,
				      _ForwardIterator2 __first2)
	{
		;
		for (; __first1 != __last1;
		     (++__first1), ((void)(++__first2))) {
			std::iter_swap(__first1, __first2);
		}
		return __first2;
	}
	template <class _Tp>
	constexpr const _Tp &min(const _Tp &__a, const _Tp &__b)
	{
		if (__b < __a) {
			return __b;
		}
		return __a;
	}
	template <class _Tp>
	constexpr const _Tp &max(const _Tp &__a, const _Tp &__b)
	{
		if (__a < __b) {
			return __b;
		}
		return __a;
	}
	template <class _Tp, class _Compare>
	constexpr const _Tp &min(const _Tp &__a, const _Tp &__b,
				 _Compare __comp)
	{
		if (__comp(__b, __a)) {
			return __b;
		}
		return __a;
	}
	template <class _Tp, class _Compare>
	constexpr const _Tp &max(const _Tp &__a, const _Tp &__b,
				 _Compare __comp)
	{
		if (__comp(__a, __b)) {
			return __b;
		}
		return __a;
	}
	template <class _Iterator>
	inline _Iterator __niter_base(_Iterator __it) noexcept(
		std::template is_nothrow_copy_constructible<_Iterator>::value)
	{
		return __it;
	}
	template <class _Ite, class _Seq>
	_Ite __niter_base(const __gnu_debug::_Safe_iterator<
			  _Ite, _Seq, random_access_iterator_tag> &);
	template <class _From, class _To>
	inline _From __niter_wrap(_From __from, _To __res)
	{
		return __from + (__res - std::__niter_base(__from));
	}
	template <class _Iterator>
	inline _Iterator __niter_wrap(const _Iterator &, _Iterator __res)
	{
		return __res;
	}
	template <bool _IsMove, bool _IsSimple, class _Category>
	struct __copy_move {
		template <class _II, class _OI>
		static _OI __copy_m(_II __first, _II __last, _OI __result)
		{
			for (; __first != __last;
			     (++__result), ((void)(++__first))) {
				(*__result) = (*__first);
			}
			return __result;
		}
	};
	template <class _Category> struct __copy_move<true, false, _Category> {
		template <class _II, class _OI>
		static _OI __copy_m(_II __first, _II __last, _OI __result)
		{
			for (; __first != __last;
			     (++__result), ((void)(++__first))) {
				(*__result) = std::move(*__first);
			}
			return __result;
		}
	};
	template <>
	struct __copy_move<false, false, random_access_iterator_tag> {
		template <class _II, class _OI>
		static _OI __copy_m(_II __first, _II __last, _OI __result)
		{
			typedef typename iterator_traits<_II>::difference_type
				_Distance;
			for (_Distance __n = __last - __first; __n > 0; --__n) {
				(*__result) = (*__first);
				++__first;
				++__result;
			}
			return __result;
		}
	};
	template <>
	struct __copy_move<true, false, random_access_iterator_tag> {
		template <class _II, class _OI>
		static _OI __copy_m(_II __first, _II __last, _OI __result)
		{
			typedef typename iterator_traits<_II>::difference_type
				_Distance;
			for (_Distance __n = __last - __first; __n > 0; --__n) {
				(*__result) = std::move(*__first);
				++__first;
				++__result;
			}
			return __result;
		}
	};
	template <bool _IsMove>
	struct __copy_move<_IsMove, true, random_access_iterator_tag> {
		template <class _Tp>
		static _Tp *__copy_m(const _Tp *__first, const _Tp *__last,
				     _Tp *__result)
		{
			using __assignable =
				__conditional_t<_IsMove, is_move_assignable<_Tp>,
						is_copy_assignable<_Tp>>;
			static_assert((__assignable::value),
				      "type must be assignable");
			const ptrdiff_t _Num = __last - __first;
			if (_Num) {
				__builtin_memmove(__result, __first,
						  sizeof(_Tp) * _Num);
			}
			return __result + _Num;
		}
	};
	template <class _Tp, class _Ref, class _Ptr> struct _Deque_iterator;
	struct _Bit_iterator;
	template <class _CharT> struct char_traits;
	template <class _CharT, class _Traits> class istreambuf_iterator;
	template <class _CharT, class _Traits> class ostreambuf_iterator;
	template <bool _IsMove, class _CharT>
	typename __gnu_cxx::__enable_if<
		__is_char<_CharT>::__value,
		ostreambuf_iterator<_CharT, char_traits<_CharT>>>::__type
	__copy_move_a2(_CharT *, _CharT *,
		       ostreambuf_iterator<_CharT, char_traits<_CharT>>);
	template <bool _IsMove, class _CharT>
	typename __gnu_cxx::__enable_if<
		__is_char<_CharT>::__value,
		ostreambuf_iterator<_CharT, char_traits<_CharT>>>::__type
	__copy_move_a2(const _CharT *, const _CharT *,
		       ostreambuf_iterator<_CharT, char_traits<_CharT>>);
	template <bool _IsMove, class _CharT>
	typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
					_CharT *>::__type
	__copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT>>,
		       istreambuf_iterator<_CharT, char_traits<_CharT>>,
		       _CharT *);
	template <bool _IsMove, class _CharT>
	typename __gnu_cxx::__enable_if<
		__is_char<_CharT>::__value,
		_Deque_iterator<_CharT, _CharT &, _CharT *>>::__type
		__copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT>>,
			       istreambuf_iterator<_CharT, char_traits<_CharT>>,
			       _Deque_iterator<_CharT, _CharT &, _CharT *>);
	template <bool _IsMove, class _II, class _OI>
	inline _OI __copy_move_a2(_II __first, _II __last, _OI __result)
	{
		typedef typename iterator_traits<_II>::iterator_category
			_Category;
		return std::template __copy_move<
			_IsMove, __memcpyable<_OI, _II>::__value,
			typename iterator_traits<_II>::iterator_category>::
			__copy_m(__first, __last, __result);
	}
	template <bool _IsMove, class _Tp, class _Ref, class _Ptr, class _OI>
	_OI __copy_move_a1(_Deque_iterator<_Tp, _Ref, _Ptr>,
			   _Deque_iterator<_Tp, _Ref, _Ptr>, _OI);
	template <bool _IsMove, class _ITp, class _IRef, class _IPtr, class _OTp>
	_Deque_iterator<_OTp, _OTp &, _OTp *> __copy_move_a1(
		_Deque_iterator<_ITp, _IRef, _IPtr>,
		_Deque_iterator<_ITp, _IRef, _IPtr>,
		_Deque_iterator<_OTp, _OTp &, _OTp *>);
	template <bool _IsMove, class _II, class _Tp>
	typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value,
					_Deque_iterator<_Tp, _Tp &, _Tp *>>::__type
		__copy_move_a1(_II, _II, _Deque_iterator<_Tp, _Tp &, _Tp *>);
	template <bool _IsMove, class _II, class _OI>
	inline _OI __copy_move_a1(_II __first, _II __last, _OI __result)
	{
		return std::__copy_move_a2<_IsMove>(__first, __last, __result);
	}
	template <bool _IsMove, class _II, class _OI>
	inline _OI __copy_move_a(_II __first, _II __last, _OI __result)
	{
		return std::__niter_wrap(__result,
					 std::__copy_move_a1<_IsMove>(
						 std::__niter_base(__first),
						 std::__niter_base(__last),
						 std::__niter_base(__result)));
	}
	template <bool _IsMove, class _Ite, class _Seq, class _Cat, class _OI>
	_OI __copy_move_a(const __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &,
			  const __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &,
			  _OI);
	template <bool _IsMove, class _II, class _Ite, class _Seq, class _Cat>
	__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> __copy_move_a(
		_II, _II,
		const __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &);
	template <bool _IsMove, class _IIte, class _ISeq, class _ICat,
		  class _OIte, class _OSeq, class _OCat>
	__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> __copy_move_a(
		const __gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &,
		const __gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &,
		const __gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> &);
	template <class _InputIterator, class _Size, class _OutputIterator>
	_OutputIterator __copy_n_a(_InputIterator __first, _Size __n,
				   _OutputIterator __result, bool)
	{
		if (__n > 0) {
			while (true) {
				(*__result) = (*__first);
				++__result;
				if ((--__n) > 0) {
					++__first;
				} else {
					break;
				}
			}
		}
		return __result;
	}
	template <class _CharT, class _Size>
	typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
					_CharT *>::__type
	__copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT>>, _Size,
		   _CharT *, bool);
	template <class _CharT, class _Size>
	typename __gnu_cxx::__enable_if<
		__is_char<_CharT>::__value,
		_Deque_iterator<_CharT, _CharT &, _CharT *>>::__type
	__copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT>>, _Size,
		   _Deque_iterator<_CharT, _CharT &, _CharT *>, bool);
	template <class _II, class _OI>
	inline _OI copy(_II __first, _II __last, _OI __result)
	{
		;
		return std::__copy_move_a<__is_move_iterator<_II>::__value>(
			std::__miter_base(__first), std::__miter_base(__last),
			__result);
	}
	template <class _II, class _OI>
	inline _OI move(_II __first, _II __last, _OI __result)
	{
		;
		return std::__copy_move_a<true>(std::__miter_base(__first),
						std::__miter_base(__last),
						__result);
	}
	template <bool _IsMove, bool _IsSimple, class _Category>
	struct __copy_move_backward {
		template <class _BI1, class _BI2>
		static _BI2 __copy_move_b(_BI1 __first, _BI1 __last,
					  _BI2 __result)
		{
			while (__first != __last) {
				(*(--__result)) = (*(--__last));
			}
			return __result;
		}
	};
	template <class _Category>
	struct __copy_move_backward<true, false, _Category> {
		template <class _BI1, class _BI2>
		static _BI2 __copy_move_b(_BI1 __first, _BI1 __last,
					  _BI2 __result)
		{
			while (__first != __last) {
				(*(--__result)) = std::move(*(--__last));
			}
			return __result;
		}
	};
	template <>
	struct __copy_move_backward<false, false, random_access_iterator_tag> {
		template <class _BI1, class _BI2>
		static _BI2 __copy_move_b(_BI1 __first, _BI1 __last,
					  _BI2 __result)
		{
			typename iterator_traits<_BI1>::difference_type __n =
				__last - __first;
			for (; __n > 0; --__n) {
				(*(--__result)) = (*(--__last));
			}
			return __result;
		}
	};
	template <>
	struct __copy_move_backward<true, false, random_access_iterator_tag> {
		template <class _BI1, class _BI2>
		static _BI2 __copy_move_b(_BI1 __first, _BI1 __last,
					  _BI2 __result)
		{
			typename iterator_traits<_BI1>::difference_type __n =
				__last - __first;
			for (; __n > 0; --__n) {
				(*(--__result)) = std::move(*(--__last));
			}
			return __result;
		}
	};
	template <bool _IsMove>
	struct __copy_move_backward<_IsMove, true, random_access_iterator_tag> {
		template <class _Tp>
		static _Tp *__copy_move_b(const _Tp *__first, const _Tp *__last,
					  _Tp *__result)
		{
			using __assignable =
				__conditional_t<_IsMove, is_move_assignable<_Tp>,
						is_copy_assignable<_Tp>>;
			static_assert((__assignable::value),
				      "type must be assignable");
			const ptrdiff_t _Num = __last - __first;
			if (_Num) {
				__builtin_memmove(__result - _Num, __first,
						  sizeof(_Tp) * _Num);
			}
			return __result - _Num;
		}
	};
	template <bool _IsMove, class _BI1, class _BI2>
	inline _BI2 __copy_move_backward_a2(_BI1 __first, _BI1 __last,
					    _BI2 __result)
	{
		typedef typename iterator_traits<_BI1>::iterator_category
			_Category;
		return std::template __copy_move_backward<
			_IsMove, __memcpyable<_BI2, _BI1>::__value,
			typename iterator_traits<_BI1>::iterator_category>::
			__copy_move_b(__first, __last, __result);
	}
	template <bool _IsMove, class _BI1, class _BI2>
	inline _BI2 __copy_move_backward_a1(_BI1 __first, _BI1 __last,
					    _BI2 __result)
	{
		return std::__copy_move_backward_a2<_IsMove>(__first, __last,
							     __result);
	}
	template <bool _IsMove, class _Tp, class _Ref, class _Ptr, class _OI>
	_OI __copy_move_backward_a1(_Deque_iterator<_Tp, _Ref, _Ptr>,
				    _Deque_iterator<_Tp, _Ref, _Ptr>, _OI);
	template <bool _IsMove, class _ITp, class _IRef, class _IPtr, class _OTp>
	_Deque_iterator<_OTp, _OTp &, _OTp *> __copy_move_backward_a1(
		_Deque_iterator<_ITp, _IRef, _IPtr>,
		_Deque_iterator<_ITp, _IRef, _IPtr>,
		_Deque_iterator<_OTp, _OTp &, _OTp *>);
	template <bool _IsMove, class _II, class _Tp>
	typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value,
					_Deque_iterator<_Tp, _Tp &, _Tp *>>::__type
		__copy_move_backward_a1(_II, _II,
					_Deque_iterator<_Tp, _Tp &, _Tp *>);
	template <bool _IsMove, class _II, class _OI>
	inline _OI __copy_move_backward_a(_II __first, _II __last, _OI __result)
	{
		return std::__niter_wrap(__result,
					 std::__copy_move_backward_a1<_IsMove>(
						 std::__niter_base(__first),
						 std::__niter_base(__last),
						 std::__niter_base(__result)));
	}
	template <bool _IsMove, class _Ite, class _Seq, class _Cat, class _OI>
	_OI __copy_move_backward_a(
		const __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &,
		const __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, _OI);
	template <bool _IsMove, class _II, class _Ite, class _Seq, class _Cat>
	__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> __copy_move_backward_a(
		_II, _II,
		const __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &);
	template <bool _IsMove, class _IIte, class _ISeq, class _ICat,
		  class _OIte, class _OSeq, class _OCat>
	__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> __copy_move_backward_a(
		const __gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &,
		const __gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &,
		const __gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> &);
	template <class _BI1, class _BI2>
	inline _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
	{
		;
		return std::__copy_move_backward_a<
			__is_move_iterator<_BI1>::__value>(
			std::__miter_base(__first), std::__miter_base(__last),
			__result);
	}
	template <class _BI1, class _BI2>
	inline _BI2 move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
	{
		;
		return std::__copy_move_backward_a<true>(
			std::__miter_base(__first), std::__miter_base(__last),
			__result);
	}
	template <class _ForwardIterator, class _Tp>
	inline typename __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value,
					       void>::__type
	__fill_a1(_ForwardIterator __first, _ForwardIterator __last,
		  const _Tp &__value)
	{
		for (; __first != __last; ++__first) {
			(*__first) = __value;
		}
	}
	template <class _ForwardIterator, class _Tp>
	inline typename __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value,
					       void>::__type
	__fill_a1(_ForwardIterator __first, _ForwardIterator __last,
		  const _Tp &__value)
	{
		const _Tp __tmp = __value;
		for (; __first != __last; ++__first) {
			(*__first) = __tmp;
		}
	}
	template <class _Tp>
	inline typename __gnu_cxx::__enable_if<__is_byte<_Tp>::__value,
					       void>::__type
	__fill_a1(_Tp * __first, _Tp * __last, const _Tp &__c)
	{
		const _Tp __tmp = __c;
		if (const size_t __len = __last - __first) {
			__builtin_memset(__first,
					 static_cast<unsigned char>(__tmp),
					 __len);
		}
	}
	template <class _Ite, class _Cont, class _Tp>
	inline void __fill_a1(__gnu_cxx::__normal_iterator<_Ite, _Cont> __first,
			      __gnu_cxx::__normal_iterator<_Ite, _Cont> __last,
			      const _Tp &__value)
	{
		std::__fill_a1(__first.base(), __last.base(), __value);
	}
	template <class _Tp, class _VTp>
	void __fill_a1(const _Deque_iterator<_Tp, _Tp &, _Tp *> &,
		       const _Deque_iterator<_Tp, _Tp &, _Tp *> &,
		       const _VTp &);
	inline void __fill_a1(_Bit_iterator, _Bit_iterator, const bool &);
	template <class _FIte, class _Tp>
	inline void __fill_a(_FIte __first, _FIte __last, const _Tp &__value)
	{
		std::__fill_a1(__first, __last, __value);
	}
	template <class _Ite, class _Seq, class _Cat, class _Tp>
	void __fill_a(const __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &,
		      const __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &,
		      const _Tp &);
	template <class _ForwardIterator, class _Tp>
	inline void fill(_ForwardIterator __first, _ForwardIterator __last,
			 const _Tp &__value)
	{
		;
		std::__fill_a(__first, __last, __value);
	}
	constexpr int __size_to_integer(int __n)
	{
		return __n;
	}
	constexpr unsigned __size_to_integer(unsigned __n)
	{
		return __n;
	}
	constexpr long __size_to_integer(long __n)
	{
		return __n;
	}
	constexpr unsigned long __size_to_integer(unsigned long __n)
	{
		return __n;
	}
	constexpr long long __size_to_integer(long long __n)
	{
		return __n;
	}
	constexpr unsigned long long __size_to_integer(unsigned long long __n)
	{
		return __n;
	}
	__extension__ constexpr __int128 __size_to_integer(__int128 __n)
	{
		return __n;
	}
	__extension__ constexpr unsigned __int128 __size_to_integer(
		unsigned __int128 __n)
	{
		return __n;
	}
	constexpr long long __size_to_integer(float __n)
	{
		return (long long)__n;
	}
	constexpr long long __size_to_integer(double __n)
	{
		return (long long)__n;
	}
	constexpr long long __size_to_integer(long double __n)
	{
		return (long long)__n;
	}
	template <class _OutputIterator, class _Size, class _Tp>
	inline typename __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value,
					       _OutputIterator>::__type
	__fill_n_a1(_OutputIterator __first, _Size __n, const _Tp &__value)
	{
		for (; __n > 0; (--__n), ((void)(++__first))) {
			(*__first) = __value;
		}
		return __first;
	}
	template <class _OutputIterator, class _Size, class _Tp>
	inline typename __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value,
					       _OutputIterator>::__type
	__fill_n_a1(_OutputIterator __first, _Size __n, const _Tp &__value)
	{
		const _Tp __tmp = __value;
		for (; __n > 0; (--__n), ((void)(++__first))) {
			(*__first) = __tmp;
		}
		return __first;
	}
	template <class _Ite, class _Seq, class _Cat, class _Size, class _Tp>
	__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> __fill_n_a(
		const __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &__first,
		_Size __n, const _Tp &__value, input_iterator_tag);
	template <class _OutputIterator, class _Size, class _Tp>
	inline _OutputIterator __fill_n_a(_OutputIterator __first, _Size __n,
					  const _Tp &__value,
					  output_iterator_tag)
	{
		static_assert((is_integral<_Size>{}),
			      "fill_n must pass integral size");
		return __fill_n_a1(__first, __n, __value);
	}
	template <class _OutputIterator, class _Size, class _Tp>
	inline _OutputIterator __fill_n_a(_OutputIterator __first, _Size __n,
					  const _Tp &__value,
					  input_iterator_tag)
	{
		static_assert((is_integral<_Size>{}),
			      "fill_n must pass integral size");
		return __fill_n_a1(__first, __n, __value);
	}
	template <class _OutputIterator, class _Size, class _Tp>
	inline _OutputIterator __fill_n_a(_OutputIterator __first, _Size __n,
					  const _Tp &__value,
					  random_access_iterator_tag)
	{
		static_assert((is_integral<_Size>{}),
			      "fill_n must pass integral size");
		if (__n <= 0) {
			return __first;
		};
		std::__fill_a(__first, __first + __n, __value);
		return __first + __n;
	}
	template <class _OI, class _Size, class _Tp>
	inline _OI fill_n(_OI __first, _Size __n, const _Tp &__value)
	{
		return std::__fill_n_a(__first, std::__size_to_integer(__n),
				       __value,
				       std::__iterator_category(__first));
	}
	template <bool _BoolType> struct __equal {
		template <class _II1, class _II2>
		static bool equal(_II1 __first1, _II1 __last1, _II2 __first2)
		{
			for (; __first1 != __last1;
			     (++__first1), ((void)(++__first2))) {
				if (!((*__first1) == (*__first2))) {
					return false;
				}
			}
			return true;
		}
	};
	template <> struct __equal<true> {
		template <class _Tp>
		static bool equal(const _Tp *__first1, const _Tp *__last1,
				  const _Tp *__first2)
		{
			if (const size_t __len = __last1 - __first1) {
				return !std::__memcmp(__first1, __first2,
						      __len);
			}
			return true;
		}
	};
	template <class _Tp, class _Ref, class _Ptr, class _II>
	typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value,
					bool>::__type
		__equal_aux1(_Deque_iterator<_Tp, _Ref, _Ptr>,
			     _Deque_iterator<_Tp, _Ref, _Ptr>, _II);
	template <class _Tp1, class _Ref1, class _Ptr1, class _Tp2, class _Ref2,
		  class _Ptr2>
	bool __equal_aux1(_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
			  _Deque_iterator<_Tp1, _Ref1, _Ptr1>,
			  _Deque_iterator<_Tp2, _Ref2, _Ptr2>);
	template <class _II, class _Tp, class _Ref, class _Ptr>
	typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value,
					bool>::__type
		__equal_aux1(_II, _II, _Deque_iterator<_Tp, _Ref, _Ptr>);
	template <class _II1, class _II2>
	inline bool __equal_aux1(_II1 __first1, _II1 __last1, _II2 __first2)
	{
		typedef typename iterator_traits<_II1>::value_type _ValueType1;
		const bool __simple = ((__is_integer<typename iterator_traits<
						_II1>::value_type>::__value ||
					__is_pointer<typename iterator_traits<
						_II1>::value_type>::__value) &&
				       __memcmpable<_II1, _II2>::__value);
		return std::template __equal<__simple>::equal(__first1, __last1,
							      __first2);
	}
	template <class _II1, class _II2>
	inline bool __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
	{
		return std::__equal_aux1(std::__niter_base(__first1),
					 std::__niter_base(__last1),
					 std::__niter_base(__first2));
	}
	template <class _II1, class _Seq1, class _Cat1, class _II2>
	bool __equal_aux(
		const __gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &,
		const __gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &, _II2);
	template <class _II1, class _II2, class _Seq2, class _Cat2>
	bool __equal_aux(
		_II1, _II1,
		const __gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2> &);
	template <class _II1, class _Seq1, class _Cat1, class _II2, class _Seq2,
		  class _Cat2>
	bool __equal_aux(
		const __gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &,
		const __gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &,
		const __gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2> &);
	template <class, class> struct __lc_rai {
		template <class _II1, class _II2>
		static _II1 __newlast1(_II1, _II1 __last1, _II2, _II2)
		{
			return __last1;
		}
		template <class _II> static bool __cnd2(_II __first, _II __last)
		{
			return __first != __last;
		}
	};
	template <>
	struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag> {
		template <class _RAI1, class _RAI2>
		static _RAI1 __newlast1(_RAI1 __first1, _RAI1 __last1,
					_RAI2 __first2, _RAI2 __last2)
		{
			const typename iterator_traits<_RAI1>::difference_type
				__diff1 = __last1 - __first1;
			const typename iterator_traits<_RAI2>::difference_type
				__diff2 = __last2 - __first2;
			return (__diff2 < __diff1) ? __first1 + __diff2 :
						     __last1;
		}
		template <class _RAI> static bool __cnd2(_RAI, _RAI)
		{
			return true;
		}
	};
	template <class _II1, class _II2, class _Compare>
	bool __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
					    _II2 __first2, _II2 __last2,
					    _Compare __comp)
	{
		typedef typename iterator_traits<_II1>::iterator_category
			_Category1;
		typedef typename iterator_traits<_II2>::iterator_category
			_Category2;
		typedef __lc_rai<
			typename iterator_traits<_II1>::iterator_category,
			typename iterator_traits<_II2>::iterator_category>
			__rai_type;
		__last1 = __rai_type::__newlast1(__first1, __last1, __first2,
						 __last2);
		for (; (__first1 != __last1) &&
		       __rai_type::__cnd2(__first2, __last2);
		     (++__first1), ((void)(++__first2))) {
			if (__comp(__first1, __first2)) {
				return true;
			}
			if (__comp(__first2, __first1)) {
				return false;
			}
		}
		return (__first1 == __last1) && (__first2 != __last2);
	}
	template <bool _BoolType> struct __lexicographical_compare {
		template <class _II1, class _II2>
		static bool __lc(_II1 __first1, _II1 __last1, _II2 __first2,
				 _II2 __last2)
		{
			using __gnu_cxx::__ops::__iter_less_iter;
			return std::__lexicographical_compare_impl(
				__first1, __last1, __first2, __last2,
				__iter_less_iter());
		}
		template <class _II1, class _II2>
		static int __3way(_II1 __first1, _II1 __last1, _II2 __first2,
				  _II2 __last2)
		{
			while (__first1 != __last1) {
				if (__first2 == __last2) {
					return +1;
				}
				if ((*__first1) < (*__first2)) {
					return -1;
				}
				if ((*__first2) < (*__first1)) {
					return +1;
				}
				++__first1;
				++__first2;
			}
			return ((int)(__first2 == __last2)) - 1;
		}
	};
	template <> struct __lexicographical_compare<true> {
		template <class _Tp, class _Up>
		static bool __lc(const _Tp *__first1, const _Tp *__last1,
				 const _Up *__first2, const _Up *__last2)
		{
			return __3way(__first1, __last1, __first2, __last2) < 0;
		}
		template <class _Tp, class _Up>
		static ptrdiff_t __3way(const _Tp *__first1, const _Tp *__last1,
					const _Up *__first2, const _Up *__last2)
		{
			const size_t __len1 = __last1 - __first1;
			const size_t __len2 = __last2 - __first2;
			if (const size_t __len = std::min(__len1, __len2)) {
				if (int __result = std::__memcmp(
					    __first1, __first2, __len)) {
					return __result;
				}
			}
			return (ptrdiff_t)(__len1 - __len2);
		}
	};
	template <class _II1, class _II2>
	inline bool __lexicographical_compare_aux1(_II1 __first1, _II1 __last1,
						   _II2 __first2, _II2 __last2)
	{
		typedef typename iterator_traits<_II1>::value_type _ValueType1;
		typedef typename iterator_traits<_II2>::value_type _ValueType2;
		const bool __simple =
			(__is_memcmp_ordered_with<
				 typename iterator_traits<_II1>::value_type,
				 typename iterator_traits<_II2>::value_type>::
				 __value &&
			 __is_pointer<_II1>::__value &&
			 __is_pointer<_II2>::__value);
		return std::template __lexicographical_compare<__simple>::__lc(
			__first1, __last1, __first2, __last2);
	}
	template <class _Tp1, class _Ref1, class _Ptr1, class _Tp2>
	bool __lexicographical_compare_aux1(_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
					    _Deque_iterator<_Tp1, _Ref1, _Ptr1>,
					    _Tp2 *, _Tp2 *);
	template <class _Tp1, class _Tp2, class _Ref2, class _Ptr2>
	bool __lexicographical_compare_aux1(
		_Tp1 *, _Tp1 *, _Deque_iterator<_Tp2, _Ref2, _Ptr2>,
		_Deque_iterator<_Tp2, _Ref2, _Ptr2>);
	template <class _Tp1, class _Ref1, class _Ptr1, class _Tp2, class _Ref2,
		  class _Ptr2>
	bool __lexicographical_compare_aux1(
		_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
		_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
		_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
		_Deque_iterator<_Tp2, _Ref2, _Ptr2>);
	template <class _II1, class _II2>
	inline bool __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
						  _II2 __first2, _II2 __last2)
	{
		return std::__lexicographical_compare_aux1(
			std::__niter_base(__first1), std::__niter_base(__last1),
			std::__niter_base(__first2),
			std::__niter_base(__last2));
	}
	template <class _Iter1, class _Seq1, class _Cat1, class _II2>
	bool __lexicographical_compare_aux(
		const __gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1> &,
		const __gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1> &, _II2,
		_II2);
	template <class _II1, class _Iter2, class _Seq2, class _Cat2>
	bool __lexicographical_compare_aux(
		_II1, _II1,
		const __gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2> &,
		const __gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2> &);
	template <class _Iter1, class _Seq1, class _Cat1, class _Iter2,
		  class _Seq2, class _Cat2>
	bool __lexicographical_compare_aux(
		const __gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1> &,
		const __gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1> &,
		const __gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2> &,
		const __gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2> &);
	template <class _ForwardIterator, class _Tp, class _Compare>
	_ForwardIterator __lower_bound(_ForwardIterator __first,
				       _ForwardIterator __last,
				       const _Tp &__val, _Compare __comp)
	{
		typedef typename iterator_traits<
			_ForwardIterator>::difference_type _DistanceType;
		_DistanceType __len = std::distance(__first, __last);
		while (__len > 0) {
			_DistanceType __half = __len >> 1;
			_ForwardIterator __middle = __first;
			std::advance(__middle, __half);
			if (__comp(__middle, __val)) {
				__first = __middle;
				++__first;
				__len = ((__len - __half) - 1);
			} else {
				__len = __half;
			}
		}
		return __first;
	}
	template <class _ForwardIterator, class _Tp>
	inline _ForwardIterator lower_bound(_ForwardIterator __first,
					    _ForwardIterator __last,
					    const _Tp &__val)
	{
		;
		return std::__lower_bound(__first, __last, __val,
					  __gnu_cxx::__ops::__iter_less_val());
	}
	constexpr int __lg(int __n)
	{
		return ((((int)sizeof(int)) * 8) - 1) - __builtin_clz(__n);
	}
	constexpr unsigned __lg(unsigned __n)
	{
		return ((((int)sizeof(int)) * 8) - 1) - __builtin_clz(__n);
	}
	constexpr long __lg(long __n)
	{
		return ((((int)sizeof(long)) * 8) - 1) - __builtin_clzl(__n);
	}
	constexpr unsigned long __lg(unsigned long __n)
	{
		return ((((int)sizeof(long)) * 8) - 1) - __builtin_clzl(__n);
	}
	constexpr long long __lg(long long __n)
	{
		return ((((int)sizeof(long long)) * 8) - 1) -
		       __builtin_clzll(__n);
	}
	constexpr unsigned long long __lg(unsigned long long __n)
	{
		return ((((int)sizeof(long long)) * 8) - 1) -
		       __builtin_clzll(__n);
	}
	template <class _II1, class _II2>
	inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2)
	{
		;
		return std::__equal_aux(__first1, __last1, __first2);
	}
	template <class _IIter1, class _IIter2, class _BinaryPredicate>
	inline bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2,
			  _BinaryPredicate __binary_pred)
	{
		;
		for (; __first1 != __last1;
		     (++__first1), ((void)(++__first2))) {
			if (!((bool)__binary_pred(*__first1, *__first2))) {
				return false;
			}
		}
		return true;
	}
	template <class _II1, class _II2>
	inline bool __equal4(_II1 __first1, _II1 __last1, _II2 __first2,
			     _II2 __last2)
	{
		using _RATag = random_access_iterator_tag;
		using _Cat1 = typename iterator_traits<_II1>::iterator_category;
		using _Cat2 = typename iterator_traits<_II2>::iterator_category;
		using _RAIters = __and_<
			is_same<typename iterator_traits<_II1>::iterator_category,
				random_access_iterator_tag>,
			is_same<typename iterator_traits<_II2>::iterator_category,
				random_access_iterator_tag>>;
		if (_RAIters()) {
			auto __d1 = std::distance(__first1, __last1);
			auto __d2 = std::distance(__first2, __last2);
			if (__d1 != __d2) {
				return false;
			}
			return std::equal(__first1, __last1, __first2);
		}
		for (; (__first1 != __last1) && (__first2 != __last2);
		     (++__first1), ((void)(++__first2))) {
			if (!((*__first1) == (*__first2))) {
				return false;
			}
		}
		return (__first1 == __last1) && (__first2 == __last2);
	}
	template <class _II1, class _II2, class _BinaryPredicate>
	inline bool __equal4(_II1 __first1, _II1 __last1, _II2 __first2,
			     _II2 __last2, _BinaryPredicate __binary_pred)
	{
		using _RATag = random_access_iterator_tag;
		using _Cat1 = typename iterator_traits<_II1>::iterator_category;
		using _Cat2 = typename iterator_traits<_II2>::iterator_category;
		using _RAIters = __and_<
			is_same<typename iterator_traits<_II1>::iterator_category,
				random_access_iterator_tag>,
			is_same<typename iterator_traits<_II2>::iterator_category,
				random_access_iterator_tag>>;
		if (_RAIters()) {
			auto __d1 = std::distance(__first1, __last1);
			auto __d2 = std::distance(__first2, __last2);
			if (__d1 != __d2) {
				return false;
			}
			return std::equal(__first1, __last1, __first2,
					  __binary_pred);
		}
		for (; (__first1 != __last1) && (__first2 != __last2);
		     (++__first1), ((void)(++__first2))) {
			if (!((bool)__binary_pred(*__first1, *__first2))) {
				return false;
			}
		}
		return (__first1 == __last1) && (__first2 == __last2);
	}
	template <class _II1, class _II2>
	inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2,
			  _II2 __last2)
	{
		;
		;
		return std::__equal4(__first1, __last1, __first2, __last2);
	}
	template <class _IIter1, class _IIter2, class _BinaryPredicate>
	inline bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2,
			  _IIter2 __last2, _BinaryPredicate __binary_pred)
	{
		;
		;
		return std::__equal4(__first1, __last1, __first2, __last2,
				     __binary_pred);
	}
	template <class _II1, class _II2>
	inline bool lexicographical_compare(_II1 __first1, _II1 __last1,
					    _II2 __first2, _II2 __last2)
	{
		;
		;
		return std::__lexicographical_compare_aux(__first1, __last1,
							  __first2, __last2);
	}
	template <class _II1, class _II2, class _Compare>
	inline bool lexicographical_compare(_II1 __first1, _II1 __last1,
					    _II2 __first2, _II2 __last2,
					    _Compare __comp)
	{
		;
		;
		return std::__lexicographical_compare_impl(
			__first1, __last1, __first2, __last2,
			__gnu_cxx::__ops::__iter_comp_iter(__comp));
	}
	template <class _InputIterator1, class _InputIterator2,
		  class _BinaryPredicate>
	pair<_InputIterator1, _InputIterator2> __mismatch(
		_InputIterator1 __first1, _InputIterator1 __last1,
		_InputIterator2 __first2, _BinaryPredicate __binary_pred)
	{
		while ((__first1 != __last1) &&
		       __binary_pred(__first1, __first2)) {
			++__first1;
			++__first2;
		}
		return pair<_InputIterator1, _InputIterator2>(__first1,
							      __first2);
	}
	template <class _InputIterator1, class _InputIterator2>
	inline pair<_InputIterator1, _InputIterator2> mismatch(
		_InputIterator1 __first1, _InputIterator1 __last1,
		_InputIterator2 __first2)
	{
		;
		return std::__mismatch(
			__first1, __last1, __first2,
			__gnu_cxx::__ops::__iter_equal_to_iter());
	}
	template <class _InputIterator1, class _InputIterator2,
		  class _BinaryPredicate>
	inline pair<_InputIterator1, _InputIterator2> mismatch(
		_InputIterator1 __first1, _InputIterator1 __last1,
		_InputIterator2 __first2, _BinaryPredicate __binary_pred)
	{
		;
		return std::__mismatch(
			__first1, __last1, __first2,
			__gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
	}
	template <class _InputIterator1, class _InputIterator2,
		  class _BinaryPredicate>
	pair<_InputIterator1, _InputIterator2> __mismatch(
		_InputIterator1 __first1, _InputIterator1 __last1,
		_InputIterator2 __first2, _InputIterator2 __last2,
		_BinaryPredicate __binary_pred)
	{
		while ((__first1 != __last1) && (__first2 != __last2) &&
		       __binary_pred(__first1, __first2)) {
			++__first1;
			++__first2;
		}
		return pair<_InputIterator1, _InputIterator2>(__first1,
							      __first2);
	}
	template <class _InputIterator1, class _InputIterator2>
	inline pair<_InputIterator1, _InputIterator2> mismatch(
		_InputIterator1 __first1, _InputIterator1 __last1,
		_InputIterator2 __first2, _InputIterator2 __last2)
	{
		;
		;
		return std::__mismatch(
			__first1, __last1, __first2, __last2,
			__gnu_cxx::__ops::__iter_equal_to_iter());
	}
	template <class _InputIterator1, class _InputIterator2,
		  class _BinaryPredicate>
	inline pair<_InputIterator1, _InputIterator2> mismatch(
		_InputIterator1 __first1, _InputIterator1 __last1,
		_InputIterator2 __first2, _InputIterator2 __last2,
		_BinaryPredicate __binary_pred)
	{
		;
		;
		return std::__mismatch(
			__first1, __last1, __first2, __last2,
			__gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
	}
	template <class _InputIterator, class _Predicate>
	inline _InputIterator __find_if(_InputIterator __first,
					_InputIterator __last,
					_Predicate __pred, input_iterator_tag)
	{
		while ((__first != __last) && (!__pred(__first))) {
			++__first;
		}
		return __first;
	}
	template <class _RandomAccessIterator, class _Predicate>
	_RandomAccessIterator __find_if(_RandomAccessIterator __first,
					_RandomAccessIterator __last,
					_Predicate __pred,
					random_access_iterator_tag)
	{
		typename iterator_traits<_RandomAccessIterator>::difference_type
			__trip_count = (__last - __first) >> 2;
		for (; __trip_count > 0; --__trip_count) {
			if (__pred(__first)) {
				return __first;
			}
			++__first;
			if (__pred(__first)) {
				return __first;
			}
			++__first;
			if (__pred(__first)) {
				return __first;
			}
			++__first;
			if (__pred(__first)) {
				return __first;
			}
			++__first;
		}
		switch (__last - __first) {
		case 3:
			if (__pred(__first)) {
				return __first;
			}
			++__first;
		case 2:
			if (__pred(__first)) {
				return __first;
			}
			++__first;
		case 1:
			if (__pred(__first)) {
				return __first;
			}
			++__first;
		case 0:
		default:
			return __last;
		}
	}
	template <class _Iterator, class _Predicate>
	inline _Iterator __find_if(_Iterator __first, _Iterator __last,
				   _Predicate __pred)
	{
		return __find_if(__first, __last, __pred,
				 std::__iterator_category(__first));
	}
	template <class _InputIterator, class _Predicate>
	typename iterator_traits<_InputIterator>::difference_type __count_if(
		_InputIterator __first, _InputIterator __last,
		_Predicate __pred)
	{
		typename iterator_traits<_InputIterator>::difference_type __n =
			(0);
		for (; __first != __last; ++__first) {
			if (__pred(__first)) {
				++__n;
			}
		}
		return __n;
	}
	template <class _ForwardIterator, class _Predicate>
	_ForwardIterator __remove_if(_ForwardIterator __first,
				     _ForwardIterator __last, _Predicate __pred)
	{
		__first = std::__find_if(__first, __last, __pred);
		if (__first == __last) {
			return __first;
		}
		_ForwardIterator __result = __first;
		++__first;
		for (; __first != __last; ++__first) {
			if (!__pred(__first)) {
				(*__result) = std::move(*__first);
				++__result;
			}
		}
		return __result;
	}
	template <class _ForwardIterator1, class _ForwardIterator2,
		  class _BinaryPredicate>
	bool __is_permutation(_ForwardIterator1 __first1,
			      _ForwardIterator1 __last1,
			      _ForwardIterator2 __first2,
			      _BinaryPredicate __pred)
	{
		for (; __first1 != __last1;
		     (++__first1), ((void)(++__first2))) {
			if (!__pred(__first1, __first2)) {
				break;
			}
		}
		if (__first1 == __last1) {
			return true;
		}
		_ForwardIterator2 __last2 = __first2;
		std::advance(__last2, std::distance(__first1, __last1));
		for (_ForwardIterator1 __scan = __first1; __scan != __last1;
		     ++__scan) {
			if (__scan !=
			    std::__find_if(__first1, __scan,
					   __gnu_cxx::__ops::__iter_comp_iter(
						   __pred, __scan))) {
				continue;
			}
			auto __matches = std::__count_if(
				__first2, __last2,
				__gnu_cxx::__ops::__iter_comp_iter(__pred,
								   __scan));
			if ((0 == __matches) ||
			    (std::__count_if(__scan, __last1,
					     __gnu_cxx::__ops::__iter_comp_iter(
						     __pred, __scan)) !=
			     __matches)) {
				return false;
			}
		}
		return true;
	}
	template <class _ForwardIterator1, class _ForwardIterator2>
	inline bool is_permutation(_ForwardIterator1 __first1,
				   _ForwardIterator1 __last1,
				   _ForwardIterator2 __first2)
	{
		;
		return std::__is_permutation(
			__first1, __last1, __first2,
			__gnu_cxx::__ops::__iter_equal_to_iter());
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	enum float_round_style {
		round_indeterminate = (-1),
		round_toward_zero = 0,
		round_to_nearest,
		round_toward_infinity,
		round_toward_neg_infinity
	};
	enum float_denorm_style {
		denorm_indeterminate = (-1),
		denorm_absent = 0,
		denorm_present
	};
	struct __numeric_limits_base {
		static constexpr inline bool is_specialized = false;
		static constexpr inline int digits = 0;
		static constexpr inline int digits10 = 0;
		static constexpr inline int max_digits10 = 0;
		static constexpr inline bool is_signed = false;
		static constexpr inline bool is_integer = false;
		static constexpr inline bool is_exact = false;
		static constexpr inline int radix = 0;
		static constexpr inline int min_exponent = 0;
		static constexpr inline int min_exponent10 = 0;
		static constexpr inline int max_exponent = 0;
		static constexpr inline int max_exponent10 = 0;
		static constexpr inline bool has_infinity = false;
		static constexpr inline bool has_quiet_NaN = false;
		static constexpr inline bool has_signaling_NaN = false;
		static constexpr inline float_denorm_style has_denorm =
			denorm_absent;
		static constexpr inline bool has_denorm_loss = false;
		static constexpr inline bool is_iec559 = false;
		static constexpr inline bool is_bounded = false;
		static constexpr inline bool is_modulo = false;
		static constexpr inline bool traps = false;
		static constexpr inline bool tinyness_before = false;
		static constexpr inline float_round_style round_style =
			round_toward_zero;
	};
	template <class _Tp>
	struct numeric_limits : public __numeric_limits_base {
		static constexpr _Tp min() noexcept
		{
			return _Tp();
		}
		static constexpr _Tp max() noexcept
		{
			return _Tp();
		}
		static constexpr _Tp lowest() noexcept
		{
			return _Tp();
		}
		static constexpr _Tp epsilon() noexcept
		{
			return _Tp();
		}
		static constexpr _Tp round_error() noexcept
		{
			return _Tp();
		}
		static constexpr _Tp infinity() noexcept
		{
			return _Tp();
		}
		static constexpr _Tp quiet_NaN() noexcept
		{
			return _Tp();
		}
		static constexpr _Tp signaling_NaN() noexcept
		{
			return _Tp();
		}
		static constexpr _Tp denorm_min() noexcept
		{
			return _Tp();
		}
	};
	template <class _Tp>
	struct numeric_limits<const _Tp> : public std::numeric_limits<_Tp> {
	};
	template <class _Tp>
	struct numeric_limits<volatile _Tp> : public std::numeric_limits<_Tp> {
	};
	template <class _Tp>
	struct numeric_limits<const volatile _Tp>
		: public std::numeric_limits<_Tp> {
	};
	template <> struct numeric_limits<bool> {
		static constexpr inline bool is_specialized = true;
		static constexpr bool min() noexcept
		{
			return false;
		}
		static constexpr bool max() noexcept
		{
			return true;
		}
		static constexpr bool lowest() noexcept
		{
			return min();
		}
		static constexpr inline int digits = 1;
		static constexpr inline int digits10 = 0;
		static constexpr inline int max_digits10 = 0;
		static constexpr inline bool is_signed = false;
		static constexpr inline bool is_integer = true;
		static constexpr inline bool is_exact = true;
		static constexpr inline int radix = 2;
		static constexpr bool epsilon() noexcept
		{
			return false;
		}
		static constexpr bool round_error() noexcept
		{
			return false;
		}
		static constexpr inline int min_exponent = 0;
		static constexpr inline int min_exponent10 = 0;
		static constexpr inline int max_exponent = 0;
		static constexpr inline int max_exponent10 = 0;
		static constexpr inline bool has_infinity = false;
		static constexpr inline bool has_quiet_NaN = false;
		static constexpr inline bool has_signaling_NaN = false;
		static constexpr inline float_denorm_style has_denorm =
			denorm_absent;
		static constexpr inline bool has_denorm_loss = false;
		static constexpr bool infinity() noexcept
		{
			return false;
		}
		static constexpr bool quiet_NaN() noexcept
		{
			return false;
		}
		static constexpr bool signaling_NaN() noexcept
		{
			return false;
		}
		static constexpr bool denorm_min() noexcept
		{
			return false;
		}
		static constexpr inline bool is_iec559 = false;
		static constexpr inline bool is_bounded = true;
		static constexpr inline bool is_modulo = false;
		static constexpr inline bool traps = true;
		static constexpr inline bool tinyness_before = false;
		static constexpr inline float_round_style round_style =
			round_toward_zero;
	};
	template <> struct numeric_limits<char> {
		static constexpr inline bool is_specialized = true;
		static constexpr char min() noexcept
		{
			return ((((char)(-1)) < 0) ?
					(-((((char)(-1)) < 0) ?
						   (((((char)1)
						      << (((sizeof(char) * (8)) -
							   (((char)(-1)) < 0)) -
							  (1))) -
						     1)
						    << 1) + 1 :
						   (~((char)0)))) -
						1 :
					((char)0));
		}
		static constexpr char max() noexcept
		{
			return ((((char)(-1)) < 0) ?
					(((((char)1) << (((sizeof(char) * (8)) -
							  (((char)(-1)) < 0)) -
							 (1))) -
					  1)
					 << 1) + 1 :
					(~((char)0)));
		}
		static constexpr char lowest() noexcept
		{
			return min();
		}
		static constexpr inline int digits =
			((sizeof(char) * (8)) - (((char)(-1)) < 0));
		static constexpr inline int digits10 =
			((((sizeof(char) * (8)) - (((char)(-1)) < 0)) *
			  (643L)) /
			 (2136));
		static constexpr inline int max_digits10 = 0;
		static constexpr inline bool is_signed = (((char)(-1)) < 0);
		static constexpr inline bool is_integer = true;
		static constexpr inline bool is_exact = true;
		static constexpr inline int radix = 2;
		static constexpr char epsilon() noexcept
		{
			return 0;
		}
		static constexpr char round_error() noexcept
		{
			return 0;
		}
		static constexpr inline int min_exponent = 0;
		static constexpr inline int min_exponent10 = 0;
		static constexpr inline int max_exponent = 0;
		static constexpr inline int max_exponent10 = 0;
		static constexpr inline bool has_infinity = false;
		static constexpr inline bool has_quiet_NaN = false;
		static constexpr inline bool has_signaling_NaN = false;
		static constexpr inline float_denorm_style has_denorm =
			denorm_absent;
		static constexpr inline bool has_denorm_loss = false;
		static constexpr char infinity() noexcept
		{
			return ((char)0);
		}
		static constexpr char quiet_NaN() noexcept
		{
			return ((char)0);
		}
		static constexpr char signaling_NaN() noexcept
		{
			return ((char)0);
		}
		static constexpr char denorm_min() noexcept
		{
			return static_cast<char>(0);
		}
		static constexpr inline bool is_iec559 = false;
		static constexpr inline bool is_bounded = true;
		static constexpr inline bool is_modulo = (!is_signed);
		static constexpr inline bool traps = true;
		static constexpr inline bool tinyness_before = false;
		static constexpr inline float_round_style round_style =
			round_toward_zero;
	};
	template <> struct numeric_limits<signed char> {
		static constexpr inline bool is_specialized = true;
		static constexpr signed char min() noexcept
		{
			return (-127) - 1;
		}
		static constexpr signed char max() noexcept
		{
			return 127;
		}
		static constexpr signed char lowest() noexcept
		{
			return min();
		}
		static constexpr inline int digits =
			((sizeof(signed char) * (8)) -
			 (((signed char)(-1)) < 0));
		static constexpr inline int digits10 =
			((((sizeof(signed char) * (8)) -
			   (((signed char)(-1)) < 0)) *
			  (643L)) /
			 (2136));
		static constexpr inline int max_digits10 = 0;
		static constexpr inline bool is_signed = true;
		static constexpr inline bool is_integer = true;
		static constexpr inline bool is_exact = true;
		static constexpr inline int radix = 2;
		static constexpr signed char epsilon() noexcept
		{
			return 0;
		}
		static constexpr signed char round_error() noexcept
		{
			return 0;
		}
		static constexpr inline int min_exponent = 0;
		static constexpr inline int min_exponent10 = 0;
		static constexpr inline int max_exponent = 0;
		static constexpr inline int max_exponent10 = 0;
		static constexpr inline bool has_infinity = false;
		static constexpr inline bool has_quiet_NaN = false;
		static constexpr inline bool has_signaling_NaN = false;
		static constexpr inline float_denorm_style has_denorm =
			denorm_absent;
		static constexpr inline bool has_denorm_loss = false;
		static constexpr signed char infinity() noexcept
		{
			return static_cast<signed char>(0);
		}
		static constexpr signed char quiet_NaN() noexcept
		{
			return static_cast<signed char>(0);
		}
		static constexpr signed char signaling_NaN() noexcept
		{
			return static_cast<signed char>(0);
		}
		static constexpr signed char denorm_min() noexcept
		{
			return static_cast<signed char>(0);
		}
		static constexpr inline bool is_iec559 = false;
		static constexpr inline bool is_bounded = true;
		static constexpr inline bool is_modulo = false;
		static constexpr inline bool traps = true;
		static constexpr inline bool tinyness_before = false;
		static constexpr inline float_round_style round_style =
			round_toward_zero;
	};
	template <> struct numeric_limits<unsigned char> {
		static constexpr inline bool is_specialized = true;
		static constexpr unsigned char min() noexcept
		{
			return 0;
		}
		static constexpr unsigned char max() noexcept
		{
			return ((127) * 2U) + (1);
		}
		static constexpr unsigned char lowest() noexcept
		{
			return min();
		}
		static constexpr inline int digits =
			((sizeof(unsigned char) * (8)) -
			 (((unsigned char)(-1)) < 0));
		static constexpr inline int digits10 =
			((((sizeof(unsigned char) * (8)) -
			   (((unsigned char)(-1)) < 0)) *
			  (643L)) /
			 (2136));
		static constexpr inline int max_digits10 = 0;
		static constexpr inline bool is_signed = false;
		static constexpr inline bool is_integer = true;
		static constexpr inline bool is_exact = true;
		static constexpr inline int radix = 2;
		static constexpr unsigned char epsilon() noexcept
		{
			return 0;
		}
		static constexpr unsigned char round_error() noexcept
		{
			return 0;
		}
		static constexpr inline int min_exponent = 0;
		static constexpr inline int min_exponent10 = 0;
		static constexpr inline int max_exponent = 0;
		static constexpr inline int max_exponent10 = 0;
		static constexpr inline bool has_infinity = false;
		static constexpr inline bool has_quiet_NaN = false;
		static constexpr inline bool has_signaling_NaN = false;
		static constexpr inline float_denorm_style has_denorm =
			denorm_absent;
		static constexpr inline bool has_denorm_loss = false;
		static constexpr unsigned char infinity() noexcept
		{
			return static_cast<unsigned char>(0);
		}
		static constexpr unsigned char quiet_NaN() noexcept
		{
			return static_cast<unsigned char>(0);
		}
		static constexpr unsigned char signaling_NaN() noexcept
		{
			return static_cast<unsigned char>(0);
		}
		static constexpr unsigned char denorm_min() noexcept
		{
			return static_cast<unsigned char>(0);
		}
		static constexpr inline bool is_iec559 = false;
		static constexpr inline bool is_bounded = true;
		static constexpr inline bool is_modulo = true;
		static constexpr inline bool traps = true;
		static constexpr inline bool tinyness_before = false;
		static constexpr inline float_round_style round_style =
			round_toward_zero;
	};
	template <> struct numeric_limits<wchar_t> {
		static constexpr inline bool is_specialized = true;
		static constexpr wchar_t min() noexcept
		{
			return ((((wchar_t)(-1)) < 0) ?
					(-((((wchar_t)(-1)) < 0) ?
						   (((((wchar_t)1)
						      << (((sizeof(wchar_t) *
							    (8)) -
							   (((wchar_t)(-1)) <
							    0)) -
							  (1))) -
						     1)
						    << 1) + 1 :
						   (~((wchar_t)0)))) -
						1 :
					((wchar_t)0));
		}
		static constexpr wchar_t max() noexcept
		{
			return ((((wchar_t)(-1)) < 0) ?
					(((((wchar_t)1)
					   << (((sizeof(wchar_t) * (8)) -
						(((wchar_t)(-1)) < 0)) -
					       (1))) -
					  1)
					 << 1) + 1 :
					(~((wchar_t)0)));
		}
		static constexpr wchar_t lowest() noexcept
		{
			return min();
		}
		static constexpr inline int digits =
			((sizeof(wchar_t) * (8)) - (((wchar_t)(-1)) < 0));
		static constexpr inline int digits10 =
			((((sizeof(wchar_t) * (8)) - (((wchar_t)(-1)) < 0)) *
			  (643L)) /
			 (2136));
		static constexpr inline int max_digits10 = 0;
		static constexpr inline bool is_signed = (((wchar_t)(-1)) < 0);
		static constexpr inline bool is_integer = true;
		static constexpr inline bool is_exact = true;
		static constexpr inline int radix = 2;
		static constexpr wchar_t epsilon() noexcept
		{
			return 0;
		}
		static constexpr wchar_t round_error() noexcept
		{
			return 0;
		}
		static constexpr inline int min_exponent = 0;
		static constexpr inline int min_exponent10 = 0;
		static constexpr inline int max_exponent = 0;
		static constexpr inline int max_exponent10 = 0;
		static constexpr inline bool has_infinity = false;
		static constexpr inline bool has_quiet_NaN = false;
		static constexpr inline bool has_signaling_NaN = false;
		static constexpr inline float_denorm_style has_denorm =
			denorm_absent;
		static constexpr inline bool has_denorm_loss = false;
		static constexpr wchar_t infinity() noexcept
		{
			return ((wchar_t)0);
		}
		static constexpr wchar_t quiet_NaN() noexcept
		{
			return ((wchar_t)0);
		}
		static constexpr wchar_t signaling_NaN() noexcept
		{
			return ((wchar_t)0);
		}
		static constexpr wchar_t denorm_min() noexcept
		{
			return ((wchar_t)0);
		}
		static constexpr inline bool is_iec559 = false;
		static constexpr inline bool is_bounded = true;
		static constexpr inline bool is_modulo = (!is_signed);
		static constexpr inline bool traps = true;
		static constexpr inline bool tinyness_before = false;
		static constexpr inline float_round_style round_style =
			round_toward_zero;
	};
	template <> struct numeric_limits<char16_t> {
		static constexpr inline bool is_specialized = true;
		static constexpr char16_t min() noexcept
		{
			return ((((char16_t)(-1)) < 0) ?
					(-((((char16_t)(-1)) < 0) ?
						   (((((char16_t)1)
						      << (((sizeof(char16_t) *
							    (8)) -
							   (((char16_t)(-1)) <
							    0)) -
							  (1))) -
						     1)
						    << 1) + 1 :
						   (~((char16_t)0)))) -
						1 :
					((char16_t)0));
		}
		static constexpr char16_t max() noexcept
		{
			return ((((char16_t)(-1)) < 0) ?
					(((((char16_t)1)
					   << (((sizeof(char16_t) * (8)) -
						(((char16_t)(-1)) < 0)) -
					       (1))) -
					  1)
					 << 1) + 1 :
					(~((char16_t)0)));
		}
		static constexpr char16_t lowest() noexcept
		{
			return min();
		}
		static constexpr inline int digits =
			((sizeof(char16_t) * (8)) - (((char16_t)(-1)) < 0));
		static constexpr inline int digits10 =
			((((sizeof(char16_t) * (8)) - (((char16_t)(-1)) < 0)) *
			  (643L)) /
			 (2136));
		static constexpr inline int max_digits10 = 0;
		static constexpr inline bool is_signed = (((char16_t)(-1)) < 0);
		static constexpr inline bool is_integer = true;
		static constexpr inline bool is_exact = true;
		static constexpr inline int radix = 2;
		static constexpr char16_t epsilon() noexcept
		{
			return 0;
		}
		static constexpr char16_t round_error() noexcept
		{
			return 0;
		}
		static constexpr inline int min_exponent = 0;
		static constexpr inline int min_exponent10 = 0;
		static constexpr inline int max_exponent = 0;
		static constexpr inline int max_exponent10 = 0;
		static constexpr inline bool has_infinity = false;
		static constexpr inline bool has_quiet_NaN = false;
		static constexpr inline bool has_signaling_NaN = false;
		static constexpr inline float_denorm_style has_denorm =
			denorm_absent;
		static constexpr inline bool has_denorm_loss = false;
		static constexpr char16_t infinity() noexcept
		{
			return ((char16_t)0);
		}
		static constexpr char16_t quiet_NaN() noexcept
		{
			return ((char16_t)0);
		}
		static constexpr char16_t signaling_NaN() noexcept
		{
			return ((char16_t)0);
		}
		static constexpr char16_t denorm_min() noexcept
		{
			return ((char16_t)0);
		}
		static constexpr inline bool is_iec559 = false;
		static constexpr inline bool is_bounded = true;
		static constexpr inline bool is_modulo = (!is_signed);
		static constexpr inline bool traps = true;
		static constexpr inline bool tinyness_before = false;
		static constexpr inline float_round_style round_style =
			round_toward_zero;
	};
	template <> struct numeric_limits<char32_t> {
		static constexpr inline bool is_specialized = true;
		static constexpr char32_t min() noexcept
		{
			return ((((char32_t)(-1)) < (0)) ?
					(-((((char32_t)(-1)) < (0)) ?
						   (((((char32_t)1)
						      << (((sizeof(char32_t) *
							    (8)) -
							   (((char32_t)(-1)) <
							    (0))) -
							  (1))) -
						     (1))
						    << 1) + (1) :
						   (~((char32_t)0)))) -
						(1) :
					((char32_t)0));
		}
		static constexpr char32_t max() noexcept
		{
			return ((((char32_t)(-1)) < (0)) ?
					(((((char32_t)1)
					   << (((sizeof(char32_t) * (8)) -
						(((char32_t)(-1)) < (0))) -
					       (1))) -
					  (1))
					 << 1) + (1) :
					(~((char32_t)0)));
		}
		static constexpr char32_t lowest() noexcept
		{
			return min();
		}
		static constexpr inline int digits =
			((sizeof(char32_t) * (8)) - (((char32_t)(-1)) < (0)));
		static constexpr inline int digits10 =
			((((sizeof(char32_t) * (8)) - (((char32_t)(-1)) < (0))) *
			  (643L)) /
			 (2136));
		static constexpr inline int max_digits10 = 0;
		static constexpr inline bool is_signed =
			(((char32_t)(-1)) < (0));
		static constexpr inline bool is_integer = true;
		static constexpr inline bool is_exact = true;
		static constexpr inline int radix = 2;
		static constexpr char32_t epsilon() noexcept
		{
			return 0;
		}
		static constexpr char32_t round_error() noexcept
		{
			return 0;
		}
		static constexpr inline int min_exponent = 0;
		static constexpr inline int min_exponent10 = 0;
		static constexpr inline int max_exponent = 0;
		static constexpr inline int max_exponent10 = 0;
		static constexpr inline bool has_infinity = false;
		static constexpr inline bool has_quiet_NaN = false;
		static constexpr inline bool has_signaling_NaN = false;
		static constexpr inline float_denorm_style has_denorm =
			denorm_absent;
		static constexpr inline bool has_denorm_loss = false;
		static constexpr char32_t infinity() noexcept
		{
			return ((char32_t)0);
		}
		static constexpr char32_t quiet_NaN() noexcept
		{
			return ((char32_t)0);
		}
		static constexpr char32_t signaling_NaN() noexcept
		{
			return ((char32_t)0);
		}
		static constexpr char32_t denorm_min() noexcept
		{
			return ((char32_t)0);
		}
		static constexpr inline bool is_iec559 = false;
		static constexpr inline bool is_bounded = true;
		static constexpr inline bool is_modulo = (!is_signed);
		static constexpr inline bool traps = true;
		static constexpr inline bool tinyness_before = false;
		static constexpr inline float_round_style round_style =
			round_toward_zero;
	};
	template <> struct numeric_limits<short> {
		static constexpr inline bool is_specialized = true;
		static constexpr short min() noexcept
		{
			return (-32767) - 1;
		}
		static constexpr short max() noexcept
		{
			return 32767;
		}
		static constexpr short lowest() noexcept
		{
			return min();
		}
		static constexpr inline int digits =
			((sizeof(short) * (8)) - (((short)(-1)) < 0));
		static constexpr inline int digits10 =
			((((sizeof(short) * (8)) - (((short)(-1)) < 0)) *
			  (643L)) /
			 (2136));
		static constexpr inline int max_digits10 = 0;
		static constexpr inline bool is_signed = true;
		static constexpr inline bool is_integer = true;
		static constexpr inline bool is_exact = true;
		static constexpr inline int radix = 2;
		static constexpr short epsilon() noexcept
		{
			return 0;
		}
		static constexpr short round_error() noexcept
		{
			return 0;
		}
		static constexpr inline int min_exponent = 0;
		static constexpr inline int min_exponent10 = 0;
		static constexpr inline int max_exponent = 0;
		static constexpr inline int max_exponent10 = 0;
		static constexpr inline bool has_infinity = false;
		static constexpr inline bool has_quiet_NaN = false;
		static constexpr inline bool has_signaling_NaN = false;
		static constexpr inline float_denorm_style has_denorm =
			denorm_absent;
		static constexpr inline bool has_denorm_loss = false;
		static constexpr short infinity() noexcept
		{
			return ((short)0);
		}
		static constexpr short quiet_NaN() noexcept
		{
			return ((short)0);
		}
		static constexpr short signaling_NaN() noexcept
		{
			return ((short)0);
		}
		static constexpr short denorm_min() noexcept
		{
			return ((short)0);
		}
		static constexpr inline bool is_iec559 = false;
		static constexpr inline bool is_bounded = true;
		static constexpr inline bool is_modulo = false;
		static constexpr inline bool traps = true;
		static constexpr inline bool tinyness_before = false;
		static constexpr inline float_round_style round_style =
			round_toward_zero;
	};
	template <> struct numeric_limits<unsigned short> {
		static constexpr inline bool is_specialized = true;
		static constexpr unsigned short min() noexcept
		{
			return 0;
		}
		static constexpr unsigned short max() noexcept
		{
			return ((32767) * 2U) + (1);
		}
		static constexpr unsigned short lowest() noexcept
		{
			return min();
		}
		static constexpr inline int digits =
			((sizeof(unsigned short) * (8)) -
			 (((unsigned short)(-1)) < 0));
		static constexpr inline int digits10 =
			((((sizeof(unsigned short) * (8)) -
			   (((unsigned short)(-1)) < 0)) *
			  (643L)) /
			 (2136));
		static constexpr inline int max_digits10 = 0;
		static constexpr inline bool is_signed = false;
		static constexpr inline bool is_integer = true;
		static constexpr inline bool is_exact = true;
		static constexpr inline int radix = 2;
		static constexpr unsigned short epsilon() noexcept
		{
			return 0;
		}
		static constexpr unsigned short round_error() noexcept
		{
			return 0;
		}
		static constexpr inline int min_exponent = 0;
		static constexpr inline int min_exponent10 = 0;
		static constexpr inline int max_exponent = 0;
		static constexpr inline int max_exponent10 = 0;
		static constexpr inline bool has_infinity = false;
		static constexpr inline bool has_quiet_NaN = false;
		static constexpr inline bool has_signaling_NaN = false;
		static constexpr inline float_denorm_style has_denorm =
			denorm_absent;
		static constexpr inline bool has_denorm_loss = false;
		static constexpr unsigned short infinity() noexcept
		{
			return static_cast<unsigned short>(0);
		}
		static constexpr unsigned short quiet_NaN() noexcept
		{
			return static_cast<unsigned short>(0);
		}
		static constexpr unsigned short signaling_NaN() noexcept
		{
			return static_cast<unsigned short>(0);
		}
		static constexpr unsigned short denorm_min() noexcept
		{
			return static_cast<unsigned short>(0);
		}
		static constexpr inline bool is_iec559 = false;
		static constexpr inline bool is_bounded = true;
		static constexpr inline bool is_modulo = true;
		static constexpr inline bool traps = true;
		static constexpr inline bool tinyness_before = false;
		static constexpr inline float_round_style round_style =
			round_toward_zero;
	};
	template <> struct numeric_limits<int> {
		static constexpr inline bool is_specialized = true;
		static constexpr int min() noexcept
		{
			return (-2147483647) - 1;
		}
		static constexpr int max() noexcept
		{
			return 2147483647;
		}
		static constexpr int lowest() noexcept
		{
			return min();
		}
		static constexpr inline int digits =
			((sizeof(int) * (8)) - (((int)(-1)) < 0));
		static constexpr inline int digits10 =
			((((sizeof(int) * (8)) - (((int)(-1)) < 0)) * (643L)) /
			 (2136));
		static constexpr inline int max_digits10 = 0;
		static constexpr inline bool is_signed = true;
		static constexpr inline bool is_integer = true;
		static constexpr inline bool is_exact = true;
		static constexpr inline int radix = 2;
		static constexpr int epsilon() noexcept
		{
			return 0;
		}
		static constexpr int round_error() noexcept
		{
			return 0;
		}
		static constexpr inline int min_exponent = 0;
		static constexpr inline int min_exponent10 = 0;
		static constexpr inline int max_exponent = 0;
		static constexpr inline int max_exponent10 = 0;
		static constexpr inline bool has_infinity = false;
		static constexpr inline bool has_quiet_NaN = false;
		static constexpr inline bool has_signaling_NaN = false;
		static constexpr inline float_denorm_style has_denorm =
			denorm_absent;
		static constexpr inline bool has_denorm_loss = false;
		static constexpr int infinity() noexcept
		{
			return static_cast<int>(0);
		}
		static constexpr int quiet_NaN() noexcept
		{
			return static_cast<int>(0);
		}
		static constexpr int signaling_NaN() noexcept
		{
			return static_cast<int>(0);
		}
		static constexpr int denorm_min() noexcept
		{
			return static_cast<int>(0);
		}
		static constexpr inline bool is_iec559 = false;
		static constexpr inline bool is_bounded = true;
		static constexpr inline bool is_modulo = false;
		static constexpr inline bool traps = true;
		static constexpr inline bool tinyness_before = false;
		static constexpr inline float_round_style round_style =
			round_toward_zero;
	};
	template <> struct numeric_limits<unsigned> {
		static constexpr inline bool is_specialized = true;
		static constexpr unsigned min() noexcept
		{
			return 0;
		}
		static constexpr unsigned max() noexcept
		{
			return ((2147483647) * 2U) + (1);
		}
		static constexpr unsigned lowest() noexcept
		{
			return min();
		}
		static constexpr inline int digits =
			((sizeof(unsigned) * (8)) - (((unsigned)(-1)) < (0)));
		static constexpr inline int digits10 =
			((((sizeof(unsigned) * (8)) - (((unsigned)(-1)) < (0))) *
			  (643L)) /
			 (2136));
		static constexpr inline int max_digits10 = 0;
		static constexpr inline bool is_signed = false;
		static constexpr inline bool is_integer = true;
		static constexpr inline bool is_exact = true;
		static constexpr inline int radix = 2;
		static constexpr unsigned epsilon() noexcept
		{
			return 0;
		}
		static constexpr unsigned round_error() noexcept
		{
			return 0;
		}
		static constexpr inline int min_exponent = 0;
		static constexpr inline int min_exponent10 = 0;
		static constexpr inline int max_exponent = 0;
		static constexpr inline int max_exponent10 = 0;
		static constexpr inline bool has_infinity = false;
		static constexpr inline bool has_quiet_NaN = false;
		static constexpr inline bool has_signaling_NaN = false;
		static constexpr inline float_denorm_style has_denorm =
			denorm_absent;
		static constexpr inline bool has_denorm_loss = false;
		static constexpr unsigned infinity() noexcept
		{
			return static_cast<unsigned>(0);
		}
		static constexpr unsigned quiet_NaN() noexcept
		{
			return static_cast<unsigned>(0);
		}
		static constexpr unsigned signaling_NaN() noexcept
		{
			return static_cast<unsigned>(0);
		}
		static constexpr unsigned denorm_min() noexcept
		{
			return static_cast<unsigned>(0);
		}
		static constexpr inline bool is_iec559 = false;
		static constexpr inline bool is_bounded = true;
		static constexpr inline bool is_modulo = true;
		static constexpr inline bool traps = true;
		static constexpr inline bool tinyness_before = false;
		static constexpr inline float_round_style round_style =
			round_toward_zero;
	};
	template <> struct numeric_limits<long> {
		static constexpr inline bool is_specialized = true;
		static constexpr long min() noexcept
		{
			return (-9223372036854775807L) - (1);
		}
		static constexpr long max() noexcept
		{
			return 9223372036854775807L;
		}
		static constexpr long lowest() noexcept
		{
			return min();
		}
		static constexpr inline int digits =
			((sizeof(long) * (8)) - (((long)(-1)) < (0)));
		static constexpr inline int digits10 =
			((((sizeof(long) * (8)) - (((long)(-1)) < (0))) *
			  (643L)) /
			 (2136));
		static constexpr inline int max_digits10 = 0;
		static constexpr inline bool is_signed = true;
		static constexpr inline bool is_integer = true;
		static constexpr inline bool is_exact = true;
		static constexpr inline int radix = 2;
		static constexpr long epsilon() noexcept
		{
			return 0;
		}
		static constexpr long round_error() noexcept
		{
			return 0;
		}
		static constexpr inline int min_exponent = 0;
		static constexpr inline int min_exponent10 = 0;
		static constexpr inline int max_exponent = 0;
		static constexpr inline int max_exponent10 = 0;
		static constexpr inline bool has_infinity = false;
		static constexpr inline bool has_quiet_NaN = false;
		static constexpr inline bool has_signaling_NaN = false;
		static constexpr inline float_denorm_style has_denorm =
			denorm_absent;
		static constexpr inline bool has_denorm_loss = false;
		static constexpr long infinity() noexcept
		{
			return static_cast<long>(0);
		}
		static constexpr long quiet_NaN() noexcept
		{
			return static_cast<long>(0);
		}
		static constexpr long signaling_NaN() noexcept
		{
			return static_cast<long>(0);
		}
		static constexpr long denorm_min() noexcept
		{
			return static_cast<long>(0);
		}
		static constexpr inline bool is_iec559 = false;
		static constexpr inline bool is_bounded = true;
		static constexpr inline bool is_modulo = false;
		static constexpr inline bool traps = true;
		static constexpr inline bool tinyness_before = false;
		static constexpr inline float_round_style round_style =
			round_toward_zero;
	};
	template <> struct numeric_limits<unsigned long> {
		static constexpr inline bool is_specialized = true;
		static constexpr unsigned long min() noexcept
		{
			return 0;
		}
		static constexpr unsigned long max() noexcept
		{
			return ((9223372036854775807L) * 2UL) + (1);
		}
		static constexpr unsigned long lowest() noexcept
		{
			return min();
		}
		static constexpr inline int digits =
			((sizeof(unsigned long) * (8)) -
			 (((unsigned long)(-1)) < (0)));
		static constexpr inline int digits10 =
			((((sizeof(unsigned long) * (8)) -
			   (((unsigned long)(-1)) < (0))) *
			  (643L)) /
			 (2136));
		static constexpr inline int max_digits10 = 0;
		static constexpr inline bool is_signed = false;
		static constexpr inline bool is_integer = true;
		static constexpr inline bool is_exact = true;
		static constexpr inline int radix = 2;
		static constexpr unsigned long epsilon() noexcept
		{
			return 0;
		}
		static constexpr unsigned long round_error() noexcept
		{
			return 0;
		}
		static constexpr inline int min_exponent = 0;
		static constexpr inline int min_exponent10 = 0;
		static constexpr inline int max_exponent = 0;
		static constexpr inline int max_exponent10 = 0;
		static constexpr inline bool has_infinity = false;
		static constexpr inline bool has_quiet_NaN = false;
		static constexpr inline bool has_signaling_NaN = false;
		static constexpr inline float_denorm_style has_denorm =
			denorm_absent;
		static constexpr inline bool has_denorm_loss = false;
		static constexpr unsigned long infinity() noexcept
		{
			return static_cast<unsigned long>(0);
		}
		static constexpr unsigned long quiet_NaN() noexcept
		{
			return static_cast<unsigned long>(0);
		}
		static constexpr unsigned long signaling_NaN() noexcept
		{
			return static_cast<unsigned long>(0);
		}
		static constexpr unsigned long denorm_min() noexcept
		{
			return static_cast<unsigned long>(0);
		}
		static constexpr inline bool is_iec559 = false;
		static constexpr inline bool is_bounded = true;
		static constexpr inline bool is_modulo = true;
		static constexpr inline bool traps = true;
		static constexpr inline bool tinyness_before = false;
		static constexpr inline float_round_style round_style =
			round_toward_zero;
	};
	template <> struct numeric_limits<long long> {
		static constexpr inline bool is_specialized = true;
		static constexpr long long min() noexcept
		{
			return (-9223372036854775807LL) - (1);
		}
		static constexpr long long max() noexcept
		{
			return 9223372036854775807LL;
		}
		static constexpr long long lowest() noexcept
		{
			return min();
		}
		static constexpr inline int digits =
			((sizeof(long long) * (8)) - (((long long)(-1)) < (0)));
		static constexpr inline int digits10 =
			((((sizeof(long long) * (8)) -
			   (((long long)(-1)) < (0))) *
			  (643L)) /
			 (2136));
		static constexpr inline int max_digits10 = 0;
		static constexpr inline bool is_signed = true;
		static constexpr inline bool is_integer = true;
		static constexpr inline bool is_exact = true;
		static constexpr inline int radix = 2;
		static constexpr long long epsilon() noexcept
		{
			return 0;
		}
		static constexpr long long round_error() noexcept
		{
			return 0;
		}
		static constexpr inline int min_exponent = 0;
		static constexpr inline int min_exponent10 = 0;
		static constexpr inline int max_exponent = 0;
		static constexpr inline int max_exponent10 = 0;
		static constexpr inline bool has_infinity = false;
		static constexpr inline bool has_quiet_NaN = false;
		static constexpr inline bool has_signaling_NaN = false;
		static constexpr inline float_denorm_style has_denorm =
			denorm_absent;
		static constexpr inline bool has_denorm_loss = false;
		static constexpr long long infinity() noexcept
		{
			return static_cast<long long>(0);
		}
		static constexpr long long quiet_NaN() noexcept
		{
			return static_cast<long long>(0);
		}
		static constexpr long long signaling_NaN() noexcept
		{
			return static_cast<long long>(0);
		}
		static constexpr long long denorm_min() noexcept
		{
			return static_cast<long long>(0);
		}
		static constexpr inline bool is_iec559 = false;
		static constexpr inline bool is_bounded = true;
		static constexpr inline bool is_modulo = false;
		static constexpr inline bool traps = true;
		static constexpr inline bool tinyness_before = false;
		static constexpr inline float_round_style round_style =
			round_toward_zero;
	};
	template <> struct numeric_limits<unsigned long long> {
		static constexpr inline bool is_specialized = true;
		static constexpr unsigned long long min() noexcept
		{
			return 0;
		}
		static constexpr unsigned long long max() noexcept
		{
			return ((9223372036854775807LL) * 2ULL) + (1);
		}
		static constexpr unsigned long long lowest() noexcept
		{
			return min();
		}
		static constexpr inline int digits =
			((sizeof(unsigned long long) * (8)) -
			 (((unsigned long long)(-1)) < (0)));
		static constexpr inline int digits10 =
			((((sizeof(unsigned long long) * (8)) -
			   (((unsigned long long)(-1)) < (0))) *
			  (643L)) /
			 (2136));
		static constexpr inline int max_digits10 = 0;
		static constexpr inline bool is_signed = false;
		static constexpr inline bool is_integer = true;
		static constexpr inline bool is_exact = true;
		static constexpr inline int radix = 2;
		static constexpr unsigned long long epsilon() noexcept
		{
			return 0;
		}
		static constexpr unsigned long long round_error() noexcept
		{
			return 0;
		}
		static constexpr inline int min_exponent = 0;
		static constexpr inline int min_exponent10 = 0;
		static constexpr inline int max_exponent = 0;
		static constexpr inline int max_exponent10 = 0;
		static constexpr inline bool has_infinity = false;
		static constexpr inline bool has_quiet_NaN = false;
		static constexpr inline bool has_signaling_NaN = false;
		static constexpr inline float_denorm_style has_denorm =
			denorm_absent;
		static constexpr inline bool has_denorm_loss = false;
		static constexpr unsigned long long infinity() noexcept
		{
			return static_cast<unsigned long long>(0);
		}
		static constexpr unsigned long long quiet_NaN() noexcept
		{
			return static_cast<unsigned long long>(0);
		}
		static constexpr unsigned long long signaling_NaN() noexcept
		{
			return static_cast<unsigned long long>(0);
		}
		static constexpr unsigned long long denorm_min() noexcept
		{
			return static_cast<unsigned long long>(0);
		}
		static constexpr inline bool is_iec559 = false;
		static constexpr inline bool is_bounded = true;
		static constexpr inline bool is_modulo = true;
		static constexpr inline bool traps = true;
		static constexpr inline bool tinyness_before = false;
		static constexpr inline float_round_style round_style =
			round_toward_zero;
	};
	template <> struct numeric_limits<__int128> {
		static constexpr inline bool is_specialized = true;
		static constexpr __int128 min() noexcept
		{
			return ((((__int128)(-1)) < (0)) ?
					(-((((__int128)(-1)) < (0)) ?
						   (((((__int128)1)
						      << ((128 -
							   (((__int128)(-1)) <
							    (0))) -
							  1)) -
						     (1))
						    << 1) + (1) :
						   (~((__int128)0)))) -
						(1) :
					((__int128)0));
		}
		static constexpr __int128 max() noexcept
		{
			return ((((__int128)(-1)) < (0)) ?
					(((((__int128)1)
					   << ((128 - (((__int128)(-1)) < (0))) -
					       1)) -
					  (1))
					 << 1) + (1) :
					(~((__int128)0)));
		}
		static constexpr inline int digits = (128 - 1);
		static constexpr inline int digits10 =
			(((128 - 1) * 643L) / (2136));
		static constexpr inline bool is_signed = true;
		static constexpr inline bool is_integer = true;
		static constexpr inline bool is_exact = true;
		static constexpr inline int radix = 2;
		static constexpr __int128 epsilon() noexcept
		{
			return 0;
		}
		static constexpr __int128 round_error() noexcept
		{
			return 0;
		}
		static constexpr __int128 lowest() noexcept
		{
			return min();
		}
		static constexpr inline int max_digits10 = 0;
		static constexpr inline int min_exponent = 0;
		static constexpr inline int min_exponent10 = 0;
		static constexpr inline int max_exponent = 0;
		static constexpr inline int max_exponent10 = 0;
		static constexpr inline bool has_infinity = false;
		static constexpr inline bool has_quiet_NaN = false;
		static constexpr inline bool has_signaling_NaN = false;
		static constexpr inline float_denorm_style has_denorm =
			denorm_absent;
		static constexpr inline bool has_denorm_loss = false;
		static constexpr __int128 infinity() noexcept
		{
			return static_cast<__int128>(0);
		}
		static constexpr __int128 quiet_NaN() noexcept
		{
			return static_cast<__int128>(0);
		}
		static constexpr __int128 signaling_NaN() noexcept
		{
			return static_cast<__int128>(0);
		}
		static constexpr __int128 denorm_min() noexcept
		{
			return static_cast<__int128>(0);
		}
		static constexpr inline bool is_iec559 = false;
		static constexpr inline bool is_bounded = true;
		static constexpr inline bool is_modulo = false;
		static constexpr inline bool traps = true;
		static constexpr inline bool tinyness_before = false;
		static constexpr inline float_round_style round_style =
			round_toward_zero;
	};
	template <> struct numeric_limits<unsigned __int128> {
		static constexpr inline bool is_specialized = true;
		static constexpr unsigned __int128 min() noexcept
		{
			return 0;
		}
		static constexpr unsigned __int128 max() noexcept
		{
			return ((((unsigned __int128)(-1)) < (0)) ?
					(((((unsigned __int128)1)
					   << ((128 -
						(((unsigned __int128)(-1)) <
						 (0))) -
					       1)) -
					  (1))
					 << 1) + (1) :
					(~((unsigned __int128)0)));
		}
		static constexpr unsigned __int128 lowest() noexcept
		{
			return min();
		}
		static constexpr inline int max_digits10 = 0;
		static constexpr inline int digits = 128;
		static constexpr inline int digits10 =
			(((128) * 643L) / (2136));
		static constexpr inline bool is_signed = false;
		static constexpr inline bool is_integer = true;
		static constexpr inline bool is_exact = true;
		static constexpr inline int radix = 2;
		static constexpr unsigned __int128 epsilon() noexcept
		{
			return 0;
		}
		static constexpr unsigned __int128 round_error() noexcept
		{
			return 0;
		}
		static constexpr inline int min_exponent = 0;
		static constexpr inline int min_exponent10 = 0;
		static constexpr inline int max_exponent = 0;
		static constexpr inline int max_exponent10 = 0;
		static constexpr inline bool has_infinity = false;
		static constexpr inline bool has_quiet_NaN = false;
		static constexpr inline bool has_signaling_NaN = false;
		static constexpr inline float_denorm_style has_denorm =
			denorm_absent;
		static constexpr inline bool has_denorm_loss = false;
		static constexpr unsigned __int128 infinity() noexcept
		{
			return static_cast<unsigned __int128>(0);
		}
		static constexpr unsigned __int128 quiet_NaN() noexcept
		{
			return static_cast<unsigned __int128>(0);
		}
		static constexpr unsigned __int128 signaling_NaN() noexcept
		{
			return static_cast<unsigned __int128>(0);
		}
		static constexpr unsigned __int128 denorm_min() noexcept
		{
			return static_cast<unsigned __int128>(0);
		}
		static constexpr inline bool is_iec559 = false;
		static constexpr inline bool is_bounded = true;
		static constexpr inline bool is_modulo = true;
		static constexpr inline bool traps = true;
		static constexpr inline bool tinyness_before = false;
		static constexpr inline float_round_style round_style =
			round_toward_zero;
	};
	template <> struct numeric_limits<float> {
		static constexpr inline bool is_specialized = true;
		static constexpr float min() noexcept
		{
			return (1.1754944E-38F);
		}
		static constexpr float max() noexcept
		{
			return (3.4028235E38F);
		}
		static constexpr float lowest() noexcept
		{
			return -(3.4028235E38F);
		}
		static constexpr inline int digits = 24;
		static constexpr inline int digits10 = 6;
		static constexpr inline int max_digits10 =
			((2) + (((24) * 643L) / (2136)));
		static constexpr inline bool is_signed = true;
		static constexpr inline bool is_integer = false;
		static constexpr inline bool is_exact = false;
		static constexpr inline int radix = 2;
		static constexpr float epsilon() noexcept
		{
			return (1.1920929E-7F);
		}
		static constexpr float round_error() noexcept
		{
			return (0.5F);
		}
		static constexpr inline int min_exponent = (-125);
		static constexpr inline int min_exponent10 = (-37);
		static constexpr inline int max_exponent = 128;
		static constexpr inline int max_exponent10 = 38;
		static constexpr inline bool has_infinity = (1);
		static constexpr inline bool has_quiet_NaN = (1);
		static constexpr inline bool has_signaling_NaN = has_quiet_NaN;
		static constexpr inline float_denorm_style has_denorm =
			(((bool)1) ? denorm_present : denorm_absent);
		static constexpr inline bool has_denorm_loss = false;
		static constexpr float infinity() noexcept
		{
			return __builtin_huge_valf();
		}
		static constexpr float quiet_NaN() noexcept
		{
			return __builtin_nanf("");
		}
		static constexpr float signaling_NaN() noexcept
		{
			return __builtin_nansf("");
		}
		static constexpr float denorm_min() noexcept
		{
			return (1.4E-45F);
		}
		static constexpr inline bool is_iec559 =
			(has_infinity && has_quiet_NaN &&
			 (has_denorm == (denorm_present)));
		static constexpr inline bool is_bounded = true;
		static constexpr inline bool is_modulo = false;
		static constexpr inline bool traps = false;
		static constexpr inline bool tinyness_before = false;
		static constexpr inline float_round_style round_style =
			round_to_nearest;
	};
	template <> struct numeric_limits<double> {
		static constexpr inline bool is_specialized = true;
		static constexpr double min() noexcept
		{
			return (double)(2.2250738585072013831E-308L);
		}
		static constexpr double max() noexcept
		{
			return (double)(1.7976931348623157081E308L);
		}
		static constexpr double lowest() noexcept
		{
			return -((double)(1.7976931348623157081E308L));
		}
		static constexpr inline int digits = 53;
		static constexpr inline int digits10 = 15;
		static constexpr inline int max_digits10 =
			((2) + (((53) * 643L) / (2136)));
		static constexpr inline bool is_signed = true;
		static constexpr inline bool is_integer = false;
		static constexpr inline bool is_exact = false;
		static constexpr inline int radix = 2;
		static constexpr double epsilon() noexcept
		{
			return (double)(2.2204460492503130808E-16L);
		}
		static constexpr double round_error() noexcept
		{
			return (0.5);
		}
		static constexpr inline int min_exponent = (-1021);
		static constexpr inline int min_exponent10 = (-307);
		static constexpr inline int max_exponent = 1024;
		static constexpr inline int max_exponent10 = 308;
		static constexpr inline bool has_infinity = (1);
		static constexpr inline bool has_quiet_NaN = (1);
		static constexpr inline bool has_signaling_NaN = has_quiet_NaN;
		static constexpr inline float_denorm_style has_denorm =
			(((bool)1) ? denorm_present : denorm_absent);
		static constexpr inline bool has_denorm_loss = false;
		static constexpr double infinity() noexcept
		{
			return __builtin_huge_val();
		}
		static constexpr double quiet_NaN() noexcept
		{
			return __builtin_nan("");
		}
		static constexpr double signaling_NaN() noexcept
		{
			return __builtin_nans("");
		}
		static constexpr double denorm_min() noexcept
		{
			return (double)(4.940656458412465442E-324L);
		}
		static constexpr inline bool is_iec559 =
			(has_infinity && has_quiet_NaN &&
			 (has_denorm == (denorm_present)));
		static constexpr inline bool is_bounded = true;
		static constexpr inline bool is_modulo = false;
		static constexpr inline bool traps = false;
		static constexpr inline bool tinyness_before = false;
		static constexpr inline float_round_style round_style =
			round_to_nearest;
	};
	template <> struct numeric_limits<long double> {
		static constexpr inline bool is_specialized = true;
		static constexpr long double min() noexcept
		{
			return (3.3621031431120935063E-4932L);
		}
		static constexpr long double max() noexcept
		{
			return (1.189731495357231765E4932L);
		}
		static constexpr long double lowest() noexcept
		{
			return -(1.189731495357231765E4932L);
		}
		static constexpr inline int digits = 64;
		static constexpr inline int digits10 = 18;
		static constexpr inline int max_digits10 =
			((2) + (((64) * 643L) / (2136)));
		static constexpr inline bool is_signed = true;
		static constexpr inline bool is_integer = false;
		static constexpr inline bool is_exact = false;
		static constexpr inline int radix = 2;
		static constexpr long double epsilon() noexcept
		{
			return (1.084202172485504434E-19L);
		}
		static constexpr long double round_error() noexcept
		{
			return (0.5L);
		}
		static constexpr inline int min_exponent = (-16381);
		static constexpr inline int min_exponent10 = (-4931);
		static constexpr inline int max_exponent = 16384;
		static constexpr inline int max_exponent10 = 4932;
		static constexpr inline bool has_infinity = (1);
		static constexpr inline bool has_quiet_NaN = (1);
		static constexpr inline bool has_signaling_NaN = has_quiet_NaN;
		static constexpr inline float_denorm_style has_denorm =
			(((bool)1) ? denorm_present : denorm_absent);
		static constexpr inline bool has_denorm_loss = false;
		static constexpr long double infinity() noexcept
		{
			return __builtin_huge_vall();
		}
		static constexpr long double quiet_NaN() noexcept
		{
			return __builtin_nanl("");
		}
		static constexpr long double signaling_NaN() noexcept
		{
			return __builtin_nansl("");
		}
		static constexpr long double denorm_min() noexcept
		{
			return (3.6E-4951L);
		}
		static constexpr inline bool is_iec559 =
			(has_infinity && has_quiet_NaN &&
			 (has_denorm == (denorm_present)));
		static constexpr inline bool is_bounded = true;
		static constexpr inline bool is_modulo = false;
		static constexpr inline bool traps = false;
		static constexpr inline bool tinyness_before = false;
		static constexpr inline float_round_style round_style =
			round_to_nearest;
	};
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	namespace __detail
	{
	template <class _Tp> struct __floating_point_constant {
		static const _Tp __value;
	};
	template <class _Tp> struct __numeric_constants {
		static _Tp __pi() throw()
		{
			return static_cast<_Tp>((3.1415926535897932385L));
		}
		static _Tp __pi_2() throw()
		{
			return static_cast<_Tp>((1.5707963267948966193L));
		}
		static _Tp __pi_3() throw()
		{
			return static_cast<_Tp>((1.0471975511965977461L));
		}
		static _Tp __pi_4() throw()
		{
			return static_cast<_Tp>((0.78539816339744830963L));
		}
		static _Tp __1_pi() throw()
		{
			return static_cast<_Tp>((0.31830988618379067154L));
		}
		static _Tp __2_sqrtpi() throw()
		{
			return static_cast<_Tp>((1.1283791670955125738L));
		}
		static _Tp __sqrt2() throw()
		{
			return static_cast<_Tp>((1.4142135623730950488L));
		}
		static _Tp __sqrt3() throw()
		{
			return static_cast<_Tp>((1.7320508075688772936L));
		}
		static _Tp __sqrtpio2() throw()
		{
			return static_cast<_Tp>((1.2533141373155002512L));
		}
		static _Tp __sqrt1_2() throw()
		{
			return static_cast<_Tp>((0.7071067811865475244L));
		}
		static _Tp __lnpi() throw()
		{
			return static_cast<_Tp>((1.1447298858494001742L));
		}
		static _Tp __gamma_e() throw()
		{
			return static_cast<_Tp>((0.5772156649015328606L));
		}
		static _Tp __euler() throw()
		{
			return static_cast<_Tp>((2.7182818284590452354L));
		}
	};
	template <class _Tp> inline bool __isnan(_Tp __x)
	{
		return std::isnan(__x);
	}
	} // namespace __detail
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	namespace __detail
	{
	template <class _Tp> _Tp __bernoulli_series(unsigned __n)
	{
		static const _Tp __num[28] = {
			((_Tp)1UL),
			((-((_Tp)1UL)) / ((_Tp)2UL)),
			(((_Tp)1UL) / ((_Tp)6UL)),
			((_Tp)0UL),
			((-((_Tp)1UL)) / ((_Tp)30UL)),
			((_Tp)0UL),
			(((_Tp)1UL) / ((_Tp)42UL)),
			((_Tp)0UL),
			((-((_Tp)1UL)) / ((_Tp)30UL)),
			((_Tp)0UL),
			(((_Tp)5UL) / ((_Tp)66UL)),
			((_Tp)0UL),
			((-((_Tp)691UL)) / ((_Tp)2730UL)),
			((_Tp)0UL),
			(((_Tp)7UL) / ((_Tp)6UL)),
			((_Tp)0UL),
			((-((_Tp)3617UL)) / ((_Tp)510UL)),
			((_Tp)0UL),
			(((_Tp)43867UL) / ((_Tp)798UL)),
			((_Tp)0UL),
			((-((_Tp)174611)) / ((_Tp)330UL)),
			((_Tp)0UL),
			(((_Tp)854513UL) / ((_Tp)138UL)),
			((_Tp)0UL),
			((-((_Tp)236364091UL)) / ((_Tp)2730UL)),
			((_Tp)0UL),
			(((_Tp)8553103UL) / ((_Tp)6UL)),
			((_Tp)0UL)
		};
		if (__n == (0)) {
			return (_Tp)1;
		}
		if (__n == (1)) {
			return (-((_Tp)1)) / ((_Tp)2);
		}
		if ((__n % (2)) == (1)) {
			return (_Tp)0;
		}
		if (__n < (28)) {
			return __num[__n];
		}
		_Tp __fact = ((_Tp)1);
		if (((__n / (2)) % (2)) == (0)) {
			__fact *= ((_Tp)(-1));
		}
		for (unsigned __k = (1); __k <= __n; ++__k) {
			__fact *= (__k / (((_Tp)2) *
					  __numeric_constants<_Tp>::__pi()));
		}
		__fact *= ((_Tp)2);
		_Tp __sum = ((_Tp)0);
		for (unsigned __i = (1); __i < (1000); ++__i) {
			_Tp __term = std::pow((_Tp)__i, -((_Tp)__n));
			if (__term <
			    std::template numeric_limits<_Tp>::epsilon()) {
				break;
			}
			__sum += __term;
		}
		return __fact * __sum;
	}
	template <class _Tp> inline _Tp __bernoulli(int __n)
	{
		return __bernoulli_series<_Tp>(__n);
	}
	template <class _Tp> _Tp __log_gamma_bernoulli(_Tp __x)
	{
		_Tp __lg =
			(((__x - ((_Tp)(0.5L))) * std::log(__x)) - __x) +
			(((_Tp)(0.5L)) *
			 std::log(((_Tp)2) * __numeric_constants<_Tp>::__pi()));
		const _Tp __xx = __x * __x;
		_Tp __help = ((_Tp)1) / __x;
		for (unsigned __i = (1); __i < (20); ++__i) {
			const _Tp __2i = (_Tp)((2) * __i);
			__help /= ((__2i * (__2i - ((_Tp)1))) * __xx);
			__lg += (__bernoulli<_Tp>((2) * __i) * __help);
		}
		return __lg;
	}
	template <class _Tp> _Tp __log_gamma_lanczos(_Tp __x)
	{
		const _Tp __xm1 = __x - ((_Tp)1);
		static const _Tp __lanczos_cheb_7[9] = {
			((_Tp)(0.99999999999980993226L)),
			((_Tp)(676.52036812188509857L)),
			((_Tp)(-(1259.1392167224028704L))),
			((_Tp)(771.32342877765307887L)),
			((_Tp)(-(176.61502916214059906L))),
			((_Tp)(12.507343278686904814L)),
			((_Tp)(-(0.1385710952657201169L))),
			((_Tp)(9.9843695780195708595E-6L)),
			((_Tp)(1.5056327351493115584E-7L))
		};
		static const _Tp __LOGROOT2PI = ((_Tp)(0.9189385332046727418L));
		_Tp __sum = (__lanczos_cheb_7[0]);
		for (unsigned __k = (1); __k < (9); ++__k) {
			__sum += ((__lanczos_cheb_7[__k]) / (__xm1 + __k));
		}
		const _Tp __term1 =
			(__xm1 + ((_Tp)(0.5L))) *
			std::log((__xm1 + ((_Tp)(7.5L))) /
				 __numeric_constants<_Tp>::__euler());
		const _Tp __term2 = __LOGROOT2PI + std::log(__sum);
		const _Tp __result = __term1 + (__term2 - ((_Tp)7));
		return __result;
	}
	template <class _Tp> _Tp __log_gamma(_Tp __x)
	{
		if (__x > ((_Tp)(0.5L))) {
			return __log_gamma_lanczos(__x);
		} else {
			const _Tp __sin_fact = std::abs(std::sin(
				__numeric_constants<_Tp>::__pi() * __x));
			if (__sin_fact == ((_Tp)0)) {
				std::__throw_domain_error(
					"Argument is nonpositive integer in __log_gamma");
			}
			return (__numeric_constants<_Tp>::__lnpi() -
				std::log(__sin_fact)) -
			       __log_gamma_lanczos(((_Tp)1) - __x);
		}
	}
	template <class _Tp> _Tp __log_gamma_sign(_Tp __x)
	{
		if (__x > ((_Tp)0)) {
			return (_Tp)1;
		} else {
			const _Tp __sin_fact = std::sin(
				__numeric_constants<_Tp>::__pi() * __x);
			if (__sin_fact > ((_Tp)0)) {
				return 1;
			} else {
				if (__sin_fact < ((_Tp)0)) {
					return -((_Tp)1);
				} else {
					return (_Tp)0;
				}
			}
		}
	}
	template <class _Tp> _Tp __log_bincoef(unsigned __n, unsigned __k)
	{
		static const _Tp __max_bincoeff =
			(std::template numeric_limits<_Tp>::max_exponent10 *
			 std::log((_Tp)10)) -
			((_Tp)1);
		_Tp __coeff = (std::lgamma((_Tp)((1) + __n)) -
			       std::lgamma((_Tp)((1) + __k))) -
			      std::lgamma((_Tp)(((1) + __n) - __k));
	}
	template <class _Tp> _Tp __bincoef(unsigned __n, unsigned __k)
	{
		static const _Tp __max_bincoeff =
			(std::template numeric_limits<_Tp>::max_exponent10 *
			 std::log((_Tp)10)) -
			((_Tp)1);
		const _Tp __log_coeff = __log_bincoef<_Tp>(__n, __k);
		if (__log_coeff > __max_bincoeff) {
			return std::template numeric_limits<_Tp>::quiet_NaN();
		} else {
			return std::exp(__log_coeff);
		}
	}
	template <class _Tp> inline _Tp __gamma(_Tp __x)
	{
		return std::exp(__log_gamma(__x));
	}
	template <class _Tp> _Tp __psi_series(_Tp __x)
	{
		_Tp __sum = (-__numeric_constants<_Tp>::__gamma_e()) -
			    (((_Tp)1) / __x);
		const unsigned __max_iter = (100000);
		for (unsigned __k = (1); __k < __max_iter; ++__k) {
			const _Tp __term = __x / (__k * (__k + __x));
			__sum += __term;
			if (std::abs(__term / __sum) <
			    std::template numeric_limits<_Tp>::epsilon()) {
				break;
			}
		}
		return __sum;
	}
	template <class _Tp> _Tp __psi_asymp(_Tp __x)
	{
		_Tp __sum = std::log(__x) - (((_Tp)(0.5L)) / __x);
		const _Tp __xx = __x * __x;
		_Tp __xp = __xx;
		const unsigned __max_iter = (100);
		for (unsigned __k = (1); __k < __max_iter; ++__k) {
			const _Tp __term = __bernoulli<_Tp>((2) * __k) /
					   (((2) * __k) * __xp);
			__sum -= __term;
			if (std::abs(__term / __sum) <
			    std::template numeric_limits<_Tp>::epsilon()) {
				break;
			}
			__xp *= __xx;
		}
		return __sum;
	}
	template <class _Tp> _Tp __psi(_Tp __x)
	{
		const int __n = static_cast<int>(__x + (0.5L));
		const _Tp __eps =
			((_Tp)4) * std::template numeric_limits<_Tp>::epsilon();
		if ((__n <= 0) && (std::abs(__x - ((_Tp)__n)) < __eps)) {
			return std::template numeric_limits<_Tp>::quiet_NaN();
		} else {
			if (__x < ((_Tp)0)) {
				const _Tp __pi =
					__numeric_constants<_Tp>::__pi();
				return __psi(((_Tp)1) - __x) -
				       ((__pi * std::cos(__pi * __x)) /
					std::sin(__pi * __x));
			} else {
				if (__x > ((_Tp)100)) {
					return __psi_asymp(__x);
				} else {
					return __psi_series(__x);
				}
			}
		}
	}
	template <class _Tp> _Tp __psi(unsigned __n, _Tp __x)
	{
		if (__x <= ((_Tp)0)) {
			std::__throw_domain_error(
				"Argument out of range in __psi");
		} else {
			if (__n == (0)) {
				return __psi(__x);
			} else {
				const _Tp __hzeta =
					__hurwitz_zeta((_Tp)(__n + (1)), __x);
				const _Tp __ln_nfact =
					std::lgamma((_Tp)(__n + (1)));
				_Tp __result = std::exp(__ln_nfact) * __hzeta;
				if ((__n % (2)) == (1)) {
					__result = (-__result);
				}
				return __result;
			}
		}
	}
	} // namespace __detail
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	namespace __detail
	{
	template <class _Tp>
	void __gamma_temme(_Tp __mu, _Tp &__gam1, _Tp &__gam2, _Tp &__gampl,
			   _Tp &__gammi)
	{
		__gampl = (((_Tp)1) / std::tgamma(((_Tp)1) + __mu));
		__gammi = (((_Tp)1) / std::tgamma(((_Tp)1) - __mu));
		if (std::abs(__mu) <
		    std::template numeric_limits<_Tp>::epsilon()) {
			__gam1 =
				(-((_Tp)__numeric_constants<_Tp>::__gamma_e()));
		} else {
			__gam1 = ((__gammi - __gampl) / (((_Tp)2) * __mu));
		}
		__gam2 = ((__gammi + __gampl) / ((_Tp)2));
	}
	template <class _Tp>
	void __bessel_jn(_Tp __nu, _Tp __x, _Tp &__Jnu, _Tp &__Nnu, _Tp &__Jpnu,
			 _Tp &__Npnu)
	{
		if (__x == ((_Tp)0)) {
			if (__nu == ((_Tp)0)) {
				__Jnu = ((_Tp)1);
				__Jpnu = ((_Tp)0);
			} else {
				if (__nu == ((_Tp)1)) {
					__Jnu = ((_Tp)0);
					__Jpnu = ((_Tp)(0.5L));
				} else {
					__Jnu = ((_Tp)0);
					__Jpnu = ((_Tp)0);
				}
			}
			__Nnu = (-std::template numeric_limits<_Tp>::infinity());
			__Npnu = std::template numeric_limits<_Tp>::infinity();
			return;
		}
		const _Tp __eps = std::template numeric_limits<_Tp>::epsilon();
		const _Tp __fp_min =
			std::sqrt(std::template numeric_limits<_Tp>::min());
		const int __max_iter = 15000;
		const _Tp __x_min = ((_Tp)2);
		const int __nl =
			(__x < __x_min) ?
				static_cast<int>(__nu + ((_Tp)(0.5L))) :
				std::max(0, static_cast<int>((__nu - __x) +
							     ((_Tp)(1.5L))));
		const _Tp __mu = __nu - __nl;
		const _Tp __mu2 = __mu * __mu;
		const _Tp __xi = ((_Tp)1) / __x;
		const _Tp __xi2 = ((_Tp)2) * __xi;
		_Tp __w = __xi2 / __numeric_constants<_Tp>::__pi();
		int __isign = 1;
		_Tp __h = __nu * __xi;
		if (__h < __fp_min) {
			__h = __fp_min;
		}
		_Tp __b = __xi2 * __nu;
		_Tp __d = ((_Tp)0);
		_Tp __c = __h;
		int __i;
		for (__i = 1; __i <= __max_iter; ++__i) {
			__b += __xi2;
			__d = (__b - __d);
			if (std::abs(__d) < __fp_min) {
				__d = __fp_min;
			}
			__c = (__b - (((_Tp)1) / __c));
			if (std::abs(__c) < __fp_min) {
				__c = __fp_min;
			}
			__d = (((_Tp)1) / __d);
			const _Tp __del = __c * __d;
			__h *= __del;
			if (__d < ((_Tp)0)) {
				__isign = (-__isign);
			}
			if (std::abs(__del - ((_Tp)1)) < __eps) {
				break;
			}
		}
		if (__i > __max_iter) {
			std::__throw_runtime_error(
				"Argument x too large in __bessel_jn; try asymptotic expansion.");
		}
		_Tp __Jnul = __isign * __fp_min;
		_Tp __Jpnul = __h * __Jnul;
		_Tp __Jnul1 = __Jnul;
		_Tp __Jpnu1 = __Jpnul;
		_Tp __fact = __nu * __xi;
		for (int __l = __nl; __l >= 1; --__l) {
			const _Tp __Jnutemp = (__fact * __Jnul) + __Jpnul;
			__fact -= __xi;
			__Jpnul = ((__fact * __Jnutemp) - __Jnul);
			__Jnul = __Jnutemp;
		}
		if (__Jnul == ((_Tp)0)) {
			__Jnul = __eps;
		}
		_Tp __f = __Jpnul / __Jnul;
		_Tp __Nmu, __Nnu1, __Npmu, __Jmu;
		if (__x < __x_min) {
			const _Tp __x2 = __x / ((_Tp)2);
			const _Tp __pimu =
				__numeric_constants<_Tp>::__pi() * __mu;
			_Tp __fact = (std::abs(__pimu) < __eps) ?
					     (_Tp)1 :
					     (__pimu / std::sin(__pimu));
			_Tp __d = (-std::log(__x2));
			_Tp __e = __mu * __d;
			_Tp __fact2 = (std::abs(__e) < __eps) ?
					      (_Tp)1 :
					      (std::sinh(__e) / __e);
			_Tp __gam1, __gam2, __gampl, __gammi;
			__gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
			_Tp __ff =
				((((_Tp)2) / __numeric_constants<_Tp>::__pi()) *
				 __fact) *
				((__gam1 * std::cosh(__e)) +
				 ((__gam2 * __fact2) * __d));
			__e = std::exp(__e);
			_Tp __p = __e /
				  (__numeric_constants<_Tp>::__pi() * __gampl);
			_Tp __q = ((_Tp)1) /
				  ((__e * __numeric_constants<_Tp>::__pi()) *
				   __gammi);
			const _Tp __pimu2 = __pimu / ((_Tp)2);
			_Tp __fact3 = (std::abs(__pimu2) < __eps) ?
					      (_Tp)1 :
					      (std::sin(__pimu2) / __pimu2);
			_Tp __r =
				((__numeric_constants<_Tp>::__pi() * __pimu2) *
				 __fact3) *
				__fact3;
			_Tp __c = ((_Tp)1);
			__d = ((-__x2) * __x2);
			_Tp __sum = __ff + (__r * __q);
			_Tp __sum1 = __p;
			for (__i = 1; __i <= __max_iter; ++__i) {
				__ff = ((((__i * __ff) + __p) + __q) /
					((__i * __i) - __mu2));
				__c *= (__d / ((_Tp)__i));
				__p /= (((_Tp)__i) - __mu);
				__q /= (((_Tp)__i) + __mu);
				const _Tp __del = __c * (__ff + (__r * __q));
				__sum += __del;
				const _Tp __del1 = (__c * __p) - (__i * __del);
				__sum1 += __del1;
				if (std::abs(__del) <
				    (__eps * (((_Tp)1) + std::abs(__sum)))) {
					break;
				}
			}
			if (__i > __max_iter) {
				std::__throw_runtime_error(
					"Bessel y series failed to converge in __bessel_jn.");
			}
			__Nmu = (-__sum);
			__Nnu1 = ((-__sum1) * __xi2);
			__Npmu = (((__mu * __xi) * __Nmu) - __Nnu1);
			__Jmu = (__w / (__Npmu - (__f * __Nmu)));
		} else {
			_Tp __a = ((_Tp)(0.25L)) - __mu2;
			_Tp __q = ((_Tp)1);
			_Tp __p = ((-__xi) / ((_Tp)2));
			_Tp __br = ((_Tp)2) * __x;
			_Tp __bi = ((_Tp)2);
			_Tp __fact = (__a * __xi) / ((__p * __p) + (__q * __q));
			_Tp __cr = __br + (__q * __fact);
			_Tp __ci = __bi + (__p * __fact);
			_Tp __den = (__br * __br) + (__bi * __bi);
			_Tp __dr = __br / __den;
			_Tp __di = (-__bi) / __den;
			_Tp __dlr = (__cr * __dr) - (__ci * __di);
			_Tp __dli = (__cr * __di) + (__ci * __dr);
			_Tp __temp = (__p * __dlr) - (__q * __dli);
			__q = ((__p * __dli) + (__q * __dlr));
			__p = __temp;
			int __i;
			for (__i = 2; __i <= __max_iter; ++__i) {
				__a += ((_Tp)(2 * (__i - 1)));
				__bi += ((_Tp)2);
				__dr = ((__a * __dr) + __br);
				__di = ((__a * __di) + __bi);
				if ((std::abs(__dr) + std::abs(__di)) <
				    __fp_min) {
					__dr = __fp_min;
				}
				__fact =
					(__a / ((__cr * __cr) + (__ci * __ci)));
				__cr = (__br + (__cr * __fact));
				__ci = (__bi - (__ci * __fact));
				if ((std::abs(__cr) + std::abs(__ci)) <
				    __fp_min) {
					__cr = __fp_min;
				}
				__den = ((__dr * __dr) + (__di * __di));
				__dr /= __den;
				__di /= (-__den);
				__dlr = ((__cr * __dr) - (__ci * __di));
				__dli = ((__cr * __di) + (__ci * __dr));
				__temp = ((__p * __dlr) - (__q * __dli));
				__q = ((__p * __dli) + (__q * __dlr));
				__p = __temp;
				if ((std::abs(__dlr - ((_Tp)1)) +
				     std::abs(__dli)) < __eps) {
					break;
				}
			}
			if (__i > __max_iter) {
				std::__throw_runtime_error(
					"Lentz\'s method failed in __bessel_jn.");
			}
			const _Tp __gam = (__p - __f) / __q;
			__Jmu = std::sqrt(__w / (((__p - __f) * __gam) + __q));
			__Jmu = std::copysign(__Jmu, __Jnul);
			__Nmu = (__gam * __Jmu);
			__Npmu = ((__p + (__q / __gam)) * __Nmu);
			__Nnu1 = (((__mu * __xi) * __Nmu) - __Npmu);
		}
		__fact = (__Jmu / __Jnul);
		__Jnu = (__fact * __Jnul1);
		__Jpnu = (__fact * __Jpnu1);
		for (__i = 1; __i <= __nl; ++__i) {
			const _Tp __Nnutemp =
				(((__mu + __i) * __xi2) * __Nnu1) - __Nmu;
			__Nmu = __Nnu1;
			__Nnu1 = __Nnutemp;
		}
		__Nnu = __Nmu;
		__Npnu = (((__nu * __xi) * __Nmu) - __Nnu1);
	}
	template <class _Tp>
	void __cyl_bessel_jn_asymp(_Tp __nu, _Tp __x, _Tp &__Jnu, _Tp &__Nnu)
	{
		const _Tp __mu = (((_Tp)4) * __nu) * __nu;
		const _Tp __8x = ((_Tp)8) * __x;
		_Tp __P = ((_Tp)0);
		_Tp __Q = ((_Tp)0);
		_Tp __k = ((_Tp)0);
		_Tp __term = ((_Tp)1);
		int __epsP = 0;
		int __epsQ = 0;
		_Tp __eps = std::template numeric_limits<_Tp>::epsilon();
		do {
			__term *= ((__k == 0) ? (_Tp)1 :
						((-(__mu - (((2 * __k) - 1) *
							    ((2 * __k) - 1)))) /
						 (__k * __8x)));
			__epsP = (std::abs(__term) < (__eps * std::abs(__P)));
			__P += __term;
			__k++;
			__term *=
				((__mu - (((2 * __k) - 1) * ((2 * __k) - 1))) /
				 (__k * __8x));
			__epsQ = (std::abs(__term) < (__eps * std::abs(__Q)));
			__Q += __term;
			if (__epsP && __epsQ && (__k > (__nu / (2.0)))) {
				break;
			}
			__k++;
		} while (__k < 1000);
		const _Tp __chi = __x - ((__nu + ((_Tp)(0.5L))) *
					 __numeric_constants<_Tp>::__pi_2());
		const _Tp __c = std::cos(__chi);
		const _Tp __s = std::sin(__chi);
		const _Tp __coef = std::sqrt(
			((_Tp)2) / (__numeric_constants<_Tp>::__pi() * __x));
		__Jnu = (__coef * ((__c * __P) - (__s * __Q)));
		__Nnu = (__coef * ((__s * __P) + (__c * __Q)));
	}
	template <class _Tp>
	_Tp __cyl_bessel_ij_series(_Tp __nu, _Tp __x, _Tp __sgn,
				   unsigned __max_iter)
	{
		if (__x == ((_Tp)0)) {
			return (__nu == ((_Tp)0)) ? (_Tp)1 : ((_Tp)0);
		}
		const _Tp __x2 = __x / ((_Tp)2);
		_Tp __fact = __nu * std::log(__x2);
		__fact -= std::lgamma(__nu + ((_Tp)1));
		__fact = std::exp(__fact);
		const _Tp __xx4 = (__sgn * __x2) * __x2;
		_Tp __Jn = ((_Tp)1);
		_Tp __term = ((_Tp)1);
		for (unsigned __i = (1); __i < __max_iter; ++__i) {
			__term *= (__xx4 / (((_Tp)__i) * (__nu + ((_Tp)__i))));
			__Jn += __term;
			if (std::abs(__term / __Jn) <
			    std::template numeric_limits<_Tp>::epsilon()) {
				break;
			}
		}
		return __fact * __Jn;
	}
	template <class _Tp> _Tp __cyl_bessel_j(_Tp __nu, _Tp __x)
	{
		if ((__nu < ((_Tp)0)) || (__x < ((_Tp)0))) {
			std::__throw_domain_error(
				"Bad argument in __cyl_bessel_j.");
		} else {
			if (__isnan(__nu) || __isnan(__x)) {
				return std::template numeric_limits<
					_Tp>::quiet_NaN();
			} else {
				if ((__x * __x) <
				    (((_Tp)10) * (__nu + ((_Tp)1)))) {
					return __cyl_bessel_ij_series(
						__nu, __x, -((_Tp)1), 200);
				} else {
					if (__x > ((_Tp)1000)) {
						_Tp __J_nu, __N_nu;
						__cyl_bessel_jn_asymp(__nu, __x,
								      __J_nu,
								      __N_nu);
						return __J_nu;
					} else {
						_Tp __J_nu, __N_nu, __Jp_nu,
							__Np_nu;
						__bessel_jn(__nu, __x, __J_nu,
							    __N_nu, __Jp_nu,
							    __Np_nu);
						return __J_nu;
					}
				}
			}
		}
	}
	template <class _Tp> _Tp __cyl_neumann_n(_Tp __nu, _Tp __x)
	{
		if ((__nu < ((_Tp)0)) || (__x < ((_Tp)0))) {
			std::__throw_domain_error(
				"Bad argument in __cyl_neumann_n.");
		} else {
			if (__isnan(__nu) || __isnan(__x)) {
				return std::template numeric_limits<
					_Tp>::quiet_NaN();
			} else {
				if (__x > ((_Tp)1000)) {
					_Tp __J_nu, __N_nu;
					__cyl_bessel_jn_asymp(__nu, __x, __J_nu,
							      __N_nu);
					return __N_nu;
				} else {
					_Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
					__bessel_jn(__nu, __x, __J_nu, __N_nu,
						    __Jp_nu, __Np_nu);
					return __N_nu;
				}
			}
		}
	}
	template <class _Tp>
	void __sph_bessel_jn(unsigned __n, _Tp __x, _Tp &__j_n, _Tp &__n_n,
			     _Tp &__jp_n, _Tp &__np_n)
	{
		const _Tp __nu = ((_Tp)__n) + ((_Tp)(0.5L));
		_Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
		__bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
		const _Tp __factor =
			__numeric_constants<_Tp>::__sqrtpio2() / std::sqrt(__x);
		__j_n = (__factor * __J_nu);
		__n_n = (__factor * __N_nu);
		__jp_n = ((__factor * __Jp_nu) - (__j_n / (((_Tp)2) * __x)));
		__np_n = ((__factor * __Np_nu) - (__n_n / (((_Tp)2) * __x)));
	}
	template <class _Tp> _Tp __sph_bessel(unsigned __n, _Tp __x)
	{
		if (__x < ((_Tp)0)) {
			std::__throw_domain_error(
				"Bad argument in __sph_bessel.");
		} else {
			if (__isnan(__x)) {
				return std::template numeric_limits<
					_Tp>::quiet_NaN();
			} else {
				if (__x == ((_Tp)0)) {
					if (__n == (0)) {
						return (_Tp)1;
					} else {
						return (_Tp)0;
					}
				} else {
					_Tp __j_n, __n_n, __jp_n, __np_n;
					__sph_bessel_jn(__n, __x, __j_n, __n_n,
							__jp_n, __np_n);
					return __j_n;
				}
			}
		}
	}
	template <class _Tp> _Tp __sph_neumann(unsigned __n, _Tp __x)
	{
		if (__x < ((_Tp)0)) {
			std::__throw_domain_error(
				"Bad argument in __sph_neumann.");
		} else {
			if (__isnan(__x)) {
				return std::template numeric_limits<
					_Tp>::quiet_NaN();
			} else {
				if (__x == ((_Tp)0)) {
					return -std::template numeric_limits<
						_Tp>::infinity();
				} else {
					_Tp __j_n, __n_n, __jp_n, __np_n;
					__sph_bessel_jn(__n, __x, __j_n, __n_n,
							__jp_n, __np_n);
					return __n_n;
				}
			}
		}
	}
	} // namespace __detail
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	namespace __detail
	{
	template <class _Tp> _Tp __beta_gamma(_Tp __x, _Tp __y)
	{
		_Tp __bet;
		if (__x > __y) {
			__bet = (std::tgamma(__x) / std::tgamma(__x + __y));
			__bet *= std::tgamma(__y);
		} else {
			__bet = (std::tgamma(__y) / std::tgamma(__x + __y));
			__bet *= std::tgamma(__x);
		}
		return __bet;
	}
	template <class _Tp> _Tp __beta_lgamma(_Tp __x, _Tp __y)
	{
		_Tp __bet = (std::lgamma(__x) + std::lgamma(__y)) -
			    std::lgamma(__x + __y);
		__bet = std::exp(__bet);
		return __bet;
	}
	template <class _Tp> _Tp __beta_product(_Tp __x, _Tp __y)
	{
		_Tp __bet = (__x + __y) / (__x * __y);
		unsigned __max_iter = (1000000);
		for (unsigned __k = (1); __k < __max_iter; ++__k) {
			_Tp __term = (((_Tp)1) + ((__x + __y) / __k)) /
				     ((((_Tp)1) + (__x / __k)) *
				      (((_Tp)1) + (__y / __k)));
			__bet *= __term;
		}
		return __bet;
	}
	template <class _Tp> inline _Tp __beta(_Tp __x, _Tp __y)
	{
		if (__isnan(__x) || __isnan(__y)) {
			return std::template numeric_limits<_Tp>::quiet_NaN();
		} else {
			return __beta_lgamma(__x, __y);
		}
	}
	} // namespace __detail
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	namespace __detail
	{
	template <class _Tp> _Tp __ellint_rf(_Tp __x, _Tp __y, _Tp __z)
	{
		const _Tp __min = std::template numeric_limits<_Tp>::min();
		const _Tp __lolim = ((_Tp)5) * __min;
		if (((__x < ((_Tp)0)) || (__y < ((_Tp)0))) ||
		    (__z < ((_Tp)0))) {
			std::__throw_domain_error(
				"Argument less than zero in __ellint_rf.");
		} else {
			if ((((__x + __y) < __lolim) ||
			     ((__x + __z) < __lolim)) ||
			    ((__y + __z) < __lolim)) {
				std::__throw_domain_error(
					"Argument too small in __ellint_rf");
			} else {
				const _Tp __c0 = (((_Tp)1) / ((_Tp)4));
				const _Tp __c1 = (((_Tp)1) / ((_Tp)24));
				const _Tp __c2 = (((_Tp)1) / ((_Tp)10));
				const _Tp __c3 = (((_Tp)3) / ((_Tp)44));
				const _Tp __c4 = (((_Tp)1) / ((_Tp)14));
				_Tp __xn = __x;
				_Tp __yn = __y;
				_Tp __zn = __z;
				const _Tp __eps = std::template numeric_limits<
					_Tp>::epsilon();
				const _Tp __errtol =
					std::pow(__eps, ((_Tp)1) / ((_Tp)6));
				_Tp __mu;
				_Tp __xndev, __yndev, __zndev;
				const unsigned __max_iter = (100);
				for (unsigned __iter = (0); __iter < __max_iter;
				     ++__iter) {
					__mu = (((__xn + __yn) + __zn) /
						((_Tp)3));
					__xndev = (2 - ((__mu + __xn) / __mu));
					__yndev = (2 - ((__mu + __yn) / __mu));
					__zndev = (2 - ((__mu + __zn) / __mu));
					_Tp __epsilon =
						std::max(std::abs(__xndev),
							 std::abs(__yndev));
					__epsilon = std::max(__epsilon,
							     std::abs(__zndev));
					if (__epsilon < __errtol) {
						break;
					}
					const _Tp __xnroot = std::sqrt(__xn);
					const _Tp __ynroot = std::sqrt(__yn);
					const _Tp __znroot = std::sqrt(__zn);
					const _Tp __lambda =
						(__xnroot *
						 (__ynroot + __znroot)) +
						(__ynroot * __znroot);
					__xn = (__c0 * (__xn + __lambda));
					__yn = (__c0 * (__yn + __lambda));
					__zn = (__c0 * (__zn + __lambda));
				}
				const _Tp __e2 = (__xndev * __yndev) -
						 (__zndev * __zndev);
				const _Tp __e3 = (__xndev * __yndev) * __zndev;
				const _Tp __s =
					(((_Tp)1) + ((((__c1 * __e2) - __c2) -
						      (__c3 * __e3)) *
						     __e2)) +
					(__c4 * __e3);
				return __s / std::sqrt(__mu);
			}
		}
	}
	template <class _Tp> _Tp __comp_ellint_1_series(_Tp __k)
	{
		const _Tp __kk = __k * __k;
		_Tp __term = __kk / ((_Tp)4);
		_Tp __sum = ((_Tp)1) + __term;
		const unsigned __max_iter = (1000);
		for (unsigned __i = (2); __i < __max_iter; ++__i) {
			__term *= (((((2) * __i) - (1)) * __kk) / ((2) * __i));
			if (__term <
			    std::template numeric_limits<_Tp>::epsilon()) {
				break;
			}
			__sum += __term;
		}
		return __numeric_constants<_Tp>::__pi_2() * __sum;
	}
	template <class _Tp> _Tp __comp_ellint_1(_Tp __k)
	{
		if (__isnan(__k)) {
			return std::template numeric_limits<_Tp>::quiet_NaN();
		} else {
			if (std::abs(__k) >= ((_Tp)1)) {
				return std::template numeric_limits<
					_Tp>::quiet_NaN();
			} else {
				return __ellint_rf(
					(_Tp)0, ((_Tp)1) - (__k * __k), (_Tp)1);
			}
		}
	}
	template <class _Tp> _Tp __ellint_1(_Tp __k, _Tp __phi)
	{
		if (__isnan(__k) || __isnan(__phi)) {
			return std::template numeric_limits<_Tp>::quiet_NaN();
		} else {
			if (std::abs(__k) > ((_Tp)1)) {
				std::__throw_domain_error(
					"Bad argument in __ellint_1.");
			} else {
				const int __n = std::floor(
					(__phi /
					 __numeric_constants<_Tp>::__pi()) +
					((_Tp)(0.5L)));
				const _Tp __phi_red =
					__phi -
					(__n *
					 __numeric_constants<_Tp>::__pi());
				const _Tp __s = std::sin(__phi_red);
				const _Tp __c = std::cos(__phi_red);
				const _Tp __F =
					__s *
					__ellint_rf(__c * __c,
						    ((_Tp)1) - (((__k * __k) *
								 __s) *
								__s),
						    (_Tp)1);
				if (__n == 0) {
					return __F;
				} else {
					return __F + ((((_Tp)2) * __n) *
						      __comp_ellint_1(__k));
				}
			}
		}
	}
	template <class _Tp> _Tp __comp_ellint_2_series(_Tp __k)
	{
		const _Tp __kk = __k * __k;
		_Tp __term = __kk;
		_Tp __sum = __term;
		const unsigned __max_iter = (1000);
		for (unsigned __i = (2); __i < __max_iter; ++__i) {
			const _Tp __i2m = ((2) * __i) - (1);
			const _Tp __i2 = (2) * __i;
			__term *= (((__i2m * __i2m) * __kk) / (__i2 * __i2));
			if (__term <
			    std::template numeric_limits<_Tp>::epsilon()) {
				break;
			}
			__sum += (__term / __i2m);
		}
		return __numeric_constants<_Tp>::__pi_2() * (((_Tp)1) - __sum);
	}
	template <class _Tp> _Tp __ellint_rd(_Tp __x, _Tp __y, _Tp __z)
	{
		const _Tp __eps = std::template numeric_limits<_Tp>::epsilon();
		const _Tp __errtol =
			std::pow(__eps / ((_Tp)8), ((_Tp)1) / ((_Tp)6));
		const _Tp __max = std::template numeric_limits<_Tp>::max();
		const _Tp __lolim =
			((_Tp)2) / std::pow(__max, ((_Tp)2) / ((_Tp)3));
		if ((__x < ((_Tp)0)) || (__y < ((_Tp)0))) {
			std::__throw_domain_error(
				"Argument less than zero in __ellint_rd.");
		} else {
			if (((__x + __y) < __lolim) || (__z < __lolim)) {
				std::__throw_domain_error(
					"Argument too small in __ellint_rd.");
			} else {
				const _Tp __c0 = (((_Tp)1) / ((_Tp)4));
				const _Tp __c1 = (((_Tp)3) / ((_Tp)14));
				const _Tp __c2 = (((_Tp)1) / ((_Tp)6));
				const _Tp __c3 = (((_Tp)9) / ((_Tp)22));
				const _Tp __c4 = (((_Tp)3) / ((_Tp)26));
				_Tp __xn = __x;
				_Tp __yn = __y;
				_Tp __zn = __z;
				_Tp __sigma = ((_Tp)0);
				_Tp __power4 = ((_Tp)1);
				_Tp __mu;
				_Tp __xndev, __yndev, __zndev;
				const unsigned __max_iter = (100);
				for (unsigned __iter = (0); __iter < __max_iter;
				     ++__iter) {
					__mu = (((__xn + __yn) +
						 (((_Tp)3) * __zn)) /
						((_Tp)5));
					__xndev = ((__mu - __xn) / __mu);
					__yndev = ((__mu - __yn) / __mu);
					__zndev = ((__mu - __zn) / __mu);
					_Tp __epsilon =
						std::max(std::abs(__xndev),
							 std::abs(__yndev));
					__epsilon = std::max(__epsilon,
							     std::abs(__zndev));
					if (__epsilon < __errtol) {
						break;
					}
					_Tp __xnroot = std::sqrt(__xn);
					_Tp __ynroot = std::sqrt(__yn);
					_Tp __znroot = std::sqrt(__zn);
					_Tp __lambda = (__xnroot *
							(__ynroot + __znroot)) +
						       (__ynroot * __znroot);
					__sigma += (__power4 /
						    (__znroot *
						     (__zn + __lambda)));
					__power4 *= __c0;
					__xn = (__c0 * (__xn + __lambda));
					__yn = (__c0 * (__yn + __lambda));
					__zn = (__c0 * (__zn + __lambda));
				}
				_Tp __ea = __xndev * __yndev;
				_Tp __eb = __zndev * __zndev;
				_Tp __ec = __ea - __eb;
				_Tp __ed = __ea - (((_Tp)6) * __eb);
				_Tp __ef = (__ed + __ec) + __ec;
				_Tp __s1 = __ed *
					   (((-__c1) +
					     ((__c3 * __ed) / ((_Tp)3))) -
					    ((((((_Tp)3) * __c4) * __zndev) *
					      __ef) /
					     ((_Tp)2)));
				_Tp __s2 = __zndev *
					   ((__c2 * __ef) +
					    (__zndev * ((((-__c3) * __ec) -
							 (__zndev * __c4)) -
							__ea)));
				return (((_Tp)3) * __sigma) +
				       ((__power4 *
					 ((((_Tp)1) + __s1) + __s2)) /
					(__mu * std::sqrt(__mu)));
			}
		}
	}
	template <class _Tp> _Tp __comp_ellint_2(_Tp __k)
	{
		if (__isnan(__k)) {
			return std::template numeric_limits<_Tp>::quiet_NaN();
		} else {
			if (std::abs(__k) == 1) {
				return (_Tp)1;
			} else {
				if (std::abs(__k) > ((_Tp)1)) {
					std::__throw_domain_error(
						"Bad argument in __comp_ellint_2.");
				} else {
					const _Tp __kk = __k * __k;
					return __ellint_rf((_Tp)0,
							   ((_Tp)1) - __kk,
							   (_Tp)1) -
					       ((__kk *
						 __ellint_rd((_Tp)0,
							     ((_Tp)1) - __kk,
							     (_Tp)1)) /
						((_Tp)3));
				}
			}
		}
	}
	template <class _Tp> _Tp __ellint_2(_Tp __k, _Tp __phi)
	{
		if (__isnan(__k) || __isnan(__phi)) {
			return std::template numeric_limits<_Tp>::quiet_NaN();
		} else {
			if (std::abs(__k) > ((_Tp)1)) {
				std::__throw_domain_error(
					"Bad argument in __ellint_2.");
			} else {
				const int __n = std::floor(
					(__phi /
					 __numeric_constants<_Tp>::__pi()) +
					((_Tp)(0.5L)));
				const _Tp __phi_red =
					__phi -
					(__n *
					 __numeric_constants<_Tp>::__pi());
				const _Tp __kk = __k * __k;
				const _Tp __s = std::sin(__phi_red);
				const _Tp __ss = __s * __s;
				const _Tp __sss = __ss * __s;
				const _Tp __c = std::cos(__phi_red);
				const _Tp __cc = __c * __c;
				const _Tp __E =
					(__s *
					 __ellint_rf(__cc,
						     ((_Tp)1) - (__kk * __ss),
						     (_Tp)1)) -
					(((__kk * __sss) *
					  __ellint_rd(__cc,
						      ((_Tp)1) - (__kk * __ss),
						      (_Tp)1)) /
					 ((_Tp)3));
				if (__n == 0) {
					return __E;
				} else {
					return __E + ((((_Tp)2) * __n) *
						      __comp_ellint_2(__k));
				}
			}
		}
	}
	template <class _Tp> _Tp __ellint_rc(_Tp __x, _Tp __y)
	{
		const _Tp __min = std::template numeric_limits<_Tp>::min();
		const _Tp __lolim = ((_Tp)5) * __min;
		if (((__x < ((_Tp)0)) || (__y < ((_Tp)0))) ||
		    ((__x + __y) < __lolim)) {
			std::__throw_domain_error(
				"Argument less than zero in __ellint_rc.");
		} else {
			const _Tp __c0 = (((_Tp)1) / ((_Tp)4));
			const _Tp __c1 = (((_Tp)1) / ((_Tp)7));
			const _Tp __c2 = (((_Tp)9) / ((_Tp)22));
			const _Tp __c3 = (((_Tp)3) / ((_Tp)10));
			const _Tp __c4 = (((_Tp)3) / ((_Tp)8));
			_Tp __xn = __x;
			_Tp __yn = __y;
			const _Tp __eps =
				std::template numeric_limits<_Tp>::epsilon();
			const _Tp __errtol = std::pow(__eps / ((_Tp)30),
						      ((_Tp)1) / ((_Tp)6));
			_Tp __mu;
			_Tp __sn;
			const unsigned __max_iter = (100);
			for (unsigned __iter = (0); __iter < __max_iter;
			     ++__iter) {
				__mu = ((__xn + (((_Tp)2) * __yn)) / ((_Tp)3));
				__sn = (((__yn + __mu) / __mu) - ((_Tp)2));
				if (std::abs(__sn) < __errtol) {
					break;
				}
				const _Tp __lambda =
					((((_Tp)2) * std::sqrt(__xn)) *
					 std::sqrt(__yn)) +
					__yn;
				__xn = (__c0 * (__xn + __lambda));
				__yn = (__c0 * (__yn + __lambda));
			}
			_Tp __s = (__sn * __sn) *
				  (__c3 +
				   (__sn *
				    (__c1 + (__sn * (__c4 + (__sn * __c2))))));
			return (((_Tp)1) + __s) / std::sqrt(__mu);
		}
	}
	template <class _Tp> _Tp __ellint_rj(_Tp __x, _Tp __y, _Tp __z, _Tp __p)
	{
		const _Tp __min = std::template numeric_limits<_Tp>::min();
		const _Tp __lolim =
			std::pow(((_Tp)5) * __min, ((_Tp)1) / ((_Tp)3));
		if (((__x < ((_Tp)0)) || (__y < ((_Tp)0))) ||
		    (__z < ((_Tp)0))) {
			std::__throw_domain_error(
				"Argument less than zero in __ellint_rj.");
		} else {
			if (((((__x + __y) < __lolim) ||
			      ((__x + __z) < __lolim)) ||
			     ((__y + __z) < __lolim)) ||
			    (__p < __lolim)) {
				std::__throw_domain_error(
					"Argument too small in __ellint_rj");
			} else {
				const _Tp __c0 = (((_Tp)1) / ((_Tp)4));
				const _Tp __c1 = (((_Tp)3) / ((_Tp)14));
				const _Tp __c2 = (((_Tp)1) / ((_Tp)3));
				const _Tp __c3 = (((_Tp)3) / ((_Tp)22));
				const _Tp __c4 = (((_Tp)3) / ((_Tp)26));
				_Tp __xn = __x;
				_Tp __yn = __y;
				_Tp __zn = __z;
				_Tp __pn = __p;
				_Tp __sigma = ((_Tp)0);
				_Tp __power4 = ((_Tp)1);
				const _Tp __eps = std::template numeric_limits<
					_Tp>::epsilon();
				const _Tp __errtol = std::pow(
					__eps / ((_Tp)8), ((_Tp)1) / ((_Tp)6));
				_Tp __mu;
				_Tp __xndev, __yndev, __zndev, __pndev;
				const unsigned __max_iter = (100);
				for (unsigned __iter = (0); __iter < __max_iter;
				     ++__iter) {
					__mu = ((((__xn + __yn) + __zn) +
						 (((_Tp)2) * __pn)) /
						((_Tp)5));
					__xndev = ((__mu - __xn) / __mu);
					__yndev = ((__mu - __yn) / __mu);
					__zndev = ((__mu - __zn) / __mu);
					__pndev = ((__mu - __pn) / __mu);
					_Tp __epsilon =
						std::max(std::abs(__xndev),
							 std::abs(__yndev));
					__epsilon = std::max(__epsilon,
							     std::abs(__zndev));
					__epsilon = std::max(__epsilon,
							     std::abs(__pndev));
					if (__epsilon < __errtol) {
						break;
					}
					const _Tp __xnroot = std::sqrt(__xn);
					const _Tp __ynroot = std::sqrt(__yn);
					const _Tp __znroot = std::sqrt(__zn);
					const _Tp __lambda =
						(__xnroot *
						 (__ynroot + __znroot)) +
						(__ynroot * __znroot);
					const _Tp __alpha1 =
						(__pn * ((__xnroot + __ynroot) +
							 __znroot)) +
						((__xnroot * __ynroot) *
						 __znroot);
					const _Tp __alpha2 =
						__alpha1 * __alpha1;
					const _Tp __beta =
						(__pn * (__pn + __lambda)) *
						(__pn + __lambda);
					__sigma +=
						(__power4 *
						 __ellint_rc(__alpha2, __beta));
					__power4 *= __c0;
					__xn = (__c0 * (__xn + __lambda));
					__yn = (__c0 * (__yn + __lambda));
					__zn = (__c0 * (__zn + __lambda));
					__pn = (__c0 * (__pn + __lambda));
				}
				_Tp __ea = (__xndev * (__yndev + __zndev)) +
					   (__yndev * __zndev);
				_Tp __eb = (__xndev * __yndev) * __zndev;
				_Tp __ec = __pndev * __pndev;
				_Tp __e2 = __ea - (((_Tp)3) * __ec);
				_Tp __e3 = __eb + ((((_Tp)2) * __pndev) *
						   (__ea - __ec));
				_Tp __s1 =
					((_Tp)1) +
					(__e2 * (((-__c1) +
						  (((((_Tp)3) * __c3) * __e2) /
						   ((_Tp)4))) -
						 (((((_Tp)3) * __c4) * __e3) /
						  ((_Tp)2))));
				_Tp __s2 =
					__eb * ((__c2 / ((_Tp)2)) +
						(__pndev * (((-__c3) - __c3) +
							    (__pndev * __c4))));
				_Tp __s3 = ((__pndev * __ea) *
					    (__c2 - (__pndev * __c3))) -
					   ((__c2 * __pndev) * __ec);
				return (((_Tp)3) * __sigma) +
				       ((__power4 * ((__s1 + __s2) + __s3)) /
					(__mu * std::sqrt(__mu)));
			}
		}
	}
	template <class _Tp> _Tp __comp_ellint_3(_Tp __k, _Tp __nu)
	{
		if (__isnan(__k) || __isnan(__nu)) {
			return std::template numeric_limits<_Tp>::quiet_NaN();
		} else {
			if (__nu == ((_Tp)1)) {
				return std::template numeric_limits<
					_Tp>::infinity();
			} else {
				if (std::abs(__k) > ((_Tp)1)) {
					std::__throw_domain_error(
						"Bad argument in __comp_ellint_3.");
				} else {
					const _Tp __kk = __k * __k;
					return __ellint_rf((_Tp)0,
							   ((_Tp)1) - __kk,
							   (_Tp)1) +
					       ((__nu *
						 __ellint_rj((_Tp)0,
							     ((_Tp)1) - __kk,
							     (_Tp)1,
							     ((_Tp)1) - __nu)) /
						((_Tp)3));
				}
			}
		}
	}
	template <class _Tp> _Tp __ellint_3(_Tp __k, _Tp __nu, _Tp __phi)
	{
		if ((__isnan(__k) || __isnan(__nu)) || __isnan(__phi)) {
			return std::template numeric_limits<_Tp>::quiet_NaN();
		} else {
			if (std::abs(__k) > ((_Tp)1)) {
				std::__throw_domain_error(
					"Bad argument in __ellint_3.");
			} else {
				const int __n = std::floor(
					(__phi /
					 __numeric_constants<_Tp>::__pi()) +
					((_Tp)(0.5L)));
				const _Tp __phi_red =
					__phi -
					(__n *
					 __numeric_constants<_Tp>::__pi());
				const _Tp __kk = __k * __k;
				const _Tp __s = std::sin(__phi_red);
				const _Tp __ss = __s * __s;
				const _Tp __sss = __ss * __s;
				const _Tp __c = std::cos(__phi_red);
				const _Tp __cc = __c * __c;
				const _Tp __Pi =
					(__s *
					 __ellint_rf(__cc,
						     ((_Tp)1) - (__kk * __ss),
						     (_Tp)1)) +
					(((__nu * __sss) *
					  __ellint_rj(__cc,
						      ((_Tp)1) - (__kk * __ss),
						      (_Tp)1,
						      ((_Tp)1) -
							      (__nu * __ss))) /
					 ((_Tp)3));
				if (__n == 0) {
					return __Pi;
				} else {
					return __Pi +
					       ((((_Tp)2) * __n) *
						__comp_ellint_3(__k, __nu));
				}
			}
		}
	}
	} // namespace __detail
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	namespace __detail
	{
	template <class _Tp> _Tp __expint_E1(_Tp);
	template <class _Tp> _Tp __expint_E1_series(_Tp __x)
	{
		const _Tp __eps = std::template numeric_limits<_Tp>::epsilon();
		_Tp __term = ((_Tp)1);
		_Tp __esum = ((_Tp)0);
		_Tp __osum = ((_Tp)0);
		const unsigned __max_iter = (1000);
		for (unsigned __i = (1); __i < __max_iter; ++__i) {
			__term *= ((-__x) / __i);
			if (std::abs(__term) < __eps) {
				break;
			}
			if (__term >= ((_Tp)0)) {
				__esum += (__term / __i);
			} else {
				__osum += (__term / __i);
			}
		}
		return (((-__esum) - __osum) -
			__numeric_constants<_Tp>::__gamma_e()) -
		       std::log(__x);
	}
	template <class _Tp> _Tp __expint_E1_asymp(_Tp __x)
	{
		_Tp __term = ((_Tp)1);
		_Tp __esum = ((_Tp)1);
		_Tp __osum = ((_Tp)0);
		const unsigned __max_iter = (1000);
		for (unsigned __i = (1); __i < __max_iter; ++__i) {
			_Tp __prev = __term;
			__term *= ((-__i) / __x);
			if (std::abs(__term) > std::abs(__prev)) {
				break;
			}
			if (__term >= ((_Tp)0)) {
				__esum += __term;
			} else {
				__osum += __term;
			}
		}
		return (std::exp(-__x) * (__esum + __osum)) / __x;
	}
	template <class _Tp> _Tp __expint_En_series(unsigned __n, _Tp __x)
	{
		const unsigned __max_iter = (1000);
		const _Tp __eps = std::template numeric_limits<_Tp>::epsilon();
		const int __nm1 = __n - (1);
		_Tp __ans = (__nm1 != 0) ?
				    ((_Tp)1) / __nm1 :
				    ((-std::log(__x)) -
				     __numeric_constants<_Tp>::__gamma_e());
		_Tp __fact = ((_Tp)1);
		for (int __i = 1; __i <= __max_iter; ++__i) {
			__fact *= ((-__x) / ((_Tp)__i));
			_Tp __del;
			if (__i != __nm1) {
				__del = ((-__fact) / ((_Tp)(__i - __nm1)));
			} else {
				_Tp __psi =
					(-__numeric_constants<_Tp>::gamma_e());
				for (int __ii = 1; __ii <= __nm1; ++__ii) {
					__psi += (((_Tp)1) / ((_Tp)__ii));
				}
				__del = (__fact * (__psi - std::log(__x)));
			}
			__ans += __del;
			if (std::abs(__del) < (__eps * std::abs(__ans))) {
				return __ans;
			}
		}
		std::__throw_runtime_error(
			"Series summation failed in __expint_En_series.");
	}
	template <class _Tp> _Tp __expint_En_cont_frac(unsigned __n, _Tp __x)
	{
		const unsigned __max_iter = (1000);
		const _Tp __eps = std::template numeric_limits<_Tp>::epsilon();
		const _Tp __fp_min = std::template numeric_limits<_Tp>::min();
		const int __nm1 = __n - (1);
		_Tp __b = __x + ((_Tp)__n);
		_Tp __c = ((_Tp)1) / __fp_min;
		_Tp __d = ((_Tp)1) / __b;
		_Tp __h = __d;
		for (unsigned __i = (1); __i <= __max_iter; ++__i) {
			_Tp __a = (-((_Tp)(__i * (__nm1 + __i))));
			__b += ((_Tp)2);
			__d = (((_Tp)1) / ((__a * __d) + __b));
			__c = (__b + (__a / __c));
			const _Tp __del = __c * __d;
			__h *= __del;
			if (std::abs(__del - ((_Tp)1)) < __eps) {
				const _Tp __ans = __h * std::exp(-__x);
				return __ans;
			}
		}
		std::__throw_runtime_error(
			"Continued fraction failed in __expint_En_cont_frac.");
	}
	template <class _Tp> _Tp __expint_En_recursion(unsigned __n, _Tp __x)
	{
		_Tp __En;
		_Tp __E1 = __expint_E1(__x);
		if (__x < ((_Tp)__n)) {
			__En = __E1;
			for (unsigned __j = (2); __j < __n; ++__j) {
				__En = ((std::exp(-__x) - (__x * __En)) /
					((_Tp)(__j - (1))));
			}
		} else {
			__En = ((_Tp)1);
			const int __N = __n + (20);
			_Tp __save = ((_Tp)0);
			for (int __j = __N; __j > 0; --__j) {
				__En = ((std::exp(-__x) - (__j * __En)) / __x);
				if (__j == __n) {
					__save = __En;
				}
			}
			_Tp __norm = __En / __E1;
			__En /= __norm;
		}
		return __En;
	}
	template <class _Tp> _Tp __expint_Ei_series(_Tp __x)
	{
		_Tp __term = ((_Tp)1);
		_Tp __sum = ((_Tp)0);
		const unsigned __max_iter = (1000);
		for (unsigned __i = (1); __i < __max_iter; ++__i) {
			__term *= (__x / __i);
			__sum += (__term / __i);
			if (__term <
			    (std::template numeric_limits<_Tp>::epsilon() *
			     __sum)) {
				break;
			}
		}
		return (__numeric_constants<_Tp>::__gamma_e() + __sum) +
		       std::log(__x);
	}
	template <class _Tp> _Tp __expint_Ei_asymp(_Tp __x)
	{
		_Tp __term = ((_Tp)1);
		_Tp __sum = ((_Tp)1);
		const unsigned __max_iter = (1000);
		for (unsigned __i = (1); __i < __max_iter; ++__i) {
			_Tp __prev = __term;
			__term *= (__i / __x);
			if (__term <
			    std::template numeric_limits<_Tp>::epsilon()) {
				break;
			}
			if (__term >= __prev) {
				break;
			}
			__sum += __term;
		}
		return (std::exp(__x) * __sum) / __x;
	}
	template <class _Tp> _Tp __expint_Ei(_Tp __x)
	{
		if (__x < ((_Tp)0)) {
			return -__expint_E1(-__x);
		} else {
			if (__x < (-std::log(std::template numeric_limits<
					     _Tp>::epsilon()))) {
				return __expint_Ei_series(__x);
			} else {
				return __expint_Ei_asymp(__x);
			}
		}
	}
	template <class _Tp> _Tp __expint_E1(_Tp __x)
	{
		if (__x < ((_Tp)0)) {
			return -__expint_Ei(-__x);
		} else {
			if (__x < ((_Tp)1)) {
				return __expint_E1_series(__x);
			} else {
				if (__x < ((_Tp)100)) {
					return __expint_En_cont_frac(1, __x);
				} else {
					return __expint_E1_asymp(__x);
				}
			}
		}
	}
	template <class _Tp> _Tp __expint_asymp(unsigned __n, _Tp __x)
	{
		_Tp __term = ((_Tp)1);
		_Tp __sum = ((_Tp)1);
		for (unsigned __i = (1); __i <= __n; ++__i) {
			_Tp __prev = __term;
			__term *= ((-((__n - __i) + (1))) / __x);
			if (std::abs(__term) > std::abs(__prev)) {
				break;
			}
			__sum += __term;
		}
		return (std::exp(-__x) * __sum) / __x;
	}
	template <class _Tp> _Tp __expint_large_n(unsigned __n, _Tp __x)
	{
		const _Tp __xpn = __x + __n;
		const _Tp __xpn2 = __xpn * __xpn;
		_Tp __term = ((_Tp)1);
		_Tp __sum = ((_Tp)1);
		for (unsigned __i = (1); __i <= __n; ++__i) {
			_Tp __prev = __term;
			__term *=
				((__n - (((2) * (__i - (1))) * __x)) / __xpn2);
			if (std::abs(__term) <
			    std::template numeric_limits<_Tp>::epsilon()) {
				break;
			}
			__sum += __term;
		}
		return (std::exp(-__x) * __sum) / __xpn;
	}
	template <class _Tp> _Tp __expint(unsigned __n, _Tp __x)
	{
		if (__isnan(__x)) {
			return std::template numeric_limits<_Tp>::quiet_NaN();
		} else {
			if ((__n <= (1)) && (__x == ((_Tp)0))) {
				return std::template numeric_limits<
					_Tp>::infinity();
			} else {
				_Tp __E0 = std::exp(__x) / __x;
				if (__n == (0)) {
					return __E0;
				}
				_Tp __E1 = __expint_E1(__x);
				if (__n == (1)) {
					return __E1;
				}
				if (__x == ((_Tp)0)) {
					return ((_Tp)1) /
					       (static_cast<_Tp>(__n - (1)));
				}
				_Tp __En = __expint_En_recursion(__n, __x);
				return __En;
			}
		}
	}
	template <class _Tp> inline _Tp __expint(_Tp __x)
	{
		if (__isnan(__x)) {
			return std::template numeric_limits<_Tp>::quiet_NaN();
		} else {
			return __expint_Ei(__x);
		}
	}
	} // namespace __detail
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	namespace __detail
	{
	template <class _Tp> _Tp __conf_hyperg_series(_Tp __a, _Tp __c, _Tp __x)
	{
		const _Tp __eps = std::template numeric_limits<_Tp>::epsilon();
		_Tp __term = ((_Tp)1);
		_Tp __Fac = ((_Tp)1);
		const unsigned __max_iter = (100000);
		unsigned __i;
		for (__i = (0); __i < __max_iter; ++__i) {
			__term *= (((__a + ((_Tp)__i)) * __x) /
				   ((__c + ((_Tp)__i)) * ((_Tp)((1) + __i))));
			if (std::abs(__term) < __eps) {
				break;
			}
			__Fac += __term;
		}
		if (__i == __max_iter) {
			std::__throw_runtime_error(
				"Series failed to converge in __conf_hyperg_series.");
		}
		return __Fac;
	}
	template <class _Tp> _Tp __conf_hyperg_luke(_Tp __a, _Tp __c, _Tp __xin)
	{
		const _Tp __big = std::pow(
			std::template numeric_limits<_Tp>::max(), (_Tp)(0.16L));
		const int __nmax = 20000;
		const _Tp __eps = std::template numeric_limits<_Tp>::epsilon();
		const _Tp __x = (-__xin);
		const _Tp __x3 = (__x * __x) * __x;
		const _Tp __t0 = __a / __c;
		const _Tp __t1 = (__a + ((_Tp)1)) / (((_Tp)2) * __c);
		const _Tp __t2 =
			(__a + ((_Tp)2)) / (((_Tp)2) * (__c + ((_Tp)1)));
		_Tp __F = ((_Tp)1);
		_Tp __prec;
		_Tp __Bnm3 = ((_Tp)1);
		_Tp __Bnm2 = ((_Tp)1) + (__t1 * __x);
		_Tp __Bnm1 =
			((_Tp)1) +
			((__t2 * __x) * (((_Tp)1) + ((__t1 / ((_Tp)3)) * __x)));
		_Tp __Anm3 = ((_Tp)1);
		_Tp __Anm2 = __Bnm2 - (__t0 * __x);
		_Tp __Anm1 =
			(__Bnm1 - ((__t0 * (((_Tp)1) + (__t2 * __x))) * __x)) +
			((((__t0 * __t1) * (__c / (__c + ((_Tp)1)))) * __x) *
			 __x);
		int __n = 3;
		while (1) {
			_Tp __npam1 = ((_Tp)(__n - 1)) + __a;
			_Tp __npcm1 = ((_Tp)(__n - 1)) + __c;
			_Tp __npam2 = ((_Tp)(__n - 2)) + __a;
			_Tp __npcm2 = ((_Tp)(__n - 2)) + __c;
			_Tp __tnm1 = (_Tp)((2 * __n) - 1);
			_Tp __tnm3 = (_Tp)((2 * __n) - 3);
			_Tp __tnm5 = (_Tp)((2 * __n) - 5);
			_Tp __F1 = (((_Tp)(__n - 2)) - __a) /
				   ((((_Tp)2) * __tnm3) * __npcm1);
			_Tp __F2 = ((((_Tp)__n) + __a) * __npam1) /
				   ((((((_Tp)4) * __tnm1) * __tnm3) * __npcm2) *
				    __npcm1);
			_Tp __F3 =
				(((-__npam2) * __npam1) *
				 (((_Tp)(__n - 2)) - __a)) /
				((((((((_Tp)8) * __tnm3) * __tnm3) * __tnm5) *
				   (((_Tp)(__n - 3)) + __c)) *
				  __npcm2) *
				 __npcm1);
			_Tp __E = ((-__npam1) * (((_Tp)(__n - 1)) - __c)) /
				  (((((_Tp)2) * __tnm3) * __npcm2) * __npcm1);
			_Tp __An = (((((_Tp)1) + (__F1 * __x)) * __Anm1) +
				    (((__E + (__F2 * __x)) * __x) * __Anm2)) +
				   ((__F3 * __x3) * __Anm3);
			_Tp __Bn = (((((_Tp)1) + (__F1 * __x)) * __Bnm1) +
				    (((__E + (__F2 * __x)) * __x) * __Bnm2)) +
				   ((__F3 * __x3) * __Bnm3);
			_Tp __r = __An / __Bn;
			__prec = std::abs((__F - __r) / __F);
			__F = __r;
			if ((__prec < __eps) || (__n > __nmax)) {
				break;
			}
			if ((std::abs(__An) > __big) ||
			    (std::abs(__Bn) > __big)) {
				__An /= __big;
				__Bn /= __big;
				__Anm1 /= __big;
				__Bnm1 /= __big;
				__Anm2 /= __big;
				__Bnm2 /= __big;
				__Anm3 /= __big;
				__Bnm3 /= __big;
			} else {
				if ((std::abs(__An) < (((_Tp)1) / __big)) ||
				    (std::abs(__Bn) < (((_Tp)1) / __big))) {
					__An *= __big;
					__Bn *= __big;
					__Anm1 *= __big;
					__Bnm1 *= __big;
					__Anm2 *= __big;
					__Bnm2 *= __big;
					__Anm3 *= __big;
					__Bnm3 *= __big;
				}
			}
			++__n;
			__Bnm3 = __Bnm2;
			__Bnm2 = __Bnm1;
			__Bnm1 = __Bn;
			__Anm3 = __Anm2;
			__Anm2 = __Anm1;
			__Anm1 = __An;
		}
		if (__n >= __nmax) {
			std::__throw_runtime_error(
				"Iteration failed to converge in __conf_hyperg_luke.");
		}
		return __F;
	}
	template <class _Tp> _Tp __conf_hyperg(_Tp __a, _Tp __c, _Tp __x)
	{
		const _Tp __c_nint = std::nearbyint(__c);
		if ((__isnan(__a) || __isnan(__c)) || __isnan(__x)) {
			return std::template numeric_limits<_Tp>::quiet_NaN();
		} else {
			if ((__c_nint == __c) && (__c_nint <= 0)) {
				return std::template numeric_limits<
					_Tp>::infinity();
			} else {
				if (__a == ((_Tp)0)) {
					return (_Tp)1;
				} else {
					if (__c == __a) {
						return std::exp(__x);
					} else {
						if (__x < ((_Tp)0)) {
							return __conf_hyperg_luke(
								__a, __c, __x);
						} else {
							return __conf_hyperg_series(
								__a, __c, __x);
						}
					}
				}
			}
		}
	}
	template <class _Tp>
	_Tp __hyperg_series(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
	{
		const _Tp __eps = std::template numeric_limits<_Tp>::epsilon();
		_Tp __term = ((_Tp)1);
		_Tp __Fabc = ((_Tp)1);
		const unsigned __max_iter = (100000);
		unsigned __i;
		for (__i = (0); __i < __max_iter; ++__i) {
			__term *= ((((__a + ((_Tp)__i)) * (__b + ((_Tp)__i))) *
				    __x) /
				   ((__c + ((_Tp)__i)) * ((_Tp)((1) + __i))));
			if (std::abs(__term) < __eps) {
				break;
			}
			__Fabc += __term;
		}
		if (__i == __max_iter) {
			std::__throw_runtime_error(
				"Series failed to converge in __hyperg_series.");
		}
		return __Fabc;
	}
	template <class _Tp>
	_Tp __hyperg_luke(_Tp __a, _Tp __b, _Tp __c, _Tp __xin)
	{
		const _Tp __big = std::pow(
			std::template numeric_limits<_Tp>::max(), (_Tp)(0.16L));
		const int __nmax = 20000;
		const _Tp __eps = std::template numeric_limits<_Tp>::epsilon();
		const _Tp __x = (-__xin);
		const _Tp __x3 = (__x * __x) * __x;
		const _Tp __t0 = (__a * __b) / __c;
		const _Tp __t1 = ((__a + ((_Tp)1)) * (__b + ((_Tp)1))) /
				 (((_Tp)2) * __c);
		const _Tp __t2 = ((__a + ((_Tp)2)) * (__b + ((_Tp)2))) /
				 (((_Tp)2) * (__c + ((_Tp)1)));
		_Tp __F = ((_Tp)1);
		_Tp __Bnm3 = ((_Tp)1);
		_Tp __Bnm2 = ((_Tp)1) + (__t1 * __x);
		_Tp __Bnm1 =
			((_Tp)1) +
			((__t2 * __x) * (((_Tp)1) + ((__t1 / ((_Tp)3)) * __x)));
		_Tp __Anm3 = ((_Tp)1);
		_Tp __Anm2 = __Bnm2 - (__t0 * __x);
		_Tp __Anm1 =
			(__Bnm1 - ((__t0 * (((_Tp)1) + (__t2 * __x))) * __x)) +
			((((__t0 * __t1) * (__c / (__c + ((_Tp)1)))) * __x) *
			 __x);
		int __n = 3;
		while (1) {
			const _Tp __npam1 = ((_Tp)(__n - 1)) + __a;
			const _Tp __npbm1 = ((_Tp)(__n - 1)) + __b;
			const _Tp __npcm1 = ((_Tp)(__n - 1)) + __c;
			const _Tp __npam2 = ((_Tp)(__n - 2)) + __a;
			const _Tp __npbm2 = ((_Tp)(__n - 2)) + __b;
			const _Tp __npcm2 = ((_Tp)(__n - 2)) + __c;
			const _Tp __tnm1 = (_Tp)((2 * __n) - 1);
			const _Tp __tnm3 = (_Tp)((2 * __n) - 3);
			const _Tp __tnm5 = (_Tp)((2 * __n) - 5);
			const _Tp __n2 = __n * __n;
			const _Tp __F1 = (((((((_Tp)3) * __n2) +
					     (((__a + __b) - ((_Tp)6)) * __n)) +
					    ((_Tp)2)) -
					   (__a * __b)) -
					  (((_Tp)2) * (__a + __b))) /
					 ((((_Tp)2) * __tnm3) * __npcm1);
			const _Tp __F2 =
				(((-((((((_Tp)3) * __n2) -
				       (((__a + __b) + ((_Tp)6)) * __n)) +
				      ((_Tp)2)) -
				     (__a * __b))) *
				  __npam1) *
				 __npbm1) /
				((((((_Tp)4) * __tnm1) * __tnm3) * __npcm2) *
				 __npcm1);
			const _Tp __F3 =
				(((((__npam2 * __npam1) * __npbm2) * __npbm1) *
				  (((_Tp)(__n - 2)) - __a)) *
				 (((_Tp)(__n - 2)) - __b)) /
				((((((((_Tp)8) * __tnm3) * __tnm3) * __tnm5) *
				   (((_Tp)(__n - 3)) + __c)) *
				  __npcm2) *
				 __npcm1);
			const _Tp __E =
				(((-__npam1) * __npbm1) *
				 (((_Tp)(__n - 1)) - __c)) /
				(((((_Tp)2) * __tnm3) * __npcm2) * __npcm1);
			_Tp __An = (((((_Tp)1) + (__F1 * __x)) * __Anm1) +
				    (((__E + (__F2 * __x)) * __x) * __Anm2)) +
				   ((__F3 * __x3) * __Anm3);
			_Tp __Bn = (((((_Tp)1) + (__F1 * __x)) * __Bnm1) +
				    (((__E + (__F2 * __x)) * __x) * __Bnm2)) +
				   ((__F3 * __x3) * __Bnm3);
			const _Tp __r = __An / __Bn;
			const _Tp __prec = std::abs((__F - __r) / __F);
			__F = __r;
			if ((__prec < __eps) || (__n > __nmax)) {
				break;
			}
			if ((std::abs(__An) > __big) ||
			    (std::abs(__Bn) > __big)) {
				__An /= __big;
				__Bn /= __big;
				__Anm1 /= __big;
				__Bnm1 /= __big;
				__Anm2 /= __big;
				__Bnm2 /= __big;
				__Anm3 /= __big;
				__Bnm3 /= __big;
			} else {
				if ((std::abs(__An) < (((_Tp)1) / __big)) ||
				    (std::abs(__Bn) < (((_Tp)1) / __big))) {
					__An *= __big;
					__Bn *= __big;
					__Anm1 *= __big;
					__Bnm1 *= __big;
					__Anm2 *= __big;
					__Bnm2 *= __big;
					__Anm3 *= __big;
					__Bnm3 *= __big;
				}
			}
			++__n;
			__Bnm3 = __Bnm2;
			__Bnm2 = __Bnm1;
			__Bnm1 = __Bn;
			__Anm3 = __Anm2;
			__Anm2 = __Anm1;
			__Anm1 = __An;
		}
		if (__n >= __nmax) {
			std::__throw_runtime_error(
				"Iteration failed to converge in __hyperg_luke.");
		}
		return __F;
	}
	template <class _Tp>
	_Tp __hyperg_reflect(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
	{
		const _Tp __d = (__c - __a) - __b;
		const int __intd = std::floor(__d + ((_Tp)(0.5L)));
		const _Tp __eps = std::template numeric_limits<_Tp>::epsilon();
		const _Tp __toler = ((_Tp)1000) * __eps;
		const _Tp __log_max =
			std::log(std::template numeric_limits<_Tp>::max());
		const bool __d_integer = std::abs(__d - __intd) < __toler;
		if (__d_integer) {
			const _Tp __ln_omx = std::log(((_Tp)1) - __x);
			const _Tp __ad = std::abs(__d);
			_Tp __F1, __F2;
			_Tp __d1, __d2;
			if (__d >= ((_Tp)0)) {
				__d1 = __d;
				__d2 = ((_Tp)0);
			} else {
				__d1 = ((_Tp)0);
				__d2 = __d;
			}
			const _Tp __lng_c = __log_gamma(__c);
			if (__ad < __eps) {
				__F1 = ((_Tp)0);
			} else {
				bool __ok_d1 = true;
				_Tp __lng_ad, __lng_ad1, __lng_bd1;
				try {
					__lng_ad = __log_gamma(__ad);
					__lng_ad1 = __log_gamma(__a + __d1);
					__lng_bd1 = __log_gamma(__b + __d1);
				} catch (...) {
					__ok_d1 = false;
				}
				if (__ok_d1) {
					_Tp __sum1 = ((_Tp)1);
					_Tp __term = ((_Tp)1);
					_Tp __ln_pre1 = (((__lng_ad + __lng_c) +
							  (__d2 * __ln_omx)) -
							 __lng_ad1) -
							__lng_bd1;
					for (int __i = 1; __i < __ad; ++__i) {
						const int __j = __i - 1;
						__term *=
							((((((__a + __d2) +
							     __j) *
							    ((__b + __d2) +
							     __j)) /
							   ((((_Tp)1) + __d2) +
							    __j)) /
							  __i) *
							 (((_Tp)1) - __x));
						__sum1 += __term;
					}
					if (__ln_pre1 > __log_max) {
						std::__throw_runtime_error(
							"Overflow of gamma functions in __hyperg_luke.");
					} else {
						__F1 = (std::exp(__ln_pre1) *
							__sum1);
					}
				} else {
					__F1 = ((_Tp)0);
				}
			}
			bool __ok_d2 = true;
			_Tp __lng_ad2, __lng_bd2;
			try {
				__lng_ad2 = __log_gamma(__a + __d2);
				__lng_bd2 = __log_gamma(__b + __d2);
			} catch (...) {
				__ok_d2 = false;
			}
			if (__ok_d2) {
				const int __maxiter = 2000;
				const _Tp __psi_1 =
					(-__numeric_constants<_Tp>::__gamma_e());
				const _Tp __psi_1pd = __psi(((_Tp)1) + __ad);
				const _Tp __psi_apd1 = __psi(__a + __d1);
				const _Tp __psi_bpd1 = __psi(__b + __d1);
				_Tp __psi_term =
					(((__psi_1 + __psi_1pd) - __psi_apd1) -
					 __psi_bpd1) -
					__ln_omx;
				_Tp __fact = ((_Tp)1);
				_Tp __sum2 = __psi_term;
				_Tp __ln_pre2 = ((__lng_c + (__d1 * __ln_omx)) -
						 __lng_ad2) -
						__lng_bd2;
				int __j;
				for (__j = 1; __j < __maxiter; ++__j) {
					const _Tp __term1 =
						(((_Tp)1) / ((_Tp)__j)) +
						(((_Tp)1) / (__ad + __j));
					const _Tp __term2 =
						(((_Tp)1) /
						 ((__a + __d1) +
						  ((_Tp)(__j - 1)))) +
						(((_Tp)1) / ((__b + __d1) +
							     ((_Tp)(__j - 1))));
					__psi_term += (__term1 - __term2);
					__fact *= (((((__a + __d1) +
						      ((_Tp)(__j - 1))) *
						     ((__b + __d1) +
						      ((_Tp)(__j - 1)))) /
						    ((__ad + __j) * __j)) *
						   (((_Tp)1) - __x));
					const _Tp __delta = __fact * __psi_term;
					__sum2 += __delta;
					if (std::abs(__delta) <
					    (__eps * std::abs(__sum2))) {
						break;
					}
				}
				if (__j == __maxiter) {
					std::__throw_runtime_error(
						"Sum F2 failed to converge in __hyperg_reflect");
				}
				if (__sum2 == ((_Tp)0)) {
					__F2 = ((_Tp)0);
				} else {
					__F2 = (std::exp(__ln_pre2) * __sum2);
				}
			} else {
				__F2 = ((_Tp)0);
			}
			const _Tp __sgn_2 =
				(((__intd % 2) == 1) ? -((_Tp)1) : ((_Tp)1));
			const _Tp __F = __F1 + (__sgn_2 * __F2);
			return __F;
		} else {
			bool __ok1 = true;
			_Tp __sgn_g1ca = ((_Tp)0), __ln_g1ca = ((_Tp)0);
			_Tp __sgn_g1cb = ((_Tp)0), __ln_g1cb = ((_Tp)0);
			try {
				__sgn_g1ca = __log_gamma_sign(__c - __a);
				__ln_g1ca = __log_gamma(__c - __a);
				__sgn_g1cb = __log_gamma_sign(__c - __b);
				__ln_g1cb = __log_gamma(__c - __b);
			} catch (...) {
				__ok1 = false;
			}
			bool __ok2 = true;
			_Tp __sgn_g2a = ((_Tp)0), __ln_g2a = ((_Tp)0);
			_Tp __sgn_g2b = ((_Tp)0), __ln_g2b = ((_Tp)0);
			try {
				__sgn_g2a = __log_gamma_sign(__a);
				__ln_g2a = __log_gamma(__a);
				__sgn_g2b = __log_gamma_sign(__b);
				__ln_g2b = __log_gamma(__b);
			} catch (...) {
				__ok2 = false;
			}
			const _Tp __sgn_gc = __log_gamma_sign(__c);
			const _Tp __ln_gc = __log_gamma(__c);
			const _Tp __sgn_gd = __log_gamma_sign(__d);
			const _Tp __ln_gd = __log_gamma(__d);
			const _Tp __sgn_gmd = __log_gamma_sign(-__d);
			const _Tp __ln_gmd = __log_gamma(-__d);
			const _Tp __sgn1 =
				((__sgn_gc * __sgn_gd) * __sgn_g1ca) *
				__sgn_g1cb;
			const _Tp __sgn2 =
				((__sgn_gc * __sgn_gmd) * __sgn_g2a) *
				__sgn_g2b;
			_Tp __pre1, __pre2;
			if (__ok1 && __ok2) {
				_Tp __ln_pre1 =
					((__ln_gc + __ln_gd) - __ln_g1ca) -
					__ln_g1cb;
				_Tp __ln_pre2 =
					(((__ln_gc + __ln_gmd) - __ln_g2a) -
					 __ln_g2b) +
					(__d * std::log(((_Tp)1) - __x));
				if ((__ln_pre1 < __log_max) &&
				    (__ln_pre2 < __log_max)) {
					__pre1 = std::exp(__ln_pre1);
					__pre2 = std::exp(__ln_pre2);
					__pre1 *= __sgn1;
					__pre2 *= __sgn2;
				} else {
					std::__throw_runtime_error(
						"Overflow of gamma functions in __hyperg_reflect");
				}
			} else {
				if (__ok1 && (!__ok2)) {
					_Tp __ln_pre1 = ((__ln_gc + __ln_gd) -
							 __ln_g1ca) -
							__ln_g1cb;
					if (__ln_pre1 < __log_max) {
						__pre1 = std::exp(__ln_pre1);
						__pre1 *= __sgn1;
						__pre2 = ((_Tp)0);
					} else {
						std::__throw_runtime_error(
							"Overflow of gamma functions in __hyperg_reflect");
					}
				} else {
					if ((!__ok1) && __ok2) {
						_Tp __ln_pre2 =
							(((__ln_gc + __ln_gmd) -
							  __ln_g2a) -
							 __ln_g2b) +
							(__d *
							 std::log(((_Tp)1) -
								  __x));
						if (__ln_pre2 < __log_max) {
							__pre1 = ((_Tp)0);
							__pre2 = std::exp(
								__ln_pre2);
							__pre2 *= __sgn2;
						} else {
							std::__throw_runtime_error(
								"Overflow of gamma functions in __hyperg_reflect");
						}
					} else {
						__pre1 = ((_Tp)0);
						__pre2 = ((_Tp)0);
						std::__throw_runtime_error(
							"Underflow of gamma functions in __hyperg_reflect");
					}
				}
			}
			const _Tp __F1 = __hyperg_series(
				__a, __b, ((_Tp)1) - __d, ((_Tp)1) - __x);
			const _Tp __F2 =
				__hyperg_series(__c - __a, __c - __b,
						((_Tp)1) + __d, ((_Tp)1) - __x);
			const _Tp __F = (__pre1 * __F1) + (__pre2 * __F2);
			return __F;
		}
	}
	template <class _Tp> _Tp __hyperg(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
	{
		const _Tp __a_nint = std::nearbyint(__a);
		const _Tp __b_nint = std::nearbyint(__b);
		const _Tp __c_nint = std::nearbyint(__c);
		const _Tp __toler =
			((_Tp)1000) *
			std::template numeric_limits<_Tp>::epsilon();
		if (std::abs(__x) >= ((_Tp)1)) {
			std::__throw_domain_error(
				"Argument outside unit circle in __hyperg.");
		} else {
			if (((__isnan(__a) || __isnan(__b)) || __isnan(__c)) ||
			    __isnan(__x)) {
				return std::template numeric_limits<
					_Tp>::quiet_NaN();
			} else {
				if ((__c_nint == __c) &&
				    (__c_nint <= ((_Tp)0))) {
					return std::template numeric_limits<
						_Tp>::infinity();
				} else {
					if ((std::abs(__c - __b) < __toler) ||
					    (std::abs(__c - __a) < __toler)) {
						return std::pow(((_Tp)1) - __x,
								(__c - __a) -
									__b);
					} else {
						if ((__a >= ((_Tp)0)) &&
						    (__b >= ((_Tp)0)) &&
						    (__c >= ((_Tp)0)) &&
						    (__x >= ((_Tp)0)) &&
						    (__x < ((_Tp)(0.995L)))) {
							return __hyperg_series(
								__a, __b, __c,
								__x);
						} else {
							if ((std::abs(__a) <
							     ((_Tp)10)) &&
							    (std::abs(__b) <
							     ((_Tp)10))) {
								if ((__a <
								     ((_Tp)0)) &&
								    (std::abs(
									     __a -
									     __a_nint) <
								     __toler)) {
									return __hyperg_series(
										__a_nint,
										__b,
										__c,
										__x);
								} else {
									if ((__b <
									     ((_Tp)0)) &&
									    (std::abs(
										     __b -
										     __b_nint) <
									     __toler)) {
										return __hyperg_series(
											__a,
											__b_nint,
											__c,
											__x);
									} else {
										if (__x <
										    (-((_Tp)(0.25L)))) {
											return __hyperg_luke(
												__a,
												__b,
												__c,
												__x);
										} else {
											if (__x <
											    ((_Tp)(0.5L))) {
												return __hyperg_series(
													__a,
													__b,
													__c,
													__x);
											} else {
												if (std::abs(
													    __c) >
												    ((_Tp)10)) {
													return __hyperg_series(
														__a,
														__b,
														__c,
														__x);
												} else {
													return __hyperg_reflect(
														__a,
														__b,
														__c,
														__x);
												}
											}
										}
									}
								}
							} else {
								return __hyperg_luke(
									__a,
									__b,
									__c,
									__x);
							}
						}
					}
				}
			}
		}
	}
	} // namespace __detail
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	namespace __detail
	{
	template <class _Tp> _Tp __poly_legendre_p(unsigned __l, _Tp __x)
	{
		if (__isnan(__x)) {
			return std::template numeric_limits<_Tp>::quiet_NaN();
		} else {
			if (__x == (+((_Tp)1))) {
				return +((_Tp)1);
			} else {
				if (__x == (-((_Tp)1))) {
					return (((__l % (2)) == (1)) ?
							-((_Tp)1) :
							(+((_Tp)1)));
				} else {
					_Tp __p_lm2 = ((_Tp)1);
					if (__l == (0)) {
						return __p_lm2;
					}
					_Tp __p_lm1 = __x;
					if (__l == (1)) {
						return __p_lm1;
					}
					_Tp __p_l = (0);
					for (unsigned __ll = (2); __ll <= __l;
					     ++__ll) {
						__p_l = ((((((_Tp)2) * __x) *
							   __p_lm1) -
							  __p_lm2) -
							 (((__x * __p_lm1) -
							   __p_lm2) /
							  ((_Tp)__ll)));
						__p_lm2 = __p_lm1;
						__p_lm1 = __p_l;
					}
					return __p_l;
				}
			}
		}
	}
	template <class _Tp>
	_Tp __assoc_legendre_p(unsigned __l, unsigned __m, _Tp __x,
			       _Tp __phase = (_Tp)(+1))
	{
		if (__m > __l) {
			return (_Tp)0;
		} else {
			if (__isnan(__x)) {
				return std::template numeric_limits<
					_Tp>::quiet_NaN();
			} else {
				if (__m == (0)) {
					return __poly_legendre_p(__l, __x);
				} else {
					_Tp __p_mm = ((_Tp)1);
					if (__m > (0)) {
						_Tp __root =
							std::sqrt(((_Tp)1) -
								  __x) *
							std::sqrt(((_Tp)1) +
								  __x);
						_Tp __fact = ((_Tp)1);
						for (unsigned __i = (1);
						     __i <= __m; ++__i) {
							__p_mm *= ((__phase *
								    __fact) *
								   __root);
							__fact += ((_Tp)2);
						}
					}
					if (__l == __m) {
						return __p_mm;
					}
					_Tp __p_mp1m =
						(((_Tp)(((2) * __m) + (1))) *
						 __x) *
						__p_mm;
					if (__l == (__m + (1))) {
						return __p_mp1m;
					}
					_Tp __p_lm2m = __p_mm;
					_Tp __P_lm1m = __p_mp1m;
					_Tp __p_lm = ((_Tp)0);
					for (unsigned __j = __m + (2);
					     __j <= __l; ++__j) {
						__p_lm =
							((((((_Tp)(((2) * __j) -
								   (1))) *
							    __x) *
							   __P_lm1m) -
							  (((_Tp)((__j + __m) -
								  (1))) *
							   __p_lm2m)) /
							 ((_Tp)(__j - __m)));
						__p_lm2m = __P_lm1m;
						__P_lm1m = __p_lm;
					}
					return __p_lm;
				}
			}
		}
	}
	template <class _Tp>
	_Tp __sph_legendre(unsigned __l, unsigned __m, _Tp __theta)
	{
		if (__isnan(__theta)) {
			return std::template numeric_limits<_Tp>::quiet_NaN();
		}
		const _Tp __x = std::cos(__theta);
		if (__m > __l) {
			return (_Tp)0;
		} else {
			if (__m == (0)) {
				_Tp __P = __poly_legendre_p(__l, __x);
				_Tp __fact = std::sqrt(
					((_Tp)(((2) * __l) + (1))) /
					(((_Tp)4) *
					 __numeric_constants<_Tp>::__pi()));
				__P *= __fact;
				return __P;
			} else {
				if ((__x == ((_Tp)1)) || (__x == (-((_Tp)1)))) {
					return (_Tp)0;
				} else {
					const _Tp __sgn = ((__m % (2)) == (1)) ?
								  -((_Tp)1) :
								  ((_Tp)1);
					const _Tp __y_mp1m_factor =
						__x *
						std::sqrt((_Tp)(((2) * __m) +
								(3)));
					const _Tp __lncirc =
						std::log1p((-__x) * __x);
					const _Tp __lnpoch =
						std::lgamma(
							(_Tp)(__m +
							      ((_Tp)(0.5L)))) -
						std::lgamma((_Tp)__m);
					const _Tp __lnpre_val =
						((-((_Tp)(0.25L))) *
						 __numeric_constants<
							 _Tp>::__lnpi()) +
						(((_Tp)(0.5L)) *
						 (__lnpoch + (__m * __lncirc)));
					const _Tp __sr = std::sqrt(
						(((_Tp)2) + (((_Tp)1) / __m)) /
						(((_Tp)4) *
						 __numeric_constants<
							 _Tp>::__pi()));
					_Tp __y_mm = (__sgn * __sr) *
						     std::exp(__lnpre_val);
					_Tp __y_mp1m = __y_mp1m_factor * __y_mm;
					if (__l == __m) {
						return __y_mm;
					} else {
						if (__l == (__m + (1))) {
							return __y_mp1m;
						} else {
							_Tp __y_lm = ((_Tp)0);
							for (unsigned __ll =
								     __m + (2);
							     __ll <= __l;
							     ++__ll) {
								const _Tp __rat1 =
									((_Tp)(__ll -
									       __m)) /
									((_Tp)(__ll +
									       __m));
								const _Tp __rat2 =
									((_Tp)((__ll -
										__m) -
									       (1))) /
									((_Tp)((__ll +
										__m) -
									       (1)));
								const _Tp __fact1 = std::sqrt(
									(__rat1 *
									 ((_Tp)(((2) *
										 __ll) +
										(1)))) *
									((_Tp)(((2) *
										__ll) -
									       (1))));
								const _Tp __fact2 = std::sqrt(
									((__rat1 *
									  __rat2) *
									 ((_Tp)(((2) *
										 __ll) +
										(1)))) /
									((_Tp)(((2) *
										__ll) -
									       (3))));
								__y_lm =
									((((__x *
									    __y_mp1m) *
									   __fact1) -
									  ((((__ll +
									      __m) -
									     (1)) *
									    __y_mm) *
									   __fact2)) /
									 ((_Tp)(__ll -
										__m)));
								__y_mm =
									__y_mp1m;
								__y_mp1m =
									__y_lm;
							}
							return __y_lm;
						}
					}
				}
			}
		}
	}
	} // namespace __detail
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	namespace __detail
	{
	template <class _Tp>
	void __bessel_ik(_Tp __nu, _Tp __x, _Tp &__Inu, _Tp &__Knu, _Tp &__Ipnu,
			 _Tp &__Kpnu)
	{
		if (__x == ((_Tp)0)) {
			if (__nu == ((_Tp)0)) {
				__Inu = ((_Tp)1);
				__Ipnu = ((_Tp)0);
			} else {
				if (__nu == ((_Tp)1)) {
					__Inu = ((_Tp)0);
					__Ipnu = ((_Tp)(0.5L));
				} else {
					__Inu = ((_Tp)0);
					__Ipnu = ((_Tp)0);
				}
			}
			__Knu = std::template numeric_limits<_Tp>::infinity();
			__Kpnu =
				(-std::template numeric_limits<_Tp>::infinity());
			return;
		}
		const _Tp __eps = std::template numeric_limits<_Tp>::epsilon();
		const _Tp __fp_min =
			((_Tp)10) *
			std::template numeric_limits<_Tp>::epsilon();
		const int __max_iter = 15000;
		const _Tp __x_min = ((_Tp)2);
		const int __nl = static_cast<int>(__nu + ((_Tp)(0.5L)));
		const _Tp __mu = __nu - __nl;
		const _Tp __mu2 = __mu * __mu;
		const _Tp __xi = ((_Tp)1) / __x;
		const _Tp __xi2 = ((_Tp)2) * __xi;
		_Tp __h = __nu * __xi;
		if (__h < __fp_min) {
			__h = __fp_min;
		}
		_Tp __b = __xi2 * __nu;
		_Tp __d = ((_Tp)0);
		_Tp __c = __h;
		int __i;
		for (__i = 1; __i <= __max_iter; ++__i) {
			__b += __xi2;
			__d = (((_Tp)1) / (__b + __d));
			__c = (__b + (((_Tp)1) / __c));
			const _Tp __del = __c * __d;
			__h *= __del;
			if (std::abs(__del - ((_Tp)1)) < __eps) {
				break;
			}
		}
		if (__i > __max_iter) {
			std::__throw_runtime_error(
				"Argument x too large in __bessel_ik; try asymptotic expansion.");
		}
		_Tp __Inul = __fp_min;
		_Tp __Ipnul = __h * __Inul;
		_Tp __Inul1 = __Inul;
		_Tp __Ipnu1 = __Ipnul;
		_Tp __fact = __nu * __xi;
		for (int __l = __nl; __l >= 1; --__l) {
			const _Tp __Inutemp = (__fact * __Inul) + __Ipnul;
			__fact -= __xi;
			__Ipnul = ((__fact * __Inutemp) + __Inul);
			__Inul = __Inutemp;
		}
		_Tp __f = __Ipnul / __Inul;
		_Tp __Kmu, __Knu1;
		if (__x < __x_min) {
			const _Tp __x2 = __x / ((_Tp)2);
			const _Tp __pimu =
				__numeric_constants<_Tp>::__pi() * __mu;
			const _Tp __fact = (std::abs(__pimu) < __eps) ?
						   (_Tp)1 :
						   (__pimu / std::sin(__pimu));
			_Tp __d = (-std::log(__x2));
			_Tp __e = __mu * __d;
			const _Tp __fact2 = (std::abs(__e) < __eps) ?
						    (_Tp)1 :
						    (std::sinh(__e) / __e);
			_Tp __gam1, __gam2, __gampl, __gammi;
			__gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
			_Tp __ff = __fact * ((__gam1 * std::cosh(__e)) +
					     ((__gam2 * __fact2) * __d));
			_Tp __sum = __ff;
			__e = std::exp(__e);
			_Tp __p = __e / (((_Tp)2) * __gampl);
			_Tp __q = ((_Tp)1) / ((((_Tp)2) * __e) * __gammi);
			_Tp __c = ((_Tp)1);
			__d = (__x2 * __x2);
			_Tp __sum1 = __p;
			int __i;
			for (__i = 1; __i <= __max_iter; ++__i) {
				__ff = ((((__i * __ff) + __p) + __q) /
					((__i * __i) - __mu2));
				__c *= (__d / __i);
				__p /= (__i - __mu);
				__q /= (__i + __mu);
				const _Tp __del = __c * __ff;
				__sum += __del;
				const _Tp __del1 = __c * (__p - (__i * __ff));
				__sum1 += __del1;
				if (std::abs(__del) <
				    (__eps * std::abs(__sum))) {
					break;
				}
			}
			if (__i > __max_iter) {
				std::__throw_runtime_error(
					"Bessel k series failed to converge in __bessel_ik.");
			}
			__Kmu = __sum;
			__Knu1 = (__sum1 * __xi2);
		} else {
			_Tp __b = ((_Tp)2) * (((_Tp)1) + __x);
			_Tp __d = ((_Tp)1) / __b;
			_Tp __delh = __d;
			_Tp __h = __delh;
			_Tp __q1 = ((_Tp)0);
			_Tp __q2 = ((_Tp)1);
			_Tp __a1 = ((_Tp)(0.25L)) - __mu2;
			_Tp __q = __c = __a1;
			_Tp __a = (-__a1);
			_Tp __s = ((_Tp)1) + (__q * __delh);
			int __i;
			for (__i = 2; __i <= __max_iter; ++__i) {
				__a -= (2 * (__i - 1));
				__c = (((-__a) * __c) / __i);
				const _Tp __qnew = (__q1 - (__b * __q2)) / __a;
				__q1 = __q2;
				__q2 = __qnew;
				__q += (__c * __qnew);
				__b += ((_Tp)2);
				__d = (((_Tp)1) / (__b + (__a * __d)));
				__delh = (((__b * __d) - ((_Tp)1)) * __delh);
				__h += __delh;
				const _Tp __dels = __q * __delh;
				__s += __dels;
				if (std::abs(__dels / __s) < __eps) {
					break;
				}
			}
			if (__i > __max_iter) {
				std::__throw_runtime_error(
					"Steed\'s method failed in __bessel_ik.");
			}
			__h = (__a1 * __h);
			__Kmu = ((std::sqrt(__numeric_constants<_Tp>::__pi() /
					    (((_Tp)2) * __x)) *
				  std::exp(-__x)) /
				 __s);
			__Knu1 = ((__Kmu *
				   (((__mu + __x) + ((_Tp)(0.5L))) - __h)) *
				  __xi);
		}
		_Tp __Kpmu = ((__mu * __xi) * __Kmu) - __Knu1;
		_Tp __Inumu = __xi / ((__f * __Kmu) - __Kpmu);
		__Inu = ((__Inumu * __Inul1) / __Inul);
		__Ipnu = ((__Inumu * __Ipnu1) / __Inul);
		for (__i = 1; __i <= __nl; ++__i) {
			const _Tp __Knutemp =
				(((__mu + __i) * __xi2) * __Knu1) + __Kmu;
			__Kmu = __Knu1;
			__Knu1 = __Knutemp;
		}
		__Knu = __Kmu;
		__Kpnu = (((__nu * __xi) * __Kmu) - __Knu1);
	}
	template <class _Tp> _Tp __cyl_bessel_i(_Tp __nu, _Tp __x)
	{
		if ((__nu < ((_Tp)0)) || (__x < ((_Tp)0))) {
			std::__throw_domain_error(
				"Bad argument in __cyl_bessel_i.");
		} else {
			if (__isnan(__nu) || __isnan(__x)) {
				return std::template numeric_limits<
					_Tp>::quiet_NaN();
			} else {
				if ((__x * __x) <
				    (((_Tp)10) * (__nu + ((_Tp)1)))) {
					return __cyl_bessel_ij_series(
						__nu, __x, +((_Tp)1), 200);
				} else {
					_Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
					__bessel_ik(__nu, __x, __I_nu, __K_nu,
						    __Ip_nu, __Kp_nu);
					return __I_nu;
				}
			}
		}
	}
	template <class _Tp> _Tp __cyl_bessel_k(_Tp __nu, _Tp __x)
	{
		if ((__nu < ((_Tp)0)) || (__x < ((_Tp)0))) {
			std::__throw_domain_error(
				"Bad argument in __cyl_bessel_k.");
		} else {
			if (__isnan(__nu) || __isnan(__x)) {
				return std::template numeric_limits<
					_Tp>::quiet_NaN();
			} else {
				_Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
				__bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu,
					    __Kp_nu);
				return __K_nu;
			}
		}
	}
	template <class _Tp>
	void __sph_bessel_ik(unsigned __n, _Tp __x, _Tp &__i_n, _Tp &__k_n,
			     _Tp &__ip_n, _Tp &__kp_n)
	{
		const _Tp __nu = ((_Tp)__n) + ((_Tp)(0.5L));
		_Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;
		__bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
		const _Tp __factor =
			__numeric_constants<_Tp>::__sqrtpio2() / std::sqrt(__x);
		__i_n = (__factor * __I_nu);
		__k_n = (__factor * __K_nu);
		__ip_n = ((__factor * __Ip_nu) - (__i_n / (((_Tp)2) * __x)));
		__kp_n = ((__factor * __Kp_nu) - (__k_n / (((_Tp)2) * __x)));
	}
	template <class _Tp>
	void __airy(_Tp __x, _Tp &__Ai, _Tp &__Bi, _Tp &__Aip, _Tp &__Bip)
	{
		const _Tp __absx = std::abs(__x);
		const _Tp __rootx = std::sqrt(__absx);
		const _Tp __z = ((((_Tp)2) * __absx) * __rootx) / ((_Tp)3);
		const _Tp _S_inf =
			std::template numeric_limits<_Tp>::infinity();
		if (__isnan(__x)) {
			__Bip = (__Aip = (__Bi = (__Ai = std::template numeric_limits<
							  _Tp>::quiet_NaN())));
		} else {
			if (__z == _S_inf) {
				__Aip = (__Ai = ((_Tp)0));
				__Bip = (__Bi = _S_inf);
			} else {
				if (__z == (-_S_inf)) {
					__Bip = (__Aip = (__Bi = (__Ai = ((
									  _Tp)0))));
				} else {
					if (__x > ((_Tp)0)) {
						_Tp __I_nu, __Ip_nu, __K_nu,
							__Kp_nu;
						__bessel_ik(((_Tp)1) / ((_Tp)3),
							    __z, __I_nu, __K_nu,
							    __Ip_nu, __Kp_nu);
						__Ai = ((__rootx * __K_nu) /
							(__numeric_constants<
								 _Tp>::__sqrt3() *
							 __numeric_constants<
								 _Tp>::__pi()));
						__Bi = (__rootx *
							((__K_nu /
							  __numeric_constants<
								  _Tp>::__pi()) +
							 ((((_Tp)2) * __I_nu) /
							  __numeric_constants<
								  _Tp>::
								  __sqrt3())));
						__bessel_ik(((_Tp)2) / ((_Tp)3),
							    __z, __I_nu, __K_nu,
							    __Ip_nu, __Kp_nu);
						__Aip = (((-__x) * __K_nu) /
							 (__numeric_constants<
								  _Tp>::__sqrt3() *
							  __numeric_constants<
								  _Tp>::__pi()));
						__Bip = (__x *
							 ((__K_nu /
							   __numeric_constants<
								   _Tp>::__pi()) +
							  ((((_Tp)2) * __I_nu) /
							   __numeric_constants<
								   _Tp>::
								   __sqrt3())));
					} else {
						if (__x < ((_Tp)0)) {
							_Tp __J_nu, __Jp_nu,
								__N_nu, __Np_nu;
							__bessel_jn(
								((_Tp)1) /
									((_Tp)3),
								__z, __J_nu,
								__N_nu, __Jp_nu,
								__Np_nu);
							__Ai = ((__rootx *
								 (__J_nu -
								  (__N_nu /
								   __numeric_constants<
									   _Tp>::
									   __sqrt3()))) /
								((_Tp)2));
							__Bi = (((-__rootx) *
								 (__N_nu +
								  (__J_nu /
								   __numeric_constants<
									   _Tp>::
									   __sqrt3()))) /
								((_Tp)2));
							__bessel_jn(
								((_Tp)2) /
									((_Tp)3),
								__z, __J_nu,
								__N_nu, __Jp_nu,
								__Np_nu);
							__Aip = ((__absx *
								  ((__N_nu /
								    __numeric_constants<
									    _Tp>::
									    __sqrt3()) +
								   __J_nu)) /
								 ((_Tp)2));
							__Bip = ((__absx *
								  ((__J_nu /
								    __numeric_constants<
									    _Tp>::
									    __sqrt3()) -
								   __N_nu)) /
								 ((_Tp)2));
						} else {
							__Ai = ((
								_Tp)(0.35502805388781723926L));
							__Bi = (__Ai *
								__numeric_constants<
									_Tp>::
									__sqrt3());
							__Aip = (-((
								_Tp)(0.2588194037928067984L)));
							__Bip = ((-__Aip) *
								 __numeric_constants<
									 _Tp>::
									 __sqrt3());
						}
					}
				}
			}
		}
	}
	} // namespace __detail
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	namespace __detail
	{
	template <class _Tp> _Tp __poly_hermite_recursion(unsigned __n, _Tp __x)
	{
		_Tp __H_0 = (1);
		if (__n == (0)) {
			return __H_0;
		}
		_Tp __H_1 = 2 * __x;
		if (__n == (1)) {
			return __H_1;
		}
		_Tp __H_n, __H_nm1, __H_nm2;
		unsigned __i;
		for (((__H_nm2 = __H_0), (__H_nm1 = __H_1)), (__i = (2));
		     __i <= __n; ++__i) {
			__H_n = (2 *
				 ((__x * __H_nm1) - ((__i - (1)) * __H_nm2)));
			__H_nm2 = __H_nm1;
			__H_nm1 = __H_n;
		}
		return __H_n;
	}
	template <class _Tp> inline _Tp __poly_hermite(unsigned __n, _Tp __x)
	{
		if (__isnan(__x)) {
			return std::template numeric_limits<_Tp>::quiet_NaN();
		} else {
			return __poly_hermite_recursion(__n, __x);
		}
	}
	} // namespace __detail
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	namespace __detail
	{
	template <class _Tpa, class _Tp>
	_Tp __poly_laguerre_large_n(unsigned __n, _Tpa __alpha1, _Tp __x)
	{
		const _Tp __a = (-((_Tp)__n));
		const _Tp __b = ((_Tp)__alpha1) + ((_Tp)1);
		const _Tp __eta = (((_Tp)2) * __b) - (((_Tp)4) * __a);
		const _Tp __cos2th = __x / __eta;
		const _Tp __sin2th = ((_Tp)1) - __cos2th;
		const _Tp __th = std::acos(std::sqrt(__cos2th));
		const _Tp __pre_h = ((((__numeric_constants<_Tp>::__pi_2() *
					__numeric_constants<_Tp>::__pi_2()) *
				       __eta) *
				      __eta) *
				     __cos2th) *
				    __sin2th;
		const _Tp __lg_b = std::lgamma(((_Tp)__n) + __b);
		const _Tp __lnfact = std::lgamma((_Tp)(__n + (1)));
		_Tp __pre_term1 = (((_Tp)(0.5L)) * (((_Tp)1) - __b)) *
				  std::log((((_Tp)(0.25L)) * __x) * __eta);
		_Tp __pre_term2 = ((_Tp)(0.25L)) * std::log(__pre_h);
		_Tp __lnpre = (((__lg_b - __lnfact) + (((_Tp)(0.5L)) * __x)) +
			       __pre_term1) -
			      __pre_term2;
		_Tp __ser_term1 =
			std::sin(__a * __numeric_constants<_Tp>::__pi());
		_Tp __ser_term2 = std::sin(
			((((_Tp)(0.25L)) * __eta) *
			 ((((_Tp)2) * __th) - std::sin(((_Tp)2) * __th))) +
			__numeric_constants<_Tp>::__pi_4());
		_Tp __ser = __ser_term1 + __ser_term2;
		return std::exp(__lnpre) * __ser;
	}
	template <class _Tpa, class _Tp>
	_Tp __poly_laguerre_hyperg(unsigned __n, _Tpa __alpha1, _Tp __x)
	{
		const _Tp __b = ((_Tp)__alpha1) + ((_Tp)1);
		const _Tp __mx = (-__x);
		const _Tp __tc_sgn =
			(__x < ((_Tp)0)) ?
				(_Tp)1 :
				(((__n % (2)) == (1)) ? -((_Tp)1) : ((_Tp)1));
		_Tp __tc = ((_Tp)1);
		const _Tp __ax = std::abs(__x);
		for (unsigned __k = (1); __k <= __n; ++__k) {
			__tc *= (__ax / __k);
		}
		_Tp __term = __tc * __tc_sgn;
		_Tp __sum = __term;
		for (int __k = ((int)__n) - 1; __k >= 0; --__k) {
			__term *= ((((__b + ((_Tp)__k)) /
				     ((_Tp)(((int)__n) - __k))) *
				    ((_Tp)(__k + 1))) /
				   __mx);
			__sum += __term;
		}
		return __sum;
	}
	template <class _Tpa, class _Tp>
	_Tp __poly_laguerre_recursion(unsigned __n, _Tpa __alpha1, _Tp __x)
	{
		_Tp __l_0 = ((_Tp)1);
		if (__n == (0)) {
			return __l_0;
		}
		_Tp __l_1 = ((-__x) + ((_Tp)1)) + ((_Tp)__alpha1);
		if (__n == (1)) {
			return __l_1;
		}
		_Tp __l_n2 = __l_0;
		_Tp __l_n1 = __l_1;
		_Tp __l_n = ((_Tp)0);
		for (unsigned __nn = (2); __nn <= __n; ++__nn) {
			__l_n = (((((((_Tp)(((2) * __nn) - (1))) +
				     ((_Tp)__alpha1)) -
				    __x) *
				   __l_n1) /
				  ((_Tp)__nn)) -
				 (((((_Tp)(__nn - (1))) + ((_Tp)__alpha1)) *
				   __l_n2) /
				  ((_Tp)__nn)));
			__l_n2 = __l_n1;
			__l_n1 = __l_n;
		}
		return __l_n;
	}
	template <class _Tpa, class _Tp>
	_Tp __poly_laguerre(unsigned __n, _Tpa __alpha1, _Tp __x)
	{
		if (__x < ((_Tp)0)) {
			std::__throw_domain_error(
				"Negative argument in __poly_laguerre.");
		} else {
			if (__isnan(__x)) {
				return std::template numeric_limits<
					_Tp>::quiet_NaN();
			} else {
				if (__n == (0)) {
					return (_Tp)1;
				} else {
					if (__n == (1)) {
						return (((_Tp)1) +
							((_Tp)__alpha1)) -
						       __x;
					} else {
						if (__x == ((_Tp)0)) {
							_Tp __prod =
								((_Tp)__alpha1) +
								((_Tp)1);
							for (unsigned __k = (2);
							     __k <= __n;
							     ++__k) {
								__prod *=
									((((_Tp)__alpha1) +
									  ((_Tp)__k)) /
									 ((_Tp)__k));
							}
							return __prod;
						} else {
							if ((__n >
							     (10000000)) &&
							    (((_Tp)__alpha1) >
							     (-((_Tp)1))) &&
							    (__x <
							     ((((_Tp)2) *
							       (((_Tp)__alpha1) +
								((_Tp)1))) +
							      ((_Tp)((4) *
								     __n))))) {
								return __poly_laguerre_large_n(
									__n,
									__alpha1,
									__x);
							} else {
								if ((((_Tp)__alpha1) >=
								     ((_Tp)0)) ||
								    ((__x >
								      ((_Tp)0)) &&
								     (((_Tp)__alpha1) <
								      (-((_Tp)(__n +
									       (1))))))) {
									return __poly_laguerre_recursion(
										__n,
										__alpha1,
										__x);
								} else {
									return __poly_laguerre_hyperg(
										__n,
										__alpha1,
										__x);
								}
							}
						}
					}
				}
			}
		}
	}
	template <class _Tp>
	inline _Tp __assoc_laguerre(unsigned __n, unsigned __m, _Tp __x)
	{
		return __poly_laguerre<unsigned, _Tp>(__n, __m, __x);
	}
	template <class _Tp> inline _Tp __laguerre(unsigned __n, _Tp __x)
	{
		return __poly_laguerre<unsigned, _Tp>(__n, 0, __x);
	}
	} // namespace __detail
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	namespace __detail
	{
	template <class _Tp> _Tp __riemann_zeta_sum(_Tp __s)
	{
		if (__s < ((_Tp)1)) {
			std::__throw_domain_error("Bad argument in zeta sum.");
		}
		const unsigned max_iter = (10000);
		_Tp __zeta = ((_Tp)0);
		for (unsigned __k = (1); __k < max_iter; ++__k) {
			_Tp __term = std::pow(static_cast<_Tp>(__k), -__s);
			if (__term <
			    std::template numeric_limits<_Tp>::epsilon()) {
				break;
			}
			__zeta += __term;
		}
		return __zeta;
	}
	template <class _Tp> _Tp __riemann_zeta_alt(_Tp __s)
	{
		_Tp __sgn = ((_Tp)1);
		_Tp __zeta = ((_Tp)0);
		for (unsigned __i = (1); __i < (10000000); ++__i) {
			_Tp __term = __sgn / std::pow(__i, __s);
			if (std::abs(__term) <
			    std::template numeric_limits<_Tp>::epsilon()) {
				break;
			}
			__zeta += __term;
			__sgn *= ((_Tp)(-1));
		}
		__zeta /= (((_Tp)1) - std::pow((_Tp)2, ((_Tp)1) - __s));
		return __zeta;
	}
	template <class _Tp> _Tp __riemann_zeta_glob(_Tp __s)
	{
		_Tp __zeta = ((_Tp)0);
		const _Tp __eps = std::template numeric_limits<_Tp>::epsilon();
		const _Tp __max_bincoeff =
			(std::template numeric_limits<_Tp>::max_exponent10 *
			 std::log((_Tp)10)) -
			((_Tp)1);
		if (__s < ((_Tp)0)) {
			if (std::fmod(__s, (_Tp)2) == ((_Tp)0)) {
				return (_Tp)0;
			} else {
				_Tp __zeta =
					__riemann_zeta_glob(((_Tp)1) - __s);
				__zeta *=
					(((std::pow(((_Tp)2) *
							    __numeric_constants<
								    _Tp>::__pi(),
						    __s) *
					   std::sin(__numeric_constants<
							    _Tp>::__pi_2() *
						    __s)) *
					  std::exp(std::lgamma(((_Tp)1) -
							       __s))) /
					 __numeric_constants<_Tp>::__pi());
				return __zeta;
			}
		}
		_Tp __num = ((_Tp)(0.5L));
		const unsigned __maxit = (10000);
		for (unsigned __i = (0); __i < __maxit; ++__i) {
			bool __punt = false;
			_Tp __sgn = ((_Tp)1);
			_Tp __term = ((_Tp)0);
			for (unsigned __j = (0); __j <= __i; ++__j) {
				_Tp __bincoeff =
					(std::lgamma((_Tp)((1) + __i)) -
					 std::lgamma((_Tp)((1) + __j))) -
					std::lgamma((_Tp)(((1) + __i) - __j));
				if (__bincoeff > __max_bincoeff) {
					__punt = true;
					break;
				}
				__bincoeff = std::exp(__bincoeff);
				__term += ((__sgn * __bincoeff) *
					   std::pow((_Tp)((1) + __j), -__s));
				__sgn *= ((_Tp)(-1));
			}
			if (__punt) {
				break;
			}
			__term *= __num;
			__zeta += __term;
			if (std::abs(__term / __zeta) < __eps) {
				break;
			}
			__num *= ((_Tp)(0.5L));
		}
		__zeta /= (((_Tp)1) - std::pow((_Tp)2, ((_Tp)1) - __s));
		return __zeta;
	}
	template <class _Tp> _Tp __riemann_zeta_product(_Tp __s)
	{
		static const _Tp __prime[] = {
			((_Tp)2),  ((_Tp)3),   ((_Tp)5),   ((_Tp)7),
			((_Tp)11), ((_Tp)13),  ((_Tp)17),  ((_Tp)19),
			((_Tp)23), ((_Tp)29),  ((_Tp)31),  ((_Tp)37),
			((_Tp)41), ((_Tp)43),  ((_Tp)47),  ((_Tp)53),
			((_Tp)59), ((_Tp)61),  ((_Tp)67),  ((_Tp)71),
			((_Tp)73), ((_Tp)79),  ((_Tp)83),  ((_Tp)89),
			((_Tp)97), ((_Tp)101), ((_Tp)103), ((_Tp)107),
			((_Tp)109)
		};
		static const unsigned __num_primes =
			(sizeof(__prime) / sizeof(_Tp));
		_Tp __zeta = ((_Tp)1);
		for (unsigned __i = (0); __i < __num_primes; ++__i) {
			const _Tp __fact =
				((_Tp)1) - std::pow(__prime[__i], -__s);
			__zeta *= __fact;
			if ((((_Tp)1) - __fact) <
			    std::template numeric_limits<_Tp>::epsilon()) {
				break;
			}
		}
		__zeta = (((_Tp)1) / __zeta);
		return __zeta;
	}
	template <class _Tp> _Tp __riemann_zeta(_Tp __s)
	{
		if (__isnan(__s)) {
			return std::template numeric_limits<_Tp>::quiet_NaN();
		} else {
			if (__s == ((_Tp)1)) {
				return std::template numeric_limits<
					_Tp>::infinity();
			} else {
				if (__s < (-((_Tp)19))) {
					_Tp __zeta = __riemann_zeta_product(
						((_Tp)1) - __s);
					__zeta *=
						(((std::pow(
							   ((_Tp)2) *
								   __numeric_constants<
									   _Tp>::
									   __pi(),
							   __s) *
						   std::sin(
							   __numeric_constants<
								   _Tp>::__pi_2() *
							   __s)) *
						  std::exp(std::lgamma(
							  ((_Tp)1) - __s))) /
						 __numeric_constants<
							 _Tp>::__pi());
					return __zeta;
				} else {
					if (__s < ((_Tp)20)) {
						bool __glob = true;
						if (__glob) {
							return __riemann_zeta_glob(
								__s);
						} else {
							if (__s > ((_Tp)1)) {
								return __riemann_zeta_sum(
									__s);
							} else {
								_Tp __zeta =
									((std::pow(
										  ((_Tp)2) *
											  __numeric_constants<
												  _Tp>::
												  __pi(),
										  __s) *
									  std::sin(
										  __numeric_constants<
											  _Tp>::
											  __pi_2() *
										  __s)) *
									 std::tgamma(
										 ((_Tp)1) -
										 __s)) *
									__riemann_zeta_sum(
										((_Tp)1) -
										__s);
								return __zeta;
							}
						}
					} else {
						return __riemann_zeta_product(
							__s);
					}
				}
			}
		}
	}
	template <class _Tp> _Tp __hurwitz_zeta_glob(_Tp __a, _Tp __s)
	{
		_Tp __zeta = ((_Tp)0);
		const _Tp __eps = std::template numeric_limits<_Tp>::epsilon();
		const _Tp __max_bincoeff =
			(std::template numeric_limits<_Tp>::max_exponent10 *
			 std::log((_Tp)10)) -
			((_Tp)1);
		const unsigned __maxit = (10000);
		for (unsigned __i = (0); __i < __maxit; ++__i) {
			bool __punt = false;
			_Tp __sgn = ((_Tp)1);
			_Tp __term = ((_Tp)0);
			for (unsigned __j = (0); __j <= __i; ++__j) {
				_Tp __bincoeff =
					(std::lgamma((_Tp)((1) + __i)) -
					 std::lgamma((_Tp)((1) + __j))) -
					std::lgamma((_Tp)(((1) + __i) - __j));
				if (__bincoeff > __max_bincoeff) {
					__punt = true;
					break;
				}
				__bincoeff = std::exp(__bincoeff);
				__term += ((__sgn * __bincoeff) *
					   std::pow((_Tp)(__a + __j), -__s));
				__sgn *= ((_Tp)(-1));
			}
			if (__punt) {
				break;
			}
			__term /= ((_Tp)(__i + (1)));
			if (std::abs(__term / __zeta) < __eps) {
				break;
			}
			__zeta += __term;
		}
		__zeta /= (__s - ((_Tp)1));
		return __zeta;
	}
	template <class _Tp> inline _Tp __hurwitz_zeta(_Tp __a, _Tp __s)
	{
		return __hurwitz_zeta_glob(__a, __s);
	}
	} // namespace __detail
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	inline float assoc_laguerref(unsigned __n, unsigned __m, float __x)
	{
		return __detail::__assoc_laguerre<float>(__n, __m, __x);
	}
	inline long double assoc_laguerrel(unsigned __n, unsigned __m,
					   long double __x)
	{
		return __detail::__assoc_laguerre<long double>(__n, __m, __x);
	}
	template <class _Tp>
	inline typename __gnu_cxx::__promote<_Tp>::__type assoc_laguerre(
		unsigned __n, unsigned __m, _Tp __x)
	{
		typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
		return __detail::__assoc_laguerre<
			typename __gnu_cxx::__promote<_Tp>::__type>(__n, __m,
								    __x);
	}
	inline float assoc_legendref(unsigned __l, unsigned __m, float __x)
	{
		return __detail::__assoc_legendre_p<float>(__l, __m, __x);
	}
	inline long double assoc_legendrel(unsigned __l, unsigned __m,
					   long double __x)
	{
		return __detail::__assoc_legendre_p<long double>(__l, __m, __x);
	}
	template <class _Tp>
	inline typename __gnu_cxx::__promote<_Tp>::__type assoc_legendre(
		unsigned __l, unsigned __m, _Tp __x)
	{
		typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
		return __detail::__assoc_legendre_p<
			typename __gnu_cxx::__promote<_Tp>::__type>(__l, __m,
								    __x);
	}
	inline float betaf(float __a, float __b)
	{
		return __detail::__beta<float>(__a, __b);
	}
	inline long double betal(long double __a, long double __b)
	{
		return __detail::__beta<long double>(__a, __b);
	}
	template <class _Tpa, class _Tpb>
	inline typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type beta(
		_Tpa __a, _Tpb __b)
	{
		typedef typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type
			__type;
		return __detail::__beta<
			typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type>(
			__a, __b);
	}
	inline float comp_ellint_1f(float __k)
	{
		return __detail::__comp_ellint_1<float>(__k);
	}
	inline long double comp_ellint_1l(long double __k)
	{
		return __detail::__comp_ellint_1<long double>(__k);
	}
	template <class _Tp>
	inline typename __gnu_cxx::__promote<_Tp>::__type comp_ellint_1(_Tp __k)
	{
		typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
		return __detail::__comp_ellint_1<
			typename __gnu_cxx::__promote<_Tp>::__type>(__k);
	}
	inline float comp_ellint_2f(float __k)
	{
		return __detail::__comp_ellint_2<float>(__k);
	}
	inline long double comp_ellint_2l(long double __k)
	{
		return __detail::__comp_ellint_2<long double>(__k);
	}
	template <class _Tp>
	inline typename __gnu_cxx::__promote<_Tp>::__type comp_ellint_2(_Tp __k)
	{
		typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
		return __detail::__comp_ellint_2<
			typename __gnu_cxx::__promote<_Tp>::__type>(__k);
	}
	inline float comp_ellint_3f(float __k, float __nu)
	{
		return __detail::__comp_ellint_3<float>(__k, __nu);
	}
	inline long double comp_ellint_3l(long double __k, long double __nu)
	{
		return __detail::__comp_ellint_3<long double>(__k, __nu);
	}
	template <class _Tp, class _Tpn>
	inline typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type comp_ellint_3(
		_Tp __k, _Tpn __nu)
	{
		typedef typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type
			__type;
		return __detail::__comp_ellint_3<
			typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type>(
			__k, __nu);
	}
	inline float cyl_bessel_if(float __nu, float __x)
	{
		return __detail::__cyl_bessel_i<float>(__nu, __x);
	}
	inline long double cyl_bessel_il(long double __nu, long double __x)
	{
		return __detail::__cyl_bessel_i<long double>(__nu, __x);
	}
	template <class _Tpnu, class _Tp>
	inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type cyl_bessel_i(
		_Tpnu __nu, _Tp __x)
	{
		typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
			__type;
		return __detail::__cyl_bessel_i<
			typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type>(
			__nu, __x);
	}
	inline float cyl_bessel_jf(float __nu, float __x)
	{
		return __detail::__cyl_bessel_j<float>(__nu, __x);
	}
	inline long double cyl_bessel_jl(long double __nu, long double __x)
	{
		return __detail::__cyl_bessel_j<long double>(__nu, __x);
	}
	template <class _Tpnu, class _Tp>
	inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type cyl_bessel_j(
		_Tpnu __nu, _Tp __x)
	{
		typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
			__type;
		return __detail::__cyl_bessel_j<
			typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type>(
			__nu, __x);
	}
	inline float cyl_bessel_kf(float __nu, float __x)
	{
		return __detail::__cyl_bessel_k<float>(__nu, __x);
	}
	inline long double cyl_bessel_kl(long double __nu, long double __x)
	{
		return __detail::__cyl_bessel_k<long double>(__nu, __x);
	}
	template <class _Tpnu, class _Tp>
	inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type cyl_bessel_k(
		_Tpnu __nu, _Tp __x)
	{
		typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
			__type;
		return __detail::__cyl_bessel_k<
			typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type>(
			__nu, __x);
	}
	inline float cyl_neumannf(float __nu, float __x)
	{
		return __detail::__cyl_neumann_n<float>(__nu, __x);
	}
	inline long double cyl_neumannl(long double __nu, long double __x)
	{
		return __detail::__cyl_neumann_n<long double>(__nu, __x);
	}
	template <class _Tpnu, class _Tp>
	inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type cyl_neumann(
		_Tpnu __nu, _Tp __x)
	{
		typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
			__type;
		return __detail::__cyl_neumann_n<
			typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type>(
			__nu, __x);
	}
	inline float ellint_1f(float __k, float __phi)
	{
		return __detail::__ellint_1<float>(__k, __phi);
	}
	inline long double ellint_1l(long double __k, long double __phi)
	{
		return __detail::__ellint_1<long double>(__k, __phi);
	}
	template <class _Tp, class _Tpp>
	inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type ellint_1(
		_Tp __k, _Tpp __phi)
	{
		typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type
			__type;
		return __detail::__ellint_1<
			typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type>(
			__k, __phi);
	}
	inline float ellint_2f(float __k, float __phi)
	{
		return __detail::__ellint_2<float>(__k, __phi);
	}
	inline long double ellint_2l(long double __k, long double __phi)
	{
		return __detail::__ellint_2<long double>(__k, __phi);
	}
	template <class _Tp, class _Tpp>
	inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type ellint_2(
		_Tp __k, _Tpp __phi)
	{
		typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type
			__type;
		return __detail::__ellint_2<
			typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type>(
			__k, __phi);
	}
	inline float ellint_3f(float __k, float __nu, float __phi)
	{
		return __detail::__ellint_3<float>(__k, __nu, __phi);
	}
	inline long double ellint_3l(long double __k, long double __nu,
				     long double __phi)
	{
		return __detail::__ellint_3<long double>(__k, __nu, __phi);
	}
	template <class _Tp, class _Tpn, class _Tpp>
	inline typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type ellint_3(
		_Tp __k, _Tpn __nu, _Tpp __phi)
	{
		typedef typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type
			__type;
		return __detail::__ellint_3<typename __gnu_cxx::__promote_3<
			_Tp, _Tpn, _Tpp>::__type>(__k, __nu, __phi);
	}
	inline float expintf(float __x)
	{
		return __detail::__expint<float>(__x);
	}
	inline long double expintl(long double __x)
	{
		return __detail::__expint<long double>(__x);
	}
	template <class _Tp>
	inline typename __gnu_cxx::__promote<_Tp>::__type expint(_Tp __x)
	{
		typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
		return __detail::__expint<
			typename __gnu_cxx::__promote<_Tp>::__type>(__x);
	}
	inline float hermitef(unsigned __n, float __x)
	{
		return __detail::__poly_hermite<float>(__n, __x);
	}
	inline long double hermitel(unsigned __n, long double __x)
	{
		return __detail::__poly_hermite<long double>(__n, __x);
	}
	template <class _Tp>
	inline typename __gnu_cxx::__promote<_Tp>::__type hermite(unsigned __n,
								  _Tp __x)
	{
		typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
		return __detail::__poly_hermite<
			typename __gnu_cxx::__promote<_Tp>::__type>(__n, __x);
	}
	inline float laguerref(unsigned __n, float __x)
	{
		return __detail::__laguerre<float>(__n, __x);
	}
	inline long double laguerrel(unsigned __n, long double __x)
	{
		return __detail::__laguerre<long double>(__n, __x);
	}
	template <class _Tp>
	inline typename __gnu_cxx::__promote<_Tp>::__type laguerre(unsigned __n,
								   _Tp __x)
	{
		typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
		return __detail::__laguerre<
			typename __gnu_cxx::__promote<_Tp>::__type>(__n, __x);
	}
	inline float legendref(unsigned __l, float __x)
	{
		return __detail::__poly_legendre_p<float>(__l, __x);
	}
	inline long double legendrel(unsigned __l, long double __x)
	{
		return __detail::__poly_legendre_p<long double>(__l, __x);
	}
	template <class _Tp>
	inline typename __gnu_cxx::__promote<_Tp>::__type legendre(unsigned __l,
								   _Tp __x)
	{
		typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
		return __detail::__poly_legendre_p<
			typename __gnu_cxx::__promote<_Tp>::__type>(__l, __x);
	}
	inline float riemann_zetaf(float __s)
	{
		return __detail::__riemann_zeta<float>(__s);
	}
	inline long double riemann_zetal(long double __s)
	{
		return __detail::__riemann_zeta<long double>(__s);
	}
	template <class _Tp>
	inline typename __gnu_cxx::__promote<_Tp>::__type riemann_zeta(_Tp __s)
	{
		typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
		return __detail::__riemann_zeta<
			typename __gnu_cxx::__promote<_Tp>::__type>(__s);
	}
	inline float sph_besself(unsigned __n, float __x)
	{
		return __detail::__sph_bessel<float>(__n, __x);
	}
	inline long double sph_bessell(unsigned __n, long double __x)
	{
		return __detail::__sph_bessel<long double>(__n, __x);
	}
	template <class _Tp>
	inline typename __gnu_cxx::__promote<_Tp>::__type sph_bessel(
		unsigned __n, _Tp __x)
	{
		typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
		return __detail::__sph_bessel<
			typename __gnu_cxx::__promote<_Tp>::__type>(__n, __x);
	}
	inline float sph_legendref(unsigned __l, unsigned __m, float __theta)
	{
		return __detail::__sph_legendre<float>(__l, __m, __theta);
	}
	inline long double sph_legendrel(unsigned __l, unsigned __m,
					 long double __theta)
	{
		return __detail::__sph_legendre<long double>(__l, __m, __theta);
	}
	template <class _Tp>
	inline typename __gnu_cxx::__promote<_Tp>::__type sph_legendre(
		unsigned __l, unsigned __m, _Tp __theta)
	{
		typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
		return __detail::__sph_legendre<
			typename __gnu_cxx::__promote<_Tp>::__type>(__l, __m,
								    __theta);
	}
	inline float sph_neumannf(unsigned __n, float __x)
	{
		return __detail::__sph_neumann<float>(__n, __x);
	}
	inline long double sph_neumannl(unsigned __n, long double __x)
	{
		return __detail::__sph_neumann<long double>(__n, __x);
	}
	template <class _Tp>
	inline typename __gnu_cxx::__promote<_Tp>::__type sph_neumann(
		unsigned __n, _Tp __x)
	{
		typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
		return __detail::__sph_neumann<
			typename __gnu_cxx::__promote<_Tp>::__type>(__n, __x);
	}
} // namespace )
namespace __gnu_cxx __attribute((__visibility__("default")))
{
	inline float airy_aif(float __x)
	{
		float __Ai, __Bi, __Aip, __Bip;
		std::__detail::__airy<float>(__x, __Ai, __Bi, __Aip, __Bip);
		return __Ai;
	}
	inline long double airy_ail(long double __x)
	{
		long double __Ai, __Bi, __Aip, __Bip;
		std::__detail::__airy<long double>(__x, __Ai, __Bi, __Aip,
						   __Bip);
		return __Ai;
	}
	template <class _Tp>
	inline typename __promote<_Tp>::__type airy_ai(_Tp __x)
	{
		typedef typename __promote<_Tp>::__type __type;
		__type __Ai, __Bi, __Aip, __Bip;
		std::__detail::__airy<typename __promote<_Tp>::__type>(
			__x, __Ai, __Bi, __Aip, __Bip);
		return __Ai;
	}
	inline float airy_bif(float __x)
	{
		float __Ai, __Bi, __Aip, __Bip;
		std::__detail::__airy<float>(__x, __Ai, __Bi, __Aip, __Bip);
		return __Bi;
	}
	inline long double airy_bil(long double __x)
	{
		long double __Ai, __Bi, __Aip, __Bip;
		std::__detail::__airy<long double>(__x, __Ai, __Bi, __Aip,
						   __Bip);
		return __Bi;
	}
	template <class _Tp>
	inline typename __promote<_Tp>::__type airy_bi(_Tp __x)
	{
		typedef typename __promote<_Tp>::__type __type;
		__type __Ai, __Bi, __Aip, __Bip;
		std::__detail::__airy<typename __promote<_Tp>::__type>(
			__x, __Ai, __Bi, __Aip, __Bip);
		return __Bi;
	}
	inline float conf_hypergf(float __a, float __c, float __x)
	{
		return std::__detail::__conf_hyperg<float>(__a, __c, __x);
	}
	inline long double conf_hypergl(long double __a, long double __c,
					long double __x)
	{
		return std::__detail::__conf_hyperg<long double>(__a, __c, __x);
	}
	template <class _Tpa, class _Tpc, class _Tp>
	inline typename __promote_3<_Tpa, _Tpc, _Tp>::__type conf_hyperg(
		_Tpa __a, _Tpc __c, _Tp __x)
	{
		typedef typename __promote_3<_Tpa, _Tpc, _Tp>::__type __type;
		return std::__detail::__conf_hyperg<
			typename __promote_3<_Tpa, _Tpc, _Tp>::__type>(__a, __c,
								       __x);
	}
	inline float hypergf(float __a, float __b, float __c, float __x)
	{
		return std::__detail::__hyperg<float>(__a, __b, __c, __x);
	}
	inline long double hypergl(long double __a, long double __b,
				   long double __c, long double __x)
	{
		return std::__detail::__hyperg<long double>(__a, __b, __c, __x);
	}
	template <class _Tpa, class _Tpb, class _Tpc, class _Tp>
	inline typename __promote_4<_Tpa, _Tpb, _Tpc, _Tp>::__type hyperg(
		_Tpa __a, _Tpb __b, _Tpc __c, _Tp __x)
	{
		typedef typename __promote_4<_Tpa, _Tpb, _Tpc, _Tp>::__type
			__type;
		return std::__detail::__hyperg<
			typename __promote_4<_Tpa, _Tpb, _Tpc, _Tp>::__type>(
			__a, __b, __c, __x);
	}
} // namespace )
}
using std::abs;
using std::acos;
using std::acosh;
using std::asin;
using std::asinh;
using std::atan;
using std::atan2;
using std::atanh;
using std::cbrt;
using std::ceil;
using std::copysign;
using std::cos;
using std::cosh;
using std::erf;
using std::erfc;
using std::exp;
using std::exp2;
using std::expm1;
using std::fabs;
using std::fdim;
using std::floor;
using std::fma;
using std::fmax;
using std::fmin;
using std::fmod;
using std::fpclassify;
using std::frexp;
using std::hypot;
using std::ilogb;
using std::isfinite;
using std::isgreater;
using std::isgreaterequal;
using std::isinf;
using std::isless;
using std::islessequal;
using std::islessgreater;
using std::isnan;
using std::isnormal;
using std::isunordered;
using std::ldexp;
using std::lgamma;
using std::llrint;
using std::llround;
using std::log;
using std::log10;
using std::log1p;
using std::log2;
using std::logb;
using std::lrint;
using std::lround;
using std::modf;
using std::nearbyint;
using std::nextafter;
using std::nexttoward;
using std::pow;
using std::remainder;
using std::remquo;
using std::rint;
using std::round;
using std::scalbln;
using std::scalbn;
using std::signbit;
using std::sin;
using std::sinh;
using std::sqrt;
using std::tan;
using std::tanh;
using std::tgamma;
using std::trunc;

namespace std
{
constexpr bool signbit(float x);
constexpr bool signbit(double x);
constexpr bool signbit(long double x);
constexpr bool isfinite(float x);
constexpr bool isfinite(double x);
constexpr bool isfinite(long double x);
constexpr bool isnan(float x);
constexpr bool isnan(double x);
constexpr bool isnan(long double x);
constexpr bool isinf(float x);
constexpr bool isinf(double x);
constexpr bool isinf(long double x);
} // namespace std
namespace std
{
template <class T> extern T __pow_helper(T, int);
template <class T> extern T __cmath_power(T, unsigned);
} // namespace std
using std::abs;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::ceil;
using std::cos;
using std::cosh;
using std::exp;
using std::fabs;
using std::floor;
using std::fmod;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sin;
using std::sinh;
using std::sqrt;
using std::tan;
using std::tanh;
namespace std
{
extern inline long long abs(long long);
extern inline long abs(long a);
extern constexpr float abs(float);
extern constexpr double abs(double);
extern constexpr float fabs(float);
extern constexpr float ceil(float);
extern constexpr float floor(float);
extern constexpr float sqrt(float);
extern constexpr float pow(float, float);
template <class _Tp, class _Up>
extern constexpr
	typename __gnu_cxx::__promote_2<_Tp, _Up>::__type pow(_Tp, _Up);
extern constexpr float log(float);
extern constexpr float log10(float);
extern constexpr float fmod(float, float);
extern inline float modf(float, float *);
extern constexpr float exp(float);
extern inline float frexp(float, int *);
extern constexpr float ldexp(float, int);
extern constexpr float asin(float);
extern constexpr float sin(float);
extern constexpr float sinh(float);
extern constexpr float acos(float);
extern constexpr float cos(float);
extern constexpr float cosh(float);
extern constexpr float atan(float);
extern constexpr float atan2(float, float);
extern constexpr float tan(float);
extern constexpr float tanh(float);
} // namespace std
namespace std
{
constexpr float logb(float a);
constexpr int ilogb(float a);
constexpr float scalbn(float a, int b);
constexpr float scalbln(float a, long b);
constexpr float exp2(float a);
constexpr float expm1(float a);
constexpr float log2(float a);
constexpr float log1p(float a);
constexpr float acosh(float a);
constexpr float asinh(float a);
constexpr float atanh(float a);
constexpr float hypot(float a, float b);
constexpr float cbrt(float a);
constexpr float erf(float a);
constexpr float erfc(float a);
constexpr float lgamma(float a);
constexpr float tgamma(float a);
constexpr float copysign(float a, float b);
constexpr float nextafter(float a, float b);
constexpr float remainder(float a, float b);
inline float remquo(float a, float b, int *quo);
constexpr float round(float a);
constexpr long lround(float a);
constexpr long long llround(float a);
constexpr float trunc(float a);
constexpr float rint(float a);
constexpr long lrint(float a);
constexpr long long llrint(float a);
constexpr float nearbyint(float a);
constexpr float fdim(float a, float b);
constexpr float fma(float a, float b, float c);
constexpr float fmax(float a, float b);
constexpr float fmin(float a, float b);
} // namespace std
static inline float exp10(const float a);
static inline float rsqrt(const float a);
static inline float rcbrt(const float a);
static inline float sinpi(const float a);
static inline float cospi(const float a);
static inline void sincospi(const float a, float *const sptr,
			    float *const cptr);
static inline void sincos(const float a, float *const sptr, float *const cptr);
static inline float j0(const float a);
static inline float j1(const float a);
static inline float jn(const int n, const float a);
static inline float y0(const float a);
static inline float y1(const float a);
static inline float yn(const int n, const float a);
__attribute__((unused)) static inline float cyl_bessel_i0(const float a);
__attribute__((unused)) static inline float cyl_bessel_i1(const float a);
static inline float erfinv(const float a);
static inline float erfcinv(const float a);
static inline float normcdfinv(const float a);
static inline float normcdf(const float a);
static inline float erfcx(const float a);
static inline double copysign(const double a, const float b);
static inline double copysign(const float a, const double b);
static inline unsigned min(const unsigned a, const unsigned b);
static inline unsigned min(const int a, const unsigned b);
static inline unsigned min(const unsigned a, const int b);
static inline long min(const long a, const long b);
static inline unsigned long min(const unsigned long a, const unsigned long b);
static inline unsigned long min(const long a, const unsigned long b);
static inline unsigned long min(const unsigned long a, const long b);
static inline long long min(const long long a, const long long b);
static inline unsigned long long min(const unsigned long long a,
				     const unsigned long long b);
static inline unsigned long long min(const long long a,
				     const unsigned long long b);
static inline unsigned long long min(const unsigned long long a,
				     const long long b);
static inline float min(const float a, const float b);
static inline double min(const double a, const double b);
static inline double min(const float a, const double b);
static inline double min(const double a, const float b);
static inline unsigned max(const unsigned a, const unsigned b);
static inline unsigned max(const int a, const unsigned b);
static inline unsigned max(const unsigned a, const int b);
static inline long max(const long a, const long b);
static inline unsigned long max(const unsigned long a, const unsigned long b);
static inline unsigned long max(const long a, const unsigned long b);
static inline unsigned long max(const unsigned long a, const long b);
static inline long long max(const long long a, const long long b);
static inline unsigned long long max(const unsigned long long a,
				     const unsigned long long b);
static inline unsigned long long max(const long long a,
				     const unsigned long long b);
static inline unsigned long long max(const unsigned long long a,
				     const long long b);
static inline float max(const float a, const float b);
static inline double max(const double a, const double b);
static inline double max(const float a, const double b);
static inline double max(const double a, const float b);
extern "C" {
__attribute__((unused)) inline void *__nv_aligned_device_malloc(size_t size,
								size_t align)
{
	int volatile ___ = 1;
	(void)size;
	(void)align;
	::exit(___);
}
}
static inline float exp10(const float a)
{
	return exp10f(a);
}
static inline float rsqrt(const float a)
{
	return rsqrtf(a);
}
static inline float rcbrt(const float a)
{
	return rcbrtf(a);
}
static inline float sinpi(const float a)
{
	return sinpif(a);
}
static inline float cospi(const float a)
{
	return cospif(a);
}
static inline void sincospi(const float a, float *const sptr, float *const cptr)
{
	sincospif(a, sptr, cptr);
}
static inline void sincos(const float a, float *const sptr, float *const cptr)
{
	sincosf(a, sptr, cptr);
}
static inline float j0(const float a)
{
	return j0f(a);
}
static inline float j1(const float a)
{
	return j1f(a);
}
static inline float jn(const int n, const float a)
{
	return jnf(n, a);
}
static inline float y0(const float a)
{
	return y0f(a);
}
static inline float y1(const float a)
{
	return y1f(a);
}
static inline float yn(const int n, const float a)
{
	return ynf(n, a);
}
__attribute__((unused)) static inline float cyl_bessel_i0(const float a)
{
	int volatile ___ = 1;
	(void)a;
	::exit(___);
}
__attribute__((unused)) static inline float cyl_bessel_i1(const float a)
{
	int volatile ___ = 1;
	(void)a;
	::exit(___);
}
static inline float erfinv(const float a)
{
	return erfinvf(a);
}
static inline float erfcinv(const float a)
{
	return erfcinvf(a);
}
static inline float normcdfinv(const float a)
{
	return normcdfinvf(a);
}
static inline float normcdf(const float a)
{
	return normcdff(a);
}
static inline float erfcx(const float a)
{
	return erfcxf(a);
}
static inline double copysign(const double a, const float b)
{
	return copysign(a, static_cast<double>(b));
}
static inline double copysign(const float a, const double b)
{
	return copysign(static_cast<double>(a), b);
}
static inline unsigned min(const unsigned a, const unsigned b)
{
	return umin(a, b);
}
static inline unsigned min(const int a, const unsigned b)
{
	return umin(static_cast<unsigned>(a), b);
}
static inline unsigned min(const unsigned a, const int b)
{
	return umin(a, static_cast<unsigned>(b));
}
static inline long min(const long a, const long b)
{
	long retval;
	if (sizeof(long) == sizeof(int)) {
		retval = (static_cast<long>(
			min(static_cast<int>(a), static_cast<int>(b))));
	} else {
		retval = (static_cast<long>(llmin(static_cast<long long>(a),
						  static_cast<long long>(b))));
	}
	return retval;
}
static inline unsigned long min(const unsigned long a, const unsigned long b)
{
	unsigned long retval;
	if (sizeof(unsigned long) == sizeof(unsigned)) {
		retval = (static_cast<unsigned long>(umin(
			static_cast<unsigned>(a), static_cast<unsigned>(b))));
	} else {
		retval = (static_cast<unsigned long>(
			ullmin(static_cast<unsigned long long>(a),
			       static_cast<unsigned long long>(b))));
	}
	return retval;
}
static inline unsigned long min(const long a, const unsigned long b)
{
	unsigned long retval;
	if (sizeof(unsigned long) == sizeof(unsigned)) {
		retval = (static_cast<unsigned long>(umin(
			static_cast<unsigned>(a), static_cast<unsigned>(b))));
	} else {
		retval = (static_cast<unsigned long>(
			ullmin(static_cast<unsigned long long>(a),
			       static_cast<unsigned long long>(b))));
	}
	return retval;
}
static inline unsigned long min(const unsigned long a, const long b)
{
	unsigned long retval;
	if (sizeof(unsigned long) == sizeof(unsigned)) {
		retval = (static_cast<unsigned long>(umin(
			static_cast<unsigned>(a), static_cast<unsigned>(b))));
	} else {
		retval = (static_cast<unsigned long>(
			ullmin(static_cast<unsigned long long>(a),
			       static_cast<unsigned long long>(b))));
	}
	return retval;
}
static inline long long min(const long long a, const long long b)
{
	return llmin(a, b);
}
static inline unsigned long long min(const unsigned long long a,
				     const unsigned long long b)
{
	return ullmin(a, b);
}
static inline unsigned long long min(const long long a,
				     const unsigned long long b)
{
	return ullmin(static_cast<unsigned long long>(a), b);
}
static inline unsigned long long min(const unsigned long long a,
				     const long long b)
{
	return ullmin(a, static_cast<unsigned long long>(b));
}
static inline float min(const float a, const float b)
{
	return fminf(a, b);
}
static inline double min(const double a, const double b)
{
	return fmin(a, b);
}
static inline double min(const float a, const double b)
{
	return fmin(static_cast<double>(a), b);
}
static inline double min(const double a, const float b)
{
	return fmin(a, static_cast<double>(b));
}
static inline unsigned max(const unsigned a, const unsigned b)
{
	return umax(a, b);
}
static inline unsigned max(const int a, const unsigned b)
{
	return umax(static_cast<unsigned>(a), b);
}
static inline unsigned max(const unsigned a, const int b)
{
	return umax(a, static_cast<unsigned>(b));
}
static inline long max(const long a, const long b)
{
	long retval;
	if (sizeof(long) == sizeof(int)) {
		retval = (static_cast<long>(
			max(static_cast<int>(a), static_cast<int>(b))));
	} else {
		retval = (static_cast<long>(llmax(static_cast<long long>(a),
						  static_cast<long long>(b))));
	}
	return retval;
}
static inline unsigned long max(const unsigned long a, const unsigned long b)
{
	unsigned long retval;
	if (sizeof(unsigned long) == sizeof(unsigned)) {
		retval = (static_cast<unsigned long>(umax(
			static_cast<unsigned>(a), static_cast<unsigned>(b))));
	} else {
		retval = (static_cast<unsigned long>(
			ullmax(static_cast<unsigned long long>(a),
			       static_cast<unsigned long long>(b))));
	}
	return retval;
}
static inline unsigned long max(const long a, const unsigned long b)
{
	unsigned long retval;
	if (sizeof(unsigned long) == sizeof(unsigned)) {
		retval = (static_cast<unsigned long>(umax(
			static_cast<unsigned>(a), static_cast<unsigned>(b))));
	} else {
		retval = (static_cast<unsigned long>(
			ullmax(static_cast<unsigned long long>(a),
			       static_cast<unsigned long long>(b))));
	}
	return retval;
}
static inline unsigned long max(const unsigned long a, const long b)
{
	unsigned long retval;
	if (sizeof(unsigned long) == sizeof(unsigned)) {
		retval = (static_cast<unsigned long>(umax(
			static_cast<unsigned>(a), static_cast<unsigned>(b))));
	} else {
		retval = (static_cast<unsigned long>(
			ullmax(static_cast<unsigned long long>(a),
			       static_cast<unsigned long long>(b))));
	}
	return retval;
}
static inline long long max(const long long a, const long long b)
{
	return llmax(a, b);
}
static inline unsigned long long max(const unsigned long long a,
				     const unsigned long long b)
{
	return ullmax(a, b);
}
static inline unsigned long long max(const long long a,
				     const unsigned long long b)
{
	return ullmax(static_cast<unsigned long long>(a), b);
}
static inline unsigned long long max(const unsigned long long a,
				     const long long b)
{
	return ullmax(a, static_cast<unsigned long long>(b));
}
static inline float max(const float a, const float b)
{
	return fmaxf(a, b);
}
static inline double max(const double a, const double b)
{
	return fmax(a, b);
}
static inline double max(const float a, const double b)
{
	return fmax(static_cast<double>(a), b);
}
static inline double max(const double a, const float b)
{
	return fmax(a, static_cast<double>(b));
}
inline int min(const int a, const int b)
{
	return (a < b) ? a : b;
}
inline unsigned umin(const unsigned a, const unsigned b)
{
	return (a < b) ? a : b;
}
inline long long llmin(const long long a, const long long b)
{
	return (a < b) ? a : b;
}
inline unsigned long long ullmin(const unsigned long long a,
				 const unsigned long long b)
{
	return (a < b) ? a : b;
}
inline int max(const int a, const int b)
{
	return (a > b) ? a : b;
}
inline unsigned umax(const unsigned a, const unsigned b)
{
	return (a > b) ? a : b;
}
inline long long llmax(const long long a, const long long b)
{
	return (a > b) ? a : b;
}
inline unsigned long long ullmax(const unsigned long long a,
				 const unsigned long long b)
{
	return (a > b) ? a : b;
}
extern "C" {
static inline int __vimax_s32_relu(const int a, const int b);
static inline unsigned __vimax_s16x2_relu(const unsigned a, const unsigned b);
static inline int __vimin_s32_relu(const int a, const int b);
static inline unsigned __vimin_s16x2_relu(const unsigned a, const unsigned b);
static inline int __vimax3_s32(const int a, const int b, const int c);
static inline unsigned __vimax3_s16x2(const unsigned a, const unsigned b,
				      const unsigned c);
static inline unsigned __vimax3_u32(const unsigned a, const unsigned b,
				    const unsigned c);
static inline unsigned __vimax3_u16x2(const unsigned a, const unsigned b,
				      const unsigned c);
static inline int __vimin3_s32(const int a, const int b, const int c);
static inline unsigned __vimin3_s16x2(const unsigned a, const unsigned b,
				      const unsigned c);
static inline unsigned __vimin3_u32(const unsigned a, const unsigned b,
				    const unsigned c);
static inline unsigned __vimin3_u16x2(const unsigned a, const unsigned b,
				      const unsigned c);
static inline int __vimax3_s32_relu(const int a, const int b, const int c);
static inline unsigned __vimax3_s16x2_relu(const unsigned a, const unsigned b,
					   const unsigned c);
static inline int __vimin3_s32_relu(const int a, const int b, const int c);
static inline unsigned __vimin3_s16x2_relu(const unsigned a, const unsigned b,
					   const unsigned c);
static inline int __viaddmax_s32(const int a, const int b, const int c);
static inline unsigned __viaddmax_s16x2(const unsigned a, const unsigned b,
					const unsigned c);
static inline unsigned __viaddmax_u32(const unsigned a, const unsigned b,
				      const unsigned c);
static inline unsigned __viaddmax_u16x2(const unsigned a, const unsigned b,
					const unsigned c);
static inline int __viaddmin_s32(const int a, const int b, const int c);
static inline unsigned __viaddmin_s16x2(const unsigned a, const unsigned b,
					const unsigned c);
static inline unsigned __viaddmin_u32(const unsigned a, const unsigned b,
				      const unsigned c);
static inline unsigned __viaddmin_u16x2(const unsigned a, const unsigned b,
					const unsigned c);
static inline int __viaddmax_s32_relu(const int a, const int b, const int c);
static inline unsigned __viaddmax_s16x2_relu(const unsigned a, const unsigned b,
					     const unsigned c);
static inline int __viaddmin_s32_relu(const int a, const int b, const int c);
static inline unsigned __viaddmin_s16x2_relu(const unsigned a, const unsigned b,
					     const unsigned c);
static inline int __vibmax_s32(const int a, const int b, bool *const pred);
static inline unsigned __vibmax_u32(const unsigned a, const unsigned b,
				    bool *const pred);
static inline int __vibmin_s32(const int a, const int b, bool *const pred);
static inline unsigned __vibmin_u32(const unsigned a, const unsigned b,
				    bool *const pred);
static inline unsigned __vibmax_s16x2(const unsigned a, const unsigned b,
				      bool *const pred_hi, bool *const pred_lo);
static inline unsigned __vibmax_u16x2(const unsigned a, const unsigned b,
				      bool *const pred_hi, bool *const pred_lo);
static inline unsigned __vibmin_s16x2(const unsigned a, const unsigned b,
				      bool *const pred_hi, bool *const pred_lo);
static inline unsigned __vibmin_u16x2(const unsigned a, const unsigned b,
				      bool *const pred_hi, bool *const pred_lo);
}
static short __internal_cast_u2s(unsigned short x)
{
	short res;
	(void)memcpy(&res, &x, sizeof x);
	return res;
}
static inline int __vimax_s32_relu(const int a, const int b)
{
	int ans = max(a, b);
	return (ans > 0) ? ans : 0;
}
static inline unsigned __vimax_s16x2_relu(const unsigned a, const unsigned b)
{
	unsigned res;
	unsigned short aU_lo = (unsigned short)(a & 65535U);
	unsigned short aU_hi = (unsigned short)(a >> 16);
	unsigned short bU_lo = (unsigned short)(b & 65535U);
	unsigned short bU_hi = (unsigned short)(b >> 16);
	short aS_lo = __internal_cast_u2s(aU_lo);
	short aS_hi = __internal_cast_u2s(aU_hi);
	short bS_lo = __internal_cast_u2s(bU_lo);
	short bS_hi = __internal_cast_u2s(bU_hi);
	int ansI_lo = max(aS_lo, bS_lo);
	int ansI_hi = max(aS_hi, bS_hi);
	if (ansI_lo < 0) {
		ansI_lo = 0;
	}
	if (ansI_hi < 0) {
		ansI_hi = 0;
	}
	unsigned ansU_lo = (unsigned)ansI_lo;
	unsigned ansU_hi = (unsigned)ansI_hi;
	res = (ansU_lo | (ansU_hi << 16));
	return res;
}
static inline int __vimin_s32_relu(const int a, const int b)
{
	int ans = min(a, b);
	return (ans > 0) ? ans : 0;
}
static inline unsigned __vimin_s16x2_relu(const unsigned a, const unsigned b)
{
	unsigned res;
	unsigned short aU_lo = (unsigned short)(a & 65535U);
	unsigned short aU_hi = (unsigned short)(a >> 16);
	unsigned short bU_lo = (unsigned short)(b & 65535U);
	unsigned short bU_hi = (unsigned short)(b >> 16);
	short aS_lo = __internal_cast_u2s(aU_lo);
	short aS_hi = __internal_cast_u2s(aU_hi);
	short bS_lo = __internal_cast_u2s(bU_lo);
	short bS_hi = __internal_cast_u2s(bU_hi);
	int ansI_lo = min(aS_lo, bS_lo);
	int ansI_hi = min(aS_hi, bS_hi);
	if (ansI_lo < 0) {
		ansI_lo = 0;
	}
	if (ansI_hi < 0) {
		ansI_hi = 0;
	}
	unsigned ansU_lo = (unsigned)ansI_lo;
	unsigned ansU_hi = (unsigned)ansI_hi;
	res = (ansU_lo | (ansU_hi << 16));
	return res;
}
static inline int __vimax3_s32(const int a, const int b, const int c)
{
	return max(max(a, b), c);
}
static inline unsigned __vimax3_s16x2(const unsigned a, const unsigned b,
				      const unsigned c)
{
	unsigned res;
	unsigned short aU_lo = (unsigned short)(a & 65535U);
	unsigned short aU_hi = (unsigned short)(a >> 16);
	unsigned short bU_lo = (unsigned short)(b & 65535U);
	unsigned short bU_hi = (unsigned short)(b >> 16);
	unsigned short cU_lo = (unsigned short)(c & 65535U);
	unsigned short cU_hi = (unsigned short)(c >> 16);
	short aS_lo = __internal_cast_u2s(aU_lo);
	short aS_hi = __internal_cast_u2s(aU_hi);
	short bS_lo = __internal_cast_u2s(bU_lo);
	short bS_hi = __internal_cast_u2s(bU_hi);
	short cS_lo = __internal_cast_u2s(cU_lo);
	short cS_hi = __internal_cast_u2s(cU_hi);
	unsigned ansU_lo = (unsigned)max(max(aS_lo, bS_lo), cS_lo);
	unsigned ansU_hi = (unsigned)max(max(aS_hi, bS_hi), cS_hi);
	res = ((ansU_lo & 65535U) | (ansU_hi << 16));
	return res;
}
static inline unsigned __vimax3_u32(const unsigned a, const unsigned b,
				    const unsigned c)
{
	return max(max(a, b), c);
}
static inline unsigned __vimax3_u16x2(const unsigned a, const unsigned b,
				      const unsigned c)
{
	unsigned res;
	unsigned short aU_lo = (unsigned short)(a & 65535U);
	unsigned short aU_hi = (unsigned short)(a >> 16);
	unsigned short bU_lo = (unsigned short)(b & 65535U);
	unsigned short bU_hi = (unsigned short)(b >> 16);
	unsigned short cU_lo = (unsigned short)(c & 65535U);
	unsigned short cU_hi = (unsigned short)(c >> 16);
	unsigned short ansU_lo = (unsigned short)max(max(aU_lo, bU_lo), cU_lo);
	unsigned short ansU_hi = (unsigned short)max(max(aU_hi, bU_hi), cU_hi);
	res = (((unsigned)ansU_lo) | (((unsigned)ansU_hi) << 16));
	return res;
}
static inline int __vimin3_s32(const int a, const int b, const int c)
{
	return min(min(a, b), c);
}
static inline unsigned __vimin3_s16x2(const unsigned a, const unsigned b,
				      const unsigned c)
{
	unsigned res;
	unsigned short aU_lo = (unsigned short)(a & 65535U);
	unsigned short aU_hi = (unsigned short)(a >> 16);
	unsigned short bU_lo = (unsigned short)(b & 65535U);
	unsigned short bU_hi = (unsigned short)(b >> 16);
	unsigned short cU_lo = (unsigned short)(c & 65535U);
	unsigned short cU_hi = (unsigned short)(c >> 16);
	short aS_lo = __internal_cast_u2s(aU_lo);
	short aS_hi = __internal_cast_u2s(aU_hi);
	short bS_lo = __internal_cast_u2s(bU_lo);
	short bS_hi = __internal_cast_u2s(bU_hi);
	short cS_lo = __internal_cast_u2s(cU_lo);
	short cS_hi = __internal_cast_u2s(cU_hi);
	unsigned ansU_lo = (unsigned)min(min(aS_lo, bS_lo), cS_lo);
	unsigned ansU_hi = (unsigned)min(min(aS_hi, bS_hi), cS_hi);
	res = ((ansU_lo & 65535U) | (ansU_hi << 16));
	return res;
}
static inline unsigned __vimin3_u32(const unsigned a, const unsigned b,
				    const unsigned c)
{
	return min(min(a, b), c);
}
static inline unsigned __vimin3_u16x2(const unsigned a, const unsigned b,
				      const unsigned c)
{
	unsigned res;
	unsigned short aU_lo = (unsigned short)(a & 65535U);
	unsigned short aU_hi = (unsigned short)(a >> 16);
	unsigned short bU_lo = (unsigned short)(b & 65535U);
	unsigned short bU_hi = (unsigned short)(b >> 16);
	unsigned short cU_lo = (unsigned short)(c & 65535U);
	unsigned short cU_hi = (unsigned short)(c >> 16);
	unsigned short ansU_lo = (unsigned short)min(min(aU_lo, bU_lo), cU_lo);
	unsigned short ansU_hi = (unsigned short)min(min(aU_hi, bU_hi), cU_hi);
	res = (((unsigned)ansU_lo) | (((unsigned)ansU_hi) << 16));
	return res;
}
static inline int __vimax3_s32_relu(const int a, const int b, const int c)
{
	int ans = max(max(a, b), c);
	return (ans > 0) ? ans : 0;
}
static inline unsigned __vimax3_s16x2_relu(const unsigned a, const unsigned b,
					   const unsigned c)
{
	unsigned res;
	unsigned short aU_lo = (unsigned short)(a & 65535U);
	unsigned short aU_hi = (unsigned short)(a >> 16);
	unsigned short bU_lo = (unsigned short)(b & 65535U);
	unsigned short bU_hi = (unsigned short)(b >> 16);
	unsigned short cU_lo = (unsigned short)(c & 65535U);
	unsigned short cU_hi = (unsigned short)(c >> 16);
	short aS_lo = __internal_cast_u2s(aU_lo);
	short aS_hi = __internal_cast_u2s(aU_hi);
	short bS_lo = __internal_cast_u2s(bU_lo);
	short bS_hi = __internal_cast_u2s(bU_hi);
	short cS_lo = __internal_cast_u2s(cU_lo);
	short cS_hi = __internal_cast_u2s(cU_hi);
	unsigned ansU_lo = (unsigned)max(0, max(max(aS_lo, bS_lo), cS_lo));
	unsigned ansU_hi = (unsigned)max(0, max(max(aS_hi, bS_hi), cS_hi));
	res = (ansU_lo | (ansU_hi << 16));
	return res;
}
static inline int __vimin3_s32_relu(const int a, const int b, const int c)
{
	int ans = min(min(a, b), c);
	return (ans > 0) ? ans : 0;
}
static inline unsigned __vimin3_s16x2_relu(const unsigned a, const unsigned b,
					   const unsigned c)
{
	unsigned res;
	unsigned short aU_lo = (unsigned short)(a & 65535U);
	unsigned short aU_hi = (unsigned short)(a >> 16);
	unsigned short bU_lo = (unsigned short)(b & 65535U);
	unsigned short bU_hi = (unsigned short)(b >> 16);
	unsigned short cU_lo = (unsigned short)(c & 65535U);
	unsigned short cU_hi = (unsigned short)(c >> 16);
	short aS_lo = __internal_cast_u2s(aU_lo);
	short aS_hi = __internal_cast_u2s(aU_hi);
	short bS_lo = __internal_cast_u2s(bU_lo);
	short bS_hi = __internal_cast_u2s(bU_hi);
	short cS_lo = __internal_cast_u2s(cU_lo);
	short cS_hi = __internal_cast_u2s(cU_hi);
	unsigned ansU_lo = (unsigned)max(0, min(min(aS_lo, bS_lo), cS_lo));
	unsigned ansU_hi = (unsigned)max(0, min(min(aS_hi, bS_hi), cS_hi));
	res = (ansU_lo | (ansU_hi << 16));
	return res;
}
static inline int __viaddmax_s32(const int a, const int b, const int c)
{
	return max(a + b, c);
}
static inline unsigned __viaddmax_s16x2(const unsigned a, const unsigned b,
					const unsigned c)
{
	unsigned res;
	unsigned short aU_lo = (unsigned short)(a & 65535U);
	unsigned short aU_hi = (unsigned short)(a >> 16);
	unsigned short bU_lo = (unsigned short)(b & 65535U);
	unsigned short bU_hi = (unsigned short)(b >> 16);
	unsigned short cU_lo = (unsigned short)(c & 65535U);
	unsigned short cU_hi = (unsigned short)(c >> 16);
	aU_lo += bU_lo;
	aU_hi += bU_hi;
	short sS_lo = __internal_cast_u2s(aU_lo);
	short sS_hi = __internal_cast_u2s(aU_hi);
	short cS_lo = __internal_cast_u2s(cU_lo);
	short cS_hi = __internal_cast_u2s(cU_hi);
	unsigned ansU_lo = (unsigned)max(sS_lo, cS_lo);
	unsigned ansU_hi = (unsigned)max(sS_hi, cS_hi);
	res = ((ansU_lo & 65535U) | (ansU_hi << 16));
	return res;
}
static inline unsigned __viaddmax_u32(const unsigned a, const unsigned b,
				      const unsigned c)
{
	return max(a + b, c);
}
static inline unsigned __viaddmax_u16x2(const unsigned a, const unsigned b,
					const unsigned c)
{
	unsigned res;
	unsigned short aU_lo = (unsigned short)(a & 65535U);
	unsigned short aU_hi = (unsigned short)(a >> 16);
	unsigned short bU_lo = (unsigned short)(b & 65535U);
	unsigned short bU_hi = (unsigned short)(b >> 16);
	unsigned short cU_lo = (unsigned short)(c & 65535U);
	unsigned short cU_hi = (unsigned short)(c >> 16);
	unsigned short ansU_lo =
		(unsigned short)max((unsigned short)(aU_lo + bU_lo), cU_lo);
	unsigned short ansU_hi =
		(unsigned short)max((unsigned short)(aU_hi + bU_hi), cU_hi);
	res = (((unsigned)ansU_lo) | (((unsigned)ansU_hi) << 16));
	return res;
}
static inline int __viaddmin_s32(const int a, const int b, const int c)
{
	return min(a + b, c);
}
static inline unsigned __viaddmin_s16x2(const unsigned a, const unsigned b,
					const unsigned c)
{
	unsigned res;
	unsigned short aU_lo = (unsigned short)(a & 65535U);
	unsigned short aU_hi = (unsigned short)(a >> 16);
	unsigned short bU_lo = (unsigned short)(b & 65535U);
	unsigned short bU_hi = (unsigned short)(b >> 16);
	unsigned short cU_lo = (unsigned short)(c & 65535U);
	unsigned short cU_hi = (unsigned short)(c >> 16);
	aU_lo += bU_lo;
	aU_hi += bU_hi;
	short sS_lo = __internal_cast_u2s(aU_lo);
	short sS_hi = __internal_cast_u2s(aU_hi);
	short cS_lo = __internal_cast_u2s(cU_lo);
	short cS_hi = __internal_cast_u2s(cU_hi);
	unsigned ansU_lo = (unsigned)min(sS_lo, cS_lo);
	unsigned ansU_hi = (unsigned)min(sS_hi, cS_hi);
	res = ((ansU_lo & 65535U) | (ansU_hi << 16));
	return res;
}
static inline unsigned __viaddmin_u32(const unsigned a, const unsigned b,
				      const unsigned c)
{
	return min(a + b, c);
}
static inline unsigned __viaddmin_u16x2(const unsigned a, const unsigned b,
					const unsigned c)
{
	unsigned res;
	unsigned short aU_lo = (unsigned short)(a & 65535U);
	unsigned short aU_hi = (unsigned short)(a >> 16);
	unsigned short bU_lo = (unsigned short)(b & 65535U);
	unsigned short bU_hi = (unsigned short)(b >> 16);
	unsigned short cU_lo = (unsigned short)(c & 65535U);
	unsigned short cU_hi = (unsigned short)(c >> 16);
	unsigned short ansU_lo =
		(unsigned short)min((unsigned short)(aU_lo + bU_lo), cU_lo);
	unsigned short ansU_hi =
		(unsigned short)min((unsigned short)(aU_hi + bU_hi), cU_hi);
	res = (((unsigned)ansU_lo) | (((unsigned)ansU_hi) << 16));
	return res;
}
static inline int __viaddmax_s32_relu(const int a, const int b, const int c)
{
	int ans = max(a + b, c);
	return (ans > 0) ? ans : 0;
}
static inline unsigned __viaddmax_s16x2_relu(const unsigned a, const unsigned b,
					     const unsigned c)
{
	unsigned res;
	unsigned short aU_lo = (unsigned short)(a & 65535U);
	unsigned short aU_hi = (unsigned short)(a >> 16);
	unsigned short bU_lo = (unsigned short)(b & 65535U);
	unsigned short bU_hi = (unsigned short)(b >> 16);
	unsigned short cU_lo = (unsigned short)(c & 65535U);
	unsigned short cU_hi = (unsigned short)(c >> 16);
	aU_lo += bU_lo;
	aU_hi += bU_hi;
	short sS_lo = __internal_cast_u2s(aU_lo);
	short sS_hi = __internal_cast_u2s(aU_hi);
	short cS_lo = __internal_cast_u2s(cU_lo);
	short cS_hi = __internal_cast_u2s(cU_hi);
	unsigned ansU_lo = (unsigned)max(0, max(sS_lo, cS_lo));
	unsigned ansU_hi = (unsigned)max(0, max(sS_hi, cS_hi));
	res = (ansU_lo | (ansU_hi << 16));
	return res;
}
static inline int __viaddmin_s32_relu(const int a, const int b, const int c)
{
	int ans = min(a + b, c);
	return (ans > 0) ? ans : 0;
}
static inline unsigned __viaddmin_s16x2_relu(const unsigned a, const unsigned b,
					     const unsigned c)
{
	unsigned res;
	unsigned short aU_lo = (unsigned short)(a & 65535U);
	unsigned short aU_hi = (unsigned short)(a >> 16);
	unsigned short bU_lo = (unsigned short)(b & 65535U);
	unsigned short bU_hi = (unsigned short)(b >> 16);
	unsigned short cU_lo = (unsigned short)(c & 65535U);
	unsigned short cU_hi = (unsigned short)(c >> 16);
	aU_lo += bU_lo;
	aU_hi += bU_hi;
	short sS_lo = __internal_cast_u2s(aU_lo);
	short sS_hi = __internal_cast_u2s(aU_hi);
	short cS_lo = __internal_cast_u2s(cU_lo);
	short cS_hi = __internal_cast_u2s(cU_hi);
	unsigned ansU_lo = (unsigned)max(0, min(sS_lo, cS_lo));
	unsigned ansU_hi = (unsigned)max(0, min(sS_hi, cS_hi));
	res = (ansU_lo | (ansU_hi << 16));
	return res;
}
static inline int __vibmax_s32(const int a, const int b, bool *const pred)
{
	int ans = max(a, b);
	(*pred) = (a >= b);
	return ans;
}
static inline unsigned __vibmax_u32(const unsigned a, const unsigned b,
				    bool *const pred)
{
	unsigned ans = max(a, b);
	(*pred) = (a >= b);
	return ans;
}
static inline int __vibmin_s32(const int a, const int b, bool *const pred)
{
	int ans = min(a, b);
	(*pred) = (a <= b);
	return ans;
}
static inline unsigned __vibmin_u32(const unsigned a, const unsigned b,
				    bool *const pred)
{
	unsigned ans = min(a, b);
	(*pred) = (a <= b);
	return ans;
}
static inline unsigned __vibmax_s16x2(const unsigned a, const unsigned b,
				      bool *const pred_hi, bool *const pred_lo)
{
	unsigned short aU_lo = (unsigned short)(a & 65535U);
	unsigned short aU_hi = (unsigned short)(a >> 16);
	unsigned short bU_lo = (unsigned short)(b & 65535U);
	unsigned short bU_hi = (unsigned short)(b >> 16);
	short aS_lo = __internal_cast_u2s(aU_lo);
	short aS_hi = __internal_cast_u2s(aU_hi);
	short bS_lo = __internal_cast_u2s(bU_lo);
	short bS_hi = __internal_cast_u2s(bU_hi);
	unsigned ansU_lo = (unsigned)max(aS_lo, bS_lo);
	unsigned ansU_hi = (unsigned)max(aS_hi, bS_hi);
	(*pred_hi) = (aS_hi >= bS_hi);
	(*pred_lo) = (aS_lo >= bS_lo);
	unsigned ans = (ansU_lo & 65535U) | (ansU_hi << 16);
	return ans;
}
static inline unsigned __vibmax_u16x2(const unsigned a, const unsigned b,
				      bool *const pred_hi, bool *const pred_lo)
{
	unsigned short aU_lo = (unsigned short)(a & 65535U);
	unsigned short aU_hi = (unsigned short)(a >> 16);
	unsigned short bU_lo = (unsigned short)(b & 65535U);
	unsigned short bU_hi = (unsigned short)(b >> 16);
	unsigned short ansU_lo = (unsigned short)max(aU_lo, bU_lo);
	unsigned short ansU_hi = (unsigned short)max(aU_hi, bU_hi);
	(*pred_hi) = (aU_hi >= bU_hi);
	(*pred_lo) = (aU_lo >= bU_lo);
	unsigned ans = ((unsigned)ansU_lo) | (((unsigned)ansU_hi) << 16);
	return ans;
}
static inline unsigned __vibmin_s16x2(const unsigned a, const unsigned b,
				      bool *const pred_hi, bool *const pred_lo)
{
	unsigned short aU_lo = (unsigned short)(a & 65535U);
	unsigned short aU_hi = (unsigned short)(a >> 16);
	unsigned short bU_lo = (unsigned short)(b & 65535U);
	unsigned short bU_hi = (unsigned short)(b >> 16);
	short aS_lo = __internal_cast_u2s(aU_lo);
	short aS_hi = __internal_cast_u2s(aU_hi);
	short bS_lo = __internal_cast_u2s(bU_lo);
	short bS_hi = __internal_cast_u2s(bU_hi);
	unsigned ansU_lo = (unsigned)min(aS_lo, bS_lo);
	unsigned ansU_hi = (unsigned)min(aS_hi, bS_hi);
	(*pred_hi) = (aS_hi <= bS_hi);
	(*pred_lo) = (aS_lo <= bS_lo);
	unsigned ans = (ansU_lo & 65535U) | (ansU_hi << 16);
	return ans;
}
static inline unsigned __vibmin_u16x2(const unsigned a, const unsigned b,
				      bool *const pred_hi, bool *const pred_lo)
{
	unsigned short aU_lo = (unsigned short)(a & 65535U);
	unsigned short aU_hi = (unsigned short)(a >> 16);
	unsigned short bU_lo = (unsigned short)(b & 65535U);
	unsigned short bU_hi = (unsigned short)(b >> 16);
	unsigned short ansU_lo = (unsigned short)min(aU_lo, bU_lo);
	unsigned short ansU_hi = (unsigned short)min(aU_hi, bU_hi);
	(*pred_hi) = (aU_hi <= bU_hi);
	(*pred_lo) = (aU_lo <= bU_lo);
	unsigned ans = ((unsigned)ansU_lo) | (((unsigned)ansU_hi) << 16);
	return ans;
}
__attribute__((unused)) static inline int atomicAdd(int *address, int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned atomicAdd(unsigned *address,
							 unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicSub(int *address, int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned atomicSub(unsigned *address,
							 unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicExch(int *address, int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned atomicExch(unsigned *address,
							  unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline float atomicExch(float *address,
						       float val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicMin(int *address, int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned atomicMin(unsigned *address,
							 unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicMax(int *address, int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned atomicMax(unsigned *address,
							 unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned atomicInc(unsigned *address,
							 unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned atomicDec(unsigned *address,
							 unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicAnd(int *address, int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned atomicAnd(unsigned *address,
							 unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicOr(int *address, int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned atomicOr(unsigned *address,
							unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicXor(int *address, int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned atomicXor(unsigned *address,
							 unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicCAS(int *address, int compare,
						    int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)compare;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
atomicCAS(unsigned *address, unsigned compare, unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)compare;
	(void)val;
	::exit(___);
}
extern "C" {
}
__attribute__((unused)) static inline unsigned long long
atomicAdd(unsigned long long *address, unsigned long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
atomicExch(unsigned long long *address, unsigned long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
atomicCAS(unsigned long long *address, unsigned long long compare,
	  unsigned long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)compare;
	(void)val;
	::exit(___);
}
__attribute((deprecated(
	"__any() is deprecated in favor of __any_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppr"
	"ess this warning)."))) __attribute__((unused)) static inline bool
any(bool cond)
{
	int volatile ___ = 1;
	(void)cond;
	::exit(___);
}
__attribute((deprecated(
	"__all() is deprecated in favor of __all_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppr"
	"ess this warning)."))) __attribute__((unused)) static inline bool
all(bool cond)
{
	int volatile ___ = 1;
	(void)cond;
	::exit(___);
}
extern "C" {
}
__attribute__((unused)) static inline double fma(double a, double b, double c,
						 cudaRoundMode mode);
__attribute__((unused)) static inline double
dmul(double a, double b, cudaRoundMode mode = cudaRoundNearest);
__attribute__((unused)) static inline double
dadd(double a, double b, cudaRoundMode mode = cudaRoundNearest);
__attribute__((unused)) static inline double
dsub(double a, double b, cudaRoundMode mode = cudaRoundNearest);
__attribute__((unused)) static inline int
double2int(double a, cudaRoundMode mode = cudaRoundZero);
__attribute__((unused)) static inline unsigned
double2uint(double a, cudaRoundMode mode = cudaRoundZero);
__attribute__((unused)) static inline long long
double2ll(double a, cudaRoundMode mode = cudaRoundZero);
__attribute__((unused)) static inline unsigned long long
double2ull(double a, cudaRoundMode mode = cudaRoundZero);
__attribute__((unused)) static inline double
ll2double(long long a, cudaRoundMode mode = cudaRoundNearest);
__attribute__((unused)) static inline double
ull2double(unsigned long long a, cudaRoundMode mode = cudaRoundNearest);
__attribute__((unused)) static inline double
int2double(int a, cudaRoundMode mode = cudaRoundNearest);
__attribute__((unused)) static inline double
uint2double(unsigned a, cudaRoundMode mode = cudaRoundNearest);
__attribute__((unused)) static inline double
float2double(float a, cudaRoundMode mode = cudaRoundNearest);
__attribute__((unused)) static inline double fma(double a, double b, double c,
						 cudaRoundMode mode)
{
	int volatile ___ = 1;
	(void)a;
	(void)b;
	(void)c;
	(void)mode;
	::exit(___);
}
__attribute__((unused)) static inline double dmul(double a, double b,
						  cudaRoundMode mode)
{
	int volatile ___ = 1;
	(void)a;
	(void)b;
	(void)mode;
	::exit(___);
}
__attribute__((unused)) static inline double dadd(double a, double b,
						  cudaRoundMode mode)
{
	int volatile ___ = 1;
	(void)a;
	(void)b;
	(void)mode;
	::exit(___);
}
__attribute__((unused)) static inline double dsub(double a, double b,
						  cudaRoundMode mode)
{
	int volatile ___ = 1;
	(void)a;
	(void)b;
	(void)mode;
	::exit(___);
}
__attribute__((unused)) static inline int double2int(double a,
						     cudaRoundMode mode)
{
	int volatile ___ = 1;
	(void)a;
	(void)mode;
	::exit(___);
}
__attribute__((unused)) static inline unsigned double2uint(double a,
							   cudaRoundMode mode)
{
	int volatile ___ = 1;
	(void)a;
	(void)mode;
	::exit(___);
}
__attribute__((unused)) static inline long long double2ll(double a,
							  cudaRoundMode mode)
{
	int volatile ___ = 1;
	(void)a;
	(void)mode;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
double2ull(double a, cudaRoundMode mode)
{
	int volatile ___ = 1;
	(void)a;
	(void)mode;
	::exit(___);
}
__attribute__((unused)) static inline double ll2double(long long a,
						       cudaRoundMode mode)
{
	int volatile ___ = 1;
	(void)a;
	(void)mode;
	::exit(___);
}
__attribute__((unused)) static inline double ull2double(unsigned long long a,
							cudaRoundMode mode)
{
	int volatile ___ = 1;
	(void)a;
	(void)mode;
	::exit(___);
}
__attribute__((unused)) static inline double int2double(int a,
							cudaRoundMode mode)
{
	int volatile ___ = 1;
	(void)a;
	(void)mode;
	::exit(___);
}
__attribute__((unused)) static inline double uint2double(unsigned a,
							 cudaRoundMode mode)
{
	int volatile ___ = 1;
	(void)a;
	(void)mode;
	::exit(___);
}
__attribute__((unused)) static inline double float2double(float a,
							  cudaRoundMode mode)
{
	int volatile ___ = 1;
	(void)a;
	(void)mode;
	::exit(___);
}
__attribute__((unused)) static inline float atomicAdd(float *address, float val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline long long atomicMin(long long *address,
							  long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline long long atomicMax(long long *address,
							  long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline long long atomicAnd(long long *address,
							  long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline long long atomicOr(long long *address,
							 long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline long long atomicXor(long long *address,
							  long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
atomicMin(unsigned long long *address, unsigned long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
atomicMax(unsigned long long *address, unsigned long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
atomicAnd(unsigned long long *address, unsigned long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
atomicOr(unsigned long long *address, unsigned long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
atomicXor(unsigned long long *address, unsigned long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline double atomicAdd(double *address,
						       double val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicAdd_block(int *address, int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicAdd_system(int *address,
							   int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
atomicAdd_block(unsigned *address, unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
atomicAdd_system(unsigned *address, unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
atomicAdd_block(unsigned long long *address, unsigned long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
atomicAdd_system(unsigned long long *address, unsigned long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline float atomicAdd_block(float *address,
							    float val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline float atomicAdd_system(float *address,
							     float val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline double atomicAdd_block(double *address,
							     double val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline double atomicAdd_system(double *address,
							      double val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicSub_block(int *address, int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicSub_system(int *address,
							   int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
atomicSub_block(unsigned *address, unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
atomicSub_system(unsigned *address, unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicExch_block(int *address,
							   int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicExch_system(int *address,
							    int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
atomicExch_block(unsigned *address, unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
atomicExch_system(unsigned *address, unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
atomicExch_block(unsigned long long *address, unsigned long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
atomicExch_system(unsigned long long *address, unsigned long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline float atomicExch_block(float *address,
							     float val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline float atomicExch_system(float *address,
							      float val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicMin_block(int *address, int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicMin_system(int *address,
							   int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline long long
atomicMin_block(long long *address, long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline long long
atomicMin_system(long long *address, long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
atomicMin_block(unsigned *address, unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
atomicMin_system(unsigned *address, unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
atomicMin_block(unsigned long long *address, unsigned long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
atomicMin_system(unsigned long long *address, unsigned long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicMax_block(int *address, int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicMax_system(int *address,
							   int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline long long
atomicMax_block(long long *address, long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline long long
atomicMax_system(long long *address, long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
atomicMax_block(unsigned *address, unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
atomicMax_system(unsigned *address, unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
atomicMax_block(unsigned long long *address, unsigned long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
atomicMax_system(unsigned long long *address, unsigned long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
atomicInc_block(unsigned *address, unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
atomicInc_system(unsigned *address, unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
atomicDec_block(unsigned *address, unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
atomicDec_system(unsigned *address, unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicCAS_block(int *address,
							  int compare, int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)compare;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicCAS_system(int *address,
							   int compare, int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)compare;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
atomicCAS_block(unsigned *address, unsigned compare, unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)compare;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
atomicCAS_system(unsigned *address, unsigned compare, unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)compare;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
atomicCAS_block(unsigned long long *address, unsigned long long compare,
		unsigned long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)compare;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
atomicCAS_system(unsigned long long *address, unsigned long long compare,
		 unsigned long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)compare;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicAnd_block(int *address, int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicAnd_system(int *address,
							   int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline long long
atomicAnd_block(long long *address, long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline long long
atomicAnd_system(long long *address, long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
atomicAnd_block(unsigned *address, unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
atomicAnd_system(unsigned *address, unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
atomicAnd_block(unsigned long long *address, unsigned long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
atomicAnd_system(unsigned long long *address, unsigned long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicOr_block(int *address, int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicOr_system(int *address, int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline long long
atomicOr_block(long long *address, long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline long long
atomicOr_system(long long *address, long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned atomicOr_block(unsigned *address,
							      unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
atomicOr_system(unsigned *address, unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
atomicOr_block(unsigned long long *address, unsigned long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
atomicOr_system(unsigned long long *address, unsigned long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicXor_block(int *address, int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline int atomicXor_system(int *address,
							   int val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline long long
atomicXor_block(long long *address, long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline long long
atomicXor_system(long long *address, long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
atomicXor_block(unsigned *address, unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
atomicXor_system(unsigned *address, unsigned val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
atomicXor_block(unsigned long long *address, unsigned long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
atomicXor_system(unsigned long long *address, unsigned long long val)
{
	int volatile ___ = 1;
	(void)address;
	(void)val;
	::exit(___);
}
extern "C" {
}
__attribute((deprecated(
	"__ballot() is deprecated in favor of __ballot_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to"
	" suppress this warning).")))
__attribute__((unused)) static inline unsigned
ballot(bool pred)
{
	int volatile ___ = 1;
	(void)pred;
	::exit(___);
}
__attribute__((unused)) static inline int syncthreads_count(bool pred)
{
	int volatile ___ = 1;
	(void)pred;
	::exit(___);
}
__attribute__((unused)) static inline bool syncthreads_and(bool pred)
{
	int volatile ___ = 1;
	(void)pred;
	::exit(___);
}
__attribute__((unused)) static inline bool syncthreads_or(bool pred)
{
	int volatile ___ = 1;
	(void)pred;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __isGlobal(const void *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __isShared(const void *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __isConstant(const void *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __isLocal(const void *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __isGridConstant(const void *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline size_t
__cvta_generic_to_global(const void *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline size_t
__cvta_generic_to_shared(const void *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline size_t
__cvta_generic_to_constant(const void *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline size_t
__cvta_generic_to_local(const void *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline size_t
__cvta_generic_to_grid_constant(const void *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline void *
__cvta_global_to_generic(size_t rawbits)
{
	int volatile ___ = 1;
	(void)rawbits;
	::exit(___);
}
__attribute__((unused)) static inline void *
__cvta_shared_to_generic(size_t rawbits)
{
	int volatile ___ = 1;
	(void)rawbits;
	::exit(___);
}
__attribute__((unused)) static inline void *
__cvta_constant_to_generic(size_t rawbits)
{
	int volatile ___ = 1;
	(void)rawbits;
	::exit(___);
}
__attribute__((unused)) static inline void *
__cvta_local_to_generic(size_t rawbits)
{
	int volatile ___ = 1;
	(void)rawbits;
	::exit(___);
}
__attribute__((unused)) static inline void *
__cvta_grid_constant_to_generic(size_t rawbits)
{
	int volatile ___ = 1;
	(void)rawbits;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __fns(unsigned mask,
						     unsigned base, int offset)
{
	int volatile ___ = 1;
	(void)mask;
	(void)base;
	(void)offset;
	::exit(___);
}
__attribute__((unused)) static inline void __barrier_sync(unsigned id)
{
	int volatile ___ = 1;
	(void)id;
	::exit(___);
}
__attribute__((unused)) static inline void __barrier_sync_count(unsigned id,
								unsigned cnt)
{
	int volatile ___ = 1;
	(void)id;
	(void)cnt;
	::exit(___);
}
__attribute__((unused)) static inline void
__syncwarp(unsigned mask = 4294967295U)
{
	int volatile ___ = 1;
	(void)mask;
	::exit(___);
}
__attribute__((unused)) static inline int __all_sync(unsigned mask, int pred)
{
	int volatile ___ = 1;
	(void)mask;
	(void)pred;
	::exit(___);
}
__attribute__((unused)) static inline int __any_sync(unsigned mask, int pred)
{
	int volatile ___ = 1;
	(void)mask;
	(void)pred;
	::exit(___);
}
__attribute__((unused)) static inline int __uni_sync(unsigned mask, int pred)
{
	int volatile ___ = 1;
	(void)mask;
	(void)pred;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __ballot_sync(unsigned mask,
							     int pred)
{
	int volatile ___ = 1;
	(void)mask;
	(void)pred;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __activemask()
{
	int volatile ___ = 1;
	::exit(___);
}
__attribute((deprecated(
	"__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup"
	"press this warning)."))) __attribute__((unused)) static inline int
__shfl(int var, int srcLane, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)srcLane;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup"
	"press this warning)."))) __attribute__((unused)) static inline unsigned
__shfl(unsigned var, int srcLane, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)srcLane;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations "
	"to suppress this warning).")))
__attribute__((unused)) static inline int
__shfl_up(int var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations "
	"to suppress this warning).")))
__attribute__((unused)) static inline unsigned
__shfl_up(unsigned var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati"
	"ons to suppress this warning).")))
__attribute__((unused)) static inline int
__shfl_down(int var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati"
	"ons to suppress this warning).")))
__attribute__((unused)) static inline unsigned
__shfl_down(unsigned var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration"
	"s to suppress this warning).")))
__attribute__((unused)) static inline int
__shfl_xor(int var, int laneMask, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)laneMask;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration"
	"s to suppress this warning).")))
__attribute__((unused)) static inline unsigned
__shfl_xor(unsigned var, int laneMask, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)laneMask;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup"
	"press this warning)."))) __attribute__((unused)) static inline float
__shfl(float var, int srcLane, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)srcLane;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations "
	"to suppress this warning).")))
__attribute__((unused)) static inline float
__shfl_up(float var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati"
	"ons to suppress this warning).")))
__attribute__((unused)) static inline float
__shfl_down(float var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration"
	"s to suppress this warning).")))
__attribute__((unused)) static inline float
__shfl_xor(float var, int laneMask, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)laneMask;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline int
__shfl_sync(unsigned mask, int var, int srcLane, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)srcLane;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
__shfl_sync(unsigned mask, unsigned var, int srcLane, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)srcLane;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline int
__shfl_up_sync(unsigned mask, int var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
__shfl_up_sync(unsigned mask, unsigned var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline int
__shfl_down_sync(unsigned mask, int var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
__shfl_down_sync(unsigned mask, unsigned var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline int
__shfl_xor_sync(unsigned mask, int var, int laneMask, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)laneMask;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
__shfl_xor_sync(unsigned mask, unsigned var, int laneMask, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)laneMask;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline float
__shfl_sync(unsigned mask, float var, int srcLane, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)srcLane;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline float
__shfl_up_sync(unsigned mask, float var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline float
__shfl_down_sync(unsigned mask, float var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline float
__shfl_xor_sync(unsigned mask, float var, int laneMask, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)laneMask;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup"
	"press this warning).")))
__attribute__((unused)) static inline unsigned long long
__shfl(unsigned long long var, int srcLane, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)srcLane;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup"
	"press this warning).")))
__attribute__((unused)) static inline long long
__shfl(long long var, int srcLane, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)srcLane;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations "
	"to suppress this warning).")))
__attribute__((unused)) static inline long long
__shfl_up(long long var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations "
	"to suppress this warning).")))
__attribute__((unused)) static inline unsigned long long
__shfl_up(unsigned long long var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati"
	"ons to suppress this warning).")))
__attribute__((unused)) static inline long long
__shfl_down(long long var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati"
	"ons to suppress this warning).")))
__attribute__((unused)) static inline unsigned long long
__shfl_down(unsigned long long var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration"
	"s to suppress this warning).")))
__attribute__((unused)) static inline long long
__shfl_xor(long long var, int laneMask, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)laneMask;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration"
	"s to suppress this warning).")))
__attribute__((unused)) static inline unsigned long long
__shfl_xor(unsigned long long var, int laneMask, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)laneMask;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup"
	"press this warning)."))) __attribute__((unused)) static inline double
__shfl(double var, int srcLane, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)srcLane;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations "
	"to suppress this warning).")))
__attribute__((unused)) static inline double
__shfl_up(double var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati"
	"ons to suppress this warning).")))
__attribute__((unused)) static inline double
__shfl_down(double var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration"
	"s to suppress this warning).")))
__attribute__((unused)) static inline double
__shfl_xor(double var, int laneMask, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)laneMask;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline long long
__shfl_sync(unsigned mask, long long var, int srcLane, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)srcLane;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
__shfl_sync(unsigned mask, unsigned long long var, int srcLane, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)srcLane;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline long long
__shfl_up_sync(unsigned mask, long long var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
__shfl_up_sync(unsigned mask, unsigned long long var, unsigned delta,
	       int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline long long
__shfl_down_sync(unsigned mask, long long var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
__shfl_down_sync(unsigned mask, unsigned long long var, unsigned delta,
		 int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline long long
__shfl_xor_sync(unsigned mask, long long var, int laneMask, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)laneMask;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
__shfl_xor_sync(unsigned mask, unsigned long long var, int laneMask,
		int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)laneMask;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline double
__shfl_sync(unsigned mask, double var, int srcLane, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)srcLane;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline double
__shfl_up_sync(unsigned mask, double var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline double
__shfl_down_sync(unsigned mask, double var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline double
__shfl_xor_sync(unsigned mask, double var, int laneMask, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)laneMask;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup"
	"press this warning)."))) __attribute__((unused)) static inline long
__shfl(long var, int srcLane, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)srcLane;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup"
	"press this warning).")))
__attribute__((unused)) static inline unsigned long
__shfl(unsigned long var, int srcLane, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)srcLane;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations "
	"to suppress this warning).")))
__attribute__((unused)) static inline long
__shfl_up(long var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations "
	"to suppress this warning).")))
__attribute__((unused)) static inline unsigned long
__shfl_up(unsigned long var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati"
	"ons to suppress this warning).")))
__attribute__((unused)) static inline long
__shfl_down(long var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati"
	"ons to suppress this warning).")))
__attribute__((unused)) static inline unsigned long
__shfl_down(unsigned long var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration"
	"s to suppress this warning).")))
__attribute__((unused)) static inline long
__shfl_xor(long var, int laneMask, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)laneMask;
	(void)width;
	::exit(___);
}
__attribute((deprecated(
	"__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration"
	"s to suppress this warning).")))
__attribute__((unused)) static inline unsigned long
__shfl_xor(unsigned long var, int laneMask, int width = 32)
{
	int volatile ___ = 1;
	(void)var;
	(void)laneMask;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline long
__shfl_sync(unsigned mask, long var, int srcLane, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)srcLane;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long
__shfl_sync(unsigned mask, unsigned long var, int srcLane, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)srcLane;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline long
__shfl_up_sync(unsigned mask, long var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long
__shfl_up_sync(unsigned mask, unsigned long var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline long
__shfl_down_sync(unsigned mask, long var, unsigned delta, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long
__shfl_down_sync(unsigned mask, unsigned long var, unsigned delta,
		 int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)delta;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline long
__shfl_xor_sync(unsigned mask, long var, int laneMask, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)laneMask;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long
__shfl_xor_sync(unsigned mask, unsigned long var, int laneMask, int width = 32)
{
	int volatile ___ = 1;
	(void)mask;
	(void)var;
	(void)laneMask;
	(void)width;
	::exit(___);
}
__attribute__((unused)) static inline long __ldg(const long *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long
__ldg(const unsigned long *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline char __ldg(const char *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline signed char __ldg(const signed char *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline short __ldg(const short *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline int __ldg(const int *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline long long __ldg(const long long *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline char2 __ldg(const char2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline char4 __ldg(const char4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline short2 __ldg(const short2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline short4 __ldg(const short4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline int2 __ldg(const int2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline int4 __ldg(const int4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline longlong2 __ldg(const longlong2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned char
__ldg(const unsigned char *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned short
__ldg(const unsigned short *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __ldg(const unsigned *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
__ldg(const unsigned long long *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uchar2 __ldg(const uchar2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uchar4 __ldg(const uchar4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline ushort2 __ldg(const ushort2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline ushort4 __ldg(const ushort4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uint2 __ldg(const uint2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uint4 __ldg(const uint4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline ulonglong2 __ldg(const ulonglong2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline float __ldg(const float *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline double __ldg(const double *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline float2 __ldg(const float2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline float4 __ldg(const float4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline double2 __ldg(const double2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline long __ldcg(const long *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long
__ldcg(const unsigned long *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline char __ldcg(const char *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline signed char __ldcg(const signed char *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline short __ldcg(const short *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline int __ldcg(const int *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline long long __ldcg(const long long *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline char2 __ldcg(const char2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline char4 __ldcg(const char4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline short2 __ldcg(const short2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline short4 __ldcg(const short4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline int2 __ldcg(const int2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline int4 __ldcg(const int4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline longlong2 __ldcg(const longlong2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned char
__ldcg(const unsigned char *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned short
__ldcg(const unsigned short *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __ldcg(const unsigned *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
__ldcg(const unsigned long long *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uchar2 __ldcg(const uchar2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uchar4 __ldcg(const uchar4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline ushort2 __ldcg(const ushort2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline ushort4 __ldcg(const ushort4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uint2 __ldcg(const uint2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uint4 __ldcg(const uint4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline ulonglong2 __ldcg(const ulonglong2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline float __ldcg(const float *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline double __ldcg(const double *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline float2 __ldcg(const float2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline float4 __ldcg(const float4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline double2 __ldcg(const double2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline long __ldca(const long *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long
__ldca(const unsigned long *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline char __ldca(const char *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline signed char __ldca(const signed char *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline short __ldca(const short *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline int __ldca(const int *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline long long __ldca(const long long *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline char2 __ldca(const char2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline char4 __ldca(const char4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline short2 __ldca(const short2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline short4 __ldca(const short4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline int2 __ldca(const int2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline int4 __ldca(const int4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline longlong2 __ldca(const longlong2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned char
__ldca(const unsigned char *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned short
__ldca(const unsigned short *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __ldca(const unsigned *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
__ldca(const unsigned long long *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uchar2 __ldca(const uchar2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uchar4 __ldca(const uchar4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline ushort2 __ldca(const ushort2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline ushort4 __ldca(const ushort4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uint2 __ldca(const uint2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uint4 __ldca(const uint4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline ulonglong2 __ldca(const ulonglong2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline float __ldca(const float *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline double __ldca(const double *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline float2 __ldca(const float2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline float4 __ldca(const float4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline double2 __ldca(const double2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline long __ldcs(const long *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long
__ldcs(const unsigned long *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline char __ldcs(const char *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline signed char __ldcs(const signed char *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline short __ldcs(const short *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline int __ldcs(const int *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline long long __ldcs(const long long *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline char2 __ldcs(const char2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline char4 __ldcs(const char4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline short2 __ldcs(const short2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline short4 __ldcs(const short4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline int2 __ldcs(const int2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline int4 __ldcs(const int4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline longlong2 __ldcs(const longlong2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned char
__ldcs(const unsigned char *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned short
__ldcs(const unsigned short *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __ldcs(const unsigned *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
__ldcs(const unsigned long long *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uchar2 __ldcs(const uchar2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uchar4 __ldcs(const uchar4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline ushort2 __ldcs(const ushort2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline ushort4 __ldcs(const ushort4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uint2 __ldcs(const uint2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uint4 __ldcs(const uint4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline ulonglong2 __ldcs(const ulonglong2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline float __ldcs(const float *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline double __ldcs(const double *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline float2 __ldcs(const float2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline float4 __ldcs(const float4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline double2 __ldcs(const double2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline long __ldlu(const long *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long
__ldlu(const unsigned long *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline char __ldlu(const char *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline signed char __ldlu(const signed char *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline short __ldlu(const short *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline int __ldlu(const int *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline long long __ldlu(const long long *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline char2 __ldlu(const char2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline char4 __ldlu(const char4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline short2 __ldlu(const short2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline short4 __ldlu(const short4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline int2 __ldlu(const int2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline int4 __ldlu(const int4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline longlong2 __ldlu(const longlong2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned char
__ldlu(const unsigned char *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned short
__ldlu(const unsigned short *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __ldlu(const unsigned *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
__ldlu(const unsigned long long *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uchar2 __ldlu(const uchar2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uchar4 __ldlu(const uchar4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline ushort2 __ldlu(const ushort2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline ushort4 __ldlu(const ushort4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uint2 __ldlu(const uint2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uint4 __ldlu(const uint4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline ulonglong2 __ldlu(const ulonglong2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline float __ldlu(const float *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline double __ldlu(const double *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline float2 __ldlu(const float2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline float4 __ldlu(const float4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline double2 __ldlu(const double2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline long __ldcv(const long *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long
__ldcv(const unsigned long *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline char __ldcv(const char *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline signed char __ldcv(const signed char *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline short __ldcv(const short *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline int __ldcv(const int *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline long long __ldcv(const long long *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline char2 __ldcv(const char2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline char4 __ldcv(const char4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline short2 __ldcv(const short2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline short4 __ldcv(const short4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline int2 __ldcv(const int2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline int4 __ldcv(const int4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline longlong2 __ldcv(const longlong2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned char
__ldcv(const unsigned char *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned short
__ldcv(const unsigned short *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __ldcv(const unsigned *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned long long
__ldcv(const unsigned long long *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uchar2 __ldcv(const uchar2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uchar4 __ldcv(const uchar4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline ushort2 __ldcv(const ushort2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline ushort4 __ldcv(const ushort4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uint2 __ldcv(const uint2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uint4 __ldcv(const uint4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline ulonglong2 __ldcv(const ulonglong2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline float __ldcv(const float *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline double __ldcv(const double *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline float2 __ldcv(const float2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline float4 __ldcv(const float4 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline double2 __ldcv(const double2 *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(long *ptr, long value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(unsigned long *ptr,
						  unsigned long value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(char *ptr, char value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(signed char *ptr,
						  signed char value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(short *ptr, short value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(int *ptr, int value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(long long *ptr,
						  long long value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(char2 *ptr, char2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(char4 *ptr, char4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(short2 *ptr, short2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(short4 *ptr, short4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(int2 *ptr, int2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(int4 *ptr, int4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(longlong2 *ptr,
						  longlong2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(unsigned char *ptr,
						  unsigned char value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(unsigned short *ptr,
						  unsigned short value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(unsigned *ptr, unsigned value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(unsigned long long *ptr,
						  unsigned long long value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(uchar2 *ptr, uchar2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(uchar4 *ptr, uchar4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(ushort2 *ptr, ushort2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(ushort4 *ptr, ushort4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(uint2 *ptr, uint2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(uint4 *ptr, uint4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(ulonglong2 *ptr,
						  ulonglong2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(float *ptr, float value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(double *ptr, double value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(float2 *ptr, float2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(float4 *ptr, float4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwb(double2 *ptr, double2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(long *ptr, long value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(unsigned long *ptr,
						  unsigned long value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(char *ptr, char value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(signed char *ptr,
						  signed char value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(short *ptr, short value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(int *ptr, int value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(long long *ptr,
						  long long value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(char2 *ptr, char2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(char4 *ptr, char4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(short2 *ptr, short2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(short4 *ptr, short4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(int2 *ptr, int2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(int4 *ptr, int4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(longlong2 *ptr,
						  longlong2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(unsigned char *ptr,
						  unsigned char value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(unsigned short *ptr,
						  unsigned short value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(unsigned *ptr, unsigned value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(unsigned long long *ptr,
						  unsigned long long value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(uchar2 *ptr, uchar2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(uchar4 *ptr, uchar4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(ushort2 *ptr, ushort2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(ushort4 *ptr, ushort4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(uint2 *ptr, uint2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(uint4 *ptr, uint4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(ulonglong2 *ptr,
						  ulonglong2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(float *ptr, float value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(double *ptr, double value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(float2 *ptr, float2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(float4 *ptr, float4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcg(double2 *ptr, double2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(long *ptr, long value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(unsigned long *ptr,
						  unsigned long value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(char *ptr, char value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(signed char *ptr,
						  signed char value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(short *ptr, short value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(int *ptr, int value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(long long *ptr,
						  long long value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(char2 *ptr, char2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(char4 *ptr, char4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(short2 *ptr, short2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(short4 *ptr, short4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(int2 *ptr, int2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(int4 *ptr, int4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(longlong2 *ptr,
						  longlong2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(unsigned char *ptr,
						  unsigned char value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(unsigned short *ptr,
						  unsigned short value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(unsigned *ptr, unsigned value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(unsigned long long *ptr,
						  unsigned long long value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(uchar2 *ptr, uchar2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(uchar4 *ptr, uchar4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(ushort2 *ptr, ushort2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(ushort4 *ptr, ushort4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(uint2 *ptr, uint2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(uint4 *ptr, uint4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(ulonglong2 *ptr,
						  ulonglong2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(float *ptr, float value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(double *ptr, double value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(float2 *ptr, float2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(float4 *ptr, float4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stcs(double2 *ptr, double2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(long *ptr, long value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(unsigned long *ptr,
						  unsigned long value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(char *ptr, char value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(signed char *ptr,
						  signed char value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(short *ptr, short value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(int *ptr, int value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(long long *ptr,
						  long long value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(char2 *ptr, char2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(char4 *ptr, char4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(short2 *ptr, short2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(short4 *ptr, short4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(int2 *ptr, int2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(int4 *ptr, int4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(longlong2 *ptr,
						  longlong2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(unsigned char *ptr,
						  unsigned char value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(unsigned short *ptr,
						  unsigned short value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(unsigned *ptr, unsigned value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(unsigned long long *ptr,
						  unsigned long long value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(uchar2 *ptr, uchar2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(uchar4 *ptr, uchar4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(ushort2 *ptr, ushort2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(ushort4 *ptr, ushort4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(uint2 *ptr, uint2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(uint4 *ptr, uint4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(ulonglong2 *ptr,
						  ulonglong2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(float *ptr, float value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(double *ptr, double value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(float2 *ptr, float2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(float4 *ptr, float4 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline void __stwt(double2 *ptr, double2 value)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
__funnelshift_l(unsigned lo, unsigned hi, unsigned shift)
{
	int volatile ___ = 1;
	(void)lo;
	(void)hi;
	(void)shift;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
__funnelshift_lc(unsigned lo, unsigned hi, unsigned shift)
{
	int volatile ___ = 1;
	(void)lo;
	(void)hi;
	(void)shift;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
__funnelshift_r(unsigned lo, unsigned hi, unsigned shift)
{
	int volatile ___ = 1;
	(void)lo;
	(void)hi;
	(void)shift;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
__funnelshift_rc(unsigned lo, unsigned hi, unsigned shift)
{
	int volatile ___ = 1;
	(void)lo;
	(void)hi;
	(void)shift;
	::exit(___);
}
__attribute__((unused)) static inline int __dp2a_lo(int srcA, int srcB, int c)
{
	int volatile ___ = 1;
	(void)srcA;
	(void)srcB;
	(void)c;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
__dp2a_lo(unsigned srcA, unsigned srcB, unsigned c)
{
	int volatile ___ = 1;
	(void)srcA;
	(void)srcB;
	(void)c;
	::exit(___);
}
__attribute__((unused)) static inline int __dp2a_lo(short2 srcA, char4 srcB,
						    int c)
{
	int volatile ___ = 1;
	(void)srcA;
	(void)srcB;
	(void)c;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
__dp2a_lo(ushort2 srcA, uchar4 srcB, unsigned c)
{
	int volatile ___ = 1;
	(void)srcA;
	(void)srcB;
	(void)c;
	::exit(___);
}
__attribute__((unused)) static inline int __dp2a_hi(int srcA, int srcB, int c)
{
	int volatile ___ = 1;
	(void)srcA;
	(void)srcB;
	(void)c;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
__dp2a_hi(unsigned srcA, unsigned srcB, unsigned c)
{
	int volatile ___ = 1;
	(void)srcA;
	(void)srcB;
	(void)c;
	::exit(___);
}
__attribute__((unused)) static inline int __dp2a_hi(short2 srcA, char4 srcB,
						    int c)
{
	int volatile ___ = 1;
	(void)srcA;
	(void)srcB;
	(void)c;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
__dp2a_hi(ushort2 srcA, uchar4 srcB, unsigned c)
{
	int volatile ___ = 1;
	(void)srcA;
	(void)srcB;
	(void)c;
	::exit(___);
}
__attribute__((unused)) static inline int __dp4a(int srcA, int srcB, int c)
{
	int volatile ___ = 1;
	(void)srcA;
	(void)srcB;
	(void)c;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __dp4a(unsigned srcA,
						      unsigned srcB, unsigned c)
{
	int volatile ___ = 1;
	(void)srcA;
	(void)srcB;
	(void)c;
	::exit(___);
}
__attribute__((unused)) static inline int __dp4a(char4 srcA, char4 srcB, int c)
{
	int volatile ___ = 1;
	(void)srcA;
	(void)srcB;
	(void)c;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __dp4a(uchar4 srcA, uchar4 srcB,
						      unsigned c)
{
	int volatile ___ = 1;
	(void)srcA;
	(void)srcB;
	(void)c;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __match_any_sync(unsigned mask,
								unsigned value)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __match_any_sync(unsigned mask,
								int value)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
__match_any_sync(unsigned mask, unsigned long value)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __match_any_sync(unsigned mask,
								long value)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
__match_any_sync(unsigned mask, unsigned long long value)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __match_any_sync(unsigned mask,
								long long value)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __match_any_sync(unsigned mask,
								float value)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __match_any_sync(unsigned mask,
								double value)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
__match_all_sync(unsigned mask, unsigned value, int *pred)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	(void)pred;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
__match_all_sync(unsigned mask, int value, int *pred)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	(void)pred;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
__match_all_sync(unsigned mask, unsigned long value, int *pred)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	(void)pred;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
__match_all_sync(unsigned mask, long value, int *pred)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	(void)pred;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
__match_all_sync(unsigned mask, unsigned long long value, int *pred)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	(void)pred;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
__match_all_sync(unsigned mask, long long value, int *pred)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	(void)pred;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
__match_all_sync(unsigned mask, float value, int *pred)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	(void)pred;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
__match_all_sync(unsigned mask, double value, int *pred)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	(void)pred;
	::exit(___);
}
__attribute__((unused)) static inline void __nanosleep(unsigned ns)
{
	int volatile ___ = 1;
	(void)ns;
	::exit(___);
}
__attribute__((unused)) static inline unsigned short
atomicCAS(unsigned short *address, unsigned short compare, unsigned short val)
{
	int volatile ___ = 1;
	(void)address;
	(void)compare;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __reduce_add_sync(unsigned mask,
								 unsigned value)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __reduce_min_sync(unsigned mask,
								 unsigned value)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __reduce_max_sync(unsigned mask,
								 unsigned value)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline int __reduce_add_sync(unsigned mask,
							    int value)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline int __reduce_min_sync(unsigned mask,
							    int value)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline int __reduce_max_sync(unsigned mask,
							    int value)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __reduce_and_sync(unsigned mask,
								 unsigned value)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __reduce_or_sync(unsigned mask,
								unsigned value)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __reduce_xor_sync(unsigned mask,
								 unsigned value)
{
	int volatile ___ = 1;
	(void)mask;
	(void)value;
	::exit(___);
}
extern "C" {
__attribute__((unused)) inline void *
__nv_associate_access_property(const void *ptr, unsigned long long property)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)property;
	::exit(___);
}
__attribute__((unused)) inline void
__nv_memcpy_async_shared_global_4(void *dst, const void *src, unsigned src_size)
{
	int volatile ___ = 1;
	(void)dst;
	(void)src;
	(void)src_size;
	::exit(___);
}
__attribute__((unused)) inline void
__nv_memcpy_async_shared_global_8(void *dst, const void *src, unsigned src_size)
{
	int volatile ___ = 1;
	(void)dst;
	(void)src;
	(void)src_size;
	::exit(___);
}
__attribute__((unused)) inline void
__nv_memcpy_async_shared_global_16(void *dst, const void *src,
				   unsigned src_size)
{
	int volatile ___ = 1;
	(void)dst;
	(void)src;
	(void)src_size;
	::exit(___);
}
}
__attribute__((unused)) static inline unsigned __isCtaShared(const void *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
__isClusterShared(const void *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline void *
__cluster_map_shared_rank(const void *ptr, unsigned target_block_rank)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)target_block_rank;
	::exit(___);
}
__attribute__((unused)) static inline unsigned
__cluster_query_shared_rank(const void *ptr)
{
	int volatile ___ = 1;
	(void)ptr;
	::exit(___);
}
__attribute__((unused)) static inline uint2
__cluster_map_shared_multicast(const void *ptr, unsigned cluster_cta_mask)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)cluster_cta_mask;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __clusterDimIsSpecified()
{
	int volatile ___ = 1;
	::exit(___);
}
__attribute__((unused)) static inline dim3 __clusterDim()
{
	int volatile ___ = 1;
	::exit(___);
}
__attribute__((unused)) static inline dim3 __clusterRelativeBlockIdx()
{
	int volatile ___ = 1;
	::exit(___);
}
__attribute__((unused)) static inline dim3 __clusterGridDimInClusters()
{
	int volatile ___ = 1;
	::exit(___);
}
__attribute__((unused)) static inline dim3 __clusterIdx()
{
	int volatile ___ = 1;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __clusterRelativeBlockRank()
{
	int volatile ___ = 1;
	::exit(___);
}
__attribute__((unused)) static inline unsigned __clusterSizeInBlocks()
{
	int volatile ___ = 1;
	::exit(___);
}
__attribute__((unused)) static inline void __cluster_barrier_arrive()
{
	int volatile ___ = 1;
	::exit(___);
}
__attribute__((unused)) static inline void __cluster_barrier_arrive_relaxed()
{
	int volatile ___ = 1;
	::exit(___);
}
__attribute__((unused)) static inline void __cluster_barrier_wait()
{
	int volatile ___ = 1;
	::exit(___);
}
__attribute__((unused)) static inline void __threadfence_cluster()
{
	int volatile ___ = 1;
	::exit(___);
}
__attribute__((unused)) static inline float2 atomicAdd(float2 *__address,
						       float2 val)
{
	int volatile ___ = 1;
	(void)__address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline float2 atomicAdd_block(float2 *__address,
							     float2 val)
{
	int volatile ___ = 1;
	(void)__address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline float2 atomicAdd_system(float2 *__address,
							      float2 val)
{
	int volatile ___ = 1;
	(void)__address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline float4 atomicAdd(float4 *__address,
						       float4 val)
{
	int volatile ___ = 1;
	(void)__address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline float4 atomicAdd_block(float4 *__address,
							     float4 val)
{
	int volatile ___ = 1;
	(void)__address;
	(void)val;
	::exit(___);
}
__attribute__((unused)) static inline float4 atomicAdd_system(float4 *__address,
							      float4 val)
{
	int volatile ___ = 1;
	(void)__address;
	(void)val;
	::exit(___);
}
extern "C" {
}
template <bool __b, class _T> struct __nv_atomic_enable_if {
};
template <class _T> struct __nv_atomic_enable_if<true, _T> {
	typedef _T __type;
};
template <class _T> struct __nv_atomic_triv_cp_helper {
	static const bool __val = __is_trivially_copyable(_T);
};
template <class _T>
__attribute__((unused)) static inline typename __nv_atomic_enable_if<
	(sizeof(_T) == (16)) && (__alignof__(_T) >= (16)) &&
		__nv_atomic_triv_cp_helper<_T>::__val,
	_T>::__type
atomicCAS(_T *__address, _T __compare, _T __val)
{
	int volatile ___ = 1;
	(void)__address;
	(void)__compare;
	(void)__val;
	::exit(___);
}
template <class _T>
__attribute__((unused)) static inline typename __nv_atomic_enable_if<
	(sizeof(_T) == (16)) && (__alignof__(_T) >= (16)) &&
		__nv_atomic_triv_cp_helper<_T>::__val,
	_T>::__type
atomicCAS_block(_T *__address, _T __compare, _T __val)
{
	int volatile ___ = 1;
	(void)__address;
	(void)__compare;
	(void)__val;
	::exit(___);
}
template <class _T>
__attribute__((unused)) static inline typename __nv_atomic_enable_if<
	(sizeof(_T) == (16)) && (__alignof__(_T) >= (16)) &&
		__nv_atomic_triv_cp_helper<_T>::__val,
	_T>::__type
atomicCAS_system(_T *__address, _T __compare, _T __val)
{
	int volatile ___ = 1;
	(void)__address;
	(void)__compare;
	(void)__val;
	::exit(___);
}
template <class _T>
__attribute__((unused)) static inline typename __nv_atomic_enable_if<
	(sizeof(_T) == (16)) && (__alignof__(_T) >= (16)) &&
		__nv_atomic_triv_cp_helper<_T>::__val,
	_T>::__type
atomicExch(_T *__address, _T __val)
{
	int volatile ___ = 1;
	(void)__address;
	(void)__val;
	::exit(___);
}
template <class _T>
__attribute__((unused)) static inline typename __nv_atomic_enable_if<
	(sizeof(_T) == (16)) && (__alignof__(_T) >= (16)) &&
		__nv_atomic_triv_cp_helper<_T>::__val,
	_T>::__type
atomicExch_block(_T *__address, _T __val)
{
	int volatile ___ = 1;
	(void)__address;
	(void)__val;
	::exit(___);
}
template <class _T>
__attribute__((unused)) static inline typename __nv_atomic_enable_if<
	(sizeof(_T) == (16)) && (__alignof__(_T) >= (16)) &&
		__nv_atomic_triv_cp_helper<_T>::__val,
	_T>::__type
atomicExch_system(_T *__address, _T __val)
{
	int volatile ___ = 1;
	(void)__address;
	(void)__val;
	::exit(___);
}
template <class T> struct __nv_itex_trait {
};
template <> struct __nv_itex_trait<char> {
	typedef void type;
};
template <> struct __nv_itex_trait<signed char> {
	typedef void type;
};
template <> struct __nv_itex_trait<char1> {
	typedef void type;
};
template <> struct __nv_itex_trait<char2> {
	typedef void type;
};
template <> struct __nv_itex_trait<char4> {
	typedef void type;
};
template <> struct __nv_itex_trait<unsigned char> {
	typedef void type;
};
template <> struct __nv_itex_trait<uchar1> {
	typedef void type;
};
template <> struct __nv_itex_trait<uchar2> {
	typedef void type;
};
template <> struct __nv_itex_trait<uchar4> {
	typedef void type;
};
template <> struct __nv_itex_trait<short> {
	typedef void type;
};
template <> struct __nv_itex_trait<short1> {
	typedef void type;
};
template <> struct __nv_itex_trait<short2> {
	typedef void type;
};
template <> struct __nv_itex_trait<short4> {
	typedef void type;
};
template <> struct __nv_itex_trait<unsigned short> {
	typedef void type;
};
template <> struct __nv_itex_trait<ushort1> {
	typedef void type;
};
template <> struct __nv_itex_trait<ushort2> {
	typedef void type;
};
template <> struct __nv_itex_trait<ushort4> {
	typedef void type;
};
template <> struct __nv_itex_trait<int> {
	typedef void type;
};
template <> struct __nv_itex_trait<int1> {
	typedef void type;
};
template <> struct __nv_itex_trait<int2> {
	typedef void type;
};
template <> struct __nv_itex_trait<int4> {
	typedef void type;
};
template <> struct __nv_itex_trait<unsigned> {
	typedef void type;
};
template <> struct __nv_itex_trait<uint1> {
	typedef void type;
};
template <> struct __nv_itex_trait<uint2> {
	typedef void type;
};
template <> struct __nv_itex_trait<uint4> {
	typedef void type;
};
template <> struct __nv_itex_trait<float> {
	typedef void type;
};
template <> struct __nv_itex_trait<float1> {
	typedef void type;
};
template <> struct __nv_itex_trait<float2> {
	typedef void type;
};
template <> struct __nv_itex_trait<float4> {
	typedef void type;
};
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex1Dfetch(T *ptr, cudaTextureObject_t obj, int x)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T tex1Dfetch(cudaTextureObject_t texObject,
					    int x)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex1D(T *ptr, cudaTextureObject_t obj, float x)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T tex1D(cudaTextureObject_t texObject, float x)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex2D(T *ptr, cudaTextureObject_t obj, float x, float y)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T tex2D(cudaTextureObject_t texObject, float x,
				       float y)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)y;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex2D(T *ptr, cudaTextureObject_t obj, float x, float y, bool *isResident)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)isResident;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T tex2D(cudaTextureObject_t texObject, float x,
				       float y, bool *isResident)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)y;
	(void)isResident;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex3D(T *ptr, cudaTextureObject_t obj, float x, float y, float z)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)z;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T tex3D(cudaTextureObject_t texObject, float x,
				       float y, float z)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)y;
	(void)z;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex3D(T *ptr, cudaTextureObject_t obj, float x, float y, float z,
      bool *isResident)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)z;
	(void)isResident;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T tex3D(cudaTextureObject_t texObject, float x,
				       float y, float z, bool *isResident)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)y;
	(void)z;
	(void)isResident;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex1DLayered(T *ptr, cudaTextureObject_t obj, float x, int layer)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)layer;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T tex1DLayered(cudaTextureObject_t texObject,
					      float x, int layer)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)layer;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex2DLayered(T *ptr, cudaTextureObject_t obj, float x, float y, int layer)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)layer;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T tex2DLayered(cudaTextureObject_t texObject,
					      float x, float y, int layer)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)y;
	(void)layer;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex2DLayered(T *ptr, cudaTextureObject_t obj, float x, float y, int layer,
	     bool *isResident)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)layer;
	(void)isResident;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T tex2DLayered(cudaTextureObject_t texObject,
					      float x, float y, int layer,
					      bool *isResident)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)y;
	(void)layer;
	(void)isResident;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
texCubemap(T *ptr, cudaTextureObject_t obj, float x, float y, float z)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)z;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T texCubemap(cudaTextureObject_t texObject,
					    float x, float y, float z)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)y;
	(void)z;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
texCubemapLayered(T *ptr, cudaTextureObject_t obj, float x, float y, float z,
		  int layer)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)z;
	(void)layer;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T
texCubemapLayered(cudaTextureObject_t texObject, float x, float y, float z,
		  int layer)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)y;
	(void)z;
	(void)layer;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex2Dgather(T *ptr, cudaTextureObject_t obj, float x, float y, int comp = 0)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)comp;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T tex2Dgather(cudaTextureObject_t to, float x,
					     float y, int comp = 0)
{
	int volatile ___ = 1;
	(void)to;
	(void)x;
	(void)y;
	(void)comp;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex2Dgather(T *ptr, cudaTextureObject_t obj, float x, float y, bool *isResident,
	    int comp = 0)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)isResident;
	(void)comp;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T tex2Dgather(cudaTextureObject_t to, float x,
					     float y, bool *isResident,
					     int comp = 0)
{
	int volatile ___ = 1;
	(void)to;
	(void)x;
	(void)y;
	(void)isResident;
	(void)comp;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex1DLod(T *ptr, cudaTextureObject_t obj, float x, float level)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)level;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T tex1DLod(cudaTextureObject_t texObject,
					  float x, float level)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)level;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex2DLod(T *ptr, cudaTextureObject_t obj, float x, float y, float level)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)level;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T tex2DLod(cudaTextureObject_t texObject,
					  float x, float y, float level)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)y;
	(void)level;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex2DLod(T *ptr, cudaTextureObject_t obj, float x, float y, float level,
	 bool *isResident)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)level;
	(void)isResident;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T tex2DLod(cudaTextureObject_t texObject,
					  float x, float y, float level,
					  bool *isResident)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)y;
	(void)level;
	(void)isResident;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex3DLod(T *ptr, cudaTextureObject_t obj, float x, float y, float z,
	 float level)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)z;
	(void)level;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T
tex3DLod(cudaTextureObject_t texObject, float x, float y, float z, float level)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)y;
	(void)z;
	(void)level;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex3DLod(T *ptr, cudaTextureObject_t obj, float x, float y, float z,
	 float level, bool *isResident)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)z;
	(void)level;
	(void)isResident;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T tex3DLod(cudaTextureObject_t texObject,
					  float x, float y, float z,
					  float level, bool *isResident)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)y;
	(void)z;
	(void)level;
	(void)isResident;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex1DLayeredLod(T *ptr, cudaTextureObject_t obj, float x, int layer,
		float level)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)layer;
	(void)level;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T
tex1DLayeredLod(cudaTextureObject_t texObject, float x, int layer, float level)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)layer;
	(void)level;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex2DLayeredLod(T *ptr, cudaTextureObject_t obj, float x, float y, int layer,
		float level)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)layer;
	(void)level;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T tex2DLayeredLod(cudaTextureObject_t texObject,
						 float x, float y, int layer,
						 float level)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)y;
	(void)layer;
	(void)level;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex2DLayeredLod(T *ptr, cudaTextureObject_t obj, float x, float y, int layer,
		float level, bool *isResident)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)layer;
	(void)level;
	(void)isResident;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T tex2DLayeredLod(cudaTextureObject_t texObject,
						 float x, float y, int layer,
						 float level, bool *isResident)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)y;
	(void)layer;
	(void)level;
	(void)isResident;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
texCubemapLod(T *ptr, cudaTextureObject_t obj, float x, float y, float z,
	      float level)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)z;
	(void)level;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T texCubemapLod(cudaTextureObject_t texObject,
					       float x, float y, float z,
					       float level)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)y;
	(void)z;
	(void)level;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
texCubemapGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float z,
	       float4 dPdx, float4 dPdy)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)z;
	(void)dPdx;
	(void)dPdy;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T texCubemapGrad(cudaTextureObject_t texObject,
						float x, float y, float z,
						float4 dPdx, float4 dPdy)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)y;
	(void)z;
	(void)dPdx;
	(void)dPdy;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
texCubemapLayeredLod(T *ptr, cudaTextureObject_t obj, float x, float y, float z,
		     int layer, float level)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)z;
	(void)layer;
	(void)level;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T
texCubemapLayeredLod(cudaTextureObject_t texObject, float x, float y, float z,
		     int layer, float level)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)y;
	(void)z;
	(void)layer;
	(void)level;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex1DGrad(T *ptr, cudaTextureObject_t obj, float x, float dPdx, float dPdy)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)dPdx;
	(void)dPdy;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T tex1DGrad(cudaTextureObject_t texObject,
					   float x, float dPdx, float dPdy)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)dPdx;
	(void)dPdy;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex2DGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float2 dPdx,
	  float2 dPdy)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)dPdx;
	(void)dPdy;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T tex2DGrad(cudaTextureObject_t texObject,
					   float x, float y, float2 dPdx,
					   float2 dPdy)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)y;
	(void)dPdx;
	(void)dPdy;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex2DGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float2 dPdx,
	  float2 dPdy, bool *isResident)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)dPdx;
	(void)dPdy;
	(void)isResident;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T tex2DGrad(cudaTextureObject_t texObject,
					   float x, float y, float2 dPdx,
					   float2 dPdy, bool *isResident)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)y;
	(void)dPdx;
	(void)dPdy;
	(void)isResident;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex3DGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float z,
	  float4 dPdx, float4 dPdy)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)z;
	(void)dPdx;
	(void)dPdy;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T tex3DGrad(cudaTextureObject_t texObject,
					   float x, float y, float z,
					   float4 dPdx, float4 dPdy)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)y;
	(void)z;
	(void)dPdx;
	(void)dPdy;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex3DGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float z,
	  float4 dPdx, float4 dPdy, bool *isResident)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)z;
	(void)dPdx;
	(void)dPdy;
	(void)isResident;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T
tex3DGrad(cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx,
	  float4 dPdy, bool *isResident)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)y;
	(void)z;
	(void)dPdx;
	(void)dPdy;
	(void)isResident;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex1DLayeredGrad(T *ptr, cudaTextureObject_t obj, float x, int layer,
		 float dPdx, float dPdy)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)layer;
	(void)dPdx;
	(void)dPdy;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T tex1DLayeredGrad(cudaTextureObject_t texObject,
						  float x, int layer,
						  float dPdx, float dPdy)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)layer;
	(void)dPdx;
	(void)dPdy;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex2DLayeredGrad(T *ptr, cudaTextureObject_t obj, float x, float y, int layer,
		 float2 dPdx, float2 dPdy)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)layer;
	(void)dPdx;
	(void)dPdy;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T tex2DLayeredGrad(cudaTextureObject_t texObject,
						  float x, float y, int layer,
						  float2 dPdx, float2 dPdy)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)y;
	(void)layer;
	(void)dPdx;
	(void)dPdy;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
tex2DLayeredGrad(T *ptr, cudaTextureObject_t obj, float x, float y, int layer,
		 float2 dPdx, float2 dPdy, bool *isResident)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)layer;
	(void)dPdx;
	(void)dPdy;
	(void)isResident;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T
tex2DLayeredGrad(cudaTextureObject_t texObject, float x, float y, int layer,
		 float2 dPdx, float2 dPdy, bool *isResident)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)y;
	(void)layer;
	(void)dPdx;
	(void)dPdy;
	(void)isResident;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_itex_trait<T>::type
texCubemapLayeredGrad(T *ptr, cudaTextureObject_t obj, float x, float y,
		      float z, int layer, float4 dPdx, float4 dPdy)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)z;
	(void)layer;
	(void)dPdx;
	(void)dPdy;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T
texCubemapLayeredGrad(cudaTextureObject_t texObject, float x, float y, float z,
		      int layer, float4 dPdx, float4 dPdy)
{
	int volatile ___ = 1;
	(void)texObject;
	(void)x;
	(void)y;
	(void)z;
	(void)layer;
	(void)dPdx;
	(void)dPdy;
	::exit(___);
}
template <class T> struct __nv_isurf_trait {
};
template <> struct __nv_isurf_trait<char> {
	typedef void type;
};
template <> struct __nv_isurf_trait<signed char> {
	typedef void type;
};
template <> struct __nv_isurf_trait<char1> {
	typedef void type;
};
template <> struct __nv_isurf_trait<unsigned char> {
	typedef void type;
};
template <> struct __nv_isurf_trait<uchar1> {
	typedef void type;
};
template <> struct __nv_isurf_trait<short> {
	typedef void type;
};
template <> struct __nv_isurf_trait<short1> {
	typedef void type;
};
template <> struct __nv_isurf_trait<unsigned short> {
	typedef void type;
};
template <> struct __nv_isurf_trait<ushort1> {
	typedef void type;
};
template <> struct __nv_isurf_trait<int> {
	typedef void type;
};
template <> struct __nv_isurf_trait<int1> {
	typedef void type;
};
template <> struct __nv_isurf_trait<unsigned> {
	typedef void type;
};
template <> struct __nv_isurf_trait<uint1> {
	typedef void type;
};
template <> struct __nv_isurf_trait<long long> {
	typedef void type;
};
template <> struct __nv_isurf_trait<longlong1> {
	typedef void type;
};
template <> struct __nv_isurf_trait<unsigned long long> {
	typedef void type;
};
template <> struct __nv_isurf_trait<ulonglong1> {
	typedef void type;
};
template <> struct __nv_isurf_trait<float> {
	typedef void type;
};
template <> struct __nv_isurf_trait<float1> {
	typedef void type;
};
template <> struct __nv_isurf_trait<char2> {
	typedef void type;
};
template <> struct __nv_isurf_trait<uchar2> {
	typedef void type;
};
template <> struct __nv_isurf_trait<short2> {
	typedef void type;
};
template <> struct __nv_isurf_trait<ushort2> {
	typedef void type;
};
template <> struct __nv_isurf_trait<int2> {
	typedef void type;
};
template <> struct __nv_isurf_trait<uint2> {
	typedef void type;
};
template <> struct __nv_isurf_trait<longlong2> {
	typedef void type;
};
template <> struct __nv_isurf_trait<ulonglong2> {
	typedef void type;
};
template <> struct __nv_isurf_trait<float2> {
	typedef void type;
};
template <> struct __nv_isurf_trait<char4> {
	typedef void type;
};
template <> struct __nv_isurf_trait<uchar4> {
	typedef void type;
};
template <> struct __nv_isurf_trait<short4> {
	typedef void type;
};
template <> struct __nv_isurf_trait<ushort4> {
	typedef void type;
};
template <> struct __nv_isurf_trait<int4> {
	typedef void type;
};
template <> struct __nv_isurf_trait<uint4> {
	typedef void type;
};
template <> struct __nv_isurf_trait<float4> {
	typedef void type;
};
template <class T>
__attribute__((unused)) static typename __nv_isurf_trait<T>::type
surf1Dread(T *ptr, cudaSurfaceObject_t obj, int x,
	   cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)mode;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T
surf1Dread(cudaSurfaceObject_t surfObject, int x,
	   cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
	int volatile ___ = 1;
	(void)surfObject;
	(void)x;
	(void)boundaryMode;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_isurf_trait<T>::type
surf2Dread(T *ptr, cudaSurfaceObject_t obj, int x, int y,
	   cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)mode;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T
surf2Dread(cudaSurfaceObject_t surfObject, int x, int y,
	   cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
	int volatile ___ = 1;
	(void)surfObject;
	(void)x;
	(void)y;
	(void)boundaryMode;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_isurf_trait<T>::type
surf3Dread(T *ptr, cudaSurfaceObject_t obj, int x, int y, int z,
	   cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)z;
	(void)mode;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T
surf3Dread(cudaSurfaceObject_t surfObject, int x, int y, int z,
	   cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
	int volatile ___ = 1;
	(void)surfObject;
	(void)x;
	(void)y;
	(void)z;
	(void)boundaryMode;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_isurf_trait<T>::type
surf1DLayeredread(T *ptr, cudaSurfaceObject_t obj, int x, int layer,
		  cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)layer;
	(void)mode;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T
surf1DLayeredread(cudaSurfaceObject_t surfObject, int x, int layer,
		  cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
	int volatile ___ = 1;
	(void)surfObject;
	(void)x;
	(void)layer;
	(void)boundaryMode;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_isurf_trait<T>::type
surf2DLayeredread(T *ptr, cudaSurfaceObject_t obj, int x, int y, int layer,
		  cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)layer;
	(void)mode;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T
surf2DLayeredread(cudaSurfaceObject_t surfObject, int x, int y, int layer,
		  cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
	int volatile ___ = 1;
	(void)surfObject;
	(void)x;
	(void)y;
	(void)layer;
	(void)boundaryMode;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_isurf_trait<T>::type
surfCubemapread(T *ptr, cudaSurfaceObject_t obj, int x, int y, int face,
		cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)face;
	(void)mode;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T
surfCubemapread(cudaSurfaceObject_t surfObject, int x, int y, int face,
		cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
	int volatile ___ = 1;
	(void)surfObject;
	(void)x;
	(void)y;
	(void)face;
	(void)boundaryMode;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_isurf_trait<T>::type
surfCubemapLayeredread(T *ptr, cudaSurfaceObject_t obj, int x, int y,
		       int layerface,
		       cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
	int volatile ___ = 1;
	(void)ptr;
	(void)obj;
	(void)x;
	(void)y;
	(void)layerface;
	(void)mode;
	::exit(___);
}
template <class T>
__attribute__((unused)) static T surfCubemapLayeredread(
	cudaSurfaceObject_t surfObject, int x, int y, int layerface,
	cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
	int volatile ___ = 1;
	(void)surfObject;
	(void)x;
	(void)y;
	(void)layerface;
	(void)boundaryMode;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_isurf_trait<T>::type
surf1Dwrite(T val, cudaSurfaceObject_t obj, int x,
	    cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
	int volatile ___ = 1;
	(void)val;
	(void)obj;
	(void)x;
	(void)mode;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_isurf_trait<T>::type
surf2Dwrite(T val, cudaSurfaceObject_t obj, int x, int y,
	    cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
	int volatile ___ = 1;
	(void)val;
	(void)obj;
	(void)x;
	(void)y;
	(void)mode;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_isurf_trait<T>::type
surf3Dwrite(T val, cudaSurfaceObject_t obj, int x, int y, int z,
	    cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
	int volatile ___ = 1;
	(void)val;
	(void)obj;
	(void)x;
	(void)y;
	(void)z;
	(void)mode;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_isurf_trait<T>::type
surf1DLayeredwrite(T val, cudaSurfaceObject_t obj, int x, int layer,
		   cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
	int volatile ___ = 1;
	(void)val;
	(void)obj;
	(void)x;
	(void)layer;
	(void)mode;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_isurf_trait<T>::type
surf2DLayeredwrite(T val, cudaSurfaceObject_t obj, int x, int y, int layer,
		   cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
	int volatile ___ = 1;
	(void)val;
	(void)obj;
	(void)x;
	(void)y;
	(void)layer;
	(void)mode;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_isurf_trait<T>::type
surfCubemapwrite(T val, cudaSurfaceObject_t obj, int x, int y, int face,
		 cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
	int volatile ___ = 1;
	(void)val;
	(void)obj;
	(void)x;
	(void)y;
	(void)face;
	(void)mode;
	::exit(___);
}
template <class T>
__attribute__((unused)) static typename __nv_isurf_trait<T>::type
surfCubemapLayeredwrite(T val, cudaSurfaceObject_t obj, int x, int y,
			int layerface,
			cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
	int volatile ___ = 1;
	(void)val;
	(void)obj;
	(void)x;
	(void)y;
	(void)layerface;
	(void)mode;
	::exit(___);
}
extern "C" unsigned __cudaPushCallConfiguration(dim3 gridDim, dim3 blockDim,
						size_t sharedMem = 0,
						CUstream_st *stream = 0);
extern "C" {
extern const uint3 __device_builtin_variable_threadIdx;
extern const uint3 __device_builtin_variable_blockIdx;
extern const dim3 __device_builtin_variable_blockDim;
extern const dim3 __device_builtin_variable_gridDim;
extern const int __device_builtin_variable_warpSize;
}

namespace std __attribute((__visibility__("default")))
{
	namespace rel_ops
	{
	template <class _Tp>
	inline bool operator!=(const _Tp &__x, const _Tp &__y)
	{
		return !(__x == __y);
	}
	template <class _Tp>
	inline bool operator>(const _Tp &__x, const _Tp &__y)
	{
		return __y < __x;
	}
	template <class _Tp>
	inline bool operator<=(const _Tp &__x, const _Tp &__y)
	{
		return !(__y < __x);
	}
	template <class _Tp>
	inline bool operator>=(const _Tp &__x, const _Tp &__y)
	{
		return !(__x < __y);
	}
	} // namespace rel_ops
} // namespace )
namespace std
{
template <class _E> class initializer_list {
    public:
	typedef _E value_type;
	typedef const _E &reference;
	typedef const _E &const_reference;
	typedef size_t size_type;
	typedef const _E *iterator;
	typedef const _E *const_iterator;

    private:
	iterator _M_array;
	size_type _M_len;
	constexpr initializer_list(const_iterator __a, size_type __l)
		: _M_array(__a), _M_len(__l)
	{
	}

    public:
	constexpr initializer_list() noexcept : _M_array((0)), _M_len((0))
	{
	}
	constexpr size_type size() const noexcept
	{
		return _M_len;
	}
	constexpr const_iterator begin() const noexcept
	{
		return _M_array;
	}
	constexpr const_iterator end() const noexcept
	{
		return begin() + size();
	}
};
template <class _Tp>
constexpr const _Tp *begin(initializer_list<_Tp> __ils) noexcept
{
	return __ils.begin();
}
template <class _Tp>
constexpr const _Tp *end(initializer_list<_Tp> __ils) noexcept
{
	return __ils.end();
}
} // namespace std
namespace std __attribute((__visibility__("default")))
{
	template <class _Tp, class _Up = _Tp>
	inline _Tp exchange(_Tp & __obj, _Up && __new_val) noexcept(
		__and_<is_nothrow_move_constructible<_Tp>,
		       is_nothrow_assignable<_Tp &, _Up>>::value)
	{
		return std::__exchange(__obj, std::forward<_Up>(__new_val));
	}
	template <class _Tp>
	[[nodiscard]] constexpr add_const_t<_Tp> &as_const(_Tp & __t) noexcept
	{
		return __t;
	}
	template <typename _Tp> void as_const(const _Tp &&) = delete;
} // namespace )

template <class T>
static inline cudaError_t cudaLaunchKernel(T *func, dim3 gridDim, dim3 blockDim,
					   void **args, size_t sharedMem = 0,
					   cudaStream_t stream = 0)
{
	return ::cudaLaunchKernel((const void *)func, gridDim, blockDim, args,
				  sharedMem, stream);
}
template <class... ExpTypes, class... ActTypes>
static inline cudaError_t cudaLaunchKernelEx(const cudaLaunchConfig_t *config,
					     void (*kernel)(ExpTypes...),
					     ActTypes &&...args)
{
	return [&](ExpTypes... coercedArgs) {
		void *pArgs[] = { (&coercedArgs)... };
		return ::cudaLaunchKernelExC(config, (const void *)(kernel),
					     pArgs);
	}(std::forward<ActTypes>(args)...);
}
template <class T>
static inline cudaError_t
cudaLaunchCooperativeKernel(T *func, dim3 gridDim, dim3 blockDim, void **args,
			    size_t sharedMem = 0, cudaStream_t stream = 0)
{
	return ::cudaLaunchCooperativeKernel((const void *)func, gridDim,
					     blockDim, args, sharedMem, stream);
}
static inline cudaError_t cudaEventCreate(cudaEvent_t *event, unsigned flags)
{
	return ::cudaEventCreateWithFlags(event, flags);
}
static inline cudaError_t cudaGraphInstantiate(cudaGraphExec_t *pGraphExec,
					       cudaGraph_t graph,
					       cudaGraphNode_t *pErrorNode,
					       char *pLogBuffer,
					       size_t bufferSize)
{
	(void)pErrorNode;
	(void)pLogBuffer;
	(void)bufferSize;
	return ::cudaGraphInstantiate(pGraphExec, graph, 0);
}
static inline cudaError_t cudaMallocHost(void **ptr, size_t size,
					 unsigned flags)
{
	return ::cudaHostAlloc(ptr, size, flags);
}
template <class T>
static inline cudaError_t cudaHostAlloc(T **ptr, size_t size, unsigned flags)
{
	return ::cudaHostAlloc((void **)((void *)ptr), size, flags);
}
template <class T>
static inline cudaError_t cudaHostGetDevicePointer(T **pDevice, void *pHost,
						   unsigned flags)
{
	return ::cudaHostGetDevicePointer((void **)((void *)pDevice), pHost,
					  flags);
}
template <class T>
static inline cudaError_t cudaMallocManaged(T **devPtr, size_t size,
					    unsigned flags = 1)
{
	return ::cudaMallocManaged((void **)((void *)devPtr), size, flags);
}
template <class T>
cudaError_t cudaMemAdvise(T *devPtr, size_t count, cudaMemoryAdvise advice,
			  cudaMemLocation location)
{
	return ::cudaMemAdvise_v2((const void *)devPtr, count, advice,
				  location);
}
template <class T>
static inline cudaError_t
cudaMemPrefetchAsync(T *devPtr, size_t count, cudaMemLocation location,
		     unsigned flags, cudaStream_t stream = 0)
{
	return ::cudaMemPrefetchAsync_v2((const void *)devPtr, count, location,
					 flags, stream);
}
template <class T>
static inline cudaError_t cudaStreamAttachMemAsync(cudaStream_t stream,
						   T *devPtr, size_t length = 0,
						   unsigned flags = 4)
{
	return ::cudaStreamAttachMemAsync(stream, (void *)devPtr, length,
					  flags);
}
template <class T> inline cudaError_t cudaMalloc(T **devPtr, size_t size)
{
	return ::cudaMalloc((void **)((void *)devPtr), size);
}
template <class T>
static inline cudaError_t cudaMallocHost(T **ptr, size_t size,
					 unsigned flags = 0)
{
	return cudaMallocHost((void **)((void *)ptr), size, flags);
}
template <class T>
static inline cudaError_t cudaMallocPitch(T **devPtr, size_t *pitch,
					  size_t width, size_t height)
{
	return ::cudaMallocPitch((void **)((void *)devPtr), pitch, width,
				 height);
}
static inline cudaError_t cudaMallocAsync(void **ptr, size_t size,
					  cudaMemPool_t memPool,
					  cudaStream_t stream)
{
	return ::cudaMallocFromPoolAsync(ptr, size, memPool, stream);
}
template <class T>
static inline cudaError_t cudaMallocAsync(T **ptr, size_t size,
					  cudaMemPool_t memPool,
					  cudaStream_t stream)
{
	return ::cudaMallocFromPoolAsync((void **)((void *)ptr), size, memPool,
					 stream);
}
template <class T>
static inline cudaError_t cudaMallocAsync(T **ptr, size_t size,
					  cudaStream_t stream)
{
	return ::cudaMallocAsync((void **)((void *)ptr), size, stream);
}
template <class T>
static inline cudaError_t cudaMallocFromPoolAsync(T **ptr, size_t size,
						  cudaMemPool_t memPool,
						  cudaStream_t stream)
{
	return ::cudaMallocFromPoolAsync((void **)((void *)ptr), size, memPool,
					 stream);
}
template <class T>
static inline cudaError_t
cudaMemcpyToSymbol(const T &symbol, const void *src, size_t count,
		   size_t offset = 0,
		   cudaMemcpyKind kind = cudaMemcpyHostToDevice)
{
	return ::cudaMemcpyToSymbol((const void *)(&symbol), src, count, offset,
				    kind);
}
template <class T>
static inline cudaError_t cudaMemcpyToSymbolAsync(
	const T &symbol, const void *src, size_t count, size_t offset = 0,
	cudaMemcpyKind kind = cudaMemcpyHostToDevice, cudaStream_t stream = 0)
{
	return ::cudaMemcpyToSymbolAsync((const void *)(&symbol), src, count,
					 offset, kind, stream);
}
template <class T>
static inline cudaError_t
cudaMemcpyFromSymbol(void *dst, const T &symbol, size_t count,
		     size_t offset = 0,
		     cudaMemcpyKind kind = cudaMemcpyDeviceToHost)
{
	return ::cudaMemcpyFromSymbol(dst, (const void *)(&symbol), count,
				      offset, kind);
}
template <class T>
static inline cudaError_t cudaMemcpyFromSymbolAsync(
	void *dst, const T &symbol, size_t count, size_t offset = 0,
	cudaMemcpyKind kind = cudaMemcpyDeviceToHost, cudaStream_t stream = 0)
{
	return ::cudaMemcpyFromSymbolAsync(dst, (const void *)(&symbol), count,
					   offset, kind, stream);
}
template <class T>
static inline cudaError_t
cudaGraphAddMemcpyNodeToSymbol(cudaGraphNode_t *pGraphNode, cudaGraph_t graph,
			       const cudaGraphNode_t *pDependencies,
			       size_t numDependencies, const T &symbol,
			       const void *src, size_t count, size_t offset,
			       cudaMemcpyKind kind)
{
	return ::cudaGraphAddMemcpyNodeToSymbol(pGraphNode, graph,
						pDependencies, numDependencies,
						(const void *)(&symbol), src,
						count, offset, kind);
}
template <class T>
static inline cudaError_t cudaGraphAddMemcpyNodeFromSymbol(
	cudaGraphNode_t *pGraphNode, cudaGraph_t graph,
	const cudaGraphNode_t *pDependencies, size_t numDependencies, void *dst,
	const T &symbol, size_t count, size_t offset, cudaMemcpyKind kind)
{
	return ::cudaGraphAddMemcpyNodeFromSymbol(
		pGraphNode, graph, pDependencies, numDependencies, dst,
		(const void *)(&symbol), count, offset, kind);
}
template <class T>
static inline cudaError_t
cudaGraphMemcpyNodeSetParamsToSymbol(cudaGraphNode_t node, const T &symbol,
				     const void *src, size_t count,
				     size_t offset, cudaMemcpyKind kind)
{
	return ::cudaGraphMemcpyNodeSetParamsToSymbol(
		node, (const void *)(&symbol), src, count, offset, kind);
}
template <class T>
static inline cudaError_t
cudaGraphMemcpyNodeSetParamsFromSymbol(cudaGraphNode_t node, void *dst,
				       const T &symbol, size_t count,
				       size_t offset, cudaMemcpyKind kind)
{
	return ::cudaGraphMemcpyNodeSetParamsFromSymbol(
		node, dst, (const void *)(&symbol), count, offset, kind);
}
template <class T>
static inline cudaError_t cudaGraphExecMemcpyNodeSetParamsToSymbol(
	cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const T &symbol,
	const void *src, size_t count, size_t offset, cudaMemcpyKind kind)
{
	return ::cudaGraphExecMemcpyNodeSetParamsToSymbol(
		hGraphExec, node, (const void *)(&symbol), src, count, offset,
		kind);
}
template <class T>
static inline cudaError_t cudaGraphExecMemcpyNodeSetParamsFromSymbol(
	cudaGraphExec_t hGraphExec, cudaGraphNode_t node, void *dst,
	const T &symbol, size_t count, size_t offset, cudaMemcpyKind kind)
{
	return ::cudaGraphExecMemcpyNodeSetParamsFromSymbol(
		hGraphExec, node, dst, (const void *)(&symbol), count, offset,
		kind);
}
static inline cudaError_t
cudaGraphExecUpdate(cudaGraphExec_t hGraphExec, cudaGraph_t hGraph,
		    cudaGraphNode_t *hErrorNode_out,
		    cudaGraphExecUpdateResult *updateResult_out)
{
	cudaGraphExecUpdateResultInfo resultInfo;
	cudaError_t status =
		cudaGraphExecUpdate(hGraphExec, hGraph, &resultInfo);
	if (hErrorNode_out) {
		(*hErrorNode_out) = (resultInfo.errorNode);
	}
	if (updateResult_out) {
		(*updateResult_out) = (resultInfo.result);
	}
	return status;
}
template <class T>
static inline cudaError_t
cudaUserObjectCreate(cudaUserObject_t *object_out, T *objectToWrap,
		     unsigned initialRefcount, unsigned flags)
{
	return ::cudaUserObjectCreate(
		object_out, objectToWrap,
		[](void *vpObj) { delete (reinterpret_cast<T *>(vpObj)); },
		initialRefcount, flags);
}
template <class T>
static inline cudaError_t
cudaUserObjectCreate(cudaUserObject_t *object_out, T *objectToWrap,
		     unsigned initialRefcount, cudaUserObjectFlags flags)
{
	return cudaUserObjectCreate(object_out, objectToWrap, initialRefcount,
				    (unsigned)flags);
}
template <class T>
static inline cudaError_t cudaGetSymbolAddress(void **devPtr, const T &symbol)
{
	return ::cudaGetSymbolAddress(devPtr, (const void *)(&symbol));
}
template <class T>
static inline cudaError_t cudaGetSymbolSize(size_t *size, const T &symbol)
{
	return ::cudaGetSymbolSize(size, (const void *)(&symbol));
}
template <class T>
static inline cudaError_t cudaFuncSetCacheConfig(T *func,
						 cudaFuncCache cacheConfig)
{
	return ::cudaFuncSetCacheConfig((const void *)func, cacheConfig);
}
template <class T>
__attribute((deprecated)) static inline cudaError_t
cudaFuncSetSharedMemConfig(T *func, cudaSharedMemConfig config)
{
	return ::cudaFuncSetSharedMemConfig((const void *)func, config);
}
template <class T>
inline cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(
	int *numBlocks, T func, int blockSize, size_t dynamicSMemSize)
{
	return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
		numBlocks, (const void *)func, blockSize, dynamicSMemSize, 0);
}
template <class T>
inline cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
	int *numBlocks, T func, int blockSize, size_t dynamicSMemSize,
	unsigned flags)
{
	return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
		numBlocks, (const void *)func, blockSize, dynamicSMemSize,
		flags);
}
class __cudaOccupancyB2DHelper {
	size_t n;

    public:
	__cudaOccupancyB2DHelper(size_t n_) : n(n_)
	{
	}
	size_t operator()(int)
	{
		return n;
	}
};
template <class UnaryFunction, class T>
static inline cudaError_t
cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(
	int *minGridSize, int *blockSize, T func,
	UnaryFunction blockSizeToDynamicSMemSize, int blockSizeLimit = 0,
	unsigned flags = 0)
{
	cudaError_t status;
	int device;
	cudaFuncAttributes attr;
	int maxThreadsPerMultiProcessor;
	int warpSize;
	int devMaxThreadsPerBlock;
	int multiProcessorCount;
	int funcMaxThreadsPerBlock;
	int occupancyLimit;
	int granularity;
	int maxBlockSize = 0;
	int numBlocks = 0;
	int maxOccupancy = 0;
	int blockSizeToTryAligned;
	int blockSizeToTry;
	int blockSizeLimitAligned;
	int occupancyInBlocks;
	int occupancyInThreads;
	size_t dynamicSMemSize;
	if (((!minGridSize) || (!blockSize)) || (!func)) {
		return cudaErrorInvalidValue;
	}
	status = ::cudaGetDevice(&device);
	if (status != (cudaSuccess)) {
		return status;
	}
	status = cudaDeviceGetAttribute(&maxThreadsPerMultiProcessor,
					cudaDevAttrMaxThreadsPerMultiProcessor,
					device);
	if (status != (cudaSuccess)) {
		return status;
	}
	status = cudaDeviceGetAttribute(&warpSize, cudaDevAttrWarpSize, device);
	if (status != (cudaSuccess)) {
		return status;
	}
	status = cudaDeviceGetAttribute(&devMaxThreadsPerBlock,
					cudaDevAttrMaxThreadsPerBlock, device);
	if (status != (cudaSuccess)) {
		return status;
	}
	status = cudaDeviceGetAttribute(&multiProcessorCount,
					cudaDevAttrMultiProcessorCount, device);
	if (status != (cudaSuccess)) {
		return status;
	}
	status = cudaFuncGetAttributes(&attr, func);
	if (status != (cudaSuccess)) {
		return status;
	}
	funcMaxThreadsPerBlock = (attr.maxThreadsPerBlock);
	occupancyLimit = maxThreadsPerMultiProcessor;
	granularity = warpSize;
	if (blockSizeLimit == 0) {
		blockSizeLimit = devMaxThreadsPerBlock;
	}
	if (devMaxThreadsPerBlock < blockSizeLimit) {
		blockSizeLimit = devMaxThreadsPerBlock;
	}
	if (funcMaxThreadsPerBlock < blockSizeLimit) {
		blockSizeLimit = funcMaxThreadsPerBlock;
	}
	blockSizeLimitAligned =
		(((blockSizeLimit + (granularity - 1)) / granularity) *
		 granularity);
	for (blockSizeToTryAligned = blockSizeLimitAligned;
	     blockSizeToTryAligned > 0; blockSizeToTryAligned -= granularity) {
		if (blockSizeLimit < blockSizeToTryAligned) {
			blockSizeToTry = blockSizeLimit;
		} else {
			blockSizeToTry = blockSizeToTryAligned;
		}
		dynamicSMemSize = blockSizeToDynamicSMemSize(blockSizeToTry);
		status = cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
			&occupancyInBlocks, func, blockSizeToTry,
			dynamicSMemSize, flags);
		if (status != (cudaSuccess)) {
			return status;
		}
		occupancyInThreads = (blockSizeToTry * occupancyInBlocks);
		if (occupancyInThreads > maxOccupancy) {
			maxBlockSize = blockSizeToTry;
			numBlocks = occupancyInBlocks;
			maxOccupancy = occupancyInThreads;
		}
		if (occupancyLimit == maxOccupancy) {
			break;
		}
	}
	(*minGridSize) = (numBlocks * multiProcessorCount);
	(*blockSize) = maxBlockSize;
	return status;
}
template <class UnaryFunction, class T>
static inline cudaError_t cudaOccupancyMaxPotentialBlockSizeVariableSMem(
	int *minGridSize, int *blockSize, T func,
	UnaryFunction blockSizeToDynamicSMemSize, int blockSizeLimit = 0)
{
	return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(
		minGridSize, blockSize, func, blockSizeToDynamicSMemSize,
		blockSizeLimit, 0);
}
template <class T>
static inline cudaError_t
cudaOccupancyMaxPotentialBlockSize(int *minGridSize, int *blockSize, T func,
				   size_t dynamicSMemSize = 0,
				   int blockSizeLimit = 0)
{
	return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(
		minGridSize, blockSize, func,
		((__cudaOccupancyB2DHelper)(dynamicSMemSize)), blockSizeLimit,
		0);
}
template <class T>
static inline cudaError_t
cudaOccupancyAvailableDynamicSMemPerBlock(size_t *dynamicSmemSize, T *func,
					  int numBlocks, int blockSize)
{
	return ::cudaOccupancyAvailableDynamicSMemPerBlock(
		dynamicSmemSize, (const void *)func, numBlocks, blockSize);
}
template <class T>
static inline cudaError_t cudaOccupancyMaxPotentialBlockSizeWithFlags(
	int *minGridSize, int *blockSize, T func, size_t dynamicSMemSize = 0,
	int blockSizeLimit = 0, unsigned flags = 0)
{
	return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(
		minGridSize, blockSize, func,
		((__cudaOccupancyB2DHelper)(dynamicSMemSize)), blockSizeLimit,
		flags);
}
template <class T>
static inline cudaError_t
cudaOccupancyMaxPotentialClusterSize(int *clusterSize, T *func,
				     const cudaLaunchConfig_t *config)
{
	return ::cudaOccupancyMaxPotentialClusterSize(
		clusterSize, (const void *)func, config);
}
template <class T>
static inline cudaError_t
cudaOccupancyMaxActiveClusters(int *numClusters, T *func,
			       const cudaLaunchConfig_t *config)
{
	return ::cudaOccupancyMaxActiveClusters(numClusters, (const void *)func,
						config);
}
template <class T>
inline cudaError_t cudaFuncGetAttributes(cudaFuncAttributes *attr, T *entry)
{
	return ::cudaFuncGetAttributes(attr, (const void *)entry);
}
template <class T>
static inline cudaError_t cudaFuncSetAttribute(T *func, cudaFuncAttribute attr,
					       int value)
{
	return ::cudaFuncSetAttribute((const void *)func, attr, value);
}
template <class T>
static inline cudaError_t cudaFuncGetName(const char **name, T *func)
{
	return ::cudaFuncGetName(name, (const void *)func);
}
template <class T>
static inline cudaError_t cudaGetKernel(cudaKernel_t *kernelPtr, T *func)
{
	return ::cudaGetKernel(kernelPtr, (const void *)func);
}

extern "C" {
typedef __builtin_va_list __gnuc_va_list;
typedef struct {
	int __count;
	union {
		unsigned __wch;
		char __wchb[4];
	} __value;
} __mbstate_t;
typedef struct _G_fpos_t {
	__off_t __pos;
	__mbstate_t __state;
} __fpos_t;
typedef struct _G_fpos64_t {
	__off64_t __pos;
	__mbstate_t __state;
} __fpos64_t;
struct _IO_FILE;
typedef _IO_FILE __FILE;
struct _IO_FILE;
typedef _IO_FILE FILE;
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;
typedef void _IO_lock_t;
struct _IO_FILE {
	int _flags;
	char *_IO_read_ptr;
	char *_IO_read_end;
	char *_IO_read_base;
	char *_IO_write_base;
	char *_IO_write_ptr;
	char *_IO_write_end;
	char *_IO_buf_base;
	char *_IO_buf_end;
	char *_IO_save_base;
	char *_IO_backup_base;
	char *_IO_save_end;
	_IO_marker *_markers;
	_IO_FILE *_chain;
	int _fileno;
	int _flags2;
	__off_t _old_offset;
	unsigned short _cur_column;
	signed char _vtable_offset;
	char _shortbuf[1];
	_IO_lock_t *_lock;
	__off64_t _offset;
	_IO_codecvt *_codecvt;
	_IO_wide_data *_wide_data;
	_IO_FILE *_freeres_list;
	void *_freeres_buf;
	size_t __pad5;
	int _mode;
	char _unused2[(((15) * sizeof(int)) - ((4) * sizeof(void *))) -
		      sizeof(size_t)];
};
typedef __ssize_t cookie_read_function_t(void *__cookie, char *__buf,
					 size_t __nbytes);
typedef __ssize_t cookie_write_function_t(void *__cookie, const char *__buf,
					  size_t __nbytes);
typedef int cookie_seek_function_t(void *__cookie, __off64_t *__pos, int __w);
typedef int cookie_close_function_t(void *__cookie);
typedef struct _IO_cookie_io_functions_t {
	cookie_read_function_t *read;
	cookie_write_function_t *write;
	cookie_seek_function_t *seek;
	cookie_close_function_t *close;
} cookie_io_functions_t;
typedef __gnuc_va_list va_list;
typedef __fpos_t fpos_t;
typedef __fpos64_t fpos64_t;
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;
extern int remove(const char *__filename) noexcept(true);
extern int rename(const char *__old, const char *__new) noexcept(true);
extern int renameat(int __oldfd, const char *__old, int __newfd,
		    const char *__new) noexcept(true);
extern int renameat2(int __oldfd, const char *__old, int __newfd,
		     const char *__new, unsigned __flags) noexcept(true);
extern int fclose(FILE *__stream);
extern FILE *tmpfile() __attribute((__malloc__))
__attribute((__malloc__(fclose, 1)));
extern FILE *tmpfile64() __attribute((__malloc__))
__attribute((__malloc__(fclose, 1)));
extern char *tmpnam(char[20]) noexcept(true);
extern char *tmpnam_r(char __s[20]) noexcept(true);
extern char *tempnam(const char *__dir, const char *__pfx) noexcept(true)
	__attribute((__malloc__)) __attribute((__malloc__(__builtin_free, 1)));
extern int fflush(FILE *__stream);
extern int fflush_unlocked(FILE *__stream);
extern int fcloseall();
extern FILE *fopen(const char *__restrict__ __filename,
		   const char *__restrict__ __modes) __attribute((__malloc__))
__attribute((__malloc__(fclose, 1)));
extern FILE *freopen(const char *__restrict__ __filename,
		     const char *__restrict__ __modes,
		     FILE *__restrict__ __stream);
extern FILE *fopen64(const char *__restrict__ __filename,
		     const char *__restrict__ __modes) __attribute((__malloc__))
__attribute((__malloc__(fclose, 1)));
extern FILE *freopen64(const char *__restrict__ __filename,
		       const char *__restrict__ __modes,
		       FILE *__restrict__ __stream);
extern FILE *fdopen(int __fd, const char *__modes) noexcept(true)
	__attribute((__malloc__)) __attribute((__malloc__(fclose, 1)));
extern FILE *fopencookie(void *__restrict__ __magic_cookie,
			 const char *__restrict__ __modes,
			 cookie_io_functions_t __io_funcs) noexcept(true)
	__attribute((__malloc__)) __attribute((__malloc__(fclose, 1)));
extern FILE *fmemopen(void *__s, size_t __len,
		      const char *__modes) noexcept(true)
	__attribute((__malloc__)) __attribute((__malloc__(fclose, 1)));
extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc) noexcept(true)
	__attribute((__malloc__)) __attribute((__malloc__(fclose, 1)));
extern void setbuf(FILE *__restrict__ __stream,
		   char *__restrict__ __buf) noexcept(true);
extern int setvbuf(FILE *__restrict__ __stream, char *__restrict__ __buf,
		   int __modes, size_t __n) noexcept(true);
extern void setbuffer(FILE *__restrict__ __stream, char *__restrict__ __buf,
		      size_t __size) noexcept(true);
extern void setlinebuf(FILE *__stream) noexcept(true);
extern int fprintf(FILE *__restrict__ __stream,
		   const char *__restrict__ __format, ...);
extern int printf(const char *__restrict__ __format, ...);
extern int sprintf(char *__restrict__ __s, const char *__restrict__ __format,
		   ...) noexcept(true);
extern int vfprintf(FILE *__restrict__ __s, const char *__restrict__ __format,
		    __gnuc_va_list __arg);
extern int vprintf(const char *__restrict__ __format, __gnuc_va_list __arg);
extern int vsprintf(char *__restrict__ __s, const char *__restrict__ __format,
		    __gnuc_va_list __arg) noexcept(true);
extern int snprintf(char *__restrict__ __s, size_t __maxlen,
		    const char *__restrict__ __format, ...) noexcept(true)
	__attribute((__format__(__printf__, 3, 4)));
extern int vsnprintf(char *__restrict__ __s, size_t __maxlen,
		     const char *__restrict__ __format,
		     __gnuc_va_list __arg) noexcept(true)
	__attribute((__format__(__printf__, 3, 0)));
extern int vasprintf(char **__restrict__ __ptr, const char *__restrict__ __f,
		     __gnuc_va_list __arg) noexcept(true)
	__attribute((__format__(__printf__, 2, 0)));
extern int __asprintf(char **__restrict__ __ptr, const char *__restrict__ __fmt,
		      ...) noexcept(true)
	__attribute((__format__(__printf__, 2, 3)));
extern int asprintf(char **__restrict__ __ptr, const char *__restrict__ __fmt,
		    ...) noexcept(true)
	__attribute((__format__(__printf__, 2, 3)));
extern int vdprintf(int __fd, const char *__restrict__ __fmt,
		    __gnuc_va_list __arg)
	__attribute((__format__(__printf__, 2, 0)));
extern int dprintf(int __fd, const char *__restrict__ __fmt, ...)
	__attribute((__format__(__printf__, 2, 3)));
extern int fscanf(FILE *__restrict__ __stream,
		  const char *__restrict__ __format,
		  ...) __asm__("__isoc99_fscanf");
extern int scanf(const char *__restrict__ __format,
		 ...) __asm__("__isoc99_scanf");
extern int sscanf(const char *__restrict__ __s,
		  const char *__restrict__ __format,
		  ...) noexcept(true) __asm__("__isoc99_sscanf");
extern int fscanf(FILE *__restrict__ __stream,
		  const char *__restrict__ __format,
		  ...) __asm__("__isoc99_fscanf");
extern int scanf(const char *__restrict__ __format,
		 ...) __asm__("__isoc99_scanf");
extern int sscanf(const char *__restrict__ __s,
		  const char *__restrict__ __format,
		  ...) noexcept(true) __asm__("__isoc99_sscanf");
extern int vfscanf(FILE *__restrict__ __s, const char *__restrict__ __format,
		   __gnuc_va_list __arg) __asm__("__isoc99_vfscanf")
	__attribute((__format__(__scanf__, 2, 0)));
extern int vscanf(const char *__restrict__ __format,
		  __gnuc_va_list __arg) __asm__("__isoc99_vscanf")
	__attribute((__format__(__scanf__, 1, 0)));
extern int
vsscanf(const char *__restrict__ __s, const char *__restrict__ __format,
	__gnuc_va_list __arg) noexcept(true) __asm__("__isoc99_vsscanf")
	__attribute((__format__(__scanf__, 2, 0)));
extern int vfscanf(FILE *__restrict__ __s, const char *__restrict__ __format,
		   __gnuc_va_list __arg) __asm__("__isoc99_vfscanf")
	__attribute((__format__(__scanf__, 2, 0)));
extern int vscanf(const char *__restrict__ __format,
		  __gnuc_va_list __arg) __asm__("__isoc99_vscanf")
	__attribute((__format__(__scanf__, 1, 0)));
extern int
vsscanf(const char *__restrict__ __s, const char *__restrict__ __format,
	__gnuc_va_list __arg) noexcept(true) __asm__("__isoc99_vsscanf")
	__attribute((__format__(__scanf__, 2, 0)));
extern int fgetc(FILE *__stream);
extern int getc(FILE *__stream);
extern int getchar();
extern int getc_unlocked(FILE *__stream);
extern int getchar_unlocked();
extern int fgetc_unlocked(FILE *__stream);
extern int fputc(int __c, FILE *__stream);
extern int putc(int __c, FILE *__stream);
extern int putchar(int __c);
extern int fputc_unlocked(int __c, FILE *__stream);
extern int putc_unlocked(int __c, FILE *__stream);
extern int putchar_unlocked(int __c);
extern int getw(FILE *__stream);
extern int putw(int __w, FILE *__stream);
extern char *fgets(char *__restrict__ __s, int __n, FILE *__restrict__ __stream)
	__attribute((__access__(__write_only__, 1, 2)));
extern char *fgets_unlocked(char *__restrict__ __s, int __n,
			    FILE *__restrict__ __stream)
	__attribute((__access__(__write_only__, 1, 2)));
extern __ssize_t __getdelim(char **__restrict__ __lineptr,
			    size_t *__restrict__ __n, int __delimiter,
			    FILE *__restrict__ __stream);
extern __ssize_t getdelim(char **__restrict__ __lineptr,
			  size_t *__restrict__ __n, int __delimiter,
			  FILE *__restrict__ __stream);
extern __ssize_t getline(char **__restrict__ __lineptr,
			 size_t *__restrict__ __n, FILE *__restrict__ __stream);
extern int fputs(const char *__restrict__ __s, FILE *__restrict__ __stream);
extern int puts(const char *__s);
extern int ungetc(int __c, FILE *__stream);
extern size_t fread(void *__restrict__ __ptr, size_t __size, size_t __n,
		    FILE *__restrict__ __stream);
extern size_t fwrite(const void *__restrict__ __ptr, size_t __size, size_t __n,
		     FILE *__restrict__ __s);
extern int fputs_unlocked(const char *__restrict__ __s,
			  FILE *__restrict__ __stream);
extern size_t fread_unlocked(void *__restrict__ __ptr, size_t __size,
			     size_t __n, FILE *__restrict__ __stream);
extern size_t fwrite_unlocked(const void *__restrict__ __ptr, size_t __size,
			      size_t __n, FILE *__restrict__ __stream);
extern int fseek(FILE *__stream, long __off, int __whence);
extern long ftell(FILE *__stream);
extern void rewind(FILE *__stream);
extern int fseeko(FILE *__stream, __off_t __off, int __whence);
extern __off_t ftello(FILE *__stream);
extern int fgetpos(FILE *__restrict__ __stream, fpos_t *__restrict__ __pos);
extern int fsetpos(FILE *__stream, const fpos_t *__pos);
extern int fseeko64(FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64(FILE *__stream);
extern int fgetpos64(FILE *__restrict__ __stream, fpos64_t *__restrict__ __pos);
extern int fsetpos64(FILE *__stream, const fpos64_t *__pos);
extern void clearerr(FILE *__stream) noexcept(true);
extern int feof(FILE *__stream) noexcept(true);
extern int ferror(FILE *__stream) noexcept(true);
extern void clearerr_unlocked(FILE *__stream) noexcept(true);
extern int feof_unlocked(FILE *__stream) noexcept(true);
extern int ferror_unlocked(FILE *__stream) noexcept(true);
extern void perror(const char *__s);
extern int fileno(FILE *__stream) noexcept(true);
extern int fileno_unlocked(FILE *__stream) noexcept(true);
extern int pclose(FILE *__stream);
extern FILE *popen(const char *__command, const char *__modes)
	__attribute((__malloc__)) __attribute((__malloc__(pclose, 1)));
extern char *ctermid(char *__s) noexcept(true)
	__attribute((__access__(__write_only__, 1)));
extern char *cuserid(char *__s) __attribute((__access__(__write_only__, 1)));
struct obstack;
extern int obstack_printf(obstack *__restrict__ __obstack,
			  const char *__restrict__ __format, ...) noexcept(true)
	__attribute((__format__(__printf__, 2, 3)));
extern int obstack_vprintf(obstack *__restrict__ __obstack,
			   const char *__restrict__ __format,
			   __gnuc_va_list __args) noexcept(true)
	__attribute((__format__(__printf__, 2, 0)));
extern void flockfile(FILE *__stream) noexcept(true);
extern int ftrylockfile(FILE *__stream) noexcept(true);
extern void funlockfile(FILE *__stream) noexcept(true);
extern int __uflow(FILE *);
extern int __overflow(FILE *, int);
}
namespace std
{
using ::clearerr;
using ::fclose;
using ::feof;
using ::ferror;
using ::fflush;
using ::fgetc;
using ::fgetpos;
using ::fgets;
using ::FILE;
using ::fopen;
using ::fpos_t;
using ::fprintf;
using ::fputc;
using ::fputs;
using ::fread;
using ::freopen;
using ::fscanf;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::fwrite;
using ::getc;
using ::getchar;
using ::perror;
using ::printf;
using ::putc;
using ::putchar;
using ::puts;
using ::remove;
using ::rename;
using ::rewind;
using ::scanf;
using ::setbuf;
using ::setvbuf;
using ::sprintf;
using ::sscanf;
using ::tmpfile;
using ::tmpnam;
using ::ungetc;
using ::vfprintf;
using ::vprintf;
using ::vsprintf;
} // namespace std
namespace __gnu_cxx
{
using ::snprintf;
using ::vfscanf;
using ::vscanf;
using ::vsnprintf;
using ::vsscanf;
} // namespace __gnu_cxx
namespace std
{
using __gnu_cxx::snprintf;
using __gnu_cxx::vfscanf;
using __gnu_cxx::vscanf;
using __gnu_cxx::vsnprintf;
using __gnu_cxx::vsscanf;
} // namespace std
extern "C++" {
namespace std
{
class exception {
    public:
	exception() noexcept
	{
	}
	virtual ~exception() noexcept;
	exception(const exception &) = default;
	exception &operator=(const exception &) = default;
	exception(exception &&) = default;
	exception &operator=(exception &&) = default;
	virtual const char *what() const noexcept;
};
} // namespace std
}
extern "C++" {
namespace std
{
class bad_alloc : public exception {
    public:
	bad_alloc() throw()
	{
	}
	bad_alloc(const bad_alloc &) = default;
	bad_alloc &operator=(const bad_alloc &) = default;
	virtual ~bad_alloc() throw();
	virtual const char *what() const throw();
};
class bad_array_new_length : public bad_alloc {
    public:
	bad_array_new_length() throw()
	{
	}
	virtual ~bad_array_new_length() throw();
	virtual const char *what() const throw();
};
enum class align_val_t : size_t {};
struct nothrow_t {
	explicit nothrow_t() = default;
};
extern const nothrow_t nothrow;
typedef void (*new_handler)(void);
new_handler set_new_handler(new_handler) throw();
new_handler get_new_handler() noexcept;
} // namespace std
[[__nodiscard__]] void *operator new(std::size_t)
	__attribute((__externally_visible__));
[[__nodiscard__]] void *operator new[](std::size_t)
	__attribute((__externally_visible__));
void operator delete(void *) noexcept __attribute((__externally_visible__));
void operator delete[](void *) noexcept __attribute((__externally_visible__));
void operator delete(void *, std::size_t) noexcept
	__attribute((__externally_visible__));
void operator delete[](void *, std::size_t) noexcept
	__attribute((__externally_visible__));
[[__nodiscard__]] void *operator new(std::size_t,
				     const std::nothrow_t &) noexcept
	__attribute((__externally_visible__, __alloc_size__(1), __malloc__));
[[__nodiscard__]] void *operator new[](std::size_t,
				       const std::nothrow_t &) noexcept
	__attribute((__externally_visible__, __alloc_size__(1), __malloc__));
void operator delete(void *, const std::nothrow_t &) noexcept
	__attribute((__externally_visible__));
void operator delete[](void *, const std::nothrow_t &) noexcept
	__attribute((__externally_visible__));
[[__nodiscard__]] void *operator new(std::size_t, std::align_val_t)
	__attribute((__externally_visible__, __alloc_size__(1), __malloc__));
[[__nodiscard__]] void *operator new(std::size_t, std::align_val_t,
				     const std::nothrow_t &) noexcept
	__attribute((__externally_visible__, __alloc_size__(1), __malloc__));
void operator delete(void *, std::align_val_t) noexcept
	__attribute((__externally_visible__));
void operator delete(void *, std::align_val_t, const std::nothrow_t &) noexcept
	__attribute((__externally_visible__));
[[__nodiscard__]] void *operator new[](std::size_t, std::align_val_t)
	__attribute((__externally_visible__, __alloc_size__(1), __malloc__));
[[__nodiscard__]] void *operator new[](std::size_t, std::align_val_t,
				       const std::nothrow_t &) noexcept
	__attribute((__externally_visible__, __alloc_size__(1), __malloc__));
void operator delete[](void *, std::align_val_t) noexcept
	__attribute((__externally_visible__));
void operator delete[](void *, std::align_val_t,
		       const std::nothrow_t &) noexcept
	__attribute((__externally_visible__));
void operator delete(void *, std::size_t, std::align_val_t) noexcept
	__attribute((__externally_visible__));
void operator delete[](void *, std::size_t, std::align_val_t) noexcept
	__attribute((__externally_visible__));
[[__nodiscard__]] inline void *operator new(std::size_t, void *__p) noexcept
{
	return __p;
}
[[__nodiscard__]] inline void *operator new[](std::size_t, void *__p) noexcept
{
	return __p;
}
inline void operator delete(void *, void *) noexcept
{
}
inline void operator delete[](void *, void *) noexcept
{
}
}
namespace std
{
template <class _Tp> [[nodiscard]] constexpr _Tp *launder(_Tp *__p) noexcept
{
	return __builtin_launder(__p);
}
template <typename _Ret, typename... _Args, bool _NE>
void launder(_Ret (*)(_Args...) noexcept(_NE)) = delete;
template <typename _Ret, typename... _Args, bool _NE>
void launder(_Ret (*)(_Args......) noexcept(_NE)) = delete;
inline void launder(void *) = delete;
inline void launder(const void *) = delete;
inline void launder(volatile void *) = delete;
inline void launder(const volatile void *) = delete;
constexpr inline size_t hardware_destructive_interference_size = (64);
constexpr inline size_t hardware_constructive_interference_size = (64);
} // namespace std
namespace std __attribute((__visibility__("default")))
{
	template <class _Tp> class __new_allocator {
	    public:
		typedef _Tp value_type;
		typedef size_t size_type;
		typedef ptrdiff_t difference_type;
		typedef _Tp *pointer;
		typedef const _Tp *const_pointer;
		typedef _Tp &reference;
		typedef const _Tp &const_reference;
		template <class _Tp1> struct rebind {
			typedef __new_allocator<_Tp1> other;
		};
		typedef true_type propagate_on_container_move_assignment;
		__new_allocator() noexcept
		{
		}
		__new_allocator(const __new_allocator &) noexcept
		{
		}
		template <class _Tp1>
		__new_allocator(const __new_allocator<_Tp1> &) noexcept
		{
		}
		~__new_allocator() noexcept
		{
		}
		pointer address(reference __x) const noexcept
		{
			return std::__addressof(__x);
		}
		const_pointer address(const_reference __x) const noexcept
		{
			return std::__addressof(__x);
		}
		[[__nodiscard__]] _Tp *allocate(size_type __n, const void * = 0)
		{
			static_assert((sizeof(_Tp) != (0)),
				      "cannot allocate incomplete types");
			if (__builtin_expect(__n > _M_max_size(), false)) {
				if (__n > (((size_t)(-1)) / sizeof(_Tp))) {
					std::__throw_bad_array_new_length();
				}
				std::__throw_bad_alloc();
			}
			if (__alignof__(_Tp) > (16)) {
				align_val_t __al =
					((align_val_t) __alignof__(_Tp));
				return static_cast<_Tp *>(::operator new(
					__n * sizeof(_Tp), __al));
			}
			return static_cast<_Tp *>(
				::operator new(__n * sizeof(_Tp)));
		}
		void deallocate(_Tp *__p,
				size_type __n __attribute((__unused__)))
		{
			if (__alignof__(_Tp) > (16)) {
				::operator delete(
					__p, __n * sizeof(_Tp),
					(align_val_t) __alignof__(_Tp));
				return;
			}
			::operator delete(__p, __n * sizeof(_Tp));
		}
		size_type max_size() const noexcept
		{
			return _M_max_size();
		}
		template <class _Up, class... _Args>
		void construct(_Up *__p, _Args &&...__args) noexcept(
			std::template is_nothrow_constructible<_Up,
							       _Args...>::value)
		{
			::new ((void *)__p) _Up(std::forward<_Args>(__args)...);
		}
		template <class _Up>
		void destroy(_Up *__p) noexcept(
			std::template is_nothrow_destructible<_Up>::value)
		{
			__p->~_Up();
		}
		template <class _Up>
		friend inline bool
		operator==(const __new_allocator<_Tp> &,
			   const std::__new_allocator<_Up> &) noexcept
		{
			return true;
		}
		template <class _Up>
		friend inline bool
		operator!=(const __new_allocator<_Tp> &,
			   const std::__new_allocator<_Up> &) noexcept
		{
			return false;
		}

	    private:
		constexpr size_type _M_max_size() const noexcept
		{
			return ((size_t)9223372036854775807L) / sizeof(_Tp);
		}
	};
} // namespace )
namespace std
{
template <class _Tp> using __allocator_base = __new_allocator<_Tp>;
}
namespace std __attribute((__visibility__("default")))
{
	template <class> class allocator;
	template <> class allocator<void>;
	template <class, class> struct uses_allocator;
	template <class> struct allocator_traits;
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <> class allocator<void> {
	    public:
		typedef void value_type;
		typedef size_t size_type;
		typedef ptrdiff_t difference_type;
		typedef void *pointer;
		typedef const void *const_pointer;
		template <class _Tp1> struct rebind {
			typedef std::allocator<_Tp1> other;
		};
		using propagate_on_container_move_assignment = true_type;
		using is_always_equal = true_type;
	};
	template <class _Tp> class allocator : public __allocator_base<_Tp> {
	    public:
		typedef _Tp value_type;
		typedef std::size_t size_type;
		typedef std::ptrdiff_t difference_type;
		typedef _Tp *pointer;
		typedef const _Tp *const_pointer;
		typedef _Tp &reference;
		typedef const _Tp &const_reference;
		template <class _Tp1> struct rebind {
			typedef allocator<_Tp1> other;
		};
		using propagate_on_container_move_assignment = std::true_type;
		using is_always_equal = std::true_type;
		allocator() noexcept
		{
		}
		allocator(const allocator &__a) noexcept
			: std::__allocator_base<_Tp>(__a)
		{
		}
		allocator &operator=(const allocator &) = default;
		template <class _Tp1>
		allocator(const allocator<_Tp1> &) noexcept
		{
		}
		~allocator() noexcept
		{
		}
		friend inline bool operator==(const allocator<_Tp> &,
					      const allocator<_Tp> &) noexcept
		{
			return true;
		}
		friend inline bool operator!=(const allocator<_Tp> &,
					      const allocator<_Tp> &) noexcept
		{
			return false;
		}
	};
	template <class _T1, class _T2>
	inline bool operator==(const allocator<_T1> &,
			       const allocator<_T2> &) noexcept
	{
		return true;
	}
	template <class _T1, class _T2>
	inline bool operator!=(const allocator<_T1> &,
			       const allocator<_T2> &) noexcept
	{
		return false;
	}
	template <class _Tp> class allocator<const _Tp> {
	    public:
		typedef _Tp value_type;
		template <class _Up> allocator(const std::allocator<_Up> &)
		{
		}
	};
	template <class _Tp> class allocator<volatile _Tp> {
	    public:
		typedef _Tp value_type;
		template <class _Up> allocator(const std::allocator<_Up> &)
		{
		}
	};
	template <class _Tp> class allocator<const volatile _Tp> {
	    public:
		typedef _Tp value_type;
		template <class _Up> allocator(const std::allocator<_Up> &)
		{
		}
	};
	extern template class allocator<char>;
	extern template class allocator<wchar_t>;
	template <class _Alloc, bool = __is_empty(_Alloc)> struct __alloc_swap {
		static void _S_do_it(_Alloc &, _Alloc &) noexcept
		{
		}
	};
	template <class _Alloc> struct __alloc_swap<_Alloc, false> {
		static void _S_do_it(_Alloc &__one, _Alloc &__two) noexcept
		{
			if (__one != __two) {
				swap(__one, __two);
			}
		}
	};
	template <class _Alloc, bool = __is_empty(_Alloc)> struct __alloc_neq {
		static bool _S_do_it(const _Alloc &, const _Alloc &)
		{
			return false;
		}
	};
	template <class _Alloc> struct __alloc_neq<_Alloc, false> {
		static bool _S_do_it(const _Alloc &__one, const _Alloc &__two)
		{
			return __one != __two;
		}
	};
	template <class _Tp,
		  bool = __or_<is_copy_constructible<typename _Tp::value_type>,
			       is_nothrow_move_constructible<
				       typename _Tp::value_type>>::value>
	struct __shrink_to_fit_aux {
		static bool _S_do_it(_Tp &) noexcept
		{
			return false;
		}
	};
	template <class _Tp> struct __shrink_to_fit_aux<_Tp, true> {
		static bool _S_do_it(_Tp &__c) noexcept
		{
			try {
				_Tp(__make_move_if_noexcept_iterator(
					    __c.begin()),
				    __make_move_if_noexcept_iterator(__c.end()),
				    __c.get_allocator())
					.swap(__c);
				return true;
			} catch (...) {
				return false;
			}
		}
	};
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _Tp> inline void destroy_at(_Tp * __location)
	{
		if constexpr ((201703L > 201703L) && is_array_v<_Tp>) {
			for (auto &__x : *__location) {
				std::destroy_at(std::__addressof(__x));
			}
		} else {
			__location->~_Tp();
		}
	}
	template <class _Tp, class... _Args>
	inline void _Construct(_Tp * __p, _Args && ...__args)
	{
		::new ((void *)__p) _Tp(std::forward<_Args>(__args)...);
	}
	template <class _T1> inline void _Construct_novalue(_T1 * __p)
	{
		::new ((void *)__p) _T1;
	}
	template <class _ForwardIterator>
	inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last);
	template <class _Tp> constexpr void _Destroy(_Tp * __pointer)
	{
		__pointer->~_Tp();
	}
	template <bool> struct _Destroy_aux {
		template <class _ForwardIterator>
		static void __destroy(_ForwardIterator __first,
				      _ForwardIterator __last)
		{
			for (; __first != __last; ++__first) {
				std::_Destroy(std::__addressof(*__first));
			}
		}
	};
	template <> struct _Destroy_aux<true> {
		template <class _ForwardIterator>
		static void __destroy(_ForwardIterator, _ForwardIterator)
		{
		}
	};
	template <class _ForwardIterator>
	inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last)
	{
		typedef typename iterator_traits<_ForwardIterator>::value_type
			_Value_type;
		static_assert((is_destructible<typename iterator_traits<
				       _ForwardIterator>::value_type>::value),
			      "value type is destructible");
		std::template _Destroy_aux<__has_trivial_destructor(
			_Value_type)>::__destroy(__first, __last);
	}
	template <bool> struct _Destroy_n_aux {
		template <class _ForwardIterator, class _Size>
		static _ForwardIterator __destroy_n(_ForwardIterator __first,
						    _Size __count)
		{
			for (; __count > 0; ((void)(++__first)), (--__count)) {
				std::_Destroy(std::__addressof(*__first));
			}
			return __first;
		}
	};
	template <> struct _Destroy_n_aux<true> {
		template <class _ForwardIterator, class _Size>
		static _ForwardIterator __destroy_n(_ForwardIterator __first,
						    _Size __count)
		{
			std::advance(__first, __count);
			return __first;
		}
	};
	template <class _ForwardIterator, class _Size>
	inline _ForwardIterator _Destroy_n(_ForwardIterator __first,
					   _Size __count)
	{
		typedef typename iterator_traits<_ForwardIterator>::value_type
			_Value_type;
		static_assert((is_destructible<typename iterator_traits<
				       _ForwardIterator>::value_type>::value),
			      "value type is destructible");
		return std::template _Destroy_n_aux<__has_trivial_destructor(
			_Value_type)>::__destroy_n(__first, __count);
	}
	template <class _ForwardIterator>
	inline void destroy(_ForwardIterator __first, _ForwardIterator __last)
	{
		std::_Destroy(__first, __last);
	}
	template <class _ForwardIterator, class _Size>
	inline _ForwardIterator destroy_n(_ForwardIterator __first,
					  _Size __count)
	{
		return std::_Destroy_n(__first, __count);
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	struct __allocator_traits_base {
		template <class _Tp, class _Up, class = void>
		struct __rebind : public __replace_first_arg<_Tp, _Up> {
		};
		template <class _Tp, class _Up>
		struct __rebind<
			_Tp, _Up,
			__void_t<typename _Tp::template rebind<_Up>::other>> {
			using type = typename _Tp::template rebind<_Up>::other;
		};

	    protected:
		template <class _Tp> using __pointer = typename _Tp::pointer;
		template <class _Tp>
		using __c_pointer = typename _Tp::const_pointer;
		template <class _Tp>
		using __v_pointer = typename _Tp::void_pointer;
		template <class _Tp>
		using __cv_pointer = typename _Tp::const_void_pointer;
		template <class _Tp>
		using __pocca =
			typename _Tp::propagate_on_container_copy_assignment;
		template <class _Tp>
		using __pocma =
			typename _Tp::propagate_on_container_move_assignment;
		template <class _Tp>
		using __pocs = typename _Tp::propagate_on_container_swap;
		template <class _Tp>
		using __equal = typename _Tp::is_always_equal;
	};
	template <class _Alloc, class _Up>
	using __alloc_rebind =
		typename __allocator_traits_base::template __rebind<_Alloc,
								    _Up>::type;
	template <class _Alloc>
	struct allocator_traits : public __allocator_traits_base {
		typedef _Alloc allocator_type;
		typedef typename _Alloc::value_type value_type;
		using pointer =
			__detected_or_t<value_type *, __pointer, _Alloc>;

	    private:
		template <template <class> class _Func, class _Tp, class = void>
		struct _Ptr {
			using type = typename pointer_traits<
				pointer>::template rebind<_Tp>;
		};
		template <template <class> class _Func, class _Tp>
		struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>> {
			using type = _Func<_Alloc>;
		};
		template <class _A2, class _PtrT, class = void> struct _Diff {
			using type =
				typename pointer_traits<_PtrT>::difference_type;
		};
		template <class _A2, class _PtrT>
		struct _Diff<_A2, _PtrT,
			     __void_t<typename _A2::difference_type>> {
			using type = typename _A2::difference_type;
		};
		template <class _A2, class _DiffT, class = void>
		struct _Size : public make_unsigned<_DiffT> {
		};
		template <class _A2, class _DiffT>
		struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>> {
			using type = typename _A2::size_type;
		};

	    public:
		using const_pointer =
			typename _Ptr<__c_pointer, const value_type>::type;
		using void_pointer = typename _Ptr<__v_pointer, void>::type;
		using const_void_pointer =
			typename _Ptr<__cv_pointer, const void>::type;
		using difference_type = typename _Diff<_Alloc, pointer>::type;
		using size_type = typename _Size<_Alloc, difference_type>::type;
		using propagate_on_container_copy_assignment =
			__detected_or_t<false_type, __pocca, _Alloc>;
		using propagate_on_container_move_assignment =
			__detected_or_t<false_type, __pocma, _Alloc>;
		using propagate_on_container_swap =
			__detected_or_t<false_type, __pocs, _Alloc>;
		using is_always_equal =
			__detected_or_t<typename is_empty<_Alloc>::type,
					__equal, _Alloc>;
		template <class _Tp>
		using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
		template <class _Tp>
		using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

	    private:
		template <class _Alloc2>
		static constexpr auto _S_allocate(_Alloc2 &__a, size_type __n,
						  const_void_pointer __hint,
						  int)
			-> __decltype((__a.allocate(__n, __hint)))
		{
			return __a.allocate(__n, __hint);
		}
		template <class _Alloc2>
		static constexpr pointer _S_allocate(_Alloc2 &__a,
						     size_type __n,
						     const_void_pointer, ...)
		{
			return __a.allocate(__n);
		}
		template <class _Tp, class... _Args> struct __construct_helper {
			template <class _Alloc2,
				  class = __decltype((
					  std::declval<_Alloc2 *>()->construct(
						  std::declval<_Tp *>(),
						  std::declval<_Args>()...)))>
			static true_type __test(int);
			template <class> static false_type __test(...);
			using type = __decltype((__test<_Alloc>(0)));
		};
		template <class _Tp, class... _Args>
		using __has_construct =
			typename __construct_helper<_Tp, _Args...>::type;
		template <class _Tp, class... _Args>
		static constexpr _Require<__has_construct<_Tp, _Args...>>
		_S_construct(_Alloc &__a, _Tp *__p, _Args &&...__args) noexcept(
			noexcept(__a.construct(__p,
					       std::forward<_Args>(__args)...)))
		{
			__a.construct(__p, std::forward<_Args>(__args)...);
		}
		template <class _Tp, class... _Args>
		static constexpr _Require<
			__and_<__not_<__has_construct<_Tp, _Args...>>,
			       is_constructible<_Tp, _Args...>>>
		_S_construct(_Alloc &, _Tp *__p, _Args &&...__args) noexcept(
			std::template is_nothrow_constructible<_Tp,
							       _Args...>::value)
		{
			::new ((void *)__p) _Tp(std::forward<_Args>(__args)...);
		}
		template <class _Alloc2, class _Tp>
		static constexpr auto
		_S_destroy(_Alloc2 &__a, _Tp *__p,
			   int) noexcept(noexcept(__a.destroy(__p)))
			-> __decltype((__a.destroy(__p)))
		{
			__a.destroy(__p);
		}
		template <class _Alloc2, class _Tp>
		static constexpr void
		_S_destroy(_Alloc2 &, _Tp *__p, ...) noexcept(
			std::template is_nothrow_destructible<_Tp>::value)
		{
			std::_Destroy(__p);
		}
		template <class _Alloc2>
		static constexpr auto _S_max_size(_Alloc2 &__a, int)
			-> __decltype((__a.max_size()))
		{
			return __a.max_size();
		}
		template <class _Alloc2>
		static constexpr size_type _S_max_size(_Alloc2 &, ...)
		{
			return __gnu_cxx::template __numeric_traits<
				       size_type>::__max /
			       sizeof(value_type);
		}
		template <class _Alloc2>
		static constexpr auto _S_select(_Alloc2 &__a, int)
			-> __decltype((
				__a.select_on_container_copy_construction()))
		{
			return __a.select_on_container_copy_construction();
		}
		template <class _Alloc2>
		static constexpr _Alloc2 _S_select(_Alloc2 &__a, ...)
		{
			return __a;
		}

	    public:
		[[__nodiscard__]] static pointer allocate(_Alloc &__a,
							  size_type __n)
		{
			return __a.allocate(__n);
		}
		[[__nodiscard__]] static pointer
		allocate(_Alloc &__a, size_type __n, const_void_pointer __hint)
		{
			return _S_allocate(__a, __n, __hint, 0);
		}
		static void deallocate(_Alloc &__a, pointer __p, size_type __n)
		{
			__a.deallocate(__p, __n);
		}
		template <class _Tp, class... _Args>
		static auto
		construct(_Alloc &__a, _Tp *__p, _Args &&...__args) noexcept(
			noexcept(_S_construct(__a, __p,
					      std::forward<_Args>(__args)...)))
			-> __decltype((_S_construct(
				__a, __p, std::forward<_Args>(__args)...)))
		{
			_S_construct(__a, __p, std::forward<_Args>(__args)...);
		}
		template <class _Tp>
		static void
		destroy(_Alloc &__a,
			_Tp *__p) noexcept(noexcept(_S_destroy(__a, __p, 0)))
		{
			_S_destroy(__a, __p, 0);
		}
		static size_type max_size(const _Alloc &__a) noexcept
		{
			return _S_max_size(__a, 0);
		}
		static _Alloc
		select_on_container_copy_construction(const _Alloc &__rhs)
		{
			return _S_select(__rhs, 0);
		}
	};
	template <class _Tp> struct allocator_traits<allocator<_Tp>> {
		using allocator_type = allocator<_Tp>;
		using value_type = _Tp;
		using pointer = _Tp *;
		using const_pointer = const _Tp *;
		using void_pointer = void *;
		using const_void_pointer = const void *;
		using difference_type = ptrdiff_t;
		using size_type = size_t;
		using propagate_on_container_copy_assignment = false_type;
		using propagate_on_container_move_assignment = true_type;
		using propagate_on_container_swap = false_type;
		using is_always_equal = true_type;
		template <class _Up> using rebind_alloc = allocator<_Up>;
		template <class _Up>
		using rebind_traits = std::allocator_traits<allocator<_Up>>;
		[[__nodiscard__]] static pointer allocate(allocator_type &__a,
							  size_type __n)
		{
			return __a.allocate(__n);
		}
		[[__nodiscard__]] static pointer
		allocate(allocator_type &__a, size_type __n,
			 const_void_pointer __hint)
		{
			return __a.allocate(__n, __hint);
		}
		static void deallocate(allocator_type &__a, pointer __p,
				       size_type __n)
		{
			__a.deallocate(__p, __n);
		}
		template <class _Up, class... _Args>
		static void construct(
			allocator_type &__a __attribute((__unused__)), _Up *__p,
			_Args &&...__args) noexcept(std::
							    template is_nothrow_constructible<
								    _Up,
								    _Args...>::
								    value)
		{
			__a.construct(__p, std::forward<_Args>(__args)...);
		}
		template <class _Up>
		static void
		destroy(allocator_type &__a __attribute((__unused__)),
			_Up *__p) noexcept(is_nothrow_destructible<_Up>::value)
		{
			__a.destroy(__p);
		}
		static size_type max_size(const allocator_type &__a
					  __attribute((__unused__))) noexcept
		{
			return __a.max_size();
		}
		static allocator_type select_on_container_copy_construction(
			const allocator_type &__rhs)
		{
			return __rhs;
		}
	};
	template <> struct allocator_traits<allocator<void>> {
		using allocator_type = allocator<void>;
		using value_type = void;
		using pointer = void *;
		using const_pointer = const void *;
		using void_pointer = void *;
		using const_void_pointer = const void *;
		using difference_type = ptrdiff_t;
		using size_type = size_t;
		using propagate_on_container_copy_assignment = false_type;
		using propagate_on_container_move_assignment = true_type;
		using propagate_on_container_swap = false_type;
		using is_always_equal = true_type;
		template <class _Up> using rebind_alloc = allocator<_Up>;
		template <class _Up>
		using rebind_traits = std::allocator_traits<allocator<_Up>>;
		static void *allocate(allocator_type &, size_type,
				      const void * = 0) = delete;
		static void deallocate(allocator_type &, void *,
				       size_type) = delete;
		template <class _Up, class... _Args>
		static void
		construct(allocator_type &, _Up *__p, _Args &&...__args) noexcept(
			std::template is_nothrow_constructible<_Up,
							       _Args...>::value)
		{
			std::_Construct(__p, std::forward<_Args>(__args)...);
		}
		template <class _Up>
		static void
		destroy(allocator_type &,
			_Up *__p) noexcept(is_nothrow_destructible<_Up>::value)
		{
			std::_Destroy(__p);
		}
		static size_type max_size(const allocator_type &) = delete;
		static allocator_type select_on_container_copy_construction(
			const allocator_type &__rhs)
		{
			return __rhs;
		}
	};
	template <class _Alloc>
	constexpr void __alloc_on_copy(_Alloc & __one, const _Alloc &__two)
	{
		typedef allocator_traits<_Alloc> __traits;
		typedef typename allocator_traits<
			_Alloc>::propagate_on_container_copy_assignment __pocca;
		if constexpr (__pocca::value) {
			__one = __two;
		}
	}
	template <class _Alloc>
	constexpr _Alloc __alloc_on_copy(const _Alloc &__a)
	{
		typedef allocator_traits<_Alloc> __traits;
		return __traits::select_on_container_copy_construction(__a);
	}
	template <class _Alloc>
	constexpr void __alloc_on_move(_Alloc & __one, _Alloc & __two)
	{
		typedef allocator_traits<_Alloc> __traits;
		typedef typename allocator_traits<
			_Alloc>::propagate_on_container_move_assignment __pocma;
		if constexpr (__pocma::value) {
			__one = std::move(__two);
		}
	}
	template <class _Alloc>
	constexpr void __alloc_on_swap(_Alloc & __one, _Alloc & __two)
	{
		typedef allocator_traits<_Alloc> __traits;
		typedef typename allocator_traits<
			_Alloc>::propagate_on_container_swap __pocs;
		if constexpr (__pocs::value) {
			using std::swap;
			swap(__one, __two);
		}
	}
	template <class _Alloc, class _Tp,
		  class _ValueT = __remove_cvref_t<typename _Alloc::value_type>,
		  class = void>
	struct __is_alloc_insertable_impl : public false_type {
	};
	template <class _Alloc, class _Tp, class _ValueT>
	struct __is_alloc_insertable_impl<
		_Alloc, _Tp, _ValueT,
		__void_t<__decltype((allocator_traits<_Alloc>::construct(
			std::declval<_Alloc &>(), std::declval<_ValueT *>(),
			std::declval<_Tp>())))>> : public true_type {
	};
	template <class _Alloc>
	struct __is_copy_insertable
		: public __is_alloc_insertable_impl<
			  _Alloc, const typename _Alloc::value_type &>::type {
	};
	template <class _Tp>
	struct __is_copy_insertable<allocator<_Tp>>
		: public is_copy_constructible<_Tp> {
	};
	template <class _Alloc>
	struct __is_move_insertable
		: public __is_alloc_insertable_impl<
			  _Alloc, typename _Alloc::value_type>::type {
	};
	template <class _Tp>
	struct __is_move_insertable<allocator<_Tp>>
		: public is_move_constructible<_Tp> {
	};
	template <class _Alloc, class = void>
	struct __is_allocator : public false_type {
	};
	template <class _Alloc>
	struct __is_allocator<
		_Alloc, __void_t<typename _Alloc::value_type,
				 __decltype((std::declval<_Alloc &>().allocate(
					 (unsigned long)0UL)))>>
		: public true_type {
	};
	template <class _Alloc>
	using _RequireAllocator =
		typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;
	template <class _Alloc>
	using _RequireNotAllocator =
		typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;
	template <class _ForwardIterator, class _Allocator>
	void _Destroy(_ForwardIterator __first, _ForwardIterator __last,
		      _Allocator & __alloc)
	{
		for (; __first != __last; ++__first) {
			allocator_traits<_Allocator>::destroy(
				__alloc, std::__addressof(*__first));
		}
	}
	template <class _ForwardIterator, class _Tp>
	inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last,
			     allocator<_Tp> &)
	{
		_Destroy(__first, __last);
	}
} // namespace )
namespace __gnu_cxx __attribute((__visibility__("default")))
{
	template <class _Alloc, class = typename _Alloc::value_type>
	struct __alloc_traits : public std::allocator_traits<_Alloc> {
		typedef _Alloc allocator_type;
		typedef std::allocator_traits<_Alloc> _Base_type;
		typedef typename std::allocator_traits<_Alloc>::value_type
			value_type;
		typedef typename std::allocator_traits<_Alloc>::pointer pointer;
		typedef typename std::allocator_traits<_Alloc>::const_pointer
			const_pointer;
		typedef typename std::allocator_traits<_Alloc>::size_type
			size_type;
		typedef typename std::allocator_traits<_Alloc>::difference_type
			difference_type;
		typedef value_type &reference;
		typedef const value_type &const_reference;
		using std::allocator_traits<_Alloc>::allocate;
		using std::allocator_traits<_Alloc>::deallocate;
		using std::allocator_traits<_Alloc>::construct;
		using std::allocator_traits<_Alloc>::destroy;
		using std::allocator_traits<_Alloc>::max_size;

	    private:
		template <class _Ptr>
		using __is_custom_pointer =
			std::__and_<std::is_same<pointer, _Ptr>,
				    std::__not_<std::is_pointer<_Ptr>>>;

	    public:
		template <class _Ptr, class... _Args>
		static constexpr std::__enable_if_t<
			__is_custom_pointer<_Ptr>::value>
		construct(_Alloc &__a, _Ptr __p, _Args &&...__args) noexcept(
			noexcept(_Base_type::construct(
				__a, std::__to_address(__p),
				std::forward<_Args>(__args)...)))
		{
			_Base_type::construct(__a, std::__to_address(__p),
					      std::forward<_Args>(__args)...);
		}
		template <class _Ptr>
		static constexpr std::__enable_if_t<
			__is_custom_pointer<_Ptr>::value>
		destroy(_Alloc &__a, _Ptr __p) noexcept(noexcept(
			_Base_type::destroy(__a, std::__to_address(__p))))
		{
			_Base_type::destroy(__a, std::__to_address(__p));
		}
		static constexpr _Alloc _S_select_on_copy(const _Alloc &__a)
		{
			return _Base_type::select_on_container_copy_construction(
				__a);
		}
		static constexpr void _S_on_swap(_Alloc &__a, _Alloc &__b)
		{
			std::__alloc_on_swap(__a, __b);
		}
		static constexpr bool _S_propagate_on_copy_assign()
		{
			return _Base_type::
				propagate_on_container_copy_assignment::value;
		}
		static constexpr bool _S_propagate_on_move_assign()
		{
			return _Base_type::
				propagate_on_container_move_assignment::value;
		}
		static constexpr bool _S_propagate_on_swap()
		{
			return _Base_type::propagate_on_container_swap::value;
		}
		static constexpr bool _S_always_equal()
		{
			return _Base_type::is_always_equal::value;
		}
		static constexpr bool _S_nothrow_move()
		{
			return (_S_propagate_on_move_assign)() ||
			       (_S_always_equal)();
		}
		template <class _Tp> struct rebind {
			typedef typename std::allocator_traits<
				_Alloc>::template rebind_alloc<_Tp>
				other;
		};
	};
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _ValueType, class _Tp>
	constexpr bool __check_constructible()
	{
		static_assert(
			(is_constructible<_ValueType, _Tp>::value),
			"result type must be constructible from input type");
		return true;
	}
	template <class _InputIterator, class _ForwardIterator>
	_ForwardIterator __do_uninit_copy(_InputIterator __first,
					  _InputIterator __last,
					  _ForwardIterator __result)
	{
		_ForwardIterator __cur = __result;
		try {
			for (; __first != __last;
			     (++__first), ((void)(++__cur))) {
				std::_Construct(std::__addressof(*__cur),
						*__first);
			}
			return __cur;
		} catch (...) {
			std::_Destroy(__result, __cur);
			throw;
		}
	}
	template <bool _TrivialValueTypes> struct __uninitialized_copy {
		template <class _InputIterator, class _ForwardIterator>
		static _ForwardIterator __uninit_copy(_InputIterator __first,
						      _InputIterator __last,
						      _ForwardIterator __result)
		{
			return std::__do_uninit_copy(__first, __last, __result);
		}
	};
	template <> struct __uninitialized_copy<true> {
		template <class _InputIterator, class _ForwardIterator>
		static _ForwardIterator __uninit_copy(_InputIterator __first,
						      _InputIterator __last,
						      _ForwardIterator __result)
		{
			return std::copy(__first, __last, __result);
		}
	};
	template <class _InputIterator, class _ForwardIterator>
	inline _ForwardIterator uninitialized_copy(_InputIterator __first,
						   _InputIterator __last,
						   _ForwardIterator __result)
	{
		typedef typename iterator_traits<_InputIterator>::value_type
			_ValueType1;
		typedef typename iterator_traits<_ForwardIterator>::value_type
			_ValueType2;
		const bool __can_memmove = __is_trivial(_ValueType1);
		using _From = __decltype((*__first));
		const bool __assignable =
			__is_trivial(_ValueType2) &&
			__is_assignable(_ValueType2 &, _From) &&
			std::__check_constructible<
				typename iterator_traits<
					_ForwardIterator>::value_type,
				__decltype((*__first))>();
		return std::template __uninitialized_copy < __can_memmove &&
		       __assignable >
			       ::__uninit_copy(__first, __last, __result);
	}
	template <class _ForwardIterator, class _Tp>
	void __do_uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
			      const _Tp &__x)
	{
		_ForwardIterator __cur = __first;
		try {
			for (; __cur != __last; ++__cur) {
				std::_Construct(std::__addressof(*__cur), __x);
			}
		} catch (...) {
			std::_Destroy(__first, __cur);
			throw;
		}
	}
	template <bool _TrivialValueType> struct __uninitialized_fill {
		template <class _ForwardIterator, class _Tp>
		static void __uninit_fill(_ForwardIterator __first,
					  _ForwardIterator __last,
					  const _Tp &__x)
		{
			std::__do_uninit_fill(__first, __last, __x);
		}
	};
	template <> struct __uninitialized_fill<true> {
		template <class _ForwardIterator, class _Tp>
		static void __uninit_fill(_ForwardIterator __first,
					  _ForwardIterator __last,
					  const _Tp &__x)
		{
			std::fill(__first, __last, __x);
		}
	};
	template <class _ForwardIterator, class _Tp>
	inline void uninitialized_fill(_ForwardIterator __first,
				       _ForwardIterator __last, const _Tp &__x)
	{
		typedef typename iterator_traits<_ForwardIterator>::value_type
			_ValueType;
		const bool __can_fill =
			__is_trivial(_ValueType) &&
			__is_assignable(_ValueType &, const _Tp &) &&
			std::__check_constructible<
				typename iterator_traits<
					_ForwardIterator>::value_type,
				const _Tp &>();
		std::template __uninitialized_fill<__can_fill>::__uninit_fill(
			__first, __last, __x);
	}
	template <class _ForwardIterator, class _Size, class _Tp>
	_ForwardIterator __do_uninit_fill_n(_ForwardIterator __first, _Size __n,
					    const _Tp &__x)
	{
		_ForwardIterator __cur = __first;
		try {
			for (; __n > 0; (--__n), ((void)(++__cur))) {
				std::_Construct(std::__addressof(*__cur), __x);
			}
			return __cur;
		} catch (...) {
			std::_Destroy(__first, __cur);
			throw;
		}
	}
	template <bool _TrivialValueType> struct __uninitialized_fill_n {
		template <class _ForwardIterator, class _Size, class _Tp>
		static _ForwardIterator
		__uninit_fill_n(_ForwardIterator __first, _Size __n,
				const _Tp &__x)
		{
			return std::__do_uninit_fill_n(__first, __n, __x);
		}
	};
	template <> struct __uninitialized_fill_n<true> {
		template <class _ForwardIterator, class _Size, class _Tp>
		static _ForwardIterator
		__uninit_fill_n(_ForwardIterator __first, _Size __n,
				const _Tp &__x)
		{
			return std::fill_n(__first, __n, __x);
		}
	};
	template <class _ForwardIterator, class _Size, class _Tp>
	inline _ForwardIterator uninitialized_fill_n(_ForwardIterator __first,
						     _Size __n, const _Tp &__x)
	{
		typedef typename iterator_traits<_ForwardIterator>::value_type
			_ValueType;
		const bool __can_fill =
			__is_trivial(_ValueType) &&
			__is_assignable(_ValueType &, const _Tp &) &&
			std::__check_constructible<
				typename iterator_traits<
					_ForwardIterator>::value_type,
				const _Tp &>() &&
			__is_integer<_Size>::__value;
		return __uninitialized_fill_n<__can_fill>::__uninit_fill_n(
			__first, __n, __x);
	}
	template <class _InputIterator, class _ForwardIterator, class _Allocator>
	_ForwardIterator __uninitialized_copy_a(_InputIterator __first,
						_InputIterator __last,
						_ForwardIterator __result,
						_Allocator & __alloc)
	{
		_ForwardIterator __cur = __result;
		try {
			typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
			for (; __first != __last;
			     (++__first), ((void)(++__cur))) {
				__traits::construct(__alloc,
						    std::__addressof(*__cur),
						    *__first);
			}
			return __cur;
		} catch (...) {
			std::_Destroy(__result, __cur, __alloc);
			throw;
		}
	}
	template <class _InputIterator, class _ForwardIterator, class _Tp>
	inline _ForwardIterator __uninitialized_copy_a(
		_InputIterator __first, _InputIterator __last,
		_ForwardIterator __result, allocator<_Tp> &)
	{
		return std::uninitialized_copy(__first, __last, __result);
	}
	template <class _InputIterator, class _ForwardIterator, class _Allocator>
	inline _ForwardIterator __uninitialized_move_a(
		_InputIterator __first, _InputIterator __last,
		_ForwardIterator __result, _Allocator & __alloc)
	{
		return std::__uninitialized_copy_a(
			std::make_move_iterator(__first),
			std::make_move_iterator(__last), __result, __alloc);
	}
	template <class _InputIterator, class _ForwardIterator, class _Allocator>
	inline _ForwardIterator __uninitialized_move_if_noexcept_a(
		_InputIterator __first, _InputIterator __last,
		_ForwardIterator __result, _Allocator & __alloc)
	{
		return std::__uninitialized_copy_a(
			std::__make_move_if_noexcept_iterator(__first),
			std::__make_move_if_noexcept_iterator(__last), __result,
			__alloc);
	}
	template <class _ForwardIterator, class _Tp, class _Allocator>
	void __uninitialized_fill_a(_ForwardIterator __first,
				    _ForwardIterator __last, const _Tp &__x,
				    _Allocator &__alloc)
	{
		_ForwardIterator __cur = __first;
		try {
			typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
			for (; __cur != __last; ++__cur) {
				__traits::construct(
					__alloc, std::__addressof(*__cur), __x);
			}
		} catch (...) {
			std::_Destroy(__first, __cur, __alloc);
			throw;
		}
	}
	template <class _ForwardIterator, class _Tp, class _Tp2>
	inline void __uninitialized_fill_a(_ForwardIterator __first,
					   _ForwardIterator __last,
					   const _Tp &__x, allocator<_Tp2> &)
	{
		std::uninitialized_fill(__first, __last, __x);
	}
	template <class _ForwardIterator, class _Size, class _Tp,
		  class _Allocator>
	_ForwardIterator __uninitialized_fill_n_a(_ForwardIterator __first,
						  _Size __n, const _Tp &__x,
						  _Allocator &__alloc)
	{
		_ForwardIterator __cur = __first;
		try {
			typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
			for (; __n > 0; (--__n), ((void)(++__cur))) {
				__traits::construct(
					__alloc, std::__addressof(*__cur), __x);
			}
			return __cur;
		} catch (...) {
			std::_Destroy(__first, __cur, __alloc);
			throw;
		}
	}
	template <class _ForwardIterator, class _Size, class _Tp, class _Tp2>
	inline _ForwardIterator __uninitialized_fill_n_a(
		_ForwardIterator __first, _Size __n, const _Tp &__x,
		allocator<_Tp2> &)
	{
		return std::uninitialized_fill_n(__first, __n, __x);
	}
	template <class _InputIterator1, class _InputIterator2,
		  class _ForwardIterator, class _Allocator>
	inline _ForwardIterator __uninitialized_copy_move(
		_InputIterator1 __first1, _InputIterator1 __last1,
		_InputIterator2 __first2, _InputIterator2 __last2,
		_ForwardIterator __result, _Allocator & __alloc)
	{
		_ForwardIterator __mid = std::__uninitialized_copy_a(
			__first1, __last1, __result, __alloc);
		try {
			return std::__uninitialized_move_a(__first2, __last2,
							   __mid, __alloc);
		} catch (...) {
			std::_Destroy(__result, __mid, __alloc);
			throw;
		}
	}
	template <class _InputIterator1, class _InputIterator2,
		  class _ForwardIterator, class _Allocator>
	inline _ForwardIterator __uninitialized_move_copy(
		_InputIterator1 __first1, _InputIterator1 __last1,
		_InputIterator2 __first2, _InputIterator2 __last2,
		_ForwardIterator __result, _Allocator & __alloc)
	{
		_ForwardIterator __mid = std::__uninitialized_move_a(
			__first1, __last1, __result, __alloc);
		try {
			return std::__uninitialized_copy_a(__first2, __last2,
							   __mid, __alloc);
		} catch (...) {
			std::_Destroy(__result, __mid, __alloc);
			throw;
		}
	}
	template <class _ForwardIterator, class _Tp, class _InputIterator,
		  class _Allocator>
	inline _ForwardIterator __uninitialized_fill_move(
		_ForwardIterator __result, _ForwardIterator __mid,
		const _Tp &__x, _InputIterator __first, _InputIterator __last,
		_Allocator &__alloc)
	{
		std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
		try {
			return std::__uninitialized_move_a(__first, __last,
							   __mid, __alloc);
		} catch (...) {
			std::_Destroy(__result, __mid, __alloc);
			throw;
		}
	}
	template <class _InputIterator, class _ForwardIterator, class _Tp,
		  class _Allocator>
	inline void __uninitialized_move_fill(
		_InputIterator __first1, _InputIterator __last1,
		_ForwardIterator __first2, _ForwardIterator __last2,
		const _Tp &__x, _Allocator &__alloc)
	{
		_ForwardIterator __mid2 = std::__uninitialized_move_a(
			__first1, __last1, __first2, __alloc);
		try {
			std::__uninitialized_fill_a(__mid2, __last2, __x,
						    __alloc);
		} catch (...) {
			std::_Destroy(__first2, __mid2, __alloc);
			throw;
		}
	}
	template <bool _TrivialValueType> struct __uninitialized_default_1 {
		template <class _ForwardIterator>
		static void __uninit_default(_ForwardIterator __first,
					     _ForwardIterator __last)
		{
			_ForwardIterator __cur = __first;
			try {
				for (; __cur != __last; ++__cur) {
					std::_Construct(
						std::__addressof(*__cur));
				}
			} catch (...) {
				std::_Destroy(__first, __cur);
				throw;
			}
		}
	};
	template <> struct __uninitialized_default_1<true> {
		template <class _ForwardIterator>
		static void __uninit_default(_ForwardIterator __first,
					     _ForwardIterator __last)
		{
			if (__first == __last) {
				return;
			}
			typename iterator_traits<_ForwardIterator>::value_type
				*__val = std::__addressof(*__first);
			std::_Construct(__val);
			if ((++__first) != __last) {
				std::fill(__first, __last, *__val);
			}
		}
	};
	template <bool _TrivialValueType> struct __uninitialized_default_n_1 {
		template <class _ForwardIterator, class _Size>
		static _ForwardIterator
		__uninit_default_n(_ForwardIterator __first, _Size __n)
		{
			_ForwardIterator __cur = __first;
			try {
				for (; __n > 0; (--__n), ((void)(++__cur))) {
					std::_Construct(
						std::__addressof(*__cur));
				}
				return __cur;
			} catch (...) {
				std::_Destroy(__first, __cur);
				throw;
			}
		}
	};
	template <> struct __uninitialized_default_n_1<true> {
		template <class _ForwardIterator, class _Size>
		static _ForwardIterator
		__uninit_default_n(_ForwardIterator __first, _Size __n)
		{
			if (__n > 0) {
				typename iterator_traits<
					_ForwardIterator>::value_type *__val =
					std::__addressof(*__first);
				std::_Construct(__val);
				++__first;
				__first = std::fill_n(__first, __n - 1, *__val);
			}
			return __first;
		}
	};
	template <class _ForwardIterator>
	inline void __uninitialized_default(_ForwardIterator __first,
					    _ForwardIterator __last)
	{
		typedef typename iterator_traits<_ForwardIterator>::value_type
			_ValueType;
		const bool __assignable =
			(is_copy_assignable<typename iterator_traits<
				 _ForwardIterator>::value_type>::value);
		std::template __uninitialized_default_1<
			__is_trivial(_ValueType) &&
			__assignable>::__uninit_default(__first, __last);
	}
	template <class _ForwardIterator, class _Size>
	inline _ForwardIterator __uninitialized_default_n(
		_ForwardIterator __first, _Size __n)
	{
		typedef typename iterator_traits<_ForwardIterator>::value_type
			_ValueType;
		constexpr bool __can_fill =
			(__and_<is_integral<_Size>,
				is_copy_assignable<typename iterator_traits<
					_ForwardIterator>::value_type>>::value);
		return __uninitialized_default_n_1 < __is_trivial(_ValueType) &&
		       __can_fill > ::__uninit_default_n(__first, __n);
	}
	template <class _ForwardIterator, class _Allocator>
	void __uninitialized_default_a(_ForwardIterator __first,
				       _ForwardIterator __last,
				       _Allocator & __alloc)
	{
		_ForwardIterator __cur = __first;
		try {
			typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
			for (; __cur != __last; ++__cur) {
				__traits::construct(__alloc,
						    std::__addressof(*__cur));
			}
		} catch (...) {
			std::_Destroy(__first, __cur, __alloc);
			throw;
		}
	}
	template <class _ForwardIterator, class _Tp>
	inline void __uninitialized_default_a(_ForwardIterator __first,
					      _ForwardIterator __last,
					      allocator<_Tp> &)
	{
		std::__uninitialized_default(__first, __last);
	}
	template <class _ForwardIterator, class _Size, class _Allocator>
	_ForwardIterator __uninitialized_default_n_a(
		_ForwardIterator __first, _Size __n, _Allocator & __alloc)
	{
		_ForwardIterator __cur = __first;
		try {
			typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
			for (; __n > 0; (--__n), ((void)(++__cur))) {
				__traits::construct(__alloc,
						    std::__addressof(*__cur));
			}
			return __cur;
		} catch (...) {
			std::_Destroy(__first, __cur, __alloc);
			throw;
		}
	}
	template <class _ForwardIterator, class _Size, class _Tp>
	inline _ForwardIterator __uninitialized_default_n_a(
		_ForwardIterator __first, _Size __n, allocator<_Tp> &)
	{
		return std::__uninitialized_default_n(__first, __n);
	}
	template <bool _TrivialValueType>
	struct __uninitialized_default_novalue_1 {
		template <class _ForwardIterator>
		static void __uninit_default_novalue(_ForwardIterator __first,
						     _ForwardIterator __last)
		{
			_ForwardIterator __cur = __first;
			try {
				for (; __cur != __last; ++__cur) {
					std::_Construct_novalue(
						std::__addressof(*__cur));
				}
			} catch (...) {
				std::_Destroy(__first, __cur);
				throw;
			}
		}
	};
	template <> struct __uninitialized_default_novalue_1<true> {
		template <class _ForwardIterator>
		static void __uninit_default_novalue(_ForwardIterator __first,
						     _ForwardIterator __last)
		{
		}
	};
	template <bool _TrivialValueType>
	struct __uninitialized_default_novalue_n_1 {
		template <class _ForwardIterator, class _Size>
		static _ForwardIterator
		__uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
		{
			_ForwardIterator __cur = __first;
			try {
				for (; __n > 0; (--__n), ((void)(++__cur))) {
					std::_Construct_novalue(
						std::__addressof(*__cur));
				}
				return __cur;
			} catch (...) {
				std::_Destroy(__first, __cur);
				throw;
			}
		}
	};
	template <> struct __uninitialized_default_novalue_n_1<true> {
		template <class _ForwardIterator, class _Size>
		static _ForwardIterator
		__uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
		{
			return std::next(__first, __n);
		}
	};
	template <class _ForwardIterator>
	inline void __uninitialized_default_novalue(_ForwardIterator __first,
						    _ForwardIterator __last)
	{
		typedef typename iterator_traits<_ForwardIterator>::value_type
			_ValueType;
		std::template __uninitialized_default_novalue_1<
			is_trivially_default_constructible<
				typename iterator_traits<
					_ForwardIterator>::value_type>::value>::
			__uninit_default_novalue(__first, __last);
	}
	template <class _ForwardIterator, class _Size>
	inline _ForwardIterator __uninitialized_default_novalue_n(
		_ForwardIterator __first, _Size __n)
	{
		typedef typename iterator_traits<_ForwardIterator>::value_type
			_ValueType;
		return __uninitialized_default_novalue_n_1<
			is_trivially_default_constructible<
				typename iterator_traits<
					_ForwardIterator>::value_type>::value>::
			__uninit_default_novalue_n(__first, __n);
	}
	template <class _InputIterator, class _Size, class _ForwardIterator>
	_ForwardIterator __uninitialized_copy_n(_InputIterator __first,
						_Size __n,
						_ForwardIterator __result,
						input_iterator_tag)
	{
		_ForwardIterator __cur = __result;
		try {
			for (; __n > 0;
			     ((--__n), ((void)(++__first))), (++__cur)) {
				std::_Construct(std::__addressof(*__cur),
						*__first);
			}
			return __cur;
		} catch (...) {
			std::_Destroy(__result, __cur);
			throw;
		}
	}
	template <class _RandomAccessIterator, class _Size,
		  class _ForwardIterator>
	inline _ForwardIterator __uninitialized_copy_n(
		_RandomAccessIterator __first, _Size __n,
		_ForwardIterator __result, random_access_iterator_tag)
	{
		return std::uninitialized_copy(__first, __first + __n,
					       __result);
	}
	template <class _InputIterator, class _Size, class _ForwardIterator>
	pair<_InputIterator, _ForwardIterator> __uninitialized_copy_n_pair(
		_InputIterator __first, _Size __n, _ForwardIterator __result,
		input_iterator_tag)
	{
		_ForwardIterator __cur = __result;
		try {
			for (; __n > 0;
			     ((--__n), ((void)(++__first))), (++__cur)) {
				std::_Construct(std::__addressof(*__cur),
						*__first);
			}
			return { __first, __cur };
		} catch (...) {
			std::_Destroy(__result, __cur);
			throw;
		}
	}
	template <class _RandomAccessIterator, class _Size,
		  class _ForwardIterator>
	inline pair<_RandomAccessIterator, _ForwardIterator>
	__uninitialized_copy_n_pair(_RandomAccessIterator __first, _Size __n,
				    _ForwardIterator __result,
				    random_access_iterator_tag)
	{
		auto __second_res =
			uninitialized_copy(__first, __first + __n, __result);
		auto __first_res = std::next(__first, __n);
		return { __first_res, __second_res };
	}
	template <class _InputIterator, class _Size, class _ForwardIterator>
	inline _ForwardIterator uninitialized_copy_n(
		_InputIterator __first, _Size __n, _ForwardIterator __result)
	{
		return std::__uninitialized_copy_n(
			__first, __n, __result,
			std::__iterator_category(__first));
	}
	template <class _InputIterator, class _Size, class _ForwardIterator>
	inline pair<_InputIterator, _ForwardIterator>
	__uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
				    _ForwardIterator __result)
	{
		return std::__uninitialized_copy_n_pair(
			__first, __n, __result,
			std::__iterator_category(__first));
	}
	template <class _ForwardIterator>
	inline void uninitialized_default_construct(_ForwardIterator __first,
						    _ForwardIterator __last)
	{
		__uninitialized_default_novalue(__first, __last);
	}
	template <class _ForwardIterator, class _Size>
	inline _ForwardIterator uninitialized_default_construct_n(
		_ForwardIterator __first, _Size __count)
	{
		return __uninitialized_default_novalue_n(__first, __count);
	}
	template <class _ForwardIterator>
	inline void uninitialized_value_construct(_ForwardIterator __first,
						  _ForwardIterator __last)
	{
		return __uninitialized_default(__first, __last);
	}
	template <class _ForwardIterator, class _Size>
	inline _ForwardIterator uninitialized_value_construct_n(
		_ForwardIterator __first, _Size __count)
	{
		return __uninitialized_default_n(__first, __count);
	}
	template <class _InputIterator, class _ForwardIterator>
	inline _ForwardIterator uninitialized_move(_InputIterator __first,
						   _InputIterator __last,
						   _ForwardIterator __result)
	{
		return std::uninitialized_copy(std::make_move_iterator(__first),
					       std::make_move_iterator(__last),
					       __result);
	}
	template <class _InputIterator, class _Size, class _ForwardIterator>
	inline pair<_InputIterator, _ForwardIterator> uninitialized_move_n(
		_InputIterator __first, _Size __count,
		_ForwardIterator __result)
	{
		auto __res = std::__uninitialized_copy_n_pair(
			std::make_move_iterator(__first), __count, __result);
		return { (__res.first).base(), (__res.second) };
	}
	template <class _Tp, class _Up, class _Allocator>
	inline void
	__relocate_object_a(_Tp *__restrict__ __dest, _Up *__restrict__ __orig, _Allocator & __alloc) noexcept(
		noexcept(std::template allocator_traits<_Allocator>::construct(
			__alloc, __dest, std::move(*__orig)))
			&&noexcept(std::template allocator_traits<
				   _Allocator>::destroy(__alloc,
							std::__addressof(
								*__orig))))
	{
		typedef allocator_traits<_Allocator> __traits;
		__traits::construct(__alloc, __dest, std::move(*__orig));
		__traits::destroy(__alloc, std::__addressof(*__orig));
	}
	template <class _Tp, class = void>
	struct __is_bitwise_relocatable : public is_trivial<_Tp> {
	};
	template <class _InputIterator, class _ForwardIterator, class _Allocator>
	inline _ForwardIterator __relocate_a_1(
		_InputIterator __first, _InputIterator __last,
		_ForwardIterator __result,
		_Allocator &
			__alloc) noexcept(noexcept(std::
							   __relocate_object_a(
								   std::addressof(
									   *__result),
								   std::addressof(
									   *__first),
								   __alloc)))
	{
		typedef typename iterator_traits<_InputIterator>::value_type
			_ValueType;
		typedef typename iterator_traits<_ForwardIterator>::value_type
			_ValueType2;
		static_assert(
			(std::template is_same<
				typename iterator_traits<
					_InputIterator>::value_type,
				typename iterator_traits<
					_ForwardIterator>::value_type>::value),
			"relocation is only possible for values of the same type");
		_ForwardIterator __cur = __result;
		for (; __first != __last; (++__first), ((void)(++__cur))) {
			std::__relocate_object_a(std::__addressof(*__cur),
						 std::__addressof(*__first),
						 __alloc);
		}
		return __cur;
	}
	template <class _Tp, class _Up>
	inline __enable_if_t<__is_bitwise_relocatable<_Tp>::value, _Tp *>
	__relocate_a_1(_Tp * __first, _Tp * __last, _Tp * __result,
		       [[__maybe_unused__]] allocator<_Up> & __alloc) noexcept
	{
		ptrdiff_t __count = __last - __first;
		if (__count > (0)) {
			__builtin_memmove(__result, __first,
					  __count * sizeof(_Tp));
		}
		return __result + __count;
	}
	template <class _InputIterator, class _ForwardIterator, class _Allocator>
	inline _ForwardIterator __relocate_a(
		_InputIterator __first, _InputIterator __last,
		_ForwardIterator __result,
		_Allocator &
			__alloc) noexcept(noexcept(__relocate_a_1(std::__niter_base(__first),
								  std::__niter_base(
									  __last),
								  std::__niter_base(
									  __result),
								  __alloc)))
	{
		return std::__relocate_a_1(std::__niter_base(__first),
					   std::__niter_base(__last),
					   std::__niter_base(__result),
					   __alloc);
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _Tp, class _Alloc> struct _Vector_base {
		typedef typename __gnu_cxx::__alloc_traits<
			_Alloc>::template rebind<_Tp>::other _Tp_alloc_type;
		typedef typename __gnu_cxx::__alloc_traits<
			_Tp_alloc_type>::pointer pointer;
		struct _Vector_impl_data {
			pointer _M_start;
			pointer _M_finish;
			pointer _M_end_of_storage;
			_Vector_impl_data() noexcept
				: _M_start(), _M_finish(), _M_end_of_storage()
			{
			}
			_Vector_impl_data(_Vector_impl_data &&__x) noexcept
				: _M_start(__x._M_start),
				  _M_finish(__x._M_finish),
				  _M_end_of_storage(__x._M_end_of_storage)
			{
				(__x._M_start) =
					((__x._M_finish) =
						 ((__x._M_end_of_storage) =
							  pointer()));
			}
			void _M_copy_data(const _Vector_impl_data &__x) noexcept
			{
				(_M_start) = (__x._M_start);
				(_M_finish) = (__x._M_finish);
				(_M_end_of_storage) = (__x._M_end_of_storage);
			}
			void _M_swap_data(_Vector_impl_data &__x) noexcept
			{
				_Vector_impl_data __tmp;
				__tmp._M_copy_data(*this);
				_M_copy_data(__x);
				__x._M_copy_data(__tmp);
			}
		};
		struct _Vector_impl : public _Tp_alloc_type,
				      public _Vector_impl_data {
			_Vector_impl() noexcept(
				is_nothrow_default_constructible<
					typename _Vector_base<_Tp, _Alloc>::
						_Tp_alloc_type>::value)
				: _Vector_base<_Tp, _Alloc>::_Tp_alloc_type()
			{
			}
			_Vector_impl(const typename _Vector_base<
				     _Tp, _Alloc>::_Tp_alloc_type &__a) noexcept
				: _Vector_base<_Tp, _Alloc>::_Tp_alloc_type(__a)
			{
			}
			_Vector_impl(_Vector_impl &&__x) noexcept
				: _Vector_base<_Tp, _Alloc>::_Vector_impl_data(
					  std::move(__x)),
				  _Vector_base<_Tp, _Alloc>::_Tp_alloc_type(
					  std::move(__x))
			{
			}
			_Vector_impl(typename _Vector_base<
				     _Tp, _Alloc>::_Tp_alloc_type &&__a) noexcept
				: _Vector_base<_Tp, _Alloc>::_Tp_alloc_type(
					  std::move(__a))
			{
			}
			_Vector_impl(typename _Vector_base<
					     _Tp, _Alloc>::_Tp_alloc_type &&__a,
				     _Vector_impl &&__rv) noexcept
				: _Vector_base<_Tp, _Alloc>::_Vector_impl_data(
					  std::move(__rv)),
				  _Vector_base<_Tp, _Alloc>::_Tp_alloc_type(
					  std::move(__a))
			{
			}
		};
		typedef _Alloc allocator_type;
		_Tp_alloc_type &_M_get_Tp_allocator() noexcept
		{
			return this->_M_impl;
		}
		const _Tp_alloc_type &_M_get_Tp_allocator() const noexcept
		{
			return this->_M_impl;
		}
		allocator_type get_allocator() const noexcept
		{
			return (allocator_type)_M_get_Tp_allocator();
		}
		_Vector_base() = default;
		_Vector_base(const allocator_type &__a) noexcept : _M_impl(__a)
		{
		}
		_Vector_base(size_t __n) : _M_impl()
		{
			_M_create_storage(__n);
		}
		_Vector_base(size_t __n, const allocator_type &__a)
			: _M_impl(__a)
		{
			_M_create_storage(__n);
		}
		_Vector_base(_Vector_base &&) = default;
		_Vector_base(_Tp_alloc_type &&__a) noexcept
			: _M_impl(std::move(__a))
		{
		}
		_Vector_base(_Vector_base &&__x, const allocator_type &__a)
			: _M_impl(__a)
		{
			if (__x.get_allocator() == __a) {
				(this->_M_impl)._M_swap_data(__x._M_impl);
			} else {
				size_t __n = ((__x._M_impl)._M_finish) -
					     ((__x._M_impl)._M_start);
				_M_create_storage(__n);
			}
		}
		_Vector_base(const allocator_type &__a, _Vector_base &&__x)
			: _M_impl((_Tp_alloc_type)__a, std::move(__x._M_impl))
		{
		}
		~_Vector_base() noexcept
		{
			_M_deallocate(((_M_impl)._M_start),
				      ((_M_impl)._M_end_of_storage) -
					      ((_M_impl)._M_start));
		}
		_Vector_impl _M_impl;
		pointer _M_allocate(size_t __n)
		{
			typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
			return (__n != (0)) ? _Tr::allocate(_M_impl, __n) :
					      pointer();
		}
		void _M_deallocate(pointer __p, size_t __n)
		{
			typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
			if (__p) {
				_Tr::deallocate(_M_impl, __p, __n);
			}
		}

	    protected:
		void _M_create_storage(size_t __n)
		{
			((this->_M_impl)._M_start) = _M_allocate(__n);
			((this->_M_impl)._M_finish) =
				((this->_M_impl)._M_start);
			((this->_M_impl)._M_end_of_storage) =
				(((this->_M_impl)._M_start) + __n);
		}
	};
	template <class _Tp, class _Alloc = allocator<_Tp>>
	class vector : protected _Vector_base<_Tp, _Alloc> {
		static_assert(
			(is_same<typename remove_cv<_Tp>::type, _Tp>::value),
			"std::vector must have a non-const, non-volatile value_type");
		typedef _Vector_base<_Tp, _Alloc> _Base;
		typedef typename _Vector_base<_Tp, _Alloc>::_Tp_alloc_type
			_Tp_alloc_type;
		typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;

	    public:
		typedef _Tp value_type;
		typedef typename _Vector_base<_Tp, _Alloc>::pointer pointer;
		typedef typename __gnu_cxx::__alloc_traits<
			_Tp_alloc_type>::const_pointer const_pointer;
		typedef typename __gnu_cxx::__alloc_traits<
			_Tp_alloc_type>::reference reference;
		typedef typename __gnu_cxx::__alloc_traits<
			_Tp_alloc_type>::const_reference const_reference;
		typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
		typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
			const_iterator;
		typedef std::reverse_iterator<const_iterator>
			const_reverse_iterator;
		typedef std::reverse_iterator<iterator> reverse_iterator;
		typedef std::size_t size_type;
		typedef std::ptrdiff_t difference_type;
		typedef _Alloc allocator_type;

	    private:
		static constexpr bool _S_nothrow_relocate(std::true_type)
		{
			return noexcept(std::__relocate_a(
				std::declval<pointer>(),
				std::declval<pointer>(),
				std::declval<pointer>(),
				std::declval<_Tp_alloc_type &>()));
		}
		static constexpr bool _S_nothrow_relocate(std::false_type)
		{
			return false;
		}
		static constexpr bool _S_use_relocate()
		{
			return _S_nothrow_relocate(
				__is_move_insertable<_Tp_alloc_type>{});
		}
		static pointer _S_do_relocate(pointer __first, pointer __last,
					      pointer __result,
					      _Tp_alloc_type &__alloc,
					      std::true_type) noexcept
		{
			return std::__relocate_a(__first, __last, __result,
						 __alloc);
		}
		static pointer _S_do_relocate(pointer, pointer,
					      pointer __result,
					      _Tp_alloc_type &,
					      std::false_type) noexcept
		{
			return __result;
		}
		static pointer _S_relocate(pointer __first, pointer __last,
					   pointer __result,
					   _Tp_alloc_type &__alloc) noexcept
		{
			return std::__relocate_a(__first, __last, __result,
						 __alloc);
		}

	    protected:
		using _Vector_base<_Tp, _Alloc>::_M_allocate;
		using _Vector_base<_Tp, _Alloc>::_M_deallocate;
		using _Vector_base<_Tp, _Alloc>::_M_impl;
		using _Vector_base<_Tp, _Alloc>::_M_get_Tp_allocator;

	    public:
		vector() = default;
		explicit vector(const allocator_type &__a) noexcept : _Base(__a)
		{
		}
		explicit vector(size_type __n,
				const allocator_type &__a = allocator_type())
			: _Base((_S_check_init_len)(__n, __a), __a)
		{
			_M_default_initialize(__n);
		}
		vector(size_type __n, const value_type &__value,
		       const allocator_type &__a = allocator_type())
			: _Base((_S_check_init_len)(__n, __a), __a)
		{
			_M_fill_initialize(__n, __value);
		}
		vector(const vector &__x)
			: _Base(__x.size(), _Alloc_traits::_S_select_on_copy(
						    __x._M_get_Tp_allocator()))
		{
			((this->_M_impl)._M_finish) =
				std::__uninitialized_copy_a(
					__x.begin(), __x.end(),
					((this->_M_impl)._M_start),
					_M_get_Tp_allocator());
		}
		vector(vector &&) noexcept = default;
		vector(const vector &__x,
		       const std::__type_identity_t<allocator_type> &__a)
			: _Base(__x.size(), __a)
		{
			((this->_M_impl)._M_finish) =
				std::__uninitialized_copy_a(
					__x.begin(), __x.end(),
					((this->_M_impl)._M_start),
					_M_get_Tp_allocator());
		}

	    private:
		vector(vector &&__rv, const allocator_type &__m,
		       std::true_type) noexcept
			: _Base(__m, std::move(__rv))
		{
		}
		vector(vector &&__rv, const allocator_type &__m,
		       std::false_type)
			: _Base(__m)
		{
			if (__rv.get_allocator() == __m) {
				(this->_M_impl)._M_swap_data((__rv._M_impl));
			} else {
				if (!__rv.empty()) {
					this->_M_create_storage(__rv.size());
					((this->_M_impl)._M_finish) =
						std::__uninitialized_move_a(
							__rv.begin(),
							__rv.end(),
							((this->_M_impl)
								 ._M_start),
							_M_get_Tp_allocator());
					__rv.clear();
				}
			}
		}

	    public:
		vector(vector &&__rv, const std::__type_identity_t<allocator_type> &__m) noexcept(
			noexcept((vector(
				std::declval<vector &&>(),
				std::declval<const allocator_type &>(),
				std::declval<typename __gnu_cxx::__alloc_traits<
					_Tp_alloc_type>::is_always_equal>()))))
			: vector(std::move(__rv), __m,
				 typename __gnu_cxx::__alloc_traits<
					 _Tp_alloc_type>::is_always_equal{})
		{
		}
		vector(initializer_list<value_type> __l,
		       const allocator_type &__a = allocator_type())
			: _Base(__a)
		{
			_M_range_initialize(__l.begin(), __l.end(),
					    std::random_access_iterator_tag());
		}
		template <class _InputIterator,
			  class = std::_RequireInputIter<_InputIterator>>
		vector(_InputIterator __first, _InputIterator __last,
		       const allocator_type &__a = allocator_type())
			: _Base(__a)
		{
			_M_range_initialize(__first, __last,
					    std::__iterator_category(__first));
		}
		~vector() noexcept
		{
			std::_Destroy(((this->_M_impl)._M_start),
				      ((this->_M_impl)._M_finish),
				      _M_get_Tp_allocator());
			;
		}
		vector &operator=(const vector &__x);
		vector &operator=(vector &&__x) noexcept(
			_Alloc_traits::_S_nothrow_move())
		{
			constexpr bool __move_storage =
				(_Alloc_traits::_S_propagate_on_move_assign() ||
				 _Alloc_traits::_S_always_equal());
			_M_move_assign(std::move(__x),
				       std::__bool_constant<__move_storage>());
			return *this;
		}
		vector &operator=(initializer_list<value_type> __l)
		{
			this->_M_assign_aux(__l.begin(), __l.end(),
					    std::random_access_iterator_tag());
			return *this;
		}
		void assign(size_type __n, const value_type &__val)
		{
			_M_fill_assign(__n, __val);
		}
		template <class _InputIterator,
			  class = std::_RequireInputIter<_InputIterator>>
		void assign(_InputIterator __first, _InputIterator __last)
		{
			_M_assign_dispatch(__first, __last,
					   std::__false_type());
		}
		void assign(initializer_list<value_type> __l)
		{
			this->_M_assign_aux(__l.begin(), __l.end(),
					    std::random_access_iterator_tag());
		}
		using _Vector_base<_Tp, _Alloc>::get_allocator;
		[[__nodiscard__]] iterator begin() noexcept
		{
			return ((
				__gnu_cxx::__normal_iterator<pointer, vector>)((
				(this->_M_impl)._M_start)));
		}
		[[__nodiscard__]] const_iterator begin() const noexcept
		{
			return ((__gnu_cxx::__normal_iterator<const_pointer,
							      vector>)((
				(this->_M_impl)._M_start)));
		}
		[[__nodiscard__]] iterator end() noexcept
		{
			return ((
				__gnu_cxx::__normal_iterator<pointer, vector>)((
				(this->_M_impl)._M_finish)));
		}
		[[__nodiscard__]] const_iterator end() const noexcept
		{
			return ((__gnu_cxx::__normal_iterator<const_pointer,
							      vector>)((
				(this->_M_impl)._M_finish)));
		}
		[[__nodiscard__]] reverse_iterator rbegin() noexcept
		{
			return ((std::reverse_iterator<iterator>)(end()));
		}
		[[__nodiscard__]] const_reverse_iterator rbegin() const noexcept
		{
			return ((std::reverse_iterator<const_iterator>)(end()));
		}
		[[__nodiscard__]] reverse_iterator rend() noexcept
		{
			return ((std::reverse_iterator<iterator>)(begin()));
		}
		[[__nodiscard__]] const_reverse_iterator rend() const noexcept
		{
			return ((
				std::reverse_iterator<const_iterator>)(begin()));
		}
		[[__nodiscard__]] const_iterator cbegin() const noexcept
		{
			return ((__gnu_cxx::__normal_iterator<const_pointer,
							      vector>)((
				(this->_M_impl)._M_start)));
		}
		[[__nodiscard__]] const_iterator cend() const noexcept
		{
			return ((__gnu_cxx::__normal_iterator<const_pointer,
							      vector>)((
				(this->_M_impl)._M_finish)));
		}
		[[__nodiscard__]] const_reverse_iterator
		crbegin() const noexcept
		{
			return ((std::reverse_iterator<const_iterator>)(end()));
		}
		[[__nodiscard__]] const_reverse_iterator crend() const noexcept
		{
			return ((
				std::reverse_iterator<const_iterator>)(begin()));
		}
		[[__nodiscard__]] size_type size() const noexcept
		{
			return (size_type)(((this->_M_impl)._M_finish) -
					   ((this->_M_impl)._M_start));
		}
		[[__nodiscard__]] size_type max_size() const noexcept
		{
			return (_S_max_size)(_M_get_Tp_allocator());
		}
		void resize(size_type __new_size)
		{
			if (__new_size > size()) {
				_M_default_append(__new_size - size());
			} else {
				if (__new_size < size()) {
					_M_erase_at_end(
						((this->_M_impl)._M_start) +
						__new_size);
				}
			}
		}
		void resize(size_type __new_size, const value_type &__x)
		{
			if (__new_size > size()) {
				_M_fill_insert(end(), __new_size - size(), __x);
			} else {
				if (__new_size < size()) {
					_M_erase_at_end(
						((this->_M_impl)._M_start) +
						__new_size);
				}
			}
		}
		void shrink_to_fit()
		{
			_M_shrink_to_fit();
		}
		[[__nodiscard__]] size_type capacity() const noexcept
		{
			return (size_type)(((this->_M_impl)._M_end_of_storage) -
					   ((this->_M_impl)._M_start));
		}
		[[__nodiscard__]] bool empty() const noexcept
		{
			return begin() == end();
		}
		void reserve(size_type __n);
		[[__nodiscard__]] reference operator[](size_type __n) noexcept
		{
			;
			return *(((this->_M_impl)._M_start) + __n);
		}
		[[__nodiscard__]] const_reference
		operator[](size_type __n) const noexcept
		{
			;
			return *(((this->_M_impl)._M_start) + __n);
		}

	    protected:
		void _M_range_check(size_type __n) const
		{
			if (__n >= size()) {
				__throw_out_of_range_fmt(
					"vector::_M_range_check: __n (which is %zu) >= this->size() (which is %zu)",
					__n, size());
			}
		}

	    public:
		reference at(size_type __n)
		{
			_M_range_check(__n);
			return (*this)[__n];
		}
		const_reference at(size_type __n) const
		{
			_M_range_check(__n);
			return (*this)[__n];
		}
		[[__nodiscard__]] reference front() noexcept
		{
			;
			return *begin();
		}
		[[__nodiscard__]] const_reference front() const noexcept
		{
			;
			return *begin();
		}
		[[__nodiscard__]] reference back() noexcept
		{
			;
			return *(end() - 1);
		}
		[[__nodiscard__]] const_reference back() const noexcept
		{
			;
			return *(end() - 1);
		}
		[[__nodiscard__]] _Tp *data() noexcept
		{
			return _M_data_ptr(((this->_M_impl)._M_start));
		}
		[[__nodiscard__]] const _Tp *data() const noexcept
		{
			return _M_data_ptr(((this->_M_impl)._M_start));
		}
		void push_back(const value_type &__x)
		{
			if (((this->_M_impl)._M_finish) !=
			    ((this->_M_impl)._M_end_of_storage)) {
				;
				_Alloc_traits::construct(
					(this->_M_impl),
					((this->_M_impl)._M_finish), __x);
				++((this->_M_impl)._M_finish);
				;
			} else {
				_M_realloc_insert(end(), __x);
			}
		}
		void push_back(value_type &&__x)
		{
			emplace_back(std::move(__x));
		}
		template <class... _Args>
		reference emplace_back(_Args &&...__args);
		void pop_back() noexcept
		{
			;
			--((this->_M_impl)._M_finish);
			_Alloc_traits::destroy((this->_M_impl),
					       ((this->_M_impl)._M_finish));
			;
		}
		template <class... _Args>
		iterator emplace(const_iterator __position, _Args &&...__args)
		{
			return _M_emplace_aux(__position,
					      std::forward<_Args>(__args)...);
		}
		iterator insert(const_iterator __position,
				const value_type &__x);
		iterator insert(const_iterator __position, value_type &&__x)
		{
			return _M_insert_rval(__position, std::move(__x));
		}
		iterator insert(const_iterator __position,
				initializer_list<value_type> __l)
		{
			auto __offset = __position - cbegin();
			_M_range_insert(begin() + __offset, __l.begin(),
					__l.end(),
					std::random_access_iterator_tag());
			return begin() + __offset;
		}
		iterator insert(const_iterator __position, size_type __n,
				const value_type &__x)
		{
			difference_type __offset = __position - cbegin();
			_M_fill_insert(begin() + __offset, __n, __x);
			return begin() + __offset;
		}
		template <class _InputIterator,
			  class = std::_RequireInputIter<_InputIterator>>
		iterator insert(const_iterator __position,
				_InputIterator __first, _InputIterator __last)
		{
			difference_type __offset = __position - cbegin();
			_M_insert_dispatch(begin() + __offset, __first, __last,
					   std::__false_type());
			return begin() + __offset;
		}
		iterator erase(const_iterator __position)
		{
			return _M_erase(begin() + (__position - cbegin()));
		}
		iterator erase(const_iterator __first, const_iterator __last)
		{
			const auto __beg = begin();
			const auto __cbeg = cbegin();
			return _M_erase(__beg + (__first - __cbeg),
					__beg + (__last - __cbeg));
		}
		void swap(vector &__x) noexcept
		{
			do {
				if (std::__is_constant_evaluated() &&
				    (!((bool)(_Alloc_traits::
						      propagate_on_container_swap::
							      value ||
					      (_M_get_Tp_allocator() ==
					       __x._M_get_Tp_allocator()))))) {
					__builtin_unreachable();
				}
			} while (false);
			(this->_M_impl)._M_swap_data((__x._M_impl));
			_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
						  __x._M_get_Tp_allocator());
		}
		void clear() noexcept
		{
			_M_erase_at_end(((this->_M_impl)._M_start));
		}

	    protected:
		template <class _ForwardIterator>
		pointer _M_allocate_and_copy(size_type __n,
					     _ForwardIterator __first,
					     _ForwardIterator __last)
		{
			pointer __result = this->_M_allocate(__n);
			try {
				std::__uninitialized_copy_a(
					__first, __last, __result,
					_M_get_Tp_allocator());
				return __result;
			} catch (...) {
				_M_deallocate(__result, __n);
				throw;
			}
		}
		template <class _InputIterator>
		void _M_range_initialize(_InputIterator __first,
					 _InputIterator __last,
					 std::input_iterator_tag)
		{
			try {
				for (; __first != __last; ++__first) {
					emplace_back(*__first);
				}
			} catch (...) {
				clear();
				throw;
			}
		}
		template <class _ForwardIterator>
		void _M_range_initialize(_ForwardIterator __first,
					 _ForwardIterator __last,
					 std::forward_iterator_tag)
		{
			const size_type __n = std::distance(__first, __last);
			((this->_M_impl)._M_start) = this->_M_allocate((
				_S_check_init_len)(__n, _M_get_Tp_allocator()));
			((this->_M_impl)._M_end_of_storage) =
				(((this->_M_impl)._M_start) + __n);
			((this->_M_impl)._M_finish) =
				std::__uninitialized_copy_a(
					__first, __last,
					((this->_M_impl)._M_start),
					_M_get_Tp_allocator());
		}
		void _M_fill_initialize(size_type __n,
					const value_type &__value)
		{
			((this->_M_impl)._M_finish) =
				std::__uninitialized_fill_n_a(
					((this->_M_impl)._M_start), __n,
					__value, _M_get_Tp_allocator());
		}
		void _M_default_initialize(size_type __n)
		{
			((this->_M_impl)._M_finish) =
				std::__uninitialized_default_n_a(
					((this->_M_impl)._M_start), __n,
					_M_get_Tp_allocator());
		}
		template <class _Integer>
		void _M_assign_dispatch(_Integer __n, _Integer __val,
					std::__true_type)
		{
			_M_fill_assign(__n, __val);
		}
		template <class _InputIterator>
		void _M_assign_dispatch(_InputIterator __first,
					_InputIterator __last,
					std::__false_type)
		{
			_M_assign_aux(__first, __last,
				      std::__iterator_category(__first));
		}
		template <class _InputIterator>
		void _M_assign_aux(_InputIterator __first,
				   _InputIterator __last,
				   std::input_iterator_tag);
		template <class _ForwardIterator>
		void _M_assign_aux(_ForwardIterator __first,
				   _ForwardIterator __last,
				   std::forward_iterator_tag);
		void _M_fill_assign(size_type __n, const value_type &__val);
		template <class _Integer>
		void _M_insert_dispatch(iterator __pos, _Integer __n,
					_Integer __val, std::__true_type)
		{
			_M_fill_insert(__pos, __n, __val);
		}
		template <class _InputIterator>
		void _M_insert_dispatch(iterator __pos, _InputIterator __first,
					_InputIterator __last,
					std::__false_type)
		{
			_M_range_insert(__pos, __first, __last,
					std::__iterator_category(__first));
		}
		template <class _InputIterator>
		void _M_range_insert(iterator __pos, _InputIterator __first,
				     _InputIterator __last,
				     std::input_iterator_tag);
		template <class _ForwardIterator>
		void _M_range_insert(iterator __pos, _ForwardIterator __first,
				     _ForwardIterator __last,
				     std::forward_iterator_tag);
		void _M_fill_insert(iterator __pos, size_type __n,
				    const value_type &__x);
		void _M_default_append(size_type __n);
		bool _M_shrink_to_fit();
		struct _Temporary_value {
			template <class... _Args>
			explicit _Temporary_value(vector *__vec,
						  _Args &&...__args)
				: _M_this(__vec)
			{
				_Alloc_traits::construct(
					((_M_this)->_M_impl), _M_ptr(),
					std::forward<_Args>(__args)...);
			}
			~_Temporary_value()
			{
				_Alloc_traits::destroy(((_M_this)->_M_impl),
						       _M_ptr());
			}
			value_type &_M_val() noexcept
			{
				return (_M_storage)._M_val;
			}

		    private:
			_Tp *_M_ptr() noexcept
			{
				return std::__addressof(((_M_storage)._M_val));
			}
			union _Storage {
				constexpr _Storage() : _M_byte()
				{
				}
				~_Storage()
				{
				}
				_Storage &operator=(const _Storage &) = delete;
				unsigned char _M_byte;
				_Tp _M_val;
			};
			vector *_M_this;
			_Storage _M_storage;
		};
		template <class _Arg>
		void _M_insert_aux(iterator __position, _Arg &&__arg);
		template <class... _Args>
		void _M_realloc_insert(iterator __position, _Args &&...__args);
		iterator _M_insert_rval(const_iterator __position,
					value_type &&__v);
		template <class... _Args>
		iterator _M_emplace_aux(const_iterator __position,
					_Args &&...__args);
		iterator _M_emplace_aux(const_iterator __position,
					value_type &&__v)
		{
			return _M_insert_rval(__position, std::move(__v));
		}
		size_type _M_check_len(size_type __n, const char *__s) const
		{
			if ((max_size() - size()) < __n) {
				__throw_length_error(__s);
			}
			const size_type __len =
				size() + (std::max)(size(), __n);
			return ((__len < size()) || (__len > max_size())) ?
				       max_size() :
				       __len;
		}
		static size_type _S_check_init_len(size_type __n,
						   const allocator_type &__a)
		{
			if (__n > (_S_max_size)((_Tp_alloc_type)__a)) {
				__throw_length_error(
					"cannot create std::vector larger than max_size()");
			}
			return __n;
		}
		static size_type _S_max_size(const _Tp_alloc_type &__a) noexcept
		{
			const std::size_t __diffmax =
				(__gnu_cxx::__numeric_traits<
					 std::ptrdiff_t>::__max /
				 sizeof(_Tp));
			const std::size_t __allocmax =
				_Alloc_traits::max_size(__a);
			return (std::min)(__diffmax, __allocmax);
		}
		void _M_erase_at_end(pointer __pos) noexcept
		{
			if (size_type __n =
				    ((this->_M_impl)._M_finish) - __pos) {
				std::_Destroy(__pos,
					      ((this->_M_impl)._M_finish),
					      _M_get_Tp_allocator());
				((this->_M_impl)._M_finish) = __pos;
				;
			}
		}
		iterator _M_erase(iterator __position);
		iterator _M_erase(iterator __first, iterator __last);

	    private:
		void _M_move_assign(vector &&__x, std::true_type) noexcept
		{
			vector __tmp(get_allocator());
			(this->_M_impl)._M_swap_data((__x._M_impl));
			(__tmp._M_impl)._M_swap_data((__x._M_impl));
			std::__alloc_on_move(_M_get_Tp_allocator(),
					     __x._M_get_Tp_allocator());
		}
		void _M_move_assign(vector &&__x, std::false_type)
		{
			if (__x._M_get_Tp_allocator() ==
			    this->_M_get_Tp_allocator()) {
				_M_move_assign(std::move(__x),
					       std::true_type());
			} else {
				this->_M_assign_aux(
					std::make_move_iterator(__x.begin()),
					std::make_move_iterator(__x.end()),
					std::random_access_iterator_tag());
				__x.clear();
			}
		}
		template <class _Up> _Up *_M_data_ptr(_Up *__ptr) const noexcept
		{
			return __ptr;
		}
		template <class _Ptr>
		typename pointer_traits<_Ptr>::element_type *
		_M_data_ptr(_Ptr __ptr) const
		{
			return (empty()) ? nullptr : std::__to_address(__ptr);
		}
	};
	template <class _InputIterator,
		  class _ValT =
			  typename iterator_traits<_InputIterator>::value_type,
		  class _Allocator = allocator<_ValT>,
		  class = _RequireInputIter<_InputIterator>,
		  class = _RequireAllocator<_Allocator>>
	vector(_InputIterator, _InputIterator, _Allocator = _Allocator())
		-> vector<_ValT, _Allocator>;
	template <class _Tp, class _Alloc>
	inline bool operator==(const vector<_Tp, _Alloc> &__x,
			       const vector<_Tp, _Alloc> &__y)
	{
		return ((__x.size() == __y.size()) &&
			std::equal(__x.begin(), __x.end(), __y.begin()));
	}
	template <class _Tp, class _Alloc>
	inline bool operator<(const vector<_Tp, _Alloc> &__x,
			      const vector<_Tp, _Alloc> &__y)
	{
		return std::lexicographical_compare(__x.begin(), __x.end(),
						    __y.begin(), __y.end());
	}
	template <class _Tp, class _Alloc>
	inline bool operator!=(const vector<_Tp, _Alloc> &__x,
			       const vector<_Tp, _Alloc> &__y)
	{
		return !(__x == __y);
	}
	template <class _Tp, class _Alloc>
	inline bool operator>(const vector<_Tp, _Alloc> &__x,
			      const vector<_Tp, _Alloc> &__y)
	{
		return __y < __x;
	}
	template <class _Tp, class _Alloc>
	inline bool operator<=(const vector<_Tp, _Alloc> &__x,
			       const vector<_Tp, _Alloc> &__y)
	{
		return !(__y < __x);
	}
	template <class _Tp, class _Alloc>
	inline bool operator>=(const vector<_Tp, _Alloc> &__x,
			       const vector<_Tp, _Alloc> &__y)
	{
		return !(__x < __y);
	}
	template <class _Tp, class _Alloc>
	inline void swap(vector<_Tp, _Alloc> & __x,
			 vector<_Tp, _Alloc> &
				 __y) noexcept(noexcept(__x.swap(__y)))
	{
		__x.swap(__y);
	}
	namespace __detail
	{
	namespace __variant
	{
	template <class> struct _Never_valueless_alt;
	template <class _Tp, class _Alloc>
	struct _Never_valueless_alt<vector<_Tp, _Alloc>>
		: public is_nothrow_move_assignable<vector<_Tp, _Alloc>> {
	};
	} // namespace __variant
	} // namespace __detail
} // namespace )
namespace std
{
size_t _Hash_bytes(const void *__ptr, size_t __len, size_t __seed);
size_t _Fnv_hash_bytes(const void *__ptr, size_t __len, size_t __seed);
} // namespace std
namespace std __attribute((__visibility__("default")))
{
	template <class _Result, class _Arg> struct __hash_base {
		typedef _Result result_type [[__deprecated__]];
		typedef _Arg argument_type [[__deprecated__]];
	};
	template <class _Tp> struct hash;
	template <class _Tp, class = void> struct __poison_hash {
		static constexpr inline bool __enable_hash_call = false;

	    private:
		__poison_hash(__poison_hash &&);
		~__poison_hash();
	};
	template <class _Tp>
	struct __poison_hash<
		_Tp, __void_t<__decltype((hash<_Tp>()(declval<_Tp>())))>> {
		static constexpr inline bool __enable_hash_call = true;
	};
	template <class _Tp, bool = is_enum<_Tp>::value> struct __hash_enum {
	    private:
		__hash_enum(__hash_enum &&);
		~__hash_enum();
	};
	template <class _Tp>
	struct __hash_enum<_Tp, true> : public __hash_base<unsigned long, _Tp> {
		std::size_t operator()(_Tp __val) const noexcept
		{
			using __type = typename underlying_type<_Tp>::type;
			return hash<typename underlying_type<_Tp>::type>{}(
				static_cast<__type>(__val));
		}
	};
	template <class _Tp> struct hash : public __hash_enum<_Tp> {
	};
	template <class _Tp>
	struct hash<_Tp *> : public __hash_base<unsigned long, _Tp *> {
		std::size_t operator()(_Tp *__p) const noexcept
		{
			return reinterpret_cast<std::size_t>(__p);
		}
	};
	template <>
	struct hash<bool> : public __hash_base<unsigned long, bool> {
		size_t operator()(bool __val) const noexcept
		{
			return static_cast<size_t>(__val);
		}
	};
	template <>
	struct hash<char> : public __hash_base<unsigned long, char> {
		size_t operator()(char __val) const noexcept
		{
			return static_cast<size_t>(__val);
		}
	};
	template <>
	struct hash<signed char>
		: public __hash_base<unsigned long, signed char> {
		size_t operator()(signed char __val) const noexcept
		{
			return static_cast<size_t>(__val);
		}
	};
	template <>
	struct hash<unsigned char>
		: public __hash_base<unsigned long, unsigned char> {
		size_t operator()(unsigned char __val) const noexcept
		{
			return static_cast<size_t>(__val);
		}
	};
	template <>
	struct hash<wchar_t> : public __hash_base<unsigned long, wchar_t> {
		size_t operator()(wchar_t __val) const noexcept
		{
			return static_cast<size_t>(__val);
		}
	};
	template <>
	struct hash<char16_t> : public __hash_base<unsigned long, char16_t> {
		size_t operator()(char16_t __val) const noexcept
		{
			return static_cast<size_t>(__val);
		}
	};
	template <>
	struct hash<char32_t> : public __hash_base<unsigned long, char32_t> {
		size_t operator()(char32_t __val) const noexcept
		{
			return static_cast<size_t>(__val);
		}
	};
	template <>
	struct hash<short> : public __hash_base<unsigned long, short> {
		size_t operator()(short __val) const noexcept
		{
			return static_cast<size_t>(__val);
		}
	};
	template <> struct hash<int> : public __hash_base<unsigned long, int> {
		size_t operator()(int __val) const noexcept
		{
			return static_cast<size_t>(__val);
		}
	};
	template <>
	struct hash<long> : public __hash_base<unsigned long, long> {
		size_t operator()(long __val) const noexcept
		{
			return static_cast<size_t>(__val);
		}
	};
	template <>
	struct hash<long long> : public __hash_base<unsigned long, long long> {
		size_t operator()(long long __val) const noexcept
		{
			return static_cast<size_t>(__val);
		}
	};
	template <>
	struct hash<unsigned short>
		: public __hash_base<unsigned long, unsigned short> {
		size_t operator()(unsigned short __val) const noexcept
		{
			return static_cast<size_t>(__val);
		}
	};
	template <>
	struct hash<unsigned> : public __hash_base<unsigned long, unsigned> {
		size_t operator()(unsigned __val) const noexcept
		{
			return static_cast<size_t>(__val);
		}
	};
	template <>
	struct hash<unsigned long>
		: public __hash_base<unsigned long, unsigned long> {
		size_t operator()(unsigned long __val) const noexcept
		{
			return static_cast<size_t>(__val);
		}
	};
	template <>
	struct hash<unsigned long long>
		: public __hash_base<unsigned long, unsigned long long> {
		size_t operator()(unsigned long long __val) const noexcept
		{
			return static_cast<size_t>(__val);
		}
	};
	template <>
	struct hash<__int128> : public __hash_base<unsigned long, __int128> {
		size_t operator()(__int128 __val) const noexcept
		{
			return static_cast<size_t>(__val);
		}
	};
	template <>
	struct hash<unsigned __int128>
		: public __hash_base<unsigned long, unsigned __int128> {
		size_t operator()(unsigned __int128 __val) const noexcept
		{
			return static_cast<size_t>(__val);
		}
	};
	struct _Hash_impl {
		static size_t
		hash(const void *__ptr, size_t __clength,
		     size_t __seed = static_cast<size_t>(3339675911UL))
		{
			return _Hash_bytes(__ptr, __clength, __seed);
		}
		template <class _Tp> static size_t hash(const _Tp &__val)
		{
			return hash(&__val, sizeof(__val));
		}
		template <class _Tp>
		static size_t __hash_combine(const _Tp &__val, size_t __hash)
		{
			return hash(&__val, sizeof(__val), __hash);
		}
	};
	struct _Fnv_hash_impl {
		static size_t
		hash(const void *__ptr, size_t __clength,
		     size_t __seed = static_cast<size_t>(2166136261UL))
		{
			return _Fnv_hash_bytes(__ptr, __clength, __seed);
		}
		template <class _Tp> static size_t hash(const _Tp &__val)
		{
			return hash(&__val, sizeof(__val));
		}
		template <class _Tp>
		static size_t __hash_combine(const _Tp &__val, size_t __hash)
		{
			return hash(&__val, sizeof(__val), __hash);
		}
	};
	template <>
	struct hash<float> : public __hash_base<unsigned long, float> {
		size_t operator()(float __val) const noexcept
		{
			return (__val != (0.0F)) ?
				       std::_Hash_impl::hash(__val) :
				       (0);
		}
	};
	template <>
	struct hash<double> : public __hash_base<unsigned long, double> {
		size_t operator()(double __val) const noexcept
		{
			return (__val != (0.0)) ? std::_Hash_impl::hash(__val) :
						  (0);
		}
	};
	template <>
	struct hash<long double>
		: public __hash_base<unsigned long, long double> {
		__attribute((__pure__)) size_t
		operator()(long double __val) const noexcept;
	};
	template <>
	struct hash<__decltype((nullptr))>
		: public __hash_base<unsigned long, __decltype((nullptr))> {
		size_t operator()(nullptr_t) const noexcept
		{
			return 0;
		}
	};
	template <class _Hash> struct __is_fast_hash : public true_type {
	};
	template <>
	struct __is_fast_hash<hash<long double>> : public false_type {
	};
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	typedef unsigned long _Bit_type;
	enum { _S_word_bit = ((int)((8) * sizeof(_Bit_type))) };
	__attribute((__nonnull__)) inline void __fill_bvector_n(
		_Bit_type *, size_t, bool) noexcept;
	struct _Bit_reference {
		_Bit_type *_M_p;
		_Bit_type _M_mask;
		_Bit_reference(_Bit_type *__x, _Bit_type __y)
			: _M_p(__x), _M_mask(__y)
		{
		}
		_Bit_reference() noexcept : _M_p((0)), _M_mask((0))
		{
		}
		_Bit_reference(const _Bit_reference &) = default;
		[[__nodiscard__]] operator bool() const noexcept
		{
			return !(!((*(_M_p)) & (_M_mask)));
		}
		_Bit_reference &operator=(bool __x) noexcept
		{
			if (__x) {
				(*(_M_p)) |= (_M_mask);
			} else {
				(*(_M_p)) &= (~(_M_mask));
			}
			return *this;
		}
		_Bit_reference &operator=(const _Bit_reference &__x) noexcept
		{
			return ((*this) = ((bool)__x));
		}
		[[__nodiscard__]] bool
		operator==(const _Bit_reference &__x) const
		{
			return ((bool)(*this)) == ((bool)__x);
		}
		[[__nodiscard__]] bool
		operator<(const _Bit_reference &__x) const
		{
			return (!((bool)(*this))) && ((bool)__x);
		}
		void flip() noexcept
		{
			(*(_M_p)) ^= (_M_mask);
		}
		friend inline void swap(_Bit_reference __x,
					_Bit_reference __y) noexcept
		{
			bool __tmp = __x;
			(__x = __y);
			(__y = __tmp);
		}
		friend inline void swap(_Bit_reference __x, bool &__y) noexcept
		{
			bool __tmp = __x;
			(__x = __y);
			__y = __tmp;
		}
		friend inline void swap(bool &__x, _Bit_reference __y) noexcept
		{
			bool __tmp = __x;
			__x = __y;
			(__y = __tmp);
		}
	};
	struct _Bit_iterator_base
		: public iterator<random_access_iterator_tag, bool> {
		_Bit_type *_M_p;
		unsigned _M_offset;
		_Bit_iterator_base(_Bit_type *__x, unsigned __y)
			: _M_p(__x), _M_offset(__y)
		{
		}
		void _M_bump_up()
		{
			if (((_M_offset)++) == (((int)_S_word_bit) - 1)) {
				(_M_offset) = (0);
				++(_M_p);
			}
		}
		void _M_bump_down()
		{
			if (((_M_offset)--) == (0)) {
				(_M_offset) = (((int)_S_word_bit) - 1);
				--(_M_p);
			}
		}
		void _M_incr(ptrdiff_t __i)
		{
			difference_type __n = __i + (_M_offset);
			(_M_p) += (__n / ((int)_S_word_bit));
			__n = (__n % ((int)_S_word_bit));
			if (__n < (0)) {
				__n += ((int)_S_word_bit);
				--(_M_p);
			}
			(_M_offset) = (static_cast<unsigned>(__n));
		}
		[[__nodiscard__]] friend inline bool
		operator==(const _Bit_iterator_base &__x,
			   const _Bit_iterator_base &__y)
		{
			return ((__x._M_p) == (__y._M_p)) &&
			       ((__x._M_offset) == (__y._M_offset));
		}
		[[__nodiscard__]] friend inline bool
		operator<(const _Bit_iterator_base &__x,
			  const _Bit_iterator_base &__y)
		{
			return ((__x._M_p) < (__y._M_p)) ||
			       (((__x._M_p) == (__y._M_p)) &&
				((__x._M_offset) < (__y._M_offset)));
		}
		[[__nodiscard__]] friend inline bool
		operator!=(const _Bit_iterator_base &__x,
			   const _Bit_iterator_base &__y)
		{
			return !(__x == __y);
		}
		[[__nodiscard__]] friend inline bool
		operator>(const _Bit_iterator_base &__x,
			  const _Bit_iterator_base &__y)
		{
			return (__y < __x);
		}
		[[__nodiscard__]] friend inline bool
		operator<=(const _Bit_iterator_base &__x,
			   const _Bit_iterator_base &__y)
		{
			return !(__y < __x);
		}
		[[__nodiscard__]] friend inline bool
		operator>=(const _Bit_iterator_base &__x,
			   const _Bit_iterator_base &__y)
		{
			return !(__x < __y);
		}
		friend inline ptrdiff_t operator-(const _Bit_iterator_base &__x,
						  const _Bit_iterator_base &__y)
		{
			return (((((int)_S_word_bit) *
				  ((__x._M_p) - (__y._M_p))) +
				 (__x._M_offset)) -
				(__y._M_offset));
		}
	};
	struct _Bit_iterator : public _Bit_iterator_base {
		typedef _Bit_reference reference;
		typedef _Bit_reference *pointer;
		typedef _Bit_iterator iterator;
		_Bit_iterator() : _Bit_iterator_base(0, 0)
		{
		}
		_Bit_iterator(_Bit_type *__x, unsigned __y)
			: _Bit_iterator_base(__x, __y)
		{
		}
		iterator _M_const_cast() const
		{
			return *this;
		}
		[[__nodiscard__]] reference operator*() const
		{
			return reference(_M_p, 1UL << (_M_offset));
		}
		iterator &operator++()
		{
			this->_M_bump_up();
			return *this;
		}
		iterator operator++(int)
		{
			iterator __tmp = *this;
			this->_M_bump_up();
			return __tmp;
		}
		iterator &operator--()
		{
			this->_M_bump_down();
			return *this;
		}
		iterator operator--(int)
		{
			iterator __tmp = *this;
			this->_M_bump_down();
			return __tmp;
		}
		iterator &operator+=(difference_type __i)
		{
			this->_M_incr(__i);
			return *this;
		}
		iterator &operator-=(difference_type __i)
		{
			((*this) += (-__i));
			return *this;
		}
		[[__nodiscard__]] reference
		operator[](difference_type __i) const
		{
			return (*(((*this) + __i)));
		}
		[[__nodiscard__]] friend inline iterator
		operator+(const _Bit_iterator::iterator &__x,
			  std::iterator<std::random_access_iterator_tag,
					bool>::difference_type __n)
		{
			iterator __tmp = __x;
			(__tmp += __n);
			return __tmp;
		}
		[[__nodiscard__]] friend inline iterator
		operator+(std::iterator<std::random_access_iterator_tag,
					bool>::difference_type __n,
			  const _Bit_iterator::iterator &__x)
		{
			return (__x + __n);
		}
		[[__nodiscard__]] friend inline iterator
		operator-(const _Bit_iterator::iterator &__x,
			  std::iterator<std::random_access_iterator_tag,
					bool>::difference_type __n)
		{
			iterator __tmp = __x;
			(__tmp -= __n);
			return __tmp;
		}
	};
	struct _Bit_const_iterator : public _Bit_iterator_base {
		typedef bool reference;
		typedef bool const_reference;
		typedef const bool *pointer;
		typedef _Bit_const_iterator const_iterator;
		_Bit_const_iterator() : _Bit_iterator_base(0, 0)
		{
		}
		_Bit_const_iterator(_Bit_type *__x, unsigned __y)
			: _Bit_iterator_base(__x, __y)
		{
		}
		_Bit_const_iterator(const _Bit_iterator &__x)
			: _Bit_iterator_base(__x._M_p, __x._M_offset)
		{
		}
		_Bit_iterator _M_const_cast() const
		{
			return _Bit_iterator(_M_p, _M_offset);
		}
		[[__nodiscard__]] const_reference operator*() const
		{
			return _Bit_reference(_M_p, 1UL << (_M_offset));
		}
		const_iterator &operator++()
		{
			this->_M_bump_up();
			return *this;
		}
		const_iterator operator++(int)
		{
			const_iterator __tmp = *this;
			this->_M_bump_up();
			return __tmp;
		}
		const_iterator &operator--()
		{
			this->_M_bump_down();
			return *this;
		}
		const_iterator operator--(int)
		{
			const_iterator __tmp = *this;
			this->_M_bump_down();
			return __tmp;
		}
		const_iterator &operator+=(difference_type __i)
		{
			this->_M_incr(__i);
			return *this;
		}
		const_iterator &operator-=(difference_type __i)
		{
			((*this) += (-__i));
			return *this;
		}
		[[__nodiscard__]] const_reference
		operator[](difference_type __i) const
		{
			return (*(((*this) + __i)));
		}
		[[__nodiscard__]] friend inline const_iterator
		operator+(const _Bit_const_iterator::const_iterator &__x,
			  std::iterator<std::random_access_iterator_tag,
					bool>::difference_type __n)
		{
			const_iterator __tmp = __x;
			(__tmp += __n);
			return __tmp;
		}
		[[__nodiscard__]] friend inline const_iterator
		operator-(const _Bit_const_iterator::const_iterator &__x,
			  std::iterator<std::random_access_iterator_tag,
					bool>::difference_type __n)
		{
			const_iterator __tmp = __x;
			(__tmp -= __n);
			return __tmp;
		}
		[[__nodiscard__]] friend inline const_iterator
		operator+(std::iterator<std::random_access_iterator_tag,
					bool>::difference_type __n,
			  const _Bit_const_iterator::const_iterator &__x)
		{
			return (__x + __n);
		}
	};
	template <class _Alloc> struct _Bvector_base {
		typedef typename __gnu_cxx::__alloc_traits<_Alloc>::
			template rebind<_Bit_type>::other _Bit_alloc_type;
		typedef __gnu_cxx::__alloc_traits<_Bit_alloc_type>
			_Bit_alloc_traits;
		typedef typename __gnu_cxx::__alloc_traits<
			_Bit_alloc_type>::pointer _Bit_pointer;
		struct _Bvector_impl_data {
			_Bit_iterator _M_start;
			_Bit_iterator _M_finish;
			_Bit_pointer _M_end_of_storage;
			_Bvector_impl_data() noexcept
				: _M_start(), _M_finish(), _M_end_of_storage()
			{
			}
			_Bvector_impl_data(const _Bvector_impl_data &) = default;
			_Bvector_impl_data &
			operator=(const _Bvector_impl_data &) = default;
			_Bvector_impl_data(_Bvector_impl_data &&__x) noexcept
				: _Bvector_impl_data(__x)
			{
				__x._M_reset();
			}
			void _M_move_data(_Bvector_impl_data &&__x) noexcept
			{
				(*this) = __x;
				__x._M_reset();
			}
			void _M_reset() noexcept
			{
				(*this) = _Bvector_impl_data();
			}
			void _M_swap_data(_Bvector_impl_data &__x) noexcept
			{
				std::swap(*this, __x);
			}
		};
		struct _Bvector_impl : public _Bit_alloc_type,
				       public _Bvector_impl_data {
			_Bvector_impl() noexcept(
				is_nothrow_default_constructible<
					typename _Bvector_base<
						_Alloc>::_Bit_alloc_type>::value)
				: _Bvector_base<_Alloc>::_Bit_alloc_type()
			{
			}
			_Bvector_impl(const typename _Bvector_base<
				      _Alloc>::_Bit_alloc_type &__a) noexcept
				: _Bvector_base<_Alloc>::_Bit_alloc_type(__a)
			{
			}
			_Bvector_impl(_Bvector_impl &&__x) noexcept
				: _Bvector_base<_Alloc>::_Bvector_impl_data(
					  std::move(__x)),
				  _Bvector_base<_Alloc>::_Bit_alloc_type(
					  std::move(__x))
			{
			}
			_Bvector_impl(
				typename _Bvector_base<_Alloc>::_Bit_alloc_type
					&&__a,
				_Bvector_impl &&__x) noexcept
				: _Bvector_base<_Alloc>::_Bvector_impl_data(
					  std::move(__x)),
				  _Bvector_base<_Alloc>::_Bit_alloc_type(
					  std::move(__a))
			{
			}
			std::_Bit_type *_M_end_addr() const noexcept
			{
				if (this->_M_end_of_storage) {
					return std::__addressof(
						       (this->_M_end_of_storage)
							       [-1]) +
					       1;
				}
				return 0;
			}
		};
		typedef _Alloc allocator_type;
		_Bit_alloc_type &_M_get_Bit_allocator() noexcept
		{
			return this->_M_impl;
		}
		const _Bit_alloc_type &_M_get_Bit_allocator() const noexcept
		{
			return this->_M_impl;
		}
		allocator_type get_allocator() const noexcept
		{
			return (allocator_type)_M_get_Bit_allocator();
		}
		_Bvector_base() = default;
		_Bvector_base(const allocator_type &__a) : _M_impl(__a)
		{
		}
		_Bvector_base(_Bvector_base &&) = default;
		_Bvector_base(_Bvector_base &&__x,
			      const allocator_type &__a) noexcept
			: _M_impl((_Bit_alloc_type)__a, std::move(__x._M_impl))
		{
		}
		~_Bvector_base()
		{
			_M_deallocate();
		}

	    protected:
		_Bvector_impl _M_impl;
		_Bit_pointer _M_allocate(size_t __n)
		{
			_Bit_pointer __p = _Bit_alloc_traits::allocate(
				_M_impl, (_S_nword)(__n));
			return __p;
		}
		void _M_deallocate()
		{
			if (((_M_impl)._M_start)._M_p) {
				const size_t __n = (_M_impl)._M_end_addr() -
						   (((_M_impl)._M_start)._M_p);
				_Bit_alloc_traits::deallocate(
					_M_impl,
					((_M_impl)._M_end_of_storage) - __n,
					__n);
				(_M_impl)._M_reset();
			}
		}
		void _M_move_data(_Bvector_base &&__x) noexcept
		{
			(_M_impl)._M_move_data(std::move(__x._M_impl));
		}
		static constexpr size_t _S_nword(size_t __n)
		{
			return ((__n + ((int)_S_word_bit)) - (1)) /
			       ((int)_S_word_bit);
		}
	};
	template <class _Alloc>
	class vector<bool, _Alloc> : protected _Bvector_base<_Alloc> {
		typedef _Bvector_base<_Alloc> _Base;
		typedef typename _Bvector_base<_Alloc>::_Bit_pointer
			_Bit_pointer;
		typedef typename _Bvector_base<_Alloc>::_Bit_alloc_traits
			_Bit_alloc_traits;
		friend struct hash<vector>;

	    public:
		typedef bool value_type;
		typedef std::size_t size_type;
		typedef std::ptrdiff_t difference_type;
		typedef std::_Bit_reference reference;
		typedef bool const_reference;
		typedef std::_Bit_reference *pointer;
		typedef const bool *const_pointer;
		typedef std::_Bit_iterator iterator;
		typedef std::_Bit_const_iterator const_iterator;
		typedef std::reverse_iterator<std::_Bit_const_iterator>
			const_reverse_iterator;
		typedef std::reverse_iterator<std::_Bit_iterator>
			reverse_iterator;
		typedef _Alloc allocator_type;
		allocator_type get_allocator() const
		{
			return _Base::get_allocator();
		}

	    protected:
		using _Bvector_base<_Alloc>::_M_allocate;
		using _Bvector_base<_Alloc>::_M_deallocate;
		using _Bvector_base<_Alloc>::_S_nword;
		using _Bvector_base<_Alloc>::_M_get_Bit_allocator;

	    public:
		vector() = default;
		explicit vector(const allocator_type &__a) : _Base(__a)
		{
		}
		explicit vector(size_type __n,
				const allocator_type &__a = allocator_type())
			: vector(__n, false, __a)
		{
		}
		vector(size_type __n, const bool &__value,
		       const allocator_type &__a = allocator_type())
			: _Base(__a)
		{
			_M_initialize(__n);
			_M_initialize_value(__value);
		}
		vector(const vector &__x)
			: _Base(_Bit_alloc_traits::_S_select_on_copy(
				  __x._M_get_Bit_allocator()))
		{
			_M_initialize(__x.size());
			_M_copy_aligned(__x.begin(), __x.end(), begin());
		}
		vector(vector &&) = default;

	    private:
		vector(vector &&__x, const allocator_type &__a,
		       std::true_type) noexcept
			: _Base(std::move(__x), __a)
		{
		}
		vector(vector &&__x, const allocator_type &__a, std::false_type)
			: _Base(__a)
		{
			if (__x.get_allocator() == __a) {
				this->_M_move_data(std::move(__x));
			} else {
				_M_initialize(__x.size());
				_M_copy_aligned(__x.begin(), __x.end(),
						begin());
				__x.clear();
			}
		}

	    public:
		vector(vector &&__x,
		       const std::__type_identity_t<allocator_type> &
			       __a) noexcept(_Bit_alloc_traits::_S_always_equal())
			: vector(std::move(__x), __a,
				 typename _Bvector_base<_Alloc>::
					 _Bit_alloc_traits::is_always_equal{})
		{
		}
		vector(const vector &__x,
		       const std::__type_identity_t<allocator_type> &__a)
			: _Base(__a)
		{
			_M_initialize(__x.size());
			_M_copy_aligned(__x.begin(), __x.end(), begin());
		}
		vector(std::initializer_list<bool> __l,
		       const allocator_type &__a = allocator_type())
			: _Base(__a)
		{
			_M_initialize_range(__l.begin(), __l.end(),
					    std::random_access_iterator_tag());
		}
		template <class _InputIterator,
			  class = std::_RequireInputIter<_InputIterator>>
		vector(_InputIterator __first, _InputIterator __last,
		       const allocator_type &__a = allocator_type())
			: _Base(__a)
		{
			_M_initialize_range(__first, __last,
					    std::__iterator_category(__first));
		}
		~vector() noexcept
		{
		}
		vector &operator=(const vector &__x)
		{
			if ((&__x) == this) {
				return *this;
			}
			if (_Bit_alloc_traits::_S_propagate_on_copy_assign()) {
				if (this->_M_get_Bit_allocator() !=
				    __x._M_get_Bit_allocator()) {
					this->_M_deallocate();
					std::__alloc_on_copy(
						_M_get_Bit_allocator(),
						__x._M_get_Bit_allocator());
					_M_initialize(__x.size());
				} else {
					std::__alloc_on_copy(
						_M_get_Bit_allocator(),
						__x._M_get_Bit_allocator());
				}
			}
			if (__x.size() > capacity()) {
				this->_M_deallocate();
				_M_initialize(__x.size());
			}
			((this->_M_impl)._M_finish) = _M_copy_aligned(
				__x.begin(), __x.end(), begin());
			return *this;
		}
		vector &operator=(vector &&__x) noexcept(
			_Bit_alloc_traits::_S_nothrow_move())
		{
			if (_Bit_alloc_traits::_S_propagate_on_move_assign() ||
			    (this->_M_get_Bit_allocator() ==
			     __x._M_get_Bit_allocator())) {
				this->_M_deallocate();
				this->_M_move_data(std::move(__x));
				std::__alloc_on_move(
					_M_get_Bit_allocator(),
					__x._M_get_Bit_allocator());
			} else {
				if (__x.size() > capacity()) {
					this->_M_deallocate();
					_M_initialize(__x.size());
				}
				((this->_M_impl)._M_finish) = _M_copy_aligned(
					__x.begin(), __x.end(), begin());
				__x.clear();
			}
			return *this;
		}
		vector &operator=(std::initializer_list<bool> __l)
		{
			this->assign(__l.begin(), __l.end());
			return *this;
		}
		void assign(size_type __n, const bool &__x)
		{
			_M_fill_assign(__n, __x);
		}
		template <class _InputIterator,
			  class = std::_RequireInputIter<_InputIterator>>
		void assign(_InputIterator __first, _InputIterator __last)
		{
			_M_assign_aux(__first, __last,
				      std::__iterator_category(__first));
		}
		void assign(std::initializer_list<bool> __l)
		{
			_M_assign_aux(__l.begin(), __l.end(),
				      std::random_access_iterator_tag());
		}
		[[__nodiscard__]] iterator begin() noexcept
		{
			return iterator((((this->_M_impl)._M_start)._M_p), 0);
		}
		[[__nodiscard__]] const_iterator begin() const noexcept
		{
			return const_iterator((((this->_M_impl)._M_start)._M_p),
					      0);
		}
		[[__nodiscard__]] iterator end() noexcept
		{
			return (this->_M_impl)._M_finish;
		}
		[[__nodiscard__]] const_iterator end() const noexcept
		{
			return (this->_M_impl)._M_finish;
		}
		[[__nodiscard__]] reverse_iterator rbegin() noexcept
		{
			return ((std::reverse_iterator<
				 std::_Bit_iterator>)(end()));
		}
		[[__nodiscard__]] const_reverse_iterator rbegin() const noexcept
		{
			return ((std::reverse_iterator<
				 std::_Bit_const_iterator>)(end()));
		}
		[[__nodiscard__]] reverse_iterator rend() noexcept
		{
			return ((std::reverse_iterator<
				 std::_Bit_iterator>)(begin()));
		}
		[[__nodiscard__]] const_reverse_iterator rend() const noexcept
		{
			return ((std::reverse_iterator<
				 std::_Bit_const_iterator>)(begin()));
		}
		[[__nodiscard__]] const_iterator cbegin() const noexcept
		{
			return const_iterator((((this->_M_impl)._M_start)._M_p),
					      0);
		}
		[[__nodiscard__]] const_iterator cend() const noexcept
		{
			return (this->_M_impl)._M_finish;
		}
		[[__nodiscard__]] const_reverse_iterator
		crbegin() const noexcept
		{
			return ((std::reverse_iterator<
				 std::_Bit_const_iterator>)(end()));
		}
		[[__nodiscard__]] const_reverse_iterator crend() const noexcept
		{
			return ((std::reverse_iterator<
				 std::_Bit_const_iterator>)(begin()));
		}
		[[__nodiscard__]] size_type size() const noexcept
		{
			return (size_type)(end() - begin());
		}
		[[__nodiscard__]] size_type max_size() const noexcept
		{
			const size_type __isize =
				((__gnu_cxx::__numeric_traits<
					  std::ptrdiff_t>::__max -
				  ((int)_S_word_bit)) +
				 (1));
			const size_type __asize = _Bit_alloc_traits::max_size(
				_M_get_Bit_allocator());
			return (__asize <= (__isize / ((int)_S_word_bit))) ?
				       __asize * ((int)_S_word_bit) :
				       __isize;
		}
		[[__nodiscard__]] size_type capacity() const noexcept
		{
			return (size_type)(const_iterator(
						   (this->_M_impl)._M_end_addr(),
						   0) -
					   begin());
		}
		[[__nodiscard__]] bool empty() const noexcept
		{
			return begin() == end();
		}
		[[__nodiscard__]] reference operator[](size_type __n)
		{
			return begin()[__n];
		}
		[[__nodiscard__]] const_reference
		operator[](size_type __n) const
		{
			return begin()[__n];
		}

	    protected:
		void _M_range_check(size_type __n) const
		{
			if (__n >= size()) {
				__throw_out_of_range_fmt(
					"vector<bool>::_M_range_check: __n (which is %zu) >= this->size() (which is %zu)",
					__n, size());
			}
		}

	    public:
		reference at(size_type __n)
		{
			_M_range_check(__n);
			return (*this)[__n];
		}
		const_reference at(size_type __n) const
		{
			_M_range_check(__n);
			return (*this)[__n];
		}
		void reserve(size_type __n)
		{
			if (__n > max_size()) {
				__throw_length_error("vector::reserve");
			}
			if (capacity() < __n) {
				_M_reallocate(__n);
			}
		}
		[[__nodiscard__]] reference front()
		{
			return *begin();
		}
		[[__nodiscard__]] const_reference front() const
		{
			return *begin();
		}
		[[__nodiscard__]] reference back()
		{
			return *(end() - 1);
		}
		[[__nodiscard__]] const_reference back() const
		{
			return *(end() - 1);
		}
		void push_back(bool __x)
		{
			if ((((this->_M_impl)._M_finish)._M_p) !=
			    (this->_M_impl)._M_end_addr()) {
				(*(((this->_M_impl)._M_finish)++)) = __x;
			} else {
				_M_insert_aux(end(), __x);
			}
		}
		void swap(vector &__x) noexcept
		{
			do {
				if (std::__is_constant_evaluated() &&
				    (!((bool)(_Bit_alloc_traits::
						      propagate_on_container_swap::
							      value ||
					      (_M_get_Bit_allocator() ==
					       __x._M_get_Bit_allocator()))))) {
					__builtin_unreachable();
				}
			} while (false);
			(this->_M_impl)._M_swap_data((__x._M_impl));
			_Bit_alloc_traits::_S_on_swap(
				_M_get_Bit_allocator(),
				__x._M_get_Bit_allocator());
		}
		static void swap(reference __x, reference __y) noexcept
		{
			bool __tmp = __x;
			(__x = __y);
			(__y = __tmp);
		}
		iterator insert(const_iterator __position, const bool &__x)
		{
			const difference_type __n = __position - begin();
			if (((((this->_M_impl)._M_finish)._M_p) !=
			     (this->_M_impl)._M_end_addr()) &&
			    (__position == end())) {
				(*(((this->_M_impl)._M_finish)++)) = __x;
			} else {
				_M_insert_aux(__position._M_const_cast(), __x);
			}
			return begin() + __n;
		}
		__attribute((__deprecated__(
			"use \'insert(position, false)\' instead"))) iterator
		insert(const_iterator __position)
		{
			return this->insert(__position._M_const_cast(), false);
		}
		template <class _InputIterator,
			  class = std::_RequireInputIter<_InputIterator>>
		iterator insert(const_iterator __position,
				_InputIterator __first, _InputIterator __last)
		{
			difference_type __offset = __position - cbegin();
			_M_insert_range(__position._M_const_cast(), __first,
					__last,
					std::__iterator_category(__first));
			return begin() + __offset;
		}
		iterator insert(const_iterator __position, size_type __n,
				const bool &__x)
		{
			difference_type __offset = __position - cbegin();
			_M_fill_insert(__position._M_const_cast(), __n, __x);
			return begin() + __offset;
		}
		iterator insert(const_iterator __p,
				std::initializer_list<bool> __l)
		{
			return this->insert(__p, __l.begin(), __l.end());
		}
		void pop_back()
		{
			--((this->_M_impl)._M_finish);
		}
		iterator erase(const_iterator __position)
		{
			return _M_erase(__position._M_const_cast());
		}
		iterator erase(const_iterator __first, const_iterator __last)
		{
			return _M_erase(__first._M_const_cast(),
					__last._M_const_cast());
		}
		void resize(size_type __new_size, bool __x = ((bool)0))
		{
			if (__new_size < size()) {
				_M_erase_at_end(begin() +
						((difference_type)__new_size));
			} else {
				insert(end(), __new_size - size(), __x);
			}
		}
		void shrink_to_fit()
		{
			_M_shrink_to_fit();
		}
		void flip() noexcept
		{
			std::_Bit_type *const __end =
				(this->_M_impl)._M_end_addr();
			for (std::_Bit_type *__p =
				     ((((this->_M_impl)._M_start)._M_p));
			     __p != __end; ++__p) {
				(*__p) = (~(*__p));
			}
		}
		void clear() noexcept
		{
			_M_erase_at_end(begin());
		}
		template <class... _Args>
		reference emplace_back(_Args &&...__args)
		{
			push_back(bool(__args...));
			return back();
		}
		template <class... _Args>
		iterator emplace(const_iterator __pos, _Args &&...__args)
		{
			return insert(__pos, bool(__args...));
		}

	    protected:
		iterator _M_copy_aligned(const_iterator __first,
					 const_iterator __last,
					 iterator __result)
		{
			std::_Bit_type *__q = std::copy(
				__first._M_p, __last._M_p, __result._M_p);
			return std::copy(const_iterator(__last._M_p, 0), __last,
					 iterator(__q, 0));
		}
		void _M_initialize(size_type __n)
		{
			if (__n) {
				_Bit_pointer __q = this->_M_allocate(__n);
				((this->_M_impl)._M_end_of_storage) =
					(__q + _S_nword(__n));
				iterator __start =
					iterator(std::__addressof(*__q), 0);
				((this->_M_impl)._M_start) = __start;
				((this->_M_impl)._M_finish) =
					(__start + ((difference_type)__n));
			}
		}
		void _M_initialize_value(bool __x) noexcept
		{
			if (std::_Bit_type *__p =
				    ((((this->_M_impl)._M_start)._M_p))) {
				__fill_bvector_n(__p,
						 (this->_M_impl)._M_end_addr() -
							 __p,
						 __x);
			}
		}
		void _M_reallocate(size_type __n);
		bool _M_shrink_to_fit();
		template <class _InputIterator>
		void _M_initialize_range(_InputIterator __first,
					 _InputIterator __last,
					 std::input_iterator_tag)
		{
			for (; __first != __last; ++__first) {
				push_back(*__first);
			}
		}
		template <class _ForwardIterator>
		void _M_initialize_range(_ForwardIterator __first,
					 _ForwardIterator __last,
					 std::forward_iterator_tag)
		{
			const size_type __n = std::distance(__first, __last);
			_M_initialize(__n);
			std::copy(__first, __last, begin());
		}
		void _M_fill_assign(std::size_t __n, bool __x)
		{
			if (__n > size()) {
				_M_initialize_value(__x);
				insert(end(), __n - size(), __x);
			} else {
				_M_erase_at_end(begin() + __n);
				_M_initialize_value(__x);
			}
		}
		template <class _InputIterator>
		void _M_assign_aux(_InputIterator __first,
				   _InputIterator __last,
				   std::input_iterator_tag)
		{
			iterator __cur = begin();
			for (; (__first != __last) && (__cur != end());
			     (++__cur), ((void)(++__first))) {
				(*__cur) = (*__first);
			}
			if (__first == __last) {
				_M_erase_at_end(__cur);
			} else {
				insert(end(), __first, __last);
			}
		}
		template <class _ForwardIterator>
		void _M_assign_aux(_ForwardIterator __first,
				   _ForwardIterator __last,
				   std::forward_iterator_tag)
		{
			const size_type __len = std::distance(__first, __last);
			if (__len < size()) {
				_M_erase_at_end(
					std::copy(__first, __last, begin()));
			} else {
				_ForwardIterator __mid = __first;
				std::advance(__mid, size());
				std::copy(__first, __mid, begin());
				insert(end(), __mid, __last);
			}
		}
		void _M_fill_insert(iterator __position, size_type __n,
				    bool __x);
		template <class _InputIterator>
		void _M_insert_range(iterator __pos, _InputIterator __first,
				     _InputIterator __last,
				     std::input_iterator_tag)
		{
			for (; __first != __last; ++__first) {
				__pos = insert(__pos, *__first);
				(++__pos);
			}
		}
		template <class _ForwardIterator>
		void _M_insert_range(iterator __position,
				     _ForwardIterator __first,
				     _ForwardIterator __last,
				     std::forward_iterator_tag);
		void _M_insert_aux(iterator __position, bool __x);
		size_type _M_check_len(size_type __n, const char *__s) const
		{
			if ((max_size() - size()) < __n) {
				__throw_length_error(__s);
			}
			const size_type __len = size() + std::max(size(), __n);
			return ((__len < size()) || (__len > max_size())) ?
				       max_size() :
				       __len;
		}
		void _M_erase_at_end(iterator __pos)
		{
			((this->_M_impl)._M_finish) = __pos;
		}
		iterator _M_erase(iterator __pos);
		iterator _M_erase(iterator __first, iterator __last);
		void data() = delete;
	};
	inline void __fill_bvector(_Bit_type * __v, unsigned __first,
				   unsigned __last, bool __x) noexcept
	{
		const _Bit_type __fmask = (~0UL) << __first;
		const _Bit_type __lmask = (~0UL) >> ((_S_word_bit)-__last);
		const _Bit_type __mask = __fmask & __lmask;
		if (__x) {
			(*__v) |= __mask;
		} else {
			(*__v) &= (~__mask);
		}
	}
	__attribute((__nonnull__)) inline void __fill_bvector_n(
		_Bit_type * __p, size_t __n, bool __x) noexcept
	{
		__builtin_memset(__p, __x ? ~0 : 0, __n * sizeof(_Bit_type));
	}
	inline void __fill_a1(_Bit_iterator __first, _Bit_iterator __last,
			      const bool &__x)
	{
		if ((__first._M_p) != (__last._M_p)) {
			_Bit_type *__first_p = __first._M_p;
			if ((__first._M_offset) != (0)) {
				__fill_bvector(__first_p++, __first._M_offset,
					       _S_word_bit, __x);
			}
			__fill_bvector_n(__first_p, (__last._M_p) - __first_p,
					 __x);
			if ((__last._M_offset) != (0)) {
				__fill_bvector(__last._M_p, 0, __last._M_offset,
					       __x);
			}
		} else {
			if ((__first._M_offset) != (__last._M_offset)) {
				__fill_bvector(__first._M_p, __first._M_offset,
					       __last._M_offset, __x);
			}
		}
	}
	template <class _Alloc>
	struct hash<vector<bool, _Alloc>>
		: public __hash_base<unsigned long, vector<bool, _Alloc>> {
		std::size_t
		operator()(const vector<bool, _Alloc> &) const noexcept;
	};
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _Tp, class _Up = typename __inv_unwrap<_Tp>::type>
	constexpr _Up &&__invfwd(typename remove_reference<_Tp>::type &
				 __t) noexcept
	{
		return static_cast<_Up &&>(__t);
	}
	template <class _Res, class _Fn, class... _Args>
	constexpr _Res __invoke_impl(__invoke_other, _Fn && __f,
				     _Args && ...__args)
	{
		return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...);
	}
	template <class _Res, class _MemFun, class _Tp, class... _Args>
	constexpr _Res __invoke_impl(__invoke_memfun_ref, _MemFun && __f,
				     _Tp && __t, _Args && ...__args)
	{
		return (__invfwd<_Tp>(__t).*
			__f)(std::forward<_Args>(__args)...);
	}
	template <class _Res, class _MemFun, class _Tp, class... _Args>
	constexpr _Res __invoke_impl(__invoke_memfun_deref, _MemFun && __f,
				     _Tp && __t, _Args && ...__args)
	{
		return ((*std::forward<_Tp>(__t)).*
			__f)(std::forward<_Args>(__args)...);
	}
	template <class _Res, class _MemPtr, class _Tp>
	constexpr _Res __invoke_impl(__invoke_memobj_ref, _MemPtr && __f,
				     _Tp && __t)
	{
		return __invfwd<_Tp>(__t).*__f;
	}
	template <class _Res, class _MemPtr, class _Tp>
	constexpr _Res __invoke_impl(__invoke_memobj_deref, _MemPtr && __f,
				     _Tp && __t)
	{
		return (*std::forward<_Tp>(__t)).*__f;
	}
	template <class _Callable, class... _Args>
	constexpr typename __invoke_result<_Callable, _Args...>::type
	__invoke(_Callable && __fn, _Args && ...__args) noexcept(
		__is_nothrow_invocable<_Callable, _Args...>::value)
	{
		using __result = __invoke_result<_Callable, _Args...>;
		using __type =
			typename __invoke_result<_Callable, _Args...>::type;
		using __tag = typename __invoke_result<_Callable,
						       _Args...>::__invoke_type;
		return std::__invoke_impl<
			typename __invoke_result<_Callable, _Args...>::type>(
			__tag{}, std::forward<_Callable>(__fn),
			std::forward<_Args>(__args)...);
	}
	template <class _Res, class _Callable, class... _Args>
	constexpr enable_if_t<is_invocable_r_v<_Res, _Callable, _Args...>, _Res>
	__invoke_r(_Callable && __fn, _Args && ...__args) noexcept(
		is_nothrow_invocable_r_v<_Res, _Callable, _Args...>)
	{
		using __result = __invoke_result<_Callable, _Args...>;
		using __type =
			typename __invoke_result<_Callable, _Args...>::type;
		using __tag = typename __invoke_result<_Callable,
						       _Args...>::__invoke_type;
		if constexpr (is_void_v<_Res>) {
			std::__invoke_impl<typename __invoke_result<
				_Callable, _Args...>::type>(
				__tag{}, std::forward<_Callable>(__fn),
				std::forward<_Args>(__args)...);
		} else {
			return std::__invoke_impl<typename __invoke_result<
				_Callable, _Args...>::type>(
				__tag{}, std::forward<_Callable>(__fn),
				std::forward<_Args>(__args)...);
		}
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _Arg, class _Result> struct unary_function {
		typedef _Arg argument_type;
		typedef _Result result_type;
	} __attribute((__deprecated__));
	template <class _Arg1, class _Arg2, class _Result>
	struct binary_function {
		typedef _Arg1 first_argument_type;
		typedef _Arg2 second_argument_type;
		typedef _Result result_type;
	} __attribute((__deprecated__));
	struct __is_transparent;
	template <class _Tp = void> struct plus;
	template <class _Tp = void> struct minus;
	template <class _Tp = void> struct multiplies;
	template <class _Tp = void> struct divides;
	template <class _Tp = void> struct modulus;
	template <class _Tp = void> struct negate;
	template <class _Tp>
	struct plus : public binary_function<_Tp, _Tp, _Tp> {
		constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const
		{
			return __x + __y;
		}
	};
	template <class _Tp>
	struct minus : public binary_function<_Tp, _Tp, _Tp> {
		constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const
		{
			return __x - __y;
		}
	};
	template <class _Tp>
	struct multiplies : public binary_function<_Tp, _Tp, _Tp> {
		constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const
		{
			return __x * __y;
		}
	};
	template <class _Tp>
	struct divides : public binary_function<_Tp, _Tp, _Tp> {
		constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const
		{
			return __x / __y;
		}
	};
	template <class _Tp>
	struct modulus : public binary_function<_Tp, _Tp, _Tp> {
		constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const
		{
			return __x % __y;
		}
	};
	template <class _Tp> struct negate : public unary_function<_Tp, _Tp> {
		constexpr _Tp operator()(const _Tp &__x) const
		{
			return -__x;
		}
	};
	template <> struct plus<void> {
		template <class _Tp, class _Up>
		constexpr auto operator()(_Tp &&__t, _Up &&__u) const
			noexcept(noexcept((std::forward<_Tp>(__t) +
					   std::forward<_Up>(__u))))
				-> __decltype((std::forward<_Tp>(__t) +
					       std::forward<_Up>(__u)))
		{
			return std::forward<_Tp>(__t) + std::forward<_Up>(__u);
		}
		typedef __is_transparent is_transparent;
	};
	template <> struct minus<void> {
		template <class _Tp, class _Up>
		constexpr auto operator()(_Tp &&__t, _Up &&__u) const
			noexcept(noexcept((std::forward<_Tp>(__t) -
					   std::forward<_Up>(__u))))
				-> __decltype((std::forward<_Tp>(__t) -
					       std::forward<_Up>(__u)))
		{
			return std::forward<_Tp>(__t) - std::forward<_Up>(__u);
		}
		typedef __is_transparent is_transparent;
	};
	template <> struct multiplies<void> {
		template <class _Tp, class _Up>
		constexpr auto operator()(_Tp &&__t, _Up &&__u) const
			noexcept(noexcept((std::forward<_Tp>(__t) *
					   std::forward<_Up>(__u))))
				-> __decltype((std::forward<_Tp>(__t) *
					       std::forward<_Up>(__u)))
		{
			return std::forward<_Tp>(__t) * std::forward<_Up>(__u);
		}
		typedef __is_transparent is_transparent;
	};
	template <> struct divides<void> {
		template <class _Tp, class _Up>
		constexpr auto operator()(_Tp &&__t, _Up &&__u) const
			noexcept(noexcept((std::forward<_Tp>(__t) /
					   std::forward<_Up>(__u))))
				-> __decltype((std::forward<_Tp>(__t) /
					       std::forward<_Up>(__u)))
		{
			return std::forward<_Tp>(__t) / std::forward<_Up>(__u);
		}
		typedef __is_transparent is_transparent;
	};
	template <> struct modulus<void> {
		template <class _Tp, class _Up>
		constexpr auto operator()(_Tp &&__t, _Up &&__u) const
			noexcept(noexcept((std::forward<_Tp>(__t) %
					   std::forward<_Up>(__u))))
				-> __decltype((std::forward<_Tp>(__t) %
					       std::forward<_Up>(__u)))
		{
			return std::forward<_Tp>(__t) % std::forward<_Up>(__u);
		}
		typedef __is_transparent is_transparent;
	};
	template <> struct negate<void> {
		template <class _Tp>
		constexpr auto operator()(_Tp &&__t) const
			noexcept(noexcept((-std::forward<_Tp>(__t))))
				-> __decltype((-std::forward<_Tp>(__t)))
		{
			return -std::forward<_Tp>(__t);
		}
		typedef __is_transparent is_transparent;
	};
	template <class _Tp = void> struct equal_to;
	template <class _Tp = void> struct not_equal_to;
	template <class _Tp = void> struct greater;
	template <class _Tp = void> struct less;
	template <class _Tp = void> struct greater_equal;
	template <class _Tp = void> struct less_equal;
	template <class _Tp>
	struct equal_to : public binary_function<_Tp, _Tp, bool> {
		constexpr bool operator()(const _Tp &__x, const _Tp &__y) const
		{
			return __x == __y;
		}
	};
	template <class _Tp>
	struct not_equal_to : public binary_function<_Tp, _Tp, bool> {
		constexpr bool operator()(const _Tp &__x, const _Tp &__y) const
		{
			return __x != __y;
		}
	};
	template <class _Tp>
	struct greater : public binary_function<_Tp, _Tp, bool> {
		constexpr bool operator()(const _Tp &__x, const _Tp &__y) const
		{
			return __x > __y;
		}
	};
	template <class _Tp>
	struct less : public binary_function<_Tp, _Tp, bool> {
		constexpr bool operator()(const _Tp &__x, const _Tp &__y) const
		{
			return __x < __y;
		}
	};
	template <class _Tp>
	struct greater_equal : public binary_function<_Tp, _Tp, bool> {
		constexpr bool operator()(const _Tp &__x, const _Tp &__y) const
		{
			return __x >= __y;
		}
	};
	template <class _Tp>
	struct less_equal : public binary_function<_Tp, _Tp, bool> {
		constexpr bool operator()(const _Tp &__x, const _Tp &__y) const
		{
			return __x <= __y;
		}
	};
	template <class _Tp>
	struct greater<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
		constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept
		{
			if (std::__is_constant_evaluated()) {
				return __x > __y;
			}
			return ((unsigned long)__x) > ((unsigned long)__y);
		}
	};
	template <class _Tp>
	struct less<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
		constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept
		{
			if (std::__is_constant_evaluated()) {
				return __x < __y;
			}
			return ((unsigned long)__x) < ((unsigned long)__y);
		}
	};
	template <class _Tp>
	struct greater_equal<_Tp *>
		: public binary_function<_Tp *, _Tp *, bool> {
		constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept
		{
			if (std::__is_constant_evaluated()) {
				return __x >= __y;
			}
			return ((unsigned long)__x) >= ((unsigned long)__y);
		}
	};
	template <class _Tp>
	struct less_equal<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
		constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept
		{
			if (std::__is_constant_evaluated()) {
				return __x <= __y;
			}
			return ((unsigned long)__x) <= ((unsigned long)__y);
		}
	};
	template <> struct equal_to<void> {
		template <class _Tp, class _Up>
		constexpr auto operator()(_Tp &&__t, _Up &&__u) const
			noexcept(noexcept((std::forward<_Tp>(__t) ==
					   std::forward<_Up>(__u))))
				-> __decltype((std::forward<_Tp>(__t) ==
					       std::forward<_Up>(__u)))
		{
			return std::forward<_Tp>(__t) == std::forward<_Up>(__u);
		}
		typedef __is_transparent is_transparent;
	};
	template <> struct not_equal_to<void> {
		template <class _Tp, class _Up>
		constexpr auto operator()(_Tp &&__t, _Up &&__u) const
			noexcept(noexcept((std::forward<_Tp>(__t) !=
					   std::forward<_Up>(__u))))
				-> __decltype((std::forward<_Tp>(__t) !=
					       std::forward<_Up>(__u)))
		{
			return std::forward<_Tp>(__t) != std::forward<_Up>(__u);
		}
		typedef __is_transparent is_transparent;
	};
	template <> struct greater<void> {
		template <class _Tp, class _Up>
		constexpr auto operator()(_Tp &&__t, _Up &&__u) const
			noexcept(noexcept((std::forward<_Tp>(__t) >
					   std::forward<_Up>(__u))))
				-> __decltype((std::forward<_Tp>(__t) >
					       std::forward<_Up>(__u)))
		{
			return _S_cmp(std::forward<_Tp>(__t),
				      std::forward<_Up>(__u),
				      __ptr_cmp<_Tp, _Up>{});
		}
		template <class _Tp, class _Up>
		constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept
		{
			return std::greater<common_type_t<_Tp *, _Up *>>{}(__t,
									   __u);
		}
		typedef __is_transparent is_transparent;

	    private:
		template <class _Tp, class _Up>
		static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u,
						       false_type)
		{
			return std::forward<_Tp>(__t) > std::forward<_Up>(__u);
		}
		template <class _Tp, class _Up>
		static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u,
					     true_type) noexcept
		{
			return std::greater<const volatile void *>{}(
				static_cast<const volatile void *>(
					std::forward<_Tp>(__t)),
				static_cast<const volatile void *>(
					std::forward<_Up>(__u)));
		}
		template <class _Tp, class _Up, class = void>
		struct __not_overloaded2 : public true_type {
		};
		template <class _Tp, class _Up>
		struct __not_overloaded2<
			_Tp, _Up,
			__void_t<__decltype((std::declval<_Tp>().operator>(
				std::declval<_Up>())))>> : public false_type {
		};
		template <class _Tp, class _Up, class = void>
		struct __not_overloaded : public __not_overloaded2<_Tp, _Up> {
		};
		template <class _Tp, class _Up>
		struct __not_overloaded<
			_Tp, _Up,
			__void_t<__decltype((operator>(std::declval<_Tp>(),
						       std::declval<_Up>())))>>
			: public false_type {
		};
		template <class _Tp, class _Up>
		using __ptr_cmp =
			__and_<__not_overloaded<_Tp, _Up>,
			       is_convertible<_Tp, const volatile void *>,
			       is_convertible<_Up, const volatile void *>>;
	};
	template <> struct less<void> {
		template <class _Tp, class _Up>
		constexpr auto operator()(_Tp &&__t, _Up &&__u) const
			noexcept(noexcept((std::forward<_Tp>(__t) <
					   std::forward<_Up>(__u))))
				-> __decltype((std::forward<_Tp>(__t) <
					       std::forward<_Up>(__u)))
		{
			return _S_cmp(std::forward<_Tp>(__t),
				      std::forward<_Up>(__u),
				      __ptr_cmp<_Tp, _Up>{});
		}
		template <class _Tp, class _Up>
		constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept
		{
			return std::less<common_type_t<_Tp *, _Up *>>{}(__t,
									__u);
		}
		typedef __is_transparent is_transparent;

	    private:
		template <class _Tp, class _Up>
		static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u,
						       false_type)
		{
			return std::forward<_Tp>(__t) < std::forward<_Up>(__u);
		}
		template <class _Tp, class _Up>
		static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u,
					     true_type) noexcept
		{
			return std::less<const volatile void *>{}(
				static_cast<const volatile void *>(
					std::forward<_Tp>(__t)),
				static_cast<const volatile void *>(
					std::forward<_Up>(__u)));
		}
		template <class _Tp, class _Up, class = void>
		struct __not_overloaded2 : public true_type {
		};
		template <class _Tp, class _Up>
		struct __not_overloaded2<
			_Tp, _Up,
			__void_t<__decltype((std::declval<_Tp>().operator<(
				std::declval<_Up>())))>> : public false_type {
		};
		template <class _Tp, class _Up, class = void>
		struct __not_overloaded : public __not_overloaded2<_Tp, _Up> {
		};
		template <class _Tp, class _Up>
		struct __not_overloaded<
			_Tp, _Up,
			__void_t<__decltype((operator<(std::declval<_Tp>(),
						       std::declval<_Up>())))>>
			: public false_type {
		};
		template <class _Tp, class _Up>
		using __ptr_cmp =
			__and_<__not_overloaded<_Tp, _Up>,
			       is_convertible<_Tp, const volatile void *>,
			       is_convertible<_Up, const volatile void *>>;
	};
	template <> struct greater_equal<void> {
		template <class _Tp, class _Up>
		constexpr auto operator()(_Tp &&__t, _Up &&__u) const
			noexcept(noexcept((std::forward<_Tp>(__t) >=
					   std::forward<_Up>(__u))))
				-> __decltype((std::forward<_Tp>(__t) >=
					       std::forward<_Up>(__u)))
		{
			return _S_cmp(std::forward<_Tp>(__t),
				      std::forward<_Up>(__u),
				      __ptr_cmp<_Tp, _Up>{});
		}
		template <class _Tp, class _Up>
		constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept
		{
			return std::greater_equal<common_type_t<_Tp *, _Up *>>{}(
				__t, __u);
		}
		typedef __is_transparent is_transparent;

	    private:
		template <class _Tp, class _Up>
		static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u,
						       false_type)
		{
			return std::forward<_Tp>(__t) >= std::forward<_Up>(__u);
		}
		template <class _Tp, class _Up>
		static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u,
					     true_type) noexcept
		{
			return std::greater_equal<const volatile void *>{}(
				static_cast<const volatile void *>(
					std::forward<_Tp>(__t)),
				static_cast<const volatile void *>(
					std::forward<_Up>(__u)));
		}
		template <class _Tp, class _Up, class = void>
		struct __not_overloaded2 : public true_type {
		};
		template <class _Tp, class _Up>
		struct __not_overloaded2<
			_Tp, _Up,
			__void_t<__decltype((std::declval<_Tp>().operator>=(
				std::declval<_Up>())))>> : public false_type {
		};
		template <class _Tp, class _Up, class = void>
		struct __not_overloaded : public __not_overloaded2<_Tp, _Up> {
		};
		template <class _Tp, class _Up>
		struct __not_overloaded<
			_Tp, _Up,
			__void_t<__decltype((operator>=(std::declval<_Tp>(),
							std::declval<_Up>())))>>
			: public false_type {
		};
		template <class _Tp, class _Up>
		using __ptr_cmp =
			__and_<__not_overloaded<_Tp, _Up>,
			       is_convertible<_Tp, const volatile void *>,
			       is_convertible<_Up, const volatile void *>>;
	};
	template <> struct less_equal<void> {
		template <class _Tp, class _Up>
		constexpr auto operator()(_Tp &&__t, _Up &&__u) const
			noexcept(noexcept((std::forward<_Tp>(__t) <=
					   std::forward<_Up>(__u))))
				-> __decltype((std::forward<_Tp>(__t) <=
					       std::forward<_Up>(__u)))
		{
			return _S_cmp(std::forward<_Tp>(__t),
				      std::forward<_Up>(__u),
				      __ptr_cmp<_Tp, _Up>{});
		}
		template <class _Tp, class _Up>
		constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept
		{
			return std::less_equal<common_type_t<_Tp *, _Up *>>{}(
				__t, __u);
		}
		typedef __is_transparent is_transparent;

	    private:
		template <class _Tp, class _Up>
		static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u,
						       false_type)
		{
			return std::forward<_Tp>(__t) <= std::forward<_Up>(__u);
		}
		template <class _Tp, class _Up>
		static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u,
					     true_type) noexcept
		{
			return std::less_equal<const volatile void *>{}(
				static_cast<const volatile void *>(
					std::forward<_Tp>(__t)),
				static_cast<const volatile void *>(
					std::forward<_Up>(__u)));
		}
		template <class _Tp, class _Up, class = void>
		struct __not_overloaded2 : public true_type {
		};
		template <class _Tp, class _Up>
		struct __not_overloaded2<
			_Tp, _Up,
			__void_t<__decltype((std::declval<_Tp>().operator<=(
				std::declval<_Up>())))>> : public false_type {
		};
		template <class _Tp, class _Up, class = void>
		struct __not_overloaded : public __not_overloaded2<_Tp, _Up> {
		};
		template <class _Tp, class _Up>
		struct __not_overloaded<
			_Tp, _Up,
			__void_t<__decltype((operator<=(std::declval<_Tp>(),
							std::declval<_Up>())))>>
			: public false_type {
		};
		template <class _Tp, class _Up>
		using __ptr_cmp =
			__and_<__not_overloaded<_Tp, _Up>,
			       is_convertible<_Tp, const volatile void *>,
			       is_convertible<_Up, const volatile void *>>;
	};
	template <class _Tp = void> struct logical_and;
	template <class _Tp = void> struct logical_or;
	template <class _Tp = void> struct logical_not;
	template <class _Tp>
	struct logical_and : public binary_function<_Tp, _Tp, bool> {
		constexpr bool operator()(const _Tp &__x, const _Tp &__y) const
		{
			return __x && __y;
		}
	};
	template <class _Tp>
	struct logical_or : public binary_function<_Tp, _Tp, bool> {
		constexpr bool operator()(const _Tp &__x, const _Tp &__y) const
		{
			return __x || __y;
		}
	};
	template <class _Tp>
	struct logical_not : public unary_function<_Tp, bool> {
		constexpr bool operator()(const _Tp &__x) const
		{
			return !__x;
		}
	};
	template <> struct logical_and<void> {
		template <class _Tp, class _Up>
		constexpr auto operator()(_Tp &&__t, _Up &&__u) const
			noexcept(noexcept((std::forward<_Tp>(__t) &&
					   std::forward<_Up>(__u))))
				-> __decltype((std::forward<_Tp>(__t) &&
					       std::forward<_Up>(__u)))
		{
			return std::forward<_Tp>(__t) && std::forward<_Up>(__u);
		}
		typedef __is_transparent is_transparent;
	};
	template <> struct logical_or<void> {
		template <class _Tp, class _Up>
		constexpr auto operator()(_Tp &&__t, _Up &&__u) const
			noexcept(noexcept((std::forward<_Tp>(__t) ||
					   std::forward<_Up>(__u))))
				-> __decltype((std::forward<_Tp>(__t) ||
					       std::forward<_Up>(__u)))
		{
			return std::forward<_Tp>(__t) || std::forward<_Up>(__u);
		}
		typedef __is_transparent is_transparent;
	};
	template <> struct logical_not<void> {
		template <class _Tp>
		constexpr auto operator()(_Tp &&__t) const
			noexcept(noexcept((!std::forward<_Tp>(__t))))
				-> __decltype((!std::forward<_Tp>(__t)))
		{
			return !std::forward<_Tp>(__t);
		}
		typedef __is_transparent is_transparent;
	};
	template <class _Tp = void> struct bit_and;
	template <class _Tp = void> struct bit_or;
	template <class _Tp = void> struct bit_xor;
	template <class _Tp = void> struct bit_not;
	template <class _Tp>
	struct bit_and : public binary_function<_Tp, _Tp, _Tp> {
		constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const
		{
			return __x & __y;
		}
	};
	template <class _Tp>
	struct bit_or : public binary_function<_Tp, _Tp, _Tp> {
		constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const
		{
			return __x | __y;
		}
	};
	template <class _Tp>
	struct bit_xor : public binary_function<_Tp, _Tp, _Tp> {
		constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const
		{
			return __x ^ __y;
		}
	};
	template <class _Tp> struct bit_not : public unary_function<_Tp, _Tp> {
		constexpr _Tp operator()(const _Tp &__x) const
		{
			return ~__x;
		}
	};
	template <> struct bit_and<void> {
		template <class _Tp, class _Up>
		constexpr auto operator()(_Tp &&__t, _Up &&__u) const
			noexcept(noexcept((std::forward<_Tp>(__t) &
					   std::forward<_Up>(__u))))
				-> __decltype((std::forward<_Tp>(__t) &
					       std::forward<_Up>(__u)))
		{
			return std::forward<_Tp>(__t) & std::forward<_Up>(__u);
		}
		typedef __is_transparent is_transparent;
	};
	template <> struct bit_or<void> {
		template <class _Tp, class _Up>
		constexpr auto operator()(_Tp &&__t, _Up &&__u) const
			noexcept(noexcept((std::forward<_Tp>(__t) |
					   std::forward<_Up>(__u))))
				-> __decltype((std::forward<_Tp>(__t) |
					       std::forward<_Up>(__u)))
		{
			return std::forward<_Tp>(__t) | std::forward<_Up>(__u);
		}
		typedef __is_transparent is_transparent;
	};
	template <> struct bit_xor<void> {
		template <class _Tp, class _Up>
		constexpr auto operator()(_Tp &&__t, _Up &&__u) const
			noexcept(noexcept((std::forward<_Tp>(__t) ^
					   std::forward<_Up>(__u))))
				-> __decltype((std::forward<_Tp>(__t) ^
					       std::forward<_Up>(__u)))
		{
			return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u);
		}
		typedef __is_transparent is_transparent;
	};
	template <> struct bit_not<void> {
		template <class _Tp>
		constexpr auto operator()(_Tp &&__t) const
			noexcept(noexcept((~std::forward<_Tp>(__t))))
				-> __decltype((~std::forward<_Tp>(__t)))
		{
			return ~std::forward<_Tp>(__t);
		}
		typedef __is_transparent is_transparent;
	};
	template <class _Predicate>
	class [[__deprecated__]] unary_negate
		: public unary_function<typename _Predicate::argument_type,
					bool> {
	    protected:
		_Predicate _M_pred;

	    public:
		constexpr explicit unary_negate(const _Predicate &__x)
			: _M_pred(__x)
		{
		}
		constexpr bool
		operator()(const typename _Predicate::argument_type &__x) const
		{
			return !(_M_pred)(__x);
		}
	};
	template <class _Predicate>
	__attribute((__deprecated__(
		"use \'std::not_fn\' instead"))) constexpr unary_negate<_Predicate>
	not1(const _Predicate &__pred)
	{
		return ((unary_negate<_Predicate>)(__pred));
	}
	template <class _Predicate>
	class [[__deprecated__]] binary_negate
		: public binary_function<
			  typename _Predicate::first_argument_type,
			  typename _Predicate::second_argument_type, bool> {
	    protected:
		_Predicate _M_pred;

	    public:
		constexpr explicit binary_negate(const _Predicate &__x)
			: _M_pred(__x)
		{
		}
		constexpr bool
		operator()(const typename _Predicate::first_argument_type &__x,
			   const typename _Predicate::second_argument_type &__y)
			const
		{
			return !(_M_pred)(__x, __y);
		}
	};
	template <class _Predicate>
	__attribute((__deprecated__(
		"use \'std::not_fn\' instead"))) constexpr binary_negate<_Predicate>
	not2(const _Predicate &__pred)
	{
		return ((binary_negate<_Predicate>)(__pred));
	}
	template <class _Arg, class _Result>
	class pointer_to_unary_function : public unary_function<_Arg, _Result> {
	    protected:
		_Result (*_M_ptr)(_Arg);

	    public:
		pointer_to_unary_function()
		{
		}
		explicit pointer_to_unary_function(_Result (*__x)(_Arg))
			: _M_ptr(__x)
		{
		}
		_Result operator()(_Arg __x) const
		{
			return (_M_ptr)(__x);
		}
	} __attribute((__deprecated__));
	template <class _Arg, class _Result>
	__attribute((__deprecated__("use \'std::function\' instead"))) inline pointer_to_unary_function<
		_Arg, _Result>
	ptr_fun(_Result(*__x)(_Arg))
	{
		return ((pointer_to_unary_function<_Arg, _Result>)(__x));
	}
	template <class _Arg1, class _Arg2, class _Result>
	class pointer_to_binary_function
		: public binary_function<_Arg1, _Arg2, _Result> {
	    protected:
		_Result (*_M_ptr)(_Arg1, _Arg2);

	    public:
		pointer_to_binary_function()
		{
		}
		explicit pointer_to_binary_function(_Result (*__x)(_Arg1,
								   _Arg2))
			: _M_ptr(__x)
		{
		}
		_Result operator()(_Arg1 __x, _Arg2 __y) const
		{
			return (_M_ptr)(__x, __y);
		}
	} __attribute((__deprecated__));
	template <class _Arg1, class _Arg2, class _Result>
	__attribute((__deprecated__("use \'std::function\' instead"))) inline pointer_to_binary_function<
		_Arg1, _Arg2, _Result>
	ptr_fun(_Result(*__x)(_Arg1, _Arg2))
	{
		return ((
			pointer_to_binary_function<_Arg1, _Arg2, _Result>)(__x));
	}
	template <class _Tp>
	struct _Identity : public unary_function<_Tp, _Tp> {
		_Tp &operator()(_Tp &__x) const
		{
			return __x;
		}
		const _Tp &operator()(const _Tp &__x) const
		{
			return __x;
		}
	};
	template <class _Tp>
	struct _Identity<const _Tp> : public std::_Identity<_Tp> {
	};
	template <class _Pair>
	struct _Select1st
		: public unary_function<_Pair, typename _Pair::first_type> {
		typename _Pair::first_type &operator()(_Pair &__x) const
		{
			return __x.first;
		}
		const typename _Pair::first_type &
		operator()(const _Pair &__x) const
		{
			return __x.first;
		}
		template <class _Pair2>
		typename _Pair2::first_type &operator()(_Pair2 &__x) const
		{
			return __x.first;
		}
		template <class _Pair2>
		const typename _Pair2::first_type &
		operator()(const _Pair2 &__x) const
		{
			return __x.first;
		}
	};
	template <class _Pair>
	struct _Select2nd
		: public unary_function<_Pair, typename _Pair::second_type> {
		typename _Pair::second_type &operator()(_Pair &__x) const
		{
			return __x.second;
		}
		const typename _Pair::second_type &
		operator()(const _Pair &__x) const
		{
			return __x.second;
		}
	};
	template <class _Ret, class _Tp>
	class mem_fun_t : public unary_function<_Tp *, _Ret> {
	    public:
		explicit mem_fun_t(_Ret (_Tp::*__pf)(void)) : _M_f(__pf)
		{
		}
		_Ret operator()(_Tp *__p) const
		{
			return (__p->*(_M_f))();
		}

	    private:
		_Ret (_Tp::*_M_f)(void);
	} __attribute((__deprecated__));
	template <class _Ret, class _Tp>
	class const_mem_fun_t : public unary_function<const _Tp *, _Ret> {
	    public:
		explicit const_mem_fun_t(_Ret (_Tp::*__pf)(void) const)
			: _M_f(__pf)
		{
		}
		_Ret operator()(const _Tp *__p) const
		{
			return (__p->*(_M_f))();
		}

	    private:
		_Ret (_Tp::*_M_f)(void) const;
	} __attribute((__deprecated__));
	template <class _Ret, class _Tp>
	class mem_fun_ref_t : public unary_function<_Tp, _Ret> {
	    public:
		explicit mem_fun_ref_t(_Ret (_Tp::*__pf)(void)) : _M_f(__pf)
		{
		}
		_Ret operator()(_Tp &__r) const
		{
			return (__r.*(_M_f))();
		}

	    private:
		_Ret (_Tp::*_M_f)(void);
	} __attribute((__deprecated__));
	template <class _Ret, class _Tp>
	class const_mem_fun_ref_t : public unary_function<_Tp, _Ret> {
	    public:
		explicit const_mem_fun_ref_t(_Ret (_Tp::*__pf)(void) const)
			: _M_f(__pf)
		{
		}
		_Ret operator()(const _Tp &__r) const
		{
			return (__r.*(_M_f))();
		}

	    private:
		_Ret (_Tp::*_M_f)(void) const;
	} __attribute((__deprecated__));
	template <class _Ret, class _Tp, class _Arg>
	class mem_fun1_t : public binary_function<_Tp *, _Arg, _Ret> {
	    public:
		explicit mem_fun1_t(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf)
		{
		}
		_Ret operator()(_Tp *__p, _Arg __x) const
		{
			return (__p->*(_M_f))(__x);
		}

	    private:
		_Ret (_Tp::*_M_f)(_Arg);
	} __attribute((__deprecated__));
	template <class _Ret, class _Tp, class _Arg>
	class const_mem_fun1_t
		: public binary_function<const _Tp *, _Arg, _Ret> {
	    public:
		explicit const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
			: _M_f(__pf)
		{
		}
		_Ret operator()(const _Tp *__p, _Arg __x) const
		{
			return (__p->*(_M_f))(__x);
		}

	    private:
		_Ret (_Tp::*_M_f)(_Arg) const;
	} __attribute((__deprecated__));
	template <class _Ret, class _Tp, class _Arg>
	class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret> {
	    public:
		explicit mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf)
		{
		}
		_Ret operator()(_Tp &__r, _Arg __x) const
		{
			return (__r.*(_M_f))(__x);
		}

	    private:
		_Ret (_Tp::*_M_f)(_Arg);
	} __attribute((__deprecated__));
	template <class _Ret, class _Tp, class _Arg>
	class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret> {
	    public:
		explicit const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
			: _M_f(__pf)
		{
		}
		_Ret operator()(const _Tp &__r, _Arg __x) const
		{
			return (__r.*(_M_f))(__x);
		}

	    private:
		_Ret (_Tp::*_M_f)(_Arg) const;
	} __attribute((__deprecated__));
	template <class _Ret, class _Tp>
	__attribute((__deprecated__(
		"use \'std::mem_fn\' instead"))) inline mem_fun_t<_Ret, _Tp>
	mem_fun(_Ret(_Tp::*__f)(void))
	{
		return ((mem_fun_t<_Ret, _Tp>)(__f));
	}
	template <class _Ret, class _Tp>
	__attribute((__deprecated__(
		"use \'std::mem_fn\' instead"))) inline const_mem_fun_t<_Ret,
									_Tp>
	mem_fun(_Ret(_Tp::*__f)(void) const)
	{
		return ((const_mem_fun_t<_Ret, _Tp>)(__f));
	}
	template <class _Ret, class _Tp>
	__attribute((__deprecated__(
		"use \'std::mem_fn\' instead"))) inline mem_fun_ref_t<_Ret, _Tp>
	mem_fun_ref(_Ret(_Tp::*__f)(void))
	{
		return ((mem_fun_ref_t<_Ret, _Tp>)(__f));
	}
	template <class _Ret, class _Tp>
	__attribute((__deprecated__(
		"use \'std::mem_fn\' instead"))) inline const_mem_fun_ref_t<_Ret,
									    _Tp>
	mem_fun_ref(_Ret(_Tp::*__f)(void) const)
	{
		return ((const_mem_fun_ref_t<_Ret, _Tp>)(__f));
	}
	template <class _Ret, class _Tp, class _Arg>
	__attribute((__deprecated__(
		"use \'std::mem_fn\' instead"))) inline mem_fun1_t<_Ret, _Tp,
								   _Arg>
	mem_fun(_Ret(_Tp::*__f)(_Arg))
	{
		return ((mem_fun1_t<_Ret, _Tp, _Arg>)(__f));
	}
	template <class _Ret, class _Tp, class _Arg>
	__attribute((__deprecated__(
		"use \'std::mem_fn\' instead"))) inline const_mem_fun1_t<_Ret,
									 _Tp,
									 _Arg>
	mem_fun(_Ret(_Tp::*__f)(_Arg) const)
	{
		return ((const_mem_fun1_t<_Ret, _Tp, _Arg>)(__f));
	}
	template <class _Ret, class _Tp, class _Arg>
	__attribute((__deprecated__(
		"use \'std::mem_fn\' instead"))) inline mem_fun1_ref_t<_Ret,
								       _Tp, _Arg>
	mem_fun_ref(_Ret(_Tp::*__f)(_Arg))
	{
		return ((mem_fun1_ref_t<_Ret, _Tp, _Arg>)(__f));
	}
	template <class _Ret, class _Tp, class _Arg>
	__attribute((__deprecated__(
		"use \'std::mem_fn\' instead"))) inline const_mem_fun1_ref_t<_Ret,
									     _Tp,
									     _Arg>
	mem_fun_ref(_Ret(_Tp::*__f)(_Arg) const)
	{
		return ((const_mem_fun1_ref_t<_Ret, _Tp, _Arg>)(__f));
	}
	template <class _Func, class _SfinaeType, class = __void_t<>>
	struct __has_is_transparent {
	};
	template <class _Func, class _SfinaeType>
	struct __has_is_transparent<_Func, _SfinaeType,
				    __void_t<typename _Func::is_transparent>> {
		typedef void type;
	};
	template <class _Func, class _SfinaeType>
	using __has_is_transparent_t =
		typename __has_is_transparent<_Func, _SfinaeType>::type;
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _Operation>
	class binder1st
		: public unary_function<typename _Operation::second_argument_type,
					typename _Operation::result_type> {
	    protected:
		_Operation op;
		typename _Operation::first_argument_type value;

	    public:
		binder1st(const _Operation &__x,
			  const typename _Operation::first_argument_type &__y)
			: op(__x), value(__y)
		{
		}
		typename _Operation::result_type
		operator()(const typename _Operation::second_argument_type &__x)
			const
		{
			return (op)(value, __x);
		}
		typename _Operation::result_type
		operator()(typename _Operation::second_argument_type &__x) const
		{
			return (op)(value, __x);
		}
	} __attribute((__deprecated__("use \'std::bind\' instead")));
	template <class _Operation, class _Tp>
	__attribute((__deprecated__(
		"use \'std::bind\' instead"))) inline binder1st<_Operation>
	bind1st(const _Operation &__fn, const _Tp &__x)
	{
		typedef typename _Operation::first_argument_type _Arg1_type;
		return binder1st<_Operation>(__fn, (_Arg1_type)__x);
	}
	template <class _Operation>
	class binder2nd
		: public unary_function<typename _Operation::first_argument_type,
					typename _Operation::result_type> {
	    protected:
		_Operation op;
		typename _Operation::second_argument_type value;

	    public:
		binder2nd(const _Operation &__x,
			  const typename _Operation::second_argument_type &__y)
			: op(__x), value(__y)
		{
		}
		typename _Operation::result_type
		operator()(const typename _Operation::first_argument_type &__x)
			const
		{
			return (op)(__x, value);
		}
		typename _Operation::result_type
		operator()(typename _Operation::first_argument_type &__x) const
		{
			return (op)(__x, value);
		}
	} __attribute((__deprecated__("use \'std::bind\' instead")));
	template <class _Operation, class _Tp>
	__attribute((__deprecated__(
		"use \'std::bind\' instead"))) inline binder2nd<_Operation>
	bind2nd(const _Operation &__fn, const _Tp &__x)
	{
		typedef typename _Operation::second_argument_type _Arg2_type;
		return binder2nd<_Operation>(__fn, (_Arg2_type)__x);
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _Res, class... _ArgTypes>
	struct _Maybe_unary_or_binary_function {
	};
	template <class _Res, class _T1>
	struct _Maybe_unary_or_binary_function<_Res, _T1>
		: public unary_function<_T1, _Res> {
	};
	template <class _Res, class _T1, class _T2>
	struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>
		: public binary_function<_T1, _T2, _Res> {
	};
	template <class _Signature> struct _Mem_fn_traits;
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits_base {
		using __result_type = _Res;
		using __maybe_type =
			_Maybe_unary_or_binary_function<_Res, _Class *,
							_ArgTypes...>;
		using __arity = integral_constant<size_t, sizeof...(_ArgTypes)>;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...)>
		: public _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
		using __vararg = std::false_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...)>
		: public _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
		using __vararg = std::true_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const>
		: public _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
		using __vararg = std::false_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const>
		: public _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
		using __vararg = std::true_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile>
		: public _Mem_fn_traits_base<_Res, volatile _Class,
					     _ArgTypes...> {
		using __vararg = std::false_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) volatile>
		: public _Mem_fn_traits_base<_Res, volatile _Class,
					     _ArgTypes...> {
		using __vararg = std::true_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile>
		: public _Mem_fn_traits_base<_Res, const volatile _Class,
					     _ArgTypes...> {
		using __vararg = std::false_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const volatile>
		: public _Mem_fn_traits_base<_Res, const volatile _Class,
					     _ArgTypes...> {
		using __vararg = std::true_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &>
		: public _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
		using __vararg = std::false_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) &>
		: public _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
		using __vararg = std::true_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &>
		: public _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
		using __vararg = std::false_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const &>
		: public _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
		using __vararg = std::true_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &>
		: public _Mem_fn_traits_base<_Res, volatile _Class,
					     _ArgTypes...> {
		using __vararg = std::false_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) volatile &>
		: public _Mem_fn_traits_base<_Res, volatile _Class,
					     _ArgTypes...> {
		using __vararg = std::true_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &>
		: public _Mem_fn_traits_base<_Res, const volatile _Class,
					     _ArgTypes...> {
		using __vararg = std::false_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...)
				      const volatile &>
		: public _Mem_fn_traits_base<_Res, const volatile _Class,
					     _ArgTypes...> {
		using __vararg = std::true_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &&>
		: public _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
		using __vararg = std::false_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) &&>
		: public _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
		using __vararg = std::true_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &&>
		: public _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
		using __vararg = std::false_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const &&>
		: public _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
		using __vararg = std::true_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &&>
		: public _Mem_fn_traits_base<_Res, volatile _Class,
					     _ArgTypes...> {
		using __vararg = std::false_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) volatile &&>
		: public _Mem_fn_traits_base<_Res, volatile _Class,
					     _ArgTypes...> {
		using __vararg = std::true_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &&>
		: public _Mem_fn_traits_base<_Res, const volatile _Class,
					     _ArgTypes...> {
		using __vararg = std::false_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...)
				      const volatile &&>
		: public _Mem_fn_traits_base<_Res, const volatile _Class,
					     _ArgTypes...> {
		using __vararg = std::true_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) noexcept>
		: public _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
		using __vararg = std::false_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) noexcept>
		: public _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
		using __vararg = std::true_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const noexcept>
		: public _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
		using __vararg = std::false_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const noexcept>
		: public _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
		using __vararg = std::true_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile noexcept>
		: public _Mem_fn_traits_base<_Res, volatile _Class,
					     _ArgTypes...> {
		using __vararg = std::false_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...,
					       ...) volatile noexcept>
		: public _Mem_fn_traits_base<_Res, volatile _Class,
					     _ArgTypes...> {
		using __vararg = std::true_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...)
				      const volatile noexcept>
		: public _Mem_fn_traits_base<_Res, const volatile _Class,
					     _ArgTypes...> {
		using __vararg = std::false_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...)
				      const volatile noexcept>
		: public _Mem_fn_traits_base<_Res, const volatile _Class,
					     _ArgTypes...> {
		using __vararg = std::true_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &noexcept>
		: public _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
		using __vararg = std::false_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) &noexcept>
		: public _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
		using __vararg = std::true_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &noexcept>
		: public _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
		using __vararg = std::false_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...)
				      const &noexcept>
		: public _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
		using __vararg = std::true_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &noexcept>
		: public _Mem_fn_traits_base<_Res, volatile _Class,
					     _ArgTypes...> {
		using __vararg = std::false_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...,
					       ...) volatile &noexcept>
		: public _Mem_fn_traits_base<_Res, volatile _Class,
					     _ArgTypes...> {
		using __vararg = std::true_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...)
				      const volatile &noexcept>
		: public _Mem_fn_traits_base<_Res, const volatile _Class,
					     _ArgTypes...> {
		using __vararg = std::false_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...)
				      const volatile &noexcept>
		: public _Mem_fn_traits_base<_Res, const volatile _Class,
					     _ArgTypes...> {
		using __vararg = std::true_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &&noexcept>
		: public _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
		using __vararg = std::false_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) &&noexcept>
		: public _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
		using __vararg = std::true_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &&noexcept>
		: public _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
		using __vararg = std::false_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...)
				      const &&noexcept>
		: public _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
		using __vararg = std::true_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &&noexcept>
		: public _Mem_fn_traits_base<_Res, volatile _Class,
					     _ArgTypes...> {
		using __vararg = std::false_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...,
					       ...) volatile &&noexcept>
		: public _Mem_fn_traits_base<_Res, volatile _Class,
					     _ArgTypes...> {
		using __vararg = std::true_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...)
				      const volatile &&noexcept>
		: public _Mem_fn_traits_base<_Res, const volatile _Class,
					     _ArgTypes...> {
		using __vararg = std::false_type;
	};
	template <class _Res, class _Class, class... _ArgTypes>
	struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...)
				      const volatile &&noexcept>
		: public _Mem_fn_traits_base<_Res, const volatile _Class,
					     _ArgTypes...> {
		using __vararg = std::true_type;
	};
	template <class _Functor, class = __void_t<>>
	struct _Maybe_get_result_type {
	};
	template <class _Functor>
	struct _Maybe_get_result_type<
		_Functor, __void_t<typename _Functor::result_type>> {
		typedef typename _Functor::result_type result_type;
	};
	template <class _Functor>
	struct _Weak_result_type_impl
		: public _Maybe_get_result_type<_Functor> {
	};
	template <class _Res, class... _ArgTypes, bool _NE>
	struct _Weak_result_type_impl<_Res(_ArgTypes...) noexcept(_NE)> {
		typedef _Res result_type;
	};
	template <class _Res, class... _ArgTypes, bool _NE>
	struct _Weak_result_type_impl<_Res(_ArgTypes..., ...) noexcept(_NE)> {
		typedef _Res result_type;
	};
	template <class _Res, class... _ArgTypes, bool _NE>
	struct _Weak_result_type_impl<_Res (*)(_ArgTypes...) noexcept(_NE)> {
		typedef _Res result_type;
	};
	template <class _Res, class... _ArgTypes, bool _NE>
	struct _Weak_result_type_impl<_Res (*)(_ArgTypes..., ...) noexcept(_NE)> {
		typedef _Res result_type;
	};
	template <class _Functor,
		  bool = is_member_function_pointer<_Functor>::value>
	struct _Weak_result_type_memfun
		: public _Weak_result_type_impl<_Functor> {
	};
	template <class _MemFunPtr>
	struct _Weak_result_type_memfun<_MemFunPtr, true> {
		using result_type =
			typename _Mem_fn_traits<_MemFunPtr>::__result_type;
	};
	template <class _Func, class _Class>
	struct _Weak_result_type_memfun<_Func(_Class::*), false> {
	};
	template <class _Functor>
	struct _Weak_result_type : public _Weak_result_type_memfun<
					   typename remove_cv<_Functor>::type> {
	};
	template <class _Tp, class = __void_t<>> struct _Refwrap_base_arg1 {
	};
	template <class _Tp>
	struct _Refwrap_base_arg1<_Tp, __void_t<typename _Tp::argument_type>> {
		typedef typename _Tp::argument_type argument_type;
	};
	template <class _Tp, class = __void_t<>> struct _Refwrap_base_arg2 {
	};
	template <class _Tp>
	struct _Refwrap_base_arg2<
		_Tp, __void_t<typename _Tp::first_argument_type,
			      typename _Tp::second_argument_type>> {
		typedef typename _Tp::first_argument_type first_argument_type;
		typedef typename _Tp::second_argument_type second_argument_type;
	};
	template <class _Tp>
	struct _Reference_wrapper_base : public _Weak_result_type<_Tp>,
					 public _Refwrap_base_arg1<_Tp>,
					 public _Refwrap_base_arg2<_Tp> {
	};
	template <class _Res, class _T1, bool _NE>
	struct _Reference_wrapper_base<_Res(_T1) noexcept(_NE)>
		: public unary_function<_T1, _Res> {
	};
	template <class _Res, class _T1>
	struct _Reference_wrapper_base<_Res(_T1) const>
		: public unary_function<_T1, _Res> {
	};
	template <class _Res, class _T1>
	struct _Reference_wrapper_base<_Res(_T1) volatile>
		: public unary_function<_T1, _Res> {
	};
	template <class _Res, class _T1>
	struct _Reference_wrapper_base<_Res(_T1) const volatile>
		: public unary_function<_T1, _Res> {
	};
	template <class _Res, class _T1, class _T2, bool _NE>
	struct _Reference_wrapper_base<_Res(_T1, _T2) noexcept(_NE)>
		: public binary_function<_T1, _T2, _Res> {
	};
	template <class _Res, class _T1, class _T2>
	struct _Reference_wrapper_base<_Res(_T1, _T2) const>
		: public binary_function<_T1, _T2, _Res> {
	};
	template <class _Res, class _T1, class _T2>
	struct _Reference_wrapper_base<_Res(_T1, _T2) volatile>
		: public binary_function<_T1, _T2, _Res> {
	};
	template <class _Res, class _T1, class _T2>
	struct _Reference_wrapper_base<_Res(_T1, _T2) const volatile>
		: public binary_function<_T1, _T2, _Res> {
	};
	template <class _Res, class _T1, bool _NE>
	struct _Reference_wrapper_base<_Res (*)(_T1) noexcept(_NE)>
		: public unary_function<_T1, _Res> {
	};
	template <class _Res, class _T1, class _T2, bool _NE>
	struct _Reference_wrapper_base<_Res (*)(_T1, _T2) noexcept(_NE)>
		: public binary_function<_T1, _T2, _Res> {
	};
	template <class _Tp, bool = is_member_function_pointer<_Tp>::value>
	struct _Reference_wrapper_base_memfun
		: public _Reference_wrapper_base<_Tp> {
	};
	template <class _MemFunPtr>
	struct _Reference_wrapper_base_memfun<_MemFunPtr, true>
		: public _Mem_fn_traits<_MemFunPtr>::__maybe_type {
		using result_type =
			typename _Mem_fn_traits<_MemFunPtr>::__result_type;
	};
	template <class _Tp>
	class reference_wrapper : public _Reference_wrapper_base_memfun<
					  typename remove_cv<_Tp>::type> {
		_Tp *_M_data;
		static _Tp *_S_fun(_Tp &__r) noexcept
		{
			return std::__addressof(__r);
		}
		static void _S_fun(_Tp &&) = delete;
		template <class _Up, class _Up2 = std::__remove_cvref_t<_Up>>
		using __not_same = typename enable_if<
			!is_same<reference_wrapper, _Up2>::value>::type;

	    public:
		typedef _Tp type;
		template <class _Up, class = __not_same<_Up>,
			  class = __decltype((reference_wrapper<_Tp>::_S_fun(
				  std::declval<_Up>())))>
		reference_wrapper(_Up &&__uref) noexcept(noexcept(
			reference_wrapper<_Tp>::_S_fun(std::declval<_Up>())))
			: _M_data(reference_wrapper<_Tp>::_S_fun(
				  std::forward<_Up>(__uref)))
		{
		}
		reference_wrapper(const reference_wrapper &) = default;
		reference_wrapper &
		operator=(const reference_wrapper &) = default;
		operator _Tp &() const noexcept
		{
			return get();
		}
		_Tp &get() const noexcept
		{
			return *(_M_data);
		}
		template <class... _Args>
		typename result_of<_Tp &(_Args &&...)>::type
		operator()(_Args &&...__args) const
		{
			return std::__invoke(get(),
					     std::forward<_Args>(__args)...);
		}
	};
	template <class _Tp> reference_wrapper(_Tp &) -> reference_wrapper<_Tp>;
	template <class _Tp>
	inline reference_wrapper<_Tp> ref(_Tp & __t) noexcept
	{
		return ((reference_wrapper<_Tp>)(__t));
	}
	template <class _Tp>
	inline reference_wrapper<const _Tp> cref(const _Tp &__t) noexcept
	{
		return ((reference_wrapper<const _Tp>)(__t));
	}
	template <typename _Tp> void ref(const _Tp &&) = delete;
	template <typename _Tp> void cref(const _Tp &&) = delete;
	template <class _Tp>
	inline reference_wrapper<_Tp> ref(reference_wrapper<_Tp> __t) noexcept
	{
		return __t;
	}
	template <class _Tp>
	inline reference_wrapper<const _Tp> cref(
		reference_wrapper<_Tp> __t) noexcept
	{
		return { __t.get() };
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _Container>
	[[__nodiscard__]] constexpr auto begin(_Container & __cont)
		->__decltype((__cont.begin()))
	{
		return __cont.begin();
	}
	template <class _Container>
	[[__nodiscard__]] constexpr auto begin(const _Container &__cont)
		->__decltype((__cont.begin()))
	{
		return __cont.begin();
	}
	template <class _Container>
	[[__nodiscard__]] constexpr auto end(_Container & __cont)
		->__decltype((__cont.end()))
	{
		return __cont.end();
	}
	template <class _Container>
	[[__nodiscard__]] constexpr auto end(const _Container &__cont)
		->__decltype((__cont.end()))
	{
		return __cont.end();
	}
	template <class _Tp, size_t _Nm>
	[[__nodiscard__]] constexpr _Tp *begin(_Tp(&__arr)[_Nm]) noexcept
	{
		return __arr;
	}
	template <class _Tp, size_t _Nm>
	[[__nodiscard__]] constexpr _Tp *end(_Tp(&__arr)[_Nm]) noexcept
	{
		return __arr + _Nm;
	}
	template <class _Tp> class valarray;
	template <class _Tp> _Tp *begin(valarray<_Tp> &) noexcept;
	template <class _Tp> const _Tp *begin(const valarray<_Tp> &) noexcept;
	template <class _Tp> _Tp *end(valarray<_Tp> &) noexcept;
	template <class _Tp> const _Tp *end(const valarray<_Tp> &) noexcept;
	template <class _Container>
	[[__nodiscard__]] constexpr auto cbegin(
		const _Container &__cont) noexcept(noexcept(std::begin(__cont)))
		->__decltype((std::begin(__cont)))
	{
		return std::begin(__cont);
	}
	template <class _Container>
	[[__nodiscard__]] constexpr auto cend(
		const _Container &__cont) noexcept(noexcept(std::end(__cont)))
		->__decltype((std::end(__cont)))
	{
		return std::end(__cont);
	}
	template <class _Container>
	[[__nodiscard__]] constexpr auto rbegin(_Container & __cont)
		->__decltype((__cont.rbegin()))
	{
		return __cont.rbegin();
	}
	template <class _Container>
	[[__nodiscard__]] constexpr auto rbegin(const _Container &__cont)
		->__decltype((__cont.rbegin()))
	{
		return __cont.rbegin();
	}
	template <class _Container>
	[[__nodiscard__]] constexpr auto rend(_Container & __cont)
		->__decltype((__cont.rend()))
	{
		return __cont.rend();
	}
	template <class _Container>
	[[__nodiscard__]] constexpr auto rend(const _Container &__cont)
		->__decltype((__cont.rend()))
	{
		return __cont.rend();
	}
	template <class _Tp, size_t _Nm>
	[[__nodiscard__]] constexpr reverse_iterator<_Tp *> rbegin(
		_Tp(&__arr)[_Nm]) noexcept
	{
		return ((reverse_iterator<_Tp *>)(__arr + _Nm));
	}
	template <class _Tp, size_t _Nm>
	[[__nodiscard__]] constexpr reverse_iterator<_Tp *> rend(
		_Tp(&__arr)[_Nm]) noexcept
	{
		return ((reverse_iterator<_Tp *>)(__arr));
	}
	template <class _Tp>
	[[__nodiscard__]] constexpr reverse_iterator<const _Tp *> rbegin(
		initializer_list<_Tp> __il) noexcept
	{
		return ((reverse_iterator<const _Tp *>)(__il.end()));
	}
	template <class _Tp>
	[[__nodiscard__]] constexpr reverse_iterator<const _Tp *> rend(
		initializer_list<_Tp> __il) noexcept
	{
		return ((reverse_iterator<const _Tp *>)(__il.begin()));
	}
	template <class _Container>
	[[__nodiscard__]] constexpr auto crbegin(const _Container &__cont)
		->__decltype((std::rbegin(__cont)))
	{
		return std::rbegin(__cont);
	}
	template <class _Container>
	[[__nodiscard__]] constexpr auto crend(const _Container &__cont)
		->__decltype((std::rend(__cont)))
	{
		return std::rend(__cont);
	}
	template <class _Container>
	[[nodiscard]] constexpr auto size(const _Container &__cont) noexcept(
		noexcept(__cont.size()))
		->__decltype((__cont.size()))
	{
		return __cont.size();
	}
	template <class _Tp, size_t _Nm>
	[[nodiscard]] constexpr size_t size(const _Tp(&)[_Nm]) noexcept
	{
		return _Nm;
	}
	template <class _Container>
	[[nodiscard]] constexpr auto empty(const _Container &__cont) noexcept(
		noexcept(__cont.empty()))
		->__decltype((__cont.empty()))
	{
		return __cont.empty();
	}
	template <class _Tp, size_t _Nm>
	[[nodiscard]] constexpr bool empty(const _Tp(&)[_Nm]) noexcept
	{
		return false;
	}
	template <class _Tp>
	[[nodiscard]] constexpr bool empty(initializer_list<_Tp> __il) noexcept
	{
		return __il.size() == 0;
	}
	template <class _Container>
	[[nodiscard]] constexpr auto data(_Container & __cont) noexcept(
		noexcept(__cont.data()))
		->__decltype((__cont.data()))
	{
		return __cont.data();
	}
	template <class _Container>
	[[nodiscard]] constexpr auto data(const _Container &__cont) noexcept(
		noexcept(__cont.data()))
		->__decltype((__cont.data()))
	{
		return __cont.data();
	}
	template <class _Tp, size_t _Nm>
	[[nodiscard]] constexpr _Tp *data(_Tp(&__array)[_Nm]) noexcept
	{
		return __array;
	}
	template <class _Tp>
	[[nodiscard]] constexpr const _Tp *data(
		initializer_list<_Tp> __il) noexcept
	{
		return __il.begin();
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _Tp, class _Alloc>
	void vector<_Tp, _Alloc>::reserve(size_type __n)
	{
		if (__n > max_size()) {
			__throw_length_error("vector::reserve");
		}
		if (capacity() < __n) {
			const size_type __old_size = size();
			pointer __tmp;
			if constexpr ((_S_use_relocate)()) {
				__tmp = this->_M_allocate(__n);
				(_S_relocate)(((this->_M_impl)._M_start),
					      ((this->_M_impl)._M_finish),
					      __tmp, _M_get_Tp_allocator());
			} else {
				__tmp = _M_allocate_and_copy(
					__n,
					std::__make_move_if_noexcept_iterator(
						((this->_M_impl)._M_start)),
					std::__make_move_if_noexcept_iterator(
						((this->_M_impl)._M_finish)));
				std::_Destroy(((this->_M_impl)._M_start),
					      ((this->_M_impl)._M_finish),
					      _M_get_Tp_allocator());
			};
			_M_deallocate(((this->_M_impl)._M_start),
				      ((this->_M_impl)._M_end_of_storage) -
					      ((this->_M_impl)._M_start));
			((this->_M_impl)._M_start) = __tmp;
			((this->_M_impl)._M_finish) = (__tmp + __old_size);
			((this->_M_impl)._M_end_of_storage) =
				(((this->_M_impl)._M_start) + __n);
		}
	}
	template <class _Tp, class _Alloc>
	template <class... _Args>
	typename vector<_Tp, _Alloc>::reference
	vector<_Tp, _Alloc>::emplace_back(_Args && ...__args)
	{
		if (((this->_M_impl)._M_finish) !=
		    ((this->_M_impl)._M_end_of_storage)) {
			;
			_Alloc_traits::construct(
				(this->_M_impl), ((this->_M_impl)._M_finish),
				std::forward<_Args>(__args)...);
			++((this->_M_impl)._M_finish);
			;
		} else {
			_M_realloc_insert(end(),
					  std::forward<_Args>(__args)...);
		}
		return back();
	}
	template <class _Tp, class _Alloc>
	typename vector<_Tp, _Alloc>::iterator vector<_Tp, _Alloc>::insert(
		const_iterator __position, const value_type &__x)
	{
		const size_type __n = __position - begin();
		if (((this->_M_impl)._M_finish) !=
		    ((this->_M_impl)._M_end_of_storage)) {
			if (__position == end()) {
				;
				_Alloc_traits::construct(
					(this->_M_impl),
					((this->_M_impl)._M_finish), __x);
				++((this->_M_impl)._M_finish);
				;
			} else {
				const auto __pos =
					begin() + (__position - cbegin());
				_Temporary_value __x_copy(this, __x);
				_M_insert_aux(__pos,
					      std::move(__x_copy._M_val()));
			}
		} else {
			_M_realloc_insert(begin() + (__position - cbegin()),
					  __x);
		}
		return ((__gnu_cxx::__normal_iterator<
			 pointer, vector>)(((this->_M_impl)._M_start) + __n));
	}
	template <class _Tp, class _Alloc>
	typename vector<_Tp, _Alloc>::iterator vector<_Tp, _Alloc>::_M_erase(
		iterator __position)
	{
		if ((__position + 1) != end()) {
			std::move(__position + 1, end(), __position);
		}
		--((this->_M_impl)._M_finish);
		_Alloc_traits::destroy((this->_M_impl),
				       ((this->_M_impl)._M_finish));
		;
		return __position;
	}
	template <class _Tp, class _Alloc>
	typename vector<_Tp, _Alloc>::iterator vector<_Tp, _Alloc>::_M_erase(
		iterator __first, iterator __last)
	{
		if (__first != __last) {
			if (__last != end()) {
				std::move(__last, end(), __first);
			}
			_M_erase_at_end(__first.base() + (end() - __last));
		}
		return __first;
	}
	template <class _Tp, class _Alloc>
	vector<_Tp, _Alloc> &vector<_Tp, _Alloc>::operator=(const vector &__x)
	{
		if (std::__addressof(__x) != this) {
			;
			if (_Alloc_traits::_S_propagate_on_copy_assign()) {
				if ((!_Alloc_traits::_S_always_equal()) &&
				    (_M_get_Tp_allocator() !=
				     __x._M_get_Tp_allocator())) {
					clear();
					_M_deallocate(
						((this->_M_impl)._M_start),
						((this->_M_impl)
							 ._M_end_of_storage) -
							((this->_M_impl)
								 ._M_start));
					((this->_M_impl)._M_start) = nullptr;
					((this->_M_impl)._M_finish) = nullptr;
					((this->_M_impl)._M_end_of_storage) =
						nullptr;
				}
				std::__alloc_on_copy(_M_get_Tp_allocator(),
						     __x._M_get_Tp_allocator());
			}
			const size_type __xlen = __x.size();
			if (__xlen > capacity()) {
				pointer __tmp = _M_allocate_and_copy(
					__xlen, __x.begin(), __x.end());
				std::_Destroy(((this->_M_impl)._M_start),
					      ((this->_M_impl)._M_finish),
					      _M_get_Tp_allocator());
				_M_deallocate(
					((this->_M_impl)._M_start),
					((this->_M_impl)._M_end_of_storage) -
						((this->_M_impl)._M_start));
				((this->_M_impl)._M_start) = __tmp;
				((this->_M_impl)._M_end_of_storage) =
					(((this->_M_impl)._M_start) + __xlen);
			} else {
				if (size() >= __xlen) {
					std::_Destroy(
						std::copy(__x.begin(),
							  __x.end(), begin()),
						end(), _M_get_Tp_allocator());
				} else {
					std::copy(((__x._M_impl)._M_start),
						  ((__x._M_impl)._M_start) +
							  size(),
						  ((this->_M_impl)._M_start));
					std::__uninitialized_copy_a(
						((__x._M_impl)._M_start) +
							size(),
						((__x._M_impl)._M_finish),
						((this->_M_impl)._M_finish),
						_M_get_Tp_allocator());
				}
			}
			((this->_M_impl)._M_finish) =
				(((this->_M_impl)._M_start) + __xlen);
		}
		return *this;
	}
	template <class _Tp, class _Alloc>
	void vector<_Tp, _Alloc>::_M_fill_assign(std::size_t __n,
						 const value_type &__val)
	{
		if (__n > capacity()) {
			vector __tmp(__n, __val, _M_get_Tp_allocator());
			(__tmp._M_impl)._M_swap_data((this->_M_impl));
		} else {
			if (__n > size()) {
				std::fill(begin(), end(), __val);
				const size_type __add = __n - size();
				;
				((this->_M_impl)._M_finish) =
					std::__uninitialized_fill_n_a(
						((this->_M_impl)._M_finish),
						__add, __val,
						_M_get_Tp_allocator());
				;
			} else {
				_M_erase_at_end(
					std::fill_n(((this->_M_impl)._M_start),
						    __n, __val));
			}
		}
	}
	template <class _Tp, class _Alloc>
	template <class _InputIterator>
	void vector<_Tp, _Alloc>::_M_assign_aux(_InputIterator __first,
						_InputIterator __last,
						std::input_iterator_tag)
	{
		pointer __cur(((this->_M_impl)._M_start));
		for (; (__first != __last) &&
		       (__cur != ((this->_M_impl)._M_finish));
		     (++__cur), ((void)(++__first))) {
			(*__cur) = (*__first);
		}
		if (__first == __last) {
			_M_erase_at_end(__cur);
		} else {
			_M_range_insert(end(), __first, __last,
					std::__iterator_category(__first));
		}
	}
	template <class _Tp, class _Alloc>
	template <class _ForwardIterator>
	void vector<_Tp, _Alloc>::_M_assign_aux(_ForwardIterator __first,
						_ForwardIterator __last,
						std::forward_iterator_tag)
	{
		const size_type __len = std::distance(__first, __last);
		if (__len > capacity()) {
			(_S_check_init_len)(__len, _M_get_Tp_allocator());
			pointer __tmp(
				_M_allocate_and_copy(__len, __first, __last));
			std::_Destroy(((this->_M_impl)._M_start),
				      ((this->_M_impl)._M_finish),
				      _M_get_Tp_allocator());
			;
			_M_deallocate(((this->_M_impl)._M_start),
				      ((this->_M_impl)._M_end_of_storage) -
					      ((this->_M_impl)._M_start));
			((this->_M_impl)._M_start) = __tmp;
			((this->_M_impl)._M_finish) =
				(((this->_M_impl)._M_start) + __len);
			((this->_M_impl)._M_end_of_storage) =
				((this->_M_impl)._M_finish);
		} else {
			if (size() >= __len) {
				_M_erase_at_end(
					std::copy(__first, __last,
						  ((this->_M_impl)._M_start)));
			} else {
				_ForwardIterator __mid = __first;
				std::advance(__mid, size());
				std::copy(__first, __mid,
					  ((this->_M_impl)._M_start));
				__attribute((__unused__)) const size_type __n =
					__len - size();
				;
				((this->_M_impl)._M_finish) =
					std::__uninitialized_copy_a(
						__mid, __last,
						((this->_M_impl)._M_finish),
						_M_get_Tp_allocator());
				;
			}
		}
	}
	template <class _Tp, class _Alloc>
	auto vector<_Tp, _Alloc>::_M_insert_rval(const_iterator __position,
						 value_type && __v)
		->iterator
	{
		const auto __n = __position - cbegin();
		if (((this->_M_impl)._M_finish) !=
		    ((this->_M_impl)._M_end_of_storage)) {
			if (__position == cend()) {
				;
				_Alloc_traits::construct(
					(this->_M_impl),
					((this->_M_impl)._M_finish),
					std::move(__v));
				++((this->_M_impl)._M_finish);
				;
			} else {
				_M_insert_aux(begin() + __n, std::move(__v));
			}
		} else {
			_M_realloc_insert(begin() + __n, std::move(__v));
		}
		return ((__gnu_cxx::__normal_iterator<
			 pointer, vector>)(((this->_M_impl)._M_start) + __n));
	}
	template <class _Tp, class _Alloc>
	template <class... _Args>
	auto vector<_Tp, _Alloc>::_M_emplace_aux(const_iterator __position,
						 _Args && ...__args)
		->iterator
	{
		const auto __n = __position - cbegin();
		if (((this->_M_impl)._M_finish) !=
		    ((this->_M_impl)._M_end_of_storage)) {
			if (__position == cend()) {
				;
				_Alloc_traits::construct(
					(this->_M_impl),
					((this->_M_impl)._M_finish),
					std::forward<_Args>(__args)...);
				++((this->_M_impl)._M_finish);
				;
			} else {
				_Temporary_value __tmp(
					this, std::forward<_Args>(__args)...);
				_M_insert_aux(begin() + __n,
					      std::move(__tmp._M_val()));
			}
		} else {
			_M_realloc_insert(begin() + __n,
					  std::forward<_Args>(__args)...);
		}
		return ((__gnu_cxx::__normal_iterator<
			 pointer, vector>)(((this->_M_impl)._M_start) + __n));
	}
	template <class _Tp, class _Alloc>
	template <class _Arg>
	void vector<_Tp, _Alloc>::_M_insert_aux(iterator __position,
						_Arg && __arg)
	{
		;
		_Alloc_traits::construct(
			(this->_M_impl), ((this->_M_impl)._M_finish),
			std::move(*(((this->_M_impl)._M_finish) - 1)));
		++((this->_M_impl)._M_finish);
		;
		std::move_backward(__position.base(),
				   ((this->_M_impl)._M_finish) - 2,
				   ((this->_M_impl)._M_finish) - 1);
		(*__position) = std::forward<_Arg>(__arg);
	}
	template <class _Tp, class _Alloc>
	template <class... _Args>
	void vector<_Tp, _Alloc>::_M_realloc_insert(iterator __position,
						    _Args && ...__args)
	{
		const size_type __len =
			_M_check_len((size_type)1, "vector::_M_realloc_insert");
		pointer __old_start = (((this->_M_impl)._M_start));
		pointer __old_finish = (((this->_M_impl)._M_finish));
		const size_type __elems_before = __position - begin();
		pointer __new_start(this->_M_allocate(__len));
		pointer __new_finish(__new_start);
		try {
			_Alloc_traits::construct(
				(this->_M_impl), __new_start + __elems_before,
				std::forward<_Args>(__args)...);
			__new_finish = pointer();
			if constexpr ((_S_use_relocate)()) {
				__new_finish =
					(_S_relocate)(__old_start,
						      __position.base(),
						      __new_start,
						      _M_get_Tp_allocator());
				++__new_finish;
				__new_finish =
					(_S_relocate)(__position.base(),
						      __old_finish,
						      __new_finish,
						      _M_get_Tp_allocator());
			} else {
				__new_finish =
					std::__uninitialized_move_if_noexcept_a(
						__old_start, __position.base(),
						__new_start,
						_M_get_Tp_allocator());
				++__new_finish;
				__new_finish =
					std::__uninitialized_move_if_noexcept_a(
						__position.base(), __old_finish,
						__new_finish,
						_M_get_Tp_allocator());
			}
		} catch (...) {
			if (!__new_finish) {
				_Alloc_traits::destroy((this->_M_impl),
						       __new_start +
							       __elems_before);
			} else {
				std::_Destroy(__new_start, __new_finish,
					      _M_get_Tp_allocator());
			}
			_M_deallocate(__new_start, __len);
			throw;
		}
		if constexpr (!(_S_use_relocate)()) {
			std::_Destroy(__old_start, __old_finish,
				      _M_get_Tp_allocator());
		};
		_M_deallocate(__old_start, ((this->_M_impl)._M_end_of_storage) -
						   __old_start);
		((this->_M_impl)._M_start) = __new_start;
		((this->_M_impl)._M_finish) = __new_finish;
		((this->_M_impl)._M_end_of_storage) = (__new_start + __len);
	}
	template <class _Tp, class _Alloc>
	void vector<_Tp, _Alloc>::_M_fill_insert(
		iterator __position, size_type __n, const value_type &__x)
	{
		if (__n != (0)) {
			if (((size_type)(((this->_M_impl)._M_end_of_storage) -
					 ((this->_M_impl)._M_finish))) >= __n) {
				_Temporary_value __tmp(this, __x);
				value_type &__x_copy = __tmp._M_val();
				const size_type __elems_after =
					end() - __position;
				pointer __old_finish(
					((this->_M_impl)._M_finish));
				if (__elems_after > __n) {
					;
					std::__uninitialized_move_a(
						((this->_M_impl)._M_finish) -
							__n,
						((this->_M_impl)._M_finish),
						((this->_M_impl)._M_finish),
						_M_get_Tp_allocator());
					((this->_M_impl)._M_finish) += __n;
					;
					std::move_backward(__position.base(),
							   __old_finish - __n,
							   __old_finish);
					std::fill(__position.base(),
						  __position.base() + __n,
						  __x_copy);
				} else {
					;
					((this->_M_impl)._M_finish) =
						std::__uninitialized_fill_n_a(
							((this->_M_impl)
								 ._M_finish),
							__n - __elems_after,
							__x_copy,
							_M_get_Tp_allocator());
					;
					std::__uninitialized_move_a(
						__position.base(), __old_finish,
						((this->_M_impl)._M_finish),
						_M_get_Tp_allocator());
					((this->_M_impl)._M_finish) +=
						__elems_after;
					;
					std::fill(__position.base(),
						  __old_finish, __x_copy);
				}
			} else {
				const size_type __len = _M_check_len(
					__n, "vector::_M_fill_insert");
				const size_type __elems_before =
					__position - begin();
				pointer __new_start(this->_M_allocate(__len));
				pointer __new_finish(__new_start);
				try {
					std::__uninitialized_fill_n_a(
						__new_start + __elems_before,
						__n, __x,
						_M_get_Tp_allocator());
					__new_finish = pointer();
					__new_finish = std::
						__uninitialized_move_if_noexcept_a(
							((this->_M_impl)
								 ._M_start),
							__position.base(),
							__new_start,
							_M_get_Tp_allocator());
					__new_finish += __n;
					__new_finish = std::
						__uninitialized_move_if_noexcept_a(
							__position.base(),
							((this->_M_impl)
								 ._M_finish),
							__new_finish,
							_M_get_Tp_allocator());
				} catch (...) {
					if (!__new_finish) {
						std::_Destroy(
							__new_start +
								__elems_before,
							(__new_start +
							 __elems_before) +
								__n,
							_M_get_Tp_allocator());
					} else {
						std::_Destroy(
							__new_start,
							__new_finish,
							_M_get_Tp_allocator());
					}
					_M_deallocate(__new_start, __len);
					throw;
				}
				std::_Destroy(((this->_M_impl)._M_start),
					      ((this->_M_impl)._M_finish),
					      _M_get_Tp_allocator());
				;
				_M_deallocate(
					((this->_M_impl)._M_start),
					((this->_M_impl)._M_end_of_storage) -
						((this->_M_impl)._M_start));
				((this->_M_impl)._M_start) = __new_start;
				((this->_M_impl)._M_finish) = __new_finish;
				((this->_M_impl)._M_end_of_storage) =
					(__new_start + __len);
			}
		}
	}
	template <class _Tp, class _Alloc>
	void vector<_Tp, _Alloc>::_M_default_append(size_type __n)
	{
		if (__n != (0)) {
			const size_type __size = size();
			size_type __navail =
				(size_type)(((this->_M_impl)._M_end_of_storage) -
					    ((this->_M_impl)._M_finish));
			if ((__size > max_size()) ||
			    (__navail > (max_size() - __size))) {
				__builtin_unreachable();
			}
			if (__navail >= __n) {
				;
				((this->_M_impl)._M_finish) =
					std::__uninitialized_default_n_a(
						((this->_M_impl)._M_finish),
						__n, _M_get_Tp_allocator());
				;
			} else {
				const size_type __len = _M_check_len(
					__n, "vector::_M_default_append");
				pointer __new_start(this->_M_allocate(__len));
				if constexpr ((_S_use_relocate)()) {
					try {
						std::__uninitialized_default_n_a(
							__new_start + __size,
							__n,
							_M_get_Tp_allocator());
					} catch (...) {
						_M_deallocate(__new_start,
							      __len);
						throw;
					}
					(_S_relocate)(
						((this->_M_impl)._M_start),
						((this->_M_impl)._M_finish),
						__new_start,
						_M_get_Tp_allocator());
				} else {
					pointer __destroy_from = pointer();
					try {
						std::__uninitialized_default_n_a(
							__new_start + __size,
							__n,
							_M_get_Tp_allocator());
						__destroy_from =
							(__new_start + __size);
						std::__uninitialized_move_if_noexcept_a(
							((this->_M_impl)
								 ._M_start),
							((this->_M_impl)
								 ._M_finish),
							__new_start,
							_M_get_Tp_allocator());
					} catch (...) {
						if (__destroy_from) {
							std::_Destroy(
								__destroy_from,
								__destroy_from +
									__n,
								_M_get_Tp_allocator());
						}
						_M_deallocate(__new_start,
							      __len);
						throw;
					}
					std::_Destroy(
						((this->_M_impl)._M_start),
						((this->_M_impl)._M_finish),
						_M_get_Tp_allocator());
				};
				_M_deallocate(
					((this->_M_impl)._M_start),
					((this->_M_impl)._M_end_of_storage) -
						((this->_M_impl)._M_start));
				((this->_M_impl)._M_start) = __new_start;
				((this->_M_impl)._M_finish) =
					((__new_start + __size) + __n);
				((this->_M_impl)._M_end_of_storage) =
					(__new_start + __len);
			}
		}
	}
	template <class _Tp, class _Alloc>
	bool vector<_Tp, _Alloc>::_M_shrink_to_fit()
	{
		if (capacity() == size()) {
			return false;
		};
		return std::template __shrink_to_fit_aux<vector>::_S_do_it(
			*this);
	}
	template <class _Tp, class _Alloc>
	template <class _InputIterator>
	void vector<_Tp, _Alloc>::_M_range_insert(iterator __pos,
						  _InputIterator __first,
						  _InputIterator __last,
						  std::input_iterator_tag)
	{
		if (__pos == end()) {
			for (; __first != __last; ++__first) {
				insert(end(), *__first);
			}
		} else {
			if (__first != __last) {
				vector __tmp(__first, __last,
					     _M_get_Tp_allocator());
				insert(__pos,
				       std::make_move_iterator(__tmp.begin()),
				       std::make_move_iterator(__tmp.end()));
			}
		}
	}
	template <class _Tp, class _Alloc>
	template <class _ForwardIterator>
	void vector<_Tp, _Alloc>::_M_range_insert(iterator __position,
						  _ForwardIterator __first,
						  _ForwardIterator __last,
						  std::forward_iterator_tag)
	{
		if (__first != __last) {
			const size_type __n = std::distance(__first, __last);
			if (((size_type)(((this->_M_impl)._M_end_of_storage) -
					 ((this->_M_impl)._M_finish))) >= __n) {
				const size_type __elems_after =
					end() - __position;
				pointer __old_finish(
					((this->_M_impl)._M_finish));
				if (__elems_after > __n) {
					;
					std::__uninitialized_move_a(
						((this->_M_impl)._M_finish) -
							__n,
						((this->_M_impl)._M_finish),
						((this->_M_impl)._M_finish),
						_M_get_Tp_allocator());
					((this->_M_impl)._M_finish) += __n;
					;
					std::move_backward(__position.base(),
							   __old_finish - __n,
							   __old_finish);
					std::copy(__first, __last, __position);
				} else {
					_ForwardIterator __mid = __first;
					std::advance(__mid, __elems_after);
					;
					std::__uninitialized_copy_a(
						__mid, __last,
						((this->_M_impl)._M_finish),
						_M_get_Tp_allocator());
					((this->_M_impl)._M_finish) +=
						(__n - __elems_after);
					;
					std::__uninitialized_move_a(
						__position.base(), __old_finish,
						((this->_M_impl)._M_finish),
						_M_get_Tp_allocator());
					((this->_M_impl)._M_finish) +=
						__elems_after;
					;
					std::copy(__first, __mid, __position);
				}
			} else {
				const size_type __len = _M_check_len(
					__n, "vector::_M_range_insert");
				pointer __new_start(this->_M_allocate(__len));
				pointer __new_finish(__new_start);
				try {
					__new_finish = std::
						__uninitialized_move_if_noexcept_a(
							((this->_M_impl)
								 ._M_start),
							__position.base(),
							__new_start,
							_M_get_Tp_allocator());
					__new_finish =
						std::__uninitialized_copy_a(
							__first, __last,
							__new_finish,
							_M_get_Tp_allocator());
					__new_finish = std::
						__uninitialized_move_if_noexcept_a(
							__position.base(),
							((this->_M_impl)
								 ._M_finish),
							__new_finish,
							_M_get_Tp_allocator());
				} catch (...) {
					std::_Destroy(__new_start, __new_finish,
						      _M_get_Tp_allocator());
					_M_deallocate(__new_start, __len);
					throw;
				}
				std::_Destroy(((this->_M_impl)._M_start),
					      ((this->_M_impl)._M_finish),
					      _M_get_Tp_allocator());
				;
				_M_deallocate(
					((this->_M_impl)._M_start),
					((this->_M_impl)._M_end_of_storage) -
						((this->_M_impl)._M_start));
				((this->_M_impl)._M_start) = __new_start;
				((this->_M_impl)._M_finish) = __new_finish;
				((this->_M_impl)._M_end_of_storage) =
					(__new_start + __len);
			}
		}
	}
	template <class _Alloc>
	void vector<bool, _Alloc>::_M_reallocate(size_type __n)
	{
		_Bit_pointer __q = this->_M_allocate(__n);
		iterator __start(std::__addressof(*__q), 0);
		iterator __finish(_M_copy_aligned(begin(), end(), __start));
		this->_M_deallocate();
		((this->_M_impl)._M_start) = __start;
		((this->_M_impl)._M_finish) = __finish;
		((this->_M_impl)._M_end_of_storage) = (__q + _S_nword(__n));
	}
	template <class _Alloc>
	void vector<bool, _Alloc>::_M_fill_insert(iterator __position,
						  size_type __n, bool __x)
	{
		if (__n == (0)) {
			return;
		}
		if ((capacity() - size()) >= __n) {
			std::copy_backward(__position, end(),
					   ((this->_M_impl)._M_finish) +
						   ((difference_type)__n));
			std::fill(__position,
				  (__position + ((difference_type)__n)), __x);
			((this->_M_impl)._M_finish) += ((difference_type)__n);
		} else {
			const size_type __len = _M_check_len(
				__n, "vector<bool>::_M_fill_insert");
			_Bit_pointer __q = this->_M_allocate(__len);
			iterator __start(std::__addressof(*__q), 0);
			iterator __i =
				_M_copy_aligned(begin(), __position, __start);
			std::fill(__i, (__i + ((difference_type)__n)), __x);
			iterator __finish =
				std::copy(__position, end(),
					  (__i + ((difference_type)__n)));
			this->_M_deallocate();
			((this->_M_impl)._M_end_of_storage) =
				(__q + _S_nword(__len));
			((this->_M_impl)._M_start) = __start;
			((this->_M_impl)._M_finish) = __finish;
		}
	}
	template <class _Alloc>
	template <class _ForwardIterator>
	void vector<bool, _Alloc>::_M_insert_range(iterator __position,
						   _ForwardIterator __first,
						   _ForwardIterator __last,
						   std::forward_iterator_tag)
	{
		if (__first != __last) {
			size_type __n = std::distance(__first, __last);
			if ((capacity() - size()) >= __n) {
				std::copy_backward(
					__position, end(),
					((this->_M_impl)._M_finish) +
						((difference_type)__n));
				std::copy(__first, __last, __position);
				((this->_M_impl)._M_finish) +=
					((difference_type)__n);
			} else {
				const size_type __len = _M_check_len(
					__n, "vector<bool>::_M_insert_range");
				_Bit_pointer __q = this->_M_allocate(__len);
				iterator __start(std::__addressof(*__q), 0);
				iterator __i = _M_copy_aligned(
					begin(), __position, __start);
				__i = std::copy(__first, __last, __i);
				iterator __finish =
					std::copy(__position, end(), __i);
				this->_M_deallocate();
				((this->_M_impl)._M_end_of_storage) =
					(__q + _S_nword(__len));
				((this->_M_impl)._M_start) = __start;
				((this->_M_impl)._M_finish) = __finish;
			}
		}
	}
	template <class _Alloc>
	void vector<bool, _Alloc>::_M_insert_aux(iterator __position, bool __x)
	{
		if ((((this->_M_impl)._M_finish)._M_p) !=
		    (this->_M_impl)._M_end_addr()) {
			std::copy_backward(__position,
					   ((this->_M_impl)._M_finish),
					   ((this->_M_impl)._M_finish) + 1);
			(((*__position)) = __x);
			++((this->_M_impl)._M_finish);
		} else {
			const size_type __len = _M_check_len(
				(size_type)1, "vector<bool>::_M_insert_aux");
			_Bit_pointer __q = this->_M_allocate(__len);
			iterator __start(std::__addressof(*__q), 0);
			iterator __i =
				_M_copy_aligned(begin(), __position, __start);
			(((*(__i++))) = __x);
			iterator __finish = std::copy(__position, end(), __i);
			this->_M_deallocate();
			((this->_M_impl)._M_end_of_storage) =
				(__q + _S_nword(__len));
			((this->_M_impl)._M_start) = __start;
			((this->_M_impl)._M_finish) = __finish;
		}
	}
	template <class _Alloc>
	typename vector<bool, _Alloc>::iterator vector<bool, _Alloc>::_M_erase(
		iterator __position)
	{
		if ((__position + (1)) != end()) {
			std::copy((__position + (1)), end(), __position);
		}
		--((this->_M_impl)._M_finish);
		return __position;
	}
	template <class _Alloc>
	typename vector<bool, _Alloc>::iterator vector<bool, _Alloc>::_M_erase(
		iterator __first, iterator __last)
	{
		if ((__first != __last)) {
			_M_erase_at_end(std::copy(__last, end(), __first));
		}
		return __first;
	}
	template <class _Alloc> bool vector<bool, _Alloc>::_M_shrink_to_fit()
	{
		if ((capacity() - size()) < ((int)_S_word_bit)) {
			return false;
		}
		try {
			if (size_type __n = size()) {
				_M_reallocate(__n);
			} else {
				this->_M_deallocate();
				(this->_M_impl)._M_reset();
			}
			return true;
		} catch (...) {
			return false;
		}
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _Alloc>
	size_t hash<vector<bool, _Alloc>>::operator()(
		const vector<bool, _Alloc> &__b) const noexcept
	{
		std::size_t __hash = (0);
		const std::size_t __words = __b.size() / _S_word_bit;
		if (__words) {
			const std::size_t __clength =
				(__words * sizeof(std::_Bit_type));
			__hash = std::_Hash_impl::hash(
				(((__b._M_impl)._M_start)._M_p), __clength);
		}
		const std::size_t __extrabits = __b.size() % _S_word_bit;
		if (__extrabits) {
			std::_Bit_type __hiword =
				(*(((__b._M_impl)._M_finish)._M_p));
			__hiword &= (~((~(static_cast<std::_Bit_type>(0)))
				       << __extrabits));
			const std::size_t __clength =
				(((__extrabits + (8)) - (1)) / (8));
			if (__words) {
				__hash = std::_Hash_impl::hash(
					&__hiword, __clength, __hash);
			} else {
				__hash = std::_Hash_impl::hash(&__hiword,
							       __clength);
			}
		}
		return __hash;
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	namespace pmr
	{
	template <class _Tp> class polymorphic_allocator;
	template <class _Tp>
	using vector = std::vector<_Tp, polymorphic_allocator<_Tp>>;
	} // namespace pmr
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _CharT> struct char_traits;
	template <> struct char_traits<char>;
	template <> struct char_traits<wchar_t>;
	template <> struct char_traits<char16_t>;
	template <> struct char_traits<char32_t>;
	inline namespace __cxx11
	{
	template <class _CharT, class _Traits = char_traits<_CharT>,
		  class _Alloc = allocator<_CharT>>
	class basic_string;
	}
	typedef __cxx11::basic_string<char> string;
	typedef __cxx11::basic_string<wchar_t> wstring;
	typedef __cxx11::basic_string<char16_t> u16string;
	typedef __cxx11::basic_string<char32_t> u32string;
} // namespace )
typedef unsigned wint_t;
typedef __mbstate_t mbstate_t;
extern "C" {
struct tm;
extern wchar_t *wcscpy(wchar_t *__restrict__ __dest,
		       const wchar_t *__restrict__ __src) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern wchar_t *wcsncpy(wchar_t *__restrict__ __dest,
			const wchar_t *__restrict__ __src,
			size_t __n) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern wchar_t *wcscat(wchar_t *__restrict__ __dest,
		       const wchar_t *__restrict__ __src) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern wchar_t *wcsncat(wchar_t *__restrict__ __dest,
			const wchar_t *__restrict__ __src,
			size_t __n) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int wcscmp(const wchar_t *__s1, const wchar_t *__s2) noexcept(true)
	__attribute((__pure__)) __attribute((__nonnull__(1, 2)));
extern int wcsncmp(const wchar_t *__s1, const wchar_t *__s2,
		   size_t __n) noexcept(true) __attribute((__pure__))
__attribute((__nonnull__(1, 2)));
extern int wcscasecmp(const wchar_t *__s1, const wchar_t *__s2) noexcept(true);
extern int wcsncasecmp(const wchar_t *__s1, const wchar_t *__s2,
		       size_t __n) noexcept(true);
extern int wcscasecmp_l(const wchar_t *__s1, const wchar_t *__s2,
			locale_t __loc) noexcept(true);
extern int wcsncasecmp_l(const wchar_t *__s1, const wchar_t *__s2, size_t __n,
			 locale_t __loc) noexcept(true);
extern int wcscoll(const wchar_t *__s1, const wchar_t *__s2) noexcept(true);
extern size_t wcsxfrm(wchar_t *__restrict__ __s1,
		      const wchar_t *__restrict__ __s2,
		      size_t __n) noexcept(true);
extern int wcscoll_l(const wchar_t *__s1, const wchar_t *__s2,
		     locale_t __loc) noexcept(true);
extern size_t wcsxfrm_l(wchar_t *__s1, const wchar_t *__s2, size_t __n,
			locale_t __loc) noexcept(true);
extern wchar_t *wcsdup(const wchar_t *__s) noexcept(true)
	__attribute((__malloc__)) __attribute((__malloc__(__builtin_free, 1)));
extern "C++" wchar_t *wcschr(wchar_t *__wcs,
			     wchar_t __wc) noexcept(true) __asm__("wcschr")
	__attribute((__pure__));
extern "C++" const wchar_t *
wcschr(const wchar_t *__wcs, wchar_t __wc) noexcept(true) __asm__("wcschr")
	__attribute((__pure__));
extern "C++" wchar_t *wcsrchr(wchar_t *__wcs,
			      wchar_t __wc) noexcept(true) __asm__("wcsrchr")
	__attribute((__pure__));
extern "C++" const wchar_t *
wcsrchr(const wchar_t *__wcs, wchar_t __wc) noexcept(true) __asm__("wcsrchr")
	__attribute((__pure__));
extern wchar_t *wcschrnul(const wchar_t *__s, wchar_t __wc) noexcept(true)
	__attribute((__pure__));
extern size_t wcscspn(const wchar_t *__wcs,
		      const wchar_t *__reject) noexcept(true)
	__attribute((__pure__));
extern size_t wcsspn(const wchar_t *__wcs,
		     const wchar_t *__accept) noexcept(true)
	__attribute((__pure__));
extern "C++" wchar_t *wcspbrk(wchar_t *__wcs, const wchar_t *__accept) noexcept(
	true) __asm__("wcspbrk") __attribute((__pure__));
extern "C++" const wchar_t *
wcspbrk(const wchar_t *__wcs,
	const wchar_t *__accept) noexcept(true) __asm__("wcspbrk")
	__attribute((__pure__));
extern "C++" wchar_t *
wcsstr(wchar_t *__haystack,
       const wchar_t *__needle) noexcept(true) __asm__("wcsstr")
	__attribute((__pure__));
extern "C++" const wchar_t *
wcsstr(const wchar_t *__haystack,
       const wchar_t *__needle) noexcept(true) __asm__("wcsstr")
	__attribute((__pure__));
extern wchar_t *wcstok(wchar_t *__restrict__ __s,
		       const wchar_t *__restrict__ __delim,
		       wchar_t **__restrict__ __ptr) noexcept(true);
extern size_t wcslen(const wchar_t *__s) noexcept(true) __attribute((__pure__));
extern "C++" wchar_t *
wcswcs(wchar_t *__haystack,
       const wchar_t *__needle) noexcept(true) __asm__("wcswcs")
	__attribute((__pure__));
extern "C++" const wchar_t *
wcswcs(const wchar_t *__haystack,
       const wchar_t *__needle) noexcept(true) __asm__("wcswcs")
	__attribute((__pure__));
extern size_t wcsnlen(const wchar_t *__s, size_t __maxlen) noexcept(true)
	__attribute((__pure__));
extern "C++" wchar_t *wmemchr(wchar_t *__s, wchar_t __c,
			      size_t __n) noexcept(true) __asm__("wmemchr")
	__attribute((__pure__));
extern "C++" const wchar_t *
wmemchr(const wchar_t *__s, wchar_t __c,
	size_t __n) noexcept(true) __asm__("wmemchr") __attribute((__pure__));
extern int wmemcmp(const wchar_t *__s1, const wchar_t *__s2,
		   size_t __n) noexcept(true) __attribute((__pure__));
extern wchar_t *wmemcpy(wchar_t *__restrict__ __s1,
			const wchar_t *__restrict__ __s2,
			size_t __n) noexcept(true);
extern wchar_t *wmemmove(wchar_t *__s1, const wchar_t *__s2,
			 size_t __n) noexcept(true);
extern wchar_t *wmemset(wchar_t *__s, wchar_t __c, size_t __n) noexcept(true);
extern wchar_t *wmempcpy(wchar_t *__restrict__ __s1,
			 const wchar_t *__restrict__ __s2,
			 size_t __n) noexcept(true);
extern wint_t btowc(int __c) noexcept(true);
extern int wctob(wint_t __c) noexcept(true);
extern int mbsinit(const mbstate_t *__ps) noexcept(true)
	__attribute((__pure__));
extern size_t mbrtowc(wchar_t *__restrict__ __pwc, const char *__restrict__ __s,
		      size_t __n, mbstate_t *__restrict__ __p) noexcept(true);
extern size_t wcrtomb(char *__restrict__ __s, wchar_t __wc,
		      mbstate_t *__restrict__ __ps) noexcept(true);
extern size_t __mbrlen(const char *__restrict__ __s, size_t __n,
		       mbstate_t *__restrict__ __ps) noexcept(true);
extern size_t mbrlen(const char *__restrict__ __s, size_t __n,
		     mbstate_t *__restrict__ __ps) noexcept(true);
extern size_t mbsrtowcs(wchar_t *__restrict__ __dst,
			const char **__restrict__ __src, size_t __len,
			mbstate_t *__restrict__ __ps) noexcept(true);
extern size_t wcsrtombs(char *__restrict__ __dst,
			const wchar_t **__restrict__ __src, size_t __len,
			mbstate_t *__restrict__ __ps) noexcept(true);
extern size_t mbsnrtowcs(wchar_t *__restrict__ __dst,
			 const char **__restrict__ __src, size_t __nmc,
			 size_t __len,
			 mbstate_t *__restrict__ __ps) noexcept(true);
extern size_t wcsnrtombs(char *__restrict__ __dst,
			 const wchar_t **__restrict__ __src, size_t __nwc,
			 size_t __len,
			 mbstate_t *__restrict__ __ps) noexcept(true);
extern int wcwidth(wchar_t __c) noexcept(true);
extern int wcswidth(const wchar_t *__s, size_t __n) noexcept(true);
extern double wcstod(const wchar_t *__restrict__ __nptr,
		     wchar_t **__restrict__ __endptr) noexcept(true);
extern float wcstof(const wchar_t *__restrict__ __nptr,
		    wchar_t **__restrict__ __endptr) noexcept(true);
extern long double wcstold(const wchar_t *__restrict__ __nptr,
			   wchar_t **__restrict__ __endptr) noexcept(true);
extern _Float32 wcstof32(const wchar_t *__restrict__ __nptr,
			 wchar_t **__restrict__ __endptr) noexcept(true);
extern _Float64 wcstof64(const wchar_t *__restrict__ __nptr,
			 wchar_t **__restrict__ __endptr) noexcept(true);
extern _Float32x wcstof32x(const wchar_t *__restrict__ __nptr,
			   wchar_t **__restrict__ __endptr) noexcept(true);
extern _Float64x wcstof64x(const wchar_t *__restrict__ __nptr,
			   wchar_t **__restrict__ __endptr) noexcept(true);
extern long wcstol(const wchar_t *__restrict__ __nptr,
		   wchar_t **__restrict__ __endptr, int __base) noexcept(true);
extern unsigned long wcstoul(const wchar_t *__restrict__ __nptr,
			     wchar_t **__restrict__ __endptr,
			     int __base) noexcept(true);
__extension__ extern long long wcstoll(const wchar_t *__restrict__ __nptr,
				       wchar_t **__restrict__ __endptr,
				       int __base) noexcept(true);
__extension__ extern unsigned long long
wcstoull(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr,
	 int __base) noexcept(true);
__extension__ extern long long wcstoq(const wchar_t *__restrict__ __nptr,
				      wchar_t **__restrict__ __endptr,
				      int __base) noexcept(true);
__extension__ extern unsigned long long
wcstouq(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr,
	int __base) noexcept(true);
extern long wcstol_l(const wchar_t *__restrict__ __nptr,
		     wchar_t **__restrict__ __endptr, int __base,
		     locale_t __loc) noexcept(true);
extern unsigned long wcstoul_l(const wchar_t *__restrict__ __nptr,
			       wchar_t **__restrict__ __endptr, int __base,
			       locale_t __loc) noexcept(true);
__extension__ extern long long wcstoll_l(const wchar_t *__restrict__ __nptr,
					 wchar_t **__restrict__ __endptr,
					 int __base,
					 locale_t __loc) noexcept(true);
__extension__ extern unsigned long long
wcstoull_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr,
	   int __base, locale_t __loc) noexcept(true);
extern double wcstod_l(const wchar_t *__restrict__ __nptr,
		       wchar_t **__restrict__ __endptr,
		       locale_t __loc) noexcept(true);
extern float wcstof_l(const wchar_t *__restrict__ __nptr,
		      wchar_t **__restrict__ __endptr,
		      locale_t __loc) noexcept(true);
extern long double wcstold_l(const wchar_t *__restrict__ __nptr,
			     wchar_t **__restrict__ __endptr,
			     locale_t __loc) noexcept(true);
extern _Float32 wcstof32_l(const wchar_t *__restrict__ __nptr,
			   wchar_t **__restrict__ __endptr,
			   locale_t __loc) noexcept(true);
extern _Float64 wcstof64_l(const wchar_t *__restrict__ __nptr,
			   wchar_t **__restrict__ __endptr,
			   locale_t __loc) noexcept(true);
extern _Float32x wcstof32x_l(const wchar_t *__restrict__ __nptr,
			     wchar_t **__restrict__ __endptr,
			     locale_t __loc) noexcept(true);
extern _Float64x wcstof64x_l(const wchar_t *__restrict__ __nptr,
			     wchar_t **__restrict__ __endptr,
			     locale_t __loc) noexcept(true);
extern wchar_t *wcpcpy(wchar_t *__restrict__ __dest,
		       const wchar_t *__restrict__ __src) noexcept(true);
extern wchar_t *wcpncpy(wchar_t *__restrict__ __dest,
			const wchar_t *__restrict__ __src,
			size_t __n) noexcept(true);
extern __FILE *open_wmemstream(wchar_t **__bufloc,
			       size_t *__sizeloc) noexcept(true)
	__attribute((__malloc__)) __attribute((__malloc__(fclose, 1)));
extern int fwide(__FILE *__fp, int __mode) noexcept(true);
extern int fwprintf(__FILE *__restrict__ __stream,
		    const wchar_t *__restrict__ __format, ...);
extern int wprintf(const wchar_t *__restrict__ __format, ...);
extern int swprintf(wchar_t *__restrict__ __s, size_t __n,
		    const wchar_t *__restrict__ __format, ...) noexcept(true);
extern int vfwprintf(__FILE *__restrict__ __s,
		     const wchar_t *__restrict__ __format,
		     __gnuc_va_list __arg);
extern int vwprintf(const wchar_t *__restrict__ __format, __gnuc_va_list __arg);
extern int vswprintf(wchar_t *__restrict__ __s, size_t __n,
		     const wchar_t *__restrict__ __format,
		     __gnuc_va_list __arg) noexcept(true);
extern int fwscanf(__FILE *__restrict__ __stream,
		   const wchar_t *__restrict__ __format,
		   ...) __asm__("__isoc99_fwscanf");
extern int wscanf(const wchar_t *__restrict__ __format,
		  ...) __asm__("__isoc99_wscanf");
extern int swscanf(const wchar_t *__restrict__ __s,
		   const wchar_t *__restrict__ __format,
		   ...) noexcept(true) __asm__("__isoc99_swscanf");
extern int fwscanf(__FILE *__restrict__ __stream,
		   const wchar_t *__restrict__ __format,
		   ...) __asm__("__isoc99_fwscanf");
extern int wscanf(const wchar_t *__restrict__ __format,
		  ...) __asm__("__isoc99_wscanf");
extern int swscanf(const wchar_t *__restrict__ __s,
		   const wchar_t *__restrict__ __format,
		   ...) noexcept(true) __asm__("__isoc99_swscanf");
extern int vfwscanf(__FILE *__restrict__ __s,
		    const wchar_t *__restrict__ __format,
		    __gnuc_va_list __arg) __asm__("__isoc99_vfwscanf");
extern int vwscanf(const wchar_t *__restrict__ __format,
		   __gnuc_va_list __arg) __asm__("__isoc99_vwscanf");
extern int
vswscanf(const wchar_t *__restrict__ __s, const wchar_t *__restrict__ __format,
	 __gnuc_va_list __arg) noexcept(true) __asm__("__isoc99_vswscanf");
extern int vfwscanf(__FILE *__restrict__ __s,
		    const wchar_t *__restrict__ __format,
		    __gnuc_va_list __arg) __asm__("__isoc99_vfwscanf");
extern int vwscanf(const wchar_t *__restrict__ __format,
		   __gnuc_va_list __arg) __asm__("__isoc99_vwscanf");
extern int
vswscanf(const wchar_t *__restrict__ __s, const wchar_t *__restrict__ __format,
	 __gnuc_va_list __arg) noexcept(true) __asm__("__isoc99_vswscanf");
extern wint_t fgetwc(__FILE *__stream);
extern wint_t getwc(__FILE *__stream);
extern wint_t getwchar();
extern wint_t fputwc(wchar_t __wc, __FILE *__stream);
extern wint_t putwc(wchar_t __wc, __FILE *__stream);
extern wint_t putwchar(wchar_t __wc);
extern wchar_t *fgetws(wchar_t *__restrict__ __ws, int __n,
		       __FILE *__restrict__ __stream);
extern int fputws(const wchar_t *__restrict__ __ws,
		  __FILE *__restrict__ __stream);
extern wint_t ungetwc(wint_t __wc, __FILE *__stream);
extern wint_t getwc_unlocked(__FILE *__stream);
extern wint_t getwchar_unlocked();
extern wint_t fgetwc_unlocked(__FILE *__stream);
extern wint_t fputwc_unlocked(wchar_t __wc, __FILE *__stream);
extern wint_t putwc_unlocked(wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked(wchar_t __wc);
extern wchar_t *fgetws_unlocked(wchar_t *__restrict__ __ws, int __n,
				__FILE *__restrict__ __stream);
extern int fputws_unlocked(const wchar_t *__restrict__ __ws,
			   __FILE *__restrict__ __stream);
extern size_t wcsftime(wchar_t *__restrict__ __s, size_t __maxsize,
		       const wchar_t *__restrict__ __format,
		       const tm *__restrict__ __tp) noexcept(true);
extern size_t wcsftime_l(wchar_t *__restrict__ __s, size_t __maxsize,
			 const wchar_t *__restrict__ __format,
			 const tm *__restrict__ __tp,
			 locale_t __loc) noexcept(true);
}
namespace std
{
using ::mbstate_t;
}
extern "C++" {
namespace std __attribute((__visibility__("default")))
{
	using ::btowc;
	using ::fgetwc;
	using ::fgetws;
	using ::fputwc;
	using ::fputws;
	using ::fwide;
	using ::fwprintf;
	using ::fwscanf;
	using ::getwc;
	using ::getwchar;
	using ::mbrlen;
	using ::mbrtowc;
	using ::mbsinit;
	using ::mbsrtowcs;
	using ::putwc;
	using ::putwchar;
	using ::swprintf;
	using ::swscanf;
	using ::ungetwc;
	using ::vfwprintf;
	using ::vfwscanf;
	using ::vswprintf;
	using ::vswscanf;
	using ::vwprintf;
	using ::vwscanf;
	using ::wcrtomb;
	using ::wcscat;
	using ::wcschr;
	using ::wcscmp;
	using ::wcscoll;
	using ::wcscpy;
	using ::wcscspn;
	using ::wcsftime;
	using ::wcslen;
	using ::wcsncat;
	using ::wcsncmp;
	using ::wcsncpy;
	using ::wcspbrk;
	using ::wcsrchr;
	using ::wcsrtombs;
	using ::wcsspn;
	using ::wcsstr;
	using ::wcstod;
	using ::wcstof;
	using ::wcstok;
	using ::wcstol;
	using ::wcstoul;
	using ::wcsxfrm;
	using ::wctob;
	using ::wint_t;
	using ::wmemchr;
	using ::wmemcmp;
	using ::wmemcpy;
	using ::wmemmove;
	using ::wmemset;
	using ::wprintf;
	using ::wscanf;
} // namespace )
}
namespace __gnu_cxx
{
using ::wcstold;
using ::wcstoll;
using ::wcstoull;
} // namespace __gnu_cxx
namespace std
{
using __gnu_cxx::wcstold;
using __gnu_cxx::wcstoll;
using __gnu_cxx::wcstoull;
} // namespace std
namespace std
{
}
namespace std __attribute((__visibility__("default")))
{
	typedef long streamoff;
	typedef ptrdiff_t streamsize;
	template <class _StateT> class fpos {
		streamoff _M_off;
		_StateT _M_state;

	    public:
		fpos() : _M_off((0)), _M_state()
		{
		}
		fpos(streamoff __off) : _M_off(__off), _M_state()
		{
		}
		fpos(const fpos &) = default;
		fpos &operator=(const fpos &) = default;
		~fpos() = default;
		operator streamoff() const
		{
			return _M_off;
		}
		void state(_StateT __st)
		{
			(_M_state) = __st;
		}
		_StateT state() const
		{
			return _M_state;
		}
		fpos &operator+=(streamoff __off)
		{
			(_M_off) += __off;
			return *this;
		}
		fpos &operator-=(streamoff __off)
		{
			(_M_off) -= __off;
			return *this;
		}
		fpos operator+(streamoff __off) const
		{
			fpos __pos(*this);
			__pos += __off;
			return __pos;
		}
		fpos operator-(streamoff __off) const
		{
			fpos __pos(*this);
			__pos -= __off;
			return __pos;
		}
		streamoff operator-(const fpos &__other) const
		{
			return (_M_off) - (__other._M_off);
		}
	};
	template <class _StateT>
	inline bool operator==(const fpos<_StateT> &__lhs,
			       const fpos<_StateT> &__rhs)
	{
		return ((streamoff)__lhs) == ((streamoff)__rhs);
	}
	template <class _StateT>
	inline bool operator!=(const fpos<_StateT> &__lhs,
			       const fpos<_StateT> &__rhs)
	{
		return ((streamoff)__lhs) != ((streamoff)__rhs);
	}
	typedef fpos<__mbstate_t> streampos;
	typedef fpos<__mbstate_t> wstreampos;
	typedef fpos<__mbstate_t> u16streampos;
	typedef fpos<__mbstate_t> u32streampos;
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	class ios_base;
	template <class _CharT, class _Traits = char_traits<_CharT>>
	class basic_ios;
	template <class _CharT, class _Traits = char_traits<_CharT>>
	class basic_streambuf;
	template <class _CharT, class _Traits = char_traits<_CharT>>
	class basic_istream;
	template <class _CharT, class _Traits = char_traits<_CharT>>
	class basic_ostream;
	template <class _CharT, class _Traits = char_traits<_CharT>>
	class basic_iostream;
	inline namespace __cxx11
	{
	template <class _CharT, class _Traits = char_traits<_CharT>,
		  class _Alloc = allocator<_CharT>>
	class basic_stringbuf;
	template <class _CharT, class _Traits = char_traits<_CharT>,
		  class _Alloc = allocator<_CharT>>
	class basic_istringstream;
	template <class _CharT, class _Traits = char_traits<_CharT>,
		  class _Alloc = allocator<_CharT>>
	class basic_ostringstream;
	template <class _CharT, class _Traits = char_traits<_CharT>,
		  class _Alloc = allocator<_CharT>>
	class basic_stringstream;
	} // namespace __cxx11
	template <class _CharT, class _Traits = char_traits<_CharT>>
	class basic_filebuf;
	template <class _CharT, class _Traits = char_traits<_CharT>>
	class basic_ifstream;
	template <class _CharT, class _Traits = char_traits<_CharT>>
	class basic_ofstream;
	template <class _CharT, class _Traits = char_traits<_CharT>>
	class basic_fstream;
	template <class _CharT, class _Traits = char_traits<_CharT>>
	class istreambuf_iterator;
	template <class _CharT, class _Traits = char_traits<_CharT>>
	class ostreambuf_iterator;
	typedef basic_ios<char> ios;
	typedef basic_streambuf<char> streambuf;
	typedef basic_istream<char> istream;
	typedef basic_ostream<char> ostream;
	typedef basic_iostream<char> iostream;
	typedef __cxx11::basic_stringbuf<char> stringbuf;
	typedef __cxx11::basic_istringstream<char> istringstream;
	typedef __cxx11::basic_ostringstream<char> ostringstream;
	typedef __cxx11::basic_stringstream<char> stringstream;
	typedef basic_filebuf<char> filebuf;
	typedef basic_ifstream<char> ifstream;
	typedef basic_ofstream<char> ofstream;
	typedef basic_fstream<char> fstream;
	typedef basic_ios<wchar_t> wios;
	typedef basic_streambuf<wchar_t> wstreambuf;
	typedef basic_istream<wchar_t> wistream;
	typedef basic_ostream<wchar_t> wostream;
	typedef basic_iostream<wchar_t> wiostream;
	typedef __cxx11::basic_stringbuf<wchar_t> wstringbuf;
	typedef __cxx11::basic_istringstream<wchar_t> wistringstream;
	typedef __cxx11::basic_ostringstream<wchar_t> wostringstream;
	typedef __cxx11::basic_stringstream<wchar_t> wstringstream;
	typedef basic_filebuf<wchar_t> wfilebuf;
	typedef basic_ifstream<wchar_t> wifstream;
	typedef basic_ofstream<wchar_t> wofstream;
	typedef basic_fstream<wchar_t> wfstream;
} // namespace )
extern "C++" {
namespace std
{
class bad_exception : public exception {
    public:
	bad_exception() noexcept
	{
	}
	virtual ~bad_exception() noexcept;
	virtual const char *what() const noexcept;
};
typedef void (*terminate_handler)(void);
terminate_handler set_terminate(terminate_handler) noexcept;
terminate_handler get_terminate() noexcept;
void terminate() noexcept __attribute((__noreturn__));
typedef void (*unexpected_handler)(void) __attribute((__deprecated__));
__attribute((__deprecated__))
unexpected_handler set_unexpected(unexpected_handler) noexcept;
__attribute((__deprecated__)) unexpected_handler get_unexpected() noexcept;
__attribute((__deprecated__)) void unexpected() __attribute((__noreturn__));
__attribute((__deprecated__("use \'std::uncaught_exceptions()\' instead"))) bool
uncaught_exception() noexcept __attribute((__pure__));
int uncaught_exceptions() noexcept __attribute((__pure__));
} // namespace std
namespace __gnu_cxx
{
void __verbose_terminate_handler();
}
}
namespace std
{
class type_info;
}
namespace __cxxabiv1
{
struct __cxa_refcounted_exception;
extern "C" {
void *__cxa_allocate_exception(size_t) noexcept;
void __cxa_free_exception(void *) noexcept;
__cxa_refcounted_exception *
__cxa_init_primary_exception(void *object, std::type_info *tinfo,
			     void (*dest)(void *)) noexcept;
}
} // namespace __cxxabiv1
extern "C++" {
namespace __cxxabiv1
{
class __class_type_info;
}
namespace std
{
class type_info {
    public:
	virtual ~type_info();
	const char *name() const noexcept
	{
		return (((__name)[0]) == ('*')) ? (__name) + 1 : (__name);
	}
	inline bool before(const type_info &__arg) const noexcept;
	inline bool operator==(const type_info &__arg) const noexcept;
	bool operator!=(const type_info &__arg) const noexcept
	{
		return !this->operator==(__arg);
	}
	size_t hash_code() const noexcept
	{
		return _Hash_bytes(this->name(), __builtin_strlen(this->name()),
				   static_cast<size_t>(3339675911UL));
	}
	virtual bool __is_pointer_p() const;
	virtual bool __is_function_p() const;
	virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
				unsigned __outer) const;
	virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
				 void **__obj_ptr) const;

    protected:
	const char *__name;
	explicit type_info(const char *__n) : __name(__n)
	{
	}

    private:
	type_info &operator=(const type_info &) = delete;
	type_info(const type_info &) = delete;
};
inline bool type_info::before(const type_info &__arg) const noexcept
{
	if ((((__name)[0]) != ('*')) || (((__arg.__name)[0]) != ('*'))) {
		return __builtin_strcmp(__name, __arg.__name) < 0;
	}
	return (__name) < (__arg.__name);
}
inline bool type_info::operator==(const type_info &__arg) const noexcept
{
	if (std::__is_constant_evaluated()) {
		return this == (&__arg);
	}
	if ((__name) == (__arg.__name)) {
		return true;
	}
	return (((__name)[0]) != ('*')) &&
	       (__builtin_strcmp(__name, __arg.name()) == 0);
}
class bad_cast : public exception {
    public:
	bad_cast() noexcept
	{
	}
	virtual ~bad_cast() noexcept;
	virtual const char *what() const noexcept;
};
class bad_typeid : public exception {
    public:
	bad_typeid() noexcept
	{
	}
	virtual ~bad_typeid() noexcept;
	virtual const char *what() const noexcept;
};
} // namespace std
}
extern "C++" {
namespace std
{
class type_info;
namespace __exception_ptr
{
class exception_ptr;
}
using __exception_ptr::exception_ptr;
__exception_ptr::exception_ptr current_exception() noexcept;
template <class _Ex>
__exception_ptr::exception_ptr make_exception_ptr(_Ex) noexcept;
void rethrow_exception(__exception_ptr::exception_ptr)
	__attribute((__noreturn__));
namespace __exception_ptr
{
using std::rethrow_exception;
class exception_ptr {
	void *_M_exception_object;
	explicit exception_ptr(void *__e) noexcept;
	void _M_addref() noexcept;
	void _M_release() noexcept;
	void *_M_get() const noexcept __attribute((__pure__));
	friend exception_ptr std::current_exception() noexcept;
	friend void std::rethrow_exception(exception_ptr);
	template <class _Ex>
	friend exception_ptr std::make_exception_ptr(_Ex) noexcept;

    public:
	inline exception_ptr() noexcept;
	inline exception_ptr(const exception_ptr &) noexcept;
	exception_ptr(nullptr_t) noexcept : _M_exception_object((nullptr))
	{
	}
	exception_ptr(exception_ptr &&__o) noexcept
		: _M_exception_object(__o._M_exception_object)
	{
		(__o._M_exception_object) = (nullptr);
	}
	inline exception_ptr &operator=(const exception_ptr &) noexcept;
	exception_ptr &operator=(exception_ptr &&__o) noexcept
	{
		((exception_ptr)(static_cast<exception_ptr &&>(__o)))
			.swap(*this);
		return *this;
	}
	inline ~exception_ptr() noexcept;
	inline void swap(exception_ptr &) noexcept;
	explicit operator bool() const noexcept
	{
		return _M_exception_object;
	}
	friend inline bool operator==(const exception_ptr &__x,
				      const exception_ptr &__y) noexcept
	{
		return (__x._M_exception_object) == (__y._M_exception_object);
	}
	friend inline bool operator!=(const exception_ptr &__x,
				      const exception_ptr &__y) noexcept
	{
		return (__x._M_exception_object) != (__y._M_exception_object);
	}
	const type_info *__cxa_exception_type() const noexcept
		__attribute((__pure__));
};
inline exception_ptr::exception_ptr() noexcept : _M_exception_object((0))
{
}
inline exception_ptr::exception_ptr(const exception_ptr &__other) noexcept
	: _M_exception_object(__other._M_exception_object)
{
	if (_M_exception_object) {
		this->_M_addref();
	}
}
inline exception_ptr::~exception_ptr() noexcept
{
	if (_M_exception_object) {
		this->_M_release();
	}
}
inline exception_ptr &
exception_ptr::operator=(const exception_ptr &__other) noexcept
{
	((exception_ptr)(__other)).swap(*this);
	return *this;
}
inline void exception_ptr::swap(exception_ptr &__other) noexcept
{
	void *__tmp = _M_exception_object;
	(_M_exception_object) = (__other._M_exception_object);
	(__other._M_exception_object) = __tmp;
}
inline void swap(exception_ptr &__lhs, exception_ptr &__rhs)
{
	__lhs.swap(__rhs);
}
template <class _Ex> inline void __dest_thunk(void *__x)
{
	(static_cast<_Ex *>(__x))->~_Ex();
}
} // namespace __exception_ptr
template <class _Ex>
__exception_ptr::exception_ptr make_exception_ptr(_Ex __ex) noexcept
{
	using _Ex2 = typename decay<_Ex>::type;
	void *__e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
	(void)__cxxabiv1::__cxa_init_primary_exception(
		__e, const_cast<type_info *>(&typeid(_Ex)),
		__exception_ptr::__dest_thunk<typename decay<_Ex>::type>);
	try {
		::new (__e) _Ex2(__ex);
		return ((__exception_ptr::exception_ptr)(__e));
	} catch (...) {
		__cxxabiv1::__cxa_free_exception(__e);
		return current_exception();
	}
}
} // namespace std
}
extern "C++" {
namespace std
{
class nested_exception {
	__exception_ptr::exception_ptr _M_ptr;

    public:
	nested_exception() noexcept : _M_ptr(current_exception())
	{
	}
	nested_exception(const nested_exception &) noexcept = default;
	nested_exception &
	operator=(const nested_exception &) noexcept = default;
	virtual ~nested_exception() noexcept;
	[[noreturn]] void rethrow_nested() const
	{
		if ((_M_ptr)) {
			rethrow_exception(_M_ptr);
		}
		std::terminate();
	}
	__exception_ptr::exception_ptr nested_ptr() const noexcept
	{
		return _M_ptr;
	}
};
template <class _Except>
struct _Nested_exception : public _Except, public nested_exception {
	explicit _Nested_exception(const _Except &__ex) : _Except(__ex)
	{
	}
	explicit _Nested_exception(_Except &&__ex)
		: _Except(static_cast<_Except &&>(__ex))
	{
	}
};
template <class _Tp>
[[noreturn]] inline void __throw_with_nested_impl(_Tp &&__t, true_type)
{
	using _Up = typename remove_reference<_Tp>::type;
	throw _Nested_exception<typename remove_reference<_Tp>::type>{
		std::forward<_Tp>(__t)
	};
}
template <class _Tp>
[[noreturn]] inline void __throw_with_nested_impl(_Tp &&__t, false_type)
{
	throw std::forward<_Tp>(__t);
}
template <class _Tp> [[noreturn]] inline void throw_with_nested(_Tp &&__t)
{
	using _Up = typename decay<_Tp>::type;
	using _CopyConstructible =
		__and_<is_copy_constructible<typename decay<_Tp>::type>,
		       is_move_constructible<typename decay<_Tp>::type>>;
	static_assert((_CopyConstructible::value),
		      "throw_with_nested argument must be CopyConstructible");
	using __nest = __and_<
		is_class<typename decay<_Tp>::type>,
		__bool_constant<!__is_final(_Up)>,
		__not_<is_base_of<nested_exception, typename decay<_Tp>::type>>>;
	std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest{});
}
template <class _Tp>
using __rethrow_if_nested_cond = typename enable_if<
	__and_<is_polymorphic<_Tp>,
	       __or_<__not_<is_base_of<nested_exception, _Tp>>,
		     is_convertible<_Tp *, nested_exception *>>>::value>::type;
template <class _Ex>
inline __rethrow_if_nested_cond<_Ex> __rethrow_if_nested_impl(const _Ex *__ptr)
{
	if (auto __ne_ptr = dynamic_cast<const nested_exception *>(__ptr)) {
		__ne_ptr->rethrow_nested();
	}
}
inline void __rethrow_if_nested_impl(const void *)
{
}
template <class _Ex> inline void rethrow_if_nested(const _Ex &__ex)
{
	std::__rethrow_if_nested_impl(std::__addressof(__ex));
}
} // namespace std
}
namespace __gnu_cxx __attribute((__visibility__("default")))
{
	template <class _CharT> struct _Char_types {
		typedef unsigned long int_type;
		typedef std::streampos pos_type;
		typedef std::streamoff off_type;
		typedef mbstate_t state_type;
	};
	template <class _CharT> struct char_traits {
		typedef _CharT char_type;
		typedef typename _Char_types<_CharT>::int_type int_type;
		typedef typename _Char_types<_CharT>::pos_type pos_type;
		typedef typename _Char_types<_CharT>::off_type off_type;
		typedef typename _Char_types<_CharT>::state_type state_type;
		static constexpr void assign(char_type &__c1,
					     const char_type &__c2)
		{
			__c1 = __c2;
		}
		static constexpr bool eq(const char_type &__c1,
					 const char_type &__c2)
		{
			return __c1 == __c2;
		}
		static constexpr bool lt(const char_type &__c1,
					 const char_type &__c2)
		{
			return __c1 < __c2;
		}
		static constexpr int compare(const char_type *__s1,
					     const char_type *__s2,
					     std::size_t __n);
		static constexpr std::size_t length(const char_type *__s);
		static constexpr const char_type *find(const char_type *__s,
						       std::size_t __n,
						       const char_type &__a);
		static char_type *move(char_type *__s1, const char_type *__s2,
				       std::size_t __n);
		static char_type *copy(char_type *__s1, const char_type *__s2,
				       std::size_t __n);
		static char_type *assign(char_type *__s, std::size_t __n,
					 char_type __a);
		static constexpr char_type to_char_type(const int_type &__c)
		{
			return static_cast<char_type>(__c);
		}
		static constexpr int_type to_int_type(const char_type &__c)
		{
			return static_cast<int_type>(__c);
		}
		static constexpr bool eq_int_type(const int_type &__c1,
						  const int_type &__c2)
		{
			return __c1 == __c2;
		}
		static constexpr int_type eof()
		{
			return static_cast<int_type>(-1);
		}
		static constexpr int_type not_eof(const int_type &__c)
		{
			return (!(eq_int_type)(__c, (eof)())) ?
				       __c :
				       (to_int_type)(char_type());
		}
	};
	template <class _CharT>
	constexpr int char_traits<_CharT>::compare(
		const char_type *__s1, const char_type *__s2, std::size_t __n)
	{
		for (std::size_t __i = (0); __i < __n; ++__i) {
			if ((lt)(__s1[__i], __s2[__i])) {
				return -1;
			} else {
				if ((lt)(__s2[__i], __s1[__i])) {
					return 1;
				}
			}
		}
		return 0;
	}
	template <class _CharT>
	constexpr std::size_t char_traits<_CharT>::length(const char_type *__p)
	{
		std::size_t __i = (0);
		while (!(eq)(__p[__i], char_type())) {
			++__i;
		}
		return __i;
	}
	template <class _CharT>
	constexpr const typename char_traits<_CharT>::char_type *
	char_traits<_CharT>::find(const char_type *__s, std::size_t __n,
				  const char_type &__a)
	{
		for (std::size_t __i = (0); __i < __n; ++__i) {
			if ((eq)(__s[__i], __a)) {
				return __s + __i;
			}
		}
		return 0;
	}
	template <class _CharT>
	typename char_traits<_CharT>::char_type *char_traits<_CharT>::move(
		char_type * __s1, const char_type *__s2, std::size_t __n)
	{
		if (__n == (0)) {
			return __s1;
		}
		__builtin_memmove(__s1, __s2, __n * sizeof(char_type));
		return __s1;
	}
	template <class _CharT>
	typename char_traits<_CharT>::char_type *char_traits<_CharT>::copy(
		char_type * __s1, const char_type *__s2, std::size_t __n)
	{
		__builtin_memcpy(__s1, __s2, __n * sizeof(char_type));
		return __s1;
	}
	template <class _CharT>
	typename char_traits<_CharT>::char_type *char_traits<_CharT>::assign(
		char_type * __s, std::size_t __n, char_type __a)
	{
		if constexpr ((sizeof(_CharT) == (1)) && __is_trivial(_CharT)) {
			unsigned char __c;
			__builtin_memcpy(&__c, __builtin_addressof(__a), 1);
			__builtin_memset(__s, __c, __n);
		} else {
			for (std::size_t __i = (0); __i < __n; ++__i) {
				(__s[__i]) = __a;
			}
		}
		return __s;
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _CharT>
	struct char_traits : public __gnu_cxx::char_traits<_CharT> {
	};
	template <> struct char_traits<char> {
		typedef char char_type;
		typedef int int_type;
		typedef streampos pos_type;
		typedef streamoff off_type;
		typedef mbstate_t state_type;
		static constexpr void assign(char_type &__c1,
					     const char_type &__c2) noexcept
		{
			__c1 = __c2;
		}
		static constexpr bool eq(const char_type &__c1,
					 const char_type &__c2) noexcept
		{
			return __c1 == __c2;
		}
		static constexpr bool lt(const char_type &__c1,
					 const char_type &__c2) noexcept
		{
			return ((static_cast<unsigned char>(__c1)) <
				(static_cast<unsigned char>(__c2)));
		}
		static constexpr int compare(const char_type *__s1,
					     const char_type *__s2, size_t __n)
		{
			if (__n == (0)) {
				return 0;
			}
			if (std::__is_constant_evaluated()) {
				for (size_t __i = (0); __i < __n; ++__i) {
					if (lt(__s1[__i], __s2[__i])) {
						return -1;
					} else {
						if (lt(__s2[__i], __s1[__i])) {
							return 1;
						}
					}
				}
				return 0;
			}
			return __builtin_memcmp(__s1, __s2, __n);
		}
		static constexpr size_t length(const char_type *__s)
		{
			if (std::__is_constant_evaluated()) {
				return __gnu_cxx::char_traits<char>::length(
					__s);
			}
			return __builtin_strlen(__s);
		}
		static constexpr const char_type *
		find(const char_type *__s, size_t __n, const char_type &__a)
		{
			if (__n == (0)) {
				return 0;
			}
			if (std::__is_constant_evaluated()) {
				return __gnu_cxx::char_traits<char>::find(
					__s, __n, __a);
			}
			return static_cast<const char_type *>(
				__builtin_memchr(__s, __a, __n));
		}
		static char_type *move(char_type *__s1, const char_type *__s2,
				       size_t __n)
		{
			if (__n == (0)) {
				return __s1;
			}
			return static_cast<char_type *>(
				__builtin_memmove(__s1, __s2, __n));
		}
		static char_type *copy(char_type *__s1, const char_type *__s2,
				       size_t __n)
		{
			if (__n == (0)) {
				return __s1;
			}
			return static_cast<char_type *>(
				__builtin_memcpy(__s1, __s2, __n));
		}
		static char_type *assign(char_type *__s, size_t __n,
					 char_type __a)
		{
			if (__n == (0)) {
				return __s;
			}
			return static_cast<char_type *>(
				__builtin_memset(__s, __a, __n));
		}
		static constexpr char_type
		to_char_type(const int_type &__c) noexcept
		{
			return static_cast<char_type>(__c);
		}
		static constexpr int_type
		to_int_type(const char_type &__c) noexcept
		{
			return static_cast<int_type>(
				static_cast<unsigned char>(__c));
		}
		static constexpr bool eq_int_type(const int_type &__c1,
						  const int_type &__c2) noexcept
		{
			return __c1 == __c2;
		}
		static constexpr int_type eof() noexcept
		{
			return static_cast<int_type>(-1);
		}
		static constexpr int_type not_eof(const int_type &__c) noexcept
		{
			return (__c == eof()) ? 0 : __c;
		}
	};
	template <> struct char_traits<wchar_t> {
		typedef wchar_t char_type;
		typedef wint_t int_type;
		typedef streamoff off_type;
		typedef wstreampos pos_type;
		typedef mbstate_t state_type;
		static constexpr void assign(char_type &__c1,
					     const char_type &__c2) noexcept
		{
			__c1 = __c2;
		}
		static constexpr bool eq(const char_type &__c1,
					 const char_type &__c2) noexcept
		{
			return __c1 == __c2;
		}
		static constexpr bool lt(const char_type &__c1,
					 const char_type &__c2) noexcept
		{
			return __c1 < __c2;
		}
		static constexpr int compare(const char_type *__s1,
					     const char_type *__s2, size_t __n)
		{
			if (__n == (0)) {
				return 0;
			}
			if (std::__is_constant_evaluated()) {
				return __gnu_cxx::char_traits<wchar_t>::compare(
					__s1, __s2, __n);
			}
			return wmemcmp(__s1, __s2, __n);
		}
		static constexpr size_t length(const char_type *__s)
		{
			if (std::__is_constant_evaluated()) {
				return __gnu_cxx::char_traits<wchar_t>::length(
					__s);
			}
			return wcslen(__s);
		}
		static constexpr const char_type *
		find(const char_type *__s, size_t __n, const char_type &__a)
		{
			if (__n == (0)) {
				return 0;
			}
			if (std::__is_constant_evaluated()) {
				return __gnu_cxx::char_traits<wchar_t>::find(
					__s, __n, __a);
			}
			return wmemchr(__s, __a, __n);
		}
		static char_type *move(char_type *__s1, const char_type *__s2,
				       size_t __n)
		{
			if (__n == (0)) {
				return __s1;
			}
			return wmemmove(__s1, __s2, __n);
		}
		static char_type *copy(char_type *__s1, const char_type *__s2,
				       size_t __n)
		{
			if (__n == (0)) {
				return __s1;
			}
			return wmemcpy(__s1, __s2, __n);
		}
		static char_type *assign(char_type *__s, size_t __n,
					 char_type __a)
		{
			if (__n == (0)) {
				return __s;
			}
			return wmemset(__s, __a, __n);
		}
		static constexpr char_type
		to_char_type(const int_type &__c) noexcept
		{
			return (char_type)__c;
		}
		static constexpr int_type
		to_int_type(const char_type &__c) noexcept
		{
			return (int_type)__c;
		}
		static constexpr bool eq_int_type(const int_type &__c1,
						  const int_type &__c2) noexcept
		{
			return __c1 == __c2;
		}
		static constexpr int_type eof() noexcept
		{
			return static_cast<int_type>(4294967295U);
		}
		static constexpr int_type not_eof(const int_type &__c) noexcept
		{
			return eq_int_type(__c, eof()) ? 0 : __c;
		}
	};
} // namespace )
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;
typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;
typedef signed char int_fast8_t;
typedef long int_fast16_t;
typedef long int_fast32_t;
typedef long int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned long uint_fast16_t;
typedef unsigned long uint_fast32_t;
typedef unsigned long uint_fast64_t;
typedef long intptr_t;
typedef unsigned long uintptr_t;
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
namespace std
{
using ::int16_t;
using ::int32_t;
using ::int64_t;
using ::int8_t;
using ::int_fast16_t;
using ::int_fast32_t;
using ::int_fast64_t;
using ::int_fast8_t;
using ::int_least16_t;
using ::int_least32_t;
using ::int_least64_t;
using ::int_least8_t;
using ::intmax_t;
using ::intptr_t;
using ::uint16_t;
using ::uint32_t;
using ::uint64_t;
using ::uint8_t;
using ::uint_fast16_t;
using ::uint_fast32_t;
using ::uint_fast64_t;
using ::uint_fast8_t;
using ::uint_least16_t;
using ::uint_least32_t;
using ::uint_least64_t;
using ::uint_least8_t;
using ::uintmax_t;
using ::uintptr_t;
} // namespace std
namespace std __attribute((__visibility__("default")))
{
	template <> struct char_traits<char16_t> {
		typedef char16_t char_type;
		typedef uint_least16_t int_type;
		typedef streamoff off_type;
		typedef u16streampos pos_type;
		typedef mbstate_t state_type;
		static constexpr void assign(char_type &__c1,
					     const char_type &__c2) noexcept
		{
			__c1 = __c2;
		}
		static constexpr bool eq(const char_type &__c1,
					 const char_type &__c2) noexcept
		{
			return __c1 == __c2;
		}
		static constexpr bool lt(const char_type &__c1,
					 const char_type &__c2) noexcept
		{
			return __c1 < __c2;
		}
		static constexpr int compare(const char_type *__s1,
					     const char_type *__s2, size_t __n)
		{
			for (size_t __i = (0); __i < __n; ++__i) {
				if (lt(__s1[__i], __s2[__i])) {
					return -1;
				} else {
					if (lt(__s2[__i], __s1[__i])) {
						return 1;
					}
				}
			}
			return 0;
		}
		static constexpr size_t length(const char_type *__s)
		{
			size_t __i = (0);
			while (!eq(__s[__i], char_type())) {
				++__i;
			}
			return __i;
		}
		static constexpr const char_type *
		find(const char_type *__s, size_t __n, const char_type &__a)
		{
			for (size_t __i = (0); __i < __n; ++__i) {
				if (eq(__s[__i], __a)) {
					return __s + __i;
				}
			}
			return 0;
		}
		static char_type *move(char_type *__s1, const char_type *__s2,
				       size_t __n)
		{
			if (__n == (0)) {
				return __s1;
			}
			return (static_cast<char_type *>(__builtin_memmove(
				__s1, __s2, __n * sizeof(char_type))));
		}
		static char_type *copy(char_type *__s1, const char_type *__s2,
				       size_t __n)
		{
			if (__n == (0)) {
				return __s1;
			}
			return (static_cast<char_type *>(__builtin_memcpy(
				__s1, __s2, __n * sizeof(char_type))));
		}
		static char_type *assign(char_type *__s, size_t __n,
					 char_type __a)
		{
			for (size_t __i = (0); __i < __n; ++__i) {
				assign(__s[__i], __a);
			}
			return __s;
		}
		static constexpr char_type
		to_char_type(const int_type &__c) noexcept
		{
			return (char_type)__c;
		}
		static constexpr int_type
		to_int_type(const char_type &__c) noexcept
		{
			return (__c == (eof())) ? (int_type)65533 :
						  ((int_type)__c);
		}
		static constexpr bool eq_int_type(const int_type &__c1,
						  const int_type &__c2) noexcept
		{
			return __c1 == __c2;
		}
		static constexpr int_type eof() noexcept
		{
			return static_cast<int_type>(-1);
		}
		static constexpr int_type not_eof(const int_type &__c) noexcept
		{
			return eq_int_type(__c, eof()) ? 0 : __c;
		}
	};
	template <> struct char_traits<char32_t> {
		typedef char32_t char_type;
		typedef uint_least32_t int_type;
		typedef streamoff off_type;
		typedef u32streampos pos_type;
		typedef mbstate_t state_type;
		static constexpr void assign(char_type &__c1,
					     const char_type &__c2) noexcept
		{
			__c1 = __c2;
		}
		static constexpr bool eq(const char_type &__c1,
					 const char_type &__c2) noexcept
		{
			return __c1 == __c2;
		}
		static constexpr bool lt(const char_type &__c1,
					 const char_type &__c2) noexcept
		{
			return __c1 < __c2;
		}
		static constexpr int compare(const char_type *__s1,
					     const char_type *__s2, size_t __n)
		{
			for (size_t __i = (0); __i < __n; ++__i) {
				if (lt(__s1[__i], __s2[__i])) {
					return -1;
				} else {
					if (lt(__s2[__i], __s1[__i])) {
						return 1;
					}
				}
			}
			return 0;
		}
		static constexpr size_t length(const char_type *__s)
		{
			size_t __i = (0);
			while (!eq(__s[__i], char_type())) {
				++__i;
			}
			return __i;
		}
		static constexpr const char_type *
		find(const char_type *__s, size_t __n, const char_type &__a)
		{
			for (size_t __i = (0); __i < __n; ++__i) {
				if (eq(__s[__i], __a)) {
					return __s + __i;
				}
			}
			return 0;
		}
		static char_type *move(char_type *__s1, const char_type *__s2,
				       size_t __n)
		{
			if (__n == (0)) {
				return __s1;
			}
			return (static_cast<char_type *>(__builtin_memmove(
				__s1, __s2, __n * sizeof(char_type))));
		}
		static char_type *copy(char_type *__s1, const char_type *__s2,
				       size_t __n)
		{
			if (__n == (0)) {
				return __s1;
			}
			return (static_cast<char_type *>(__builtin_memcpy(
				__s1, __s2, __n * sizeof(char_type))));
		}
		static char_type *assign(char_type *__s, size_t __n,
					 char_type __a)
		{
			for (size_t __i = (0); __i < __n; ++__i) {
				assign(__s[__i], __a);
			}
			return __s;
		}
		static constexpr char_type
		to_char_type(const int_type &__c) noexcept
		{
			return (char_type)__c;
		}
		static constexpr int_type
		to_int_type(const char_type &__c) noexcept
		{
			return (int_type)__c;
		}
		static constexpr bool eq_int_type(const int_type &__c1,
						  const int_type &__c2) noexcept
		{
			return __c1 == __c2;
		}
		static constexpr int_type eof() noexcept
		{
			return static_cast<int_type>(-1);
		}
		static constexpr int_type not_eof(const int_type &__c) noexcept
		{
			return eq_int_type(__c, eof()) ? 0 : __c;
		}
	};
} // namespace )
extern "C" {
struct lconv {
	char *decimal_point;
	char *thousands_sep;
	char *grouping;
	char *int_curr_symbol;
	char *currency_symbol;
	char *mon_decimal_point;
	char *mon_thousands_sep;
	char *mon_grouping;
	char *positive_sign;
	char *negative_sign;
	char int_frac_digits;
	char frac_digits;
	char p_cs_precedes;
	char p_sep_by_space;
	char n_cs_precedes;
	char n_sep_by_space;
	char p_sign_posn;
	char n_sign_posn;
	char int_p_cs_precedes;
	char int_p_sep_by_space;
	char int_n_cs_precedes;
	char int_n_sep_by_space;
	char int_p_sign_posn;
	char int_n_sign_posn;
};
extern char *setlocale(int __category, const char *__locale) noexcept(true);
extern lconv *localeconv() noexcept(true);
extern locale_t newlocale(int __category_mask, const char *__locale,
			  locale_t __base) noexcept(true);
extern locale_t duplocale(locale_t __dataset) noexcept(true);
extern void freelocale(locale_t __dataset) noexcept(true);
extern locale_t uselocale(locale_t __dataset) noexcept(true);
}
namespace std
{
using ::lconv;
using ::localeconv;
using ::setlocale;
} // namespace std
namespace __gnu_cxx __attribute((__visibility__("default")))
{
	extern "C" __typeof__(uselocale) __uselocale;
}
namespace std __attribute((__visibility__("default")))
{
	typedef __locale_t __c_locale;
	inline int __convert_from_v(const __c_locale &__cloc
				    __attribute((__unused__)),
				    char *__out,
				    const int __size __attribute((__unused__)),
				    const char *__fmt, ...)
	{
		__c_locale __old = __gnu_cxx::__uselocale(__cloc);
		__builtin_va_list __args;
		__builtin_va_start((__args), __fmt);
		const int __ret =
			__builtin_vsnprintf(__out, __size, __fmt, __args);
		__builtin_va_end(__args);
		__gnu_cxx::__uselocale(__old);
		return __ret;
	}
} // namespace )
namespace std
{
using ::isalnum;
using ::isalpha;
using ::iscntrl;
using ::isdigit;
using ::isgraph;
using ::islower;
using ::isprint;
using ::ispunct;
using ::isspace;
using ::isupper;
using ::isxdigit;
using ::tolower;
using ::toupper;
} // namespace std
namespace std
{
using ::isblank;
}
namespace std __attribute((__visibility__("default")))
{
	class locale;
	template <class _Facet> bool has_facet(const locale &) throw();
	template <class _Facet> const _Facet &use_facet(const locale &);
	template <class _CharT> inline bool isspace(_CharT, const locale &);
	template <class _CharT> inline bool isprint(_CharT, const locale &);
	template <class _CharT> inline bool iscntrl(_CharT, const locale &);
	template <class _CharT> inline bool isupper(_CharT, const locale &);
	template <class _CharT> inline bool islower(_CharT, const locale &);
	template <class _CharT> inline bool isalpha(_CharT, const locale &);
	template <class _CharT> inline bool isdigit(_CharT, const locale &);
	template <class _CharT> inline bool ispunct(_CharT, const locale &);
	template <class _CharT> inline bool isxdigit(_CharT, const locale &);
	template <class _CharT> inline bool isalnum(_CharT, const locale &);
	template <class _CharT> inline bool isgraph(_CharT, const locale &);
	template <class _CharT> inline bool isblank(_CharT, const locale &);
	template <class _CharT> inline _CharT toupper(_CharT, const locale &);
	template <class _CharT> inline _CharT tolower(_CharT, const locale &);
	struct ctype_base;
	template <class _CharT> class ctype;
	template <> class ctype<char>;
	template <> class ctype<wchar_t>;
	template <class _CharT> class ctype_byname;
	class codecvt_base;
	template <class _InternT, class _ExternT, class _StateT> class codecvt;
	template <> class codecvt<char, char, __mbstate_t>;
	template <> class codecvt<wchar_t, char, __mbstate_t>;
	template <> class codecvt<char16_t, char, __mbstate_t>;
	template <> class codecvt<char32_t, char, __mbstate_t>;
	template <class _InternT, class _ExternT, class _StateT>
	class codecvt_byname;
	template <class _CharT, class _InIter = istreambuf_iterator<_CharT>>
	class num_get;
	template <class _CharT, class _OutIter = ostreambuf_iterator<_CharT>>
	class num_put;
	inline namespace __cxx11
	{
	template <class _CharT> class numpunct;
	template <class _CharT> class numpunct_byname;
	} // namespace __cxx11
	inline namespace __cxx11
	{
	template <class _CharT> class collate;
	template <class _CharT> class collate_byname;
	} // namespace __cxx11
	class time_base;
	inline namespace __cxx11
	{
	template <class _CharT, class _InIter = istreambuf_iterator<_CharT>>
	class time_get;
	template <class _CharT, class _InIter = istreambuf_iterator<_CharT>>
	class time_get_byname;
	} // namespace __cxx11
	template <class _CharT, class _OutIter = ostreambuf_iterator<_CharT>>
	class time_put;
	template <class _CharT, class _OutIter = ostreambuf_iterator<_CharT>>
	class time_put_byname;
	class money_base;
	inline namespace __cxx11
	{
	template <class _CharT, class _InIter = istreambuf_iterator<_CharT>>
	class money_get;
	template <class _CharT, class _OutIter = ostreambuf_iterator<_CharT>>
	class money_put;
	} // namespace __cxx11
	inline namespace __cxx11
	{
	template <class _CharT, bool _Intl = false> class moneypunct;
	template <class _CharT, bool _Intl = false> class moneypunct_byname;
	} // namespace __cxx11
	struct messages_base;
	inline namespace __cxx11
	{
	template <class _CharT> class messages;
	template <class _CharT> class messages_byname;
	} // namespace __cxx11
} // namespace )
struct sched_param {
	int sched_priority;
};
extern "C" {
extern int clone(int (*__fn)(void *__arg), void *__child_stack, int __flags,
		 void *__arg, ...) noexcept(true);
extern int unshare(int __flags) noexcept(true);
extern int sched_getcpu() noexcept(true);
extern int getcpu(unsigned *, unsigned *) noexcept(true);
extern int setns(int __fd, int __nstype) noexcept(true);
}
typedef unsigned long __cpu_mask;
typedef struct {
	__cpu_mask __bits[(1024) / ((8) * sizeof(__cpu_mask))];
} cpu_set_t;
extern "C" {
extern int __sched_cpucount(size_t __setsize,
			    const cpu_set_t *__setp) noexcept(true);
extern cpu_set_t *__sched_cpualloc(size_t __count) noexcept(true);
extern void __sched_cpufree(cpu_set_t *__set) noexcept(true);
}
extern "C" {
extern int sched_setparam(__pid_t __pid,
			  const sched_param *__param) noexcept(true);
extern int sched_getparam(__pid_t __pid, sched_param *__param) noexcept(true);
extern int sched_setscheduler(__pid_t __pid, int __policy,
			      const sched_param *__param) noexcept(true);
extern int sched_getscheduler(__pid_t __pid) noexcept(true);
extern int sched_yield() noexcept(true);
extern int sched_get_priority_max(int __algorithm) noexcept(true);
extern int sched_get_priority_min(int __algorithm) noexcept(true);
extern int sched_rr_get_interval(__pid_t __pid, timespec *__t) noexcept(true);
extern int sched_setaffinity(__pid_t __pid, size_t __cpusetsize,
			     const cpu_set_t *__cpuset) noexcept(true);
extern int sched_getaffinity(__pid_t __pid, size_t __cpusetsize,
			     cpu_set_t *__cpuset) noexcept(true);
}
typedef long __jmp_buf[8];
struct __jmp_buf_tag {
	__jmp_buf __jmpbuf;
	int __mask_was_saved;
	__sigset_t __saved_mask;
};
enum { PTHREAD_CREATE_JOINABLE, PTHREAD_CREATE_DETACHED };
enum {
	PTHREAD_MUTEX_TIMED_NP,
	PTHREAD_MUTEX_RECURSIVE_NP,
	PTHREAD_MUTEX_ERRORCHECK_NP,
	PTHREAD_MUTEX_ADAPTIVE_NP,
	PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
	PTHREAD_MUTEX_RECURSIVE,
	PTHREAD_MUTEX_ERRORCHECK,
	PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL,
	PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP
};
enum {
	PTHREAD_MUTEX_STALLED,
	PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
	PTHREAD_MUTEX_ROBUST,
	PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};
enum { PTHREAD_PRIO_NONE, PTHREAD_PRIO_INHERIT, PTHREAD_PRIO_PROTECT };
enum {
	PTHREAD_RWLOCK_PREFER_READER_NP,
	PTHREAD_RWLOCK_PREFER_WRITER_NP,
	PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
	PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
enum { PTHREAD_INHERIT_SCHED, PTHREAD_EXPLICIT_SCHED };
enum { PTHREAD_SCOPE_SYSTEM, PTHREAD_SCOPE_PROCESS };
enum { PTHREAD_PROCESS_PRIVATE, PTHREAD_PROCESS_SHARED };
struct _pthread_cleanup_buffer {
	void (*__routine)(void *);
	void *__arg;
	int __canceltype;
	_pthread_cleanup_buffer *__prev;
};
enum { PTHREAD_CANCEL_ENABLE, PTHREAD_CANCEL_DISABLE };
enum { PTHREAD_CANCEL_DEFERRED, PTHREAD_CANCEL_ASYNCHRONOUS };
extern "C" {
extern int pthread_create(pthread_t *__restrict__ __newthread,
			  const pthread_attr_t *__restrict__ __attr,
			  void *(*__start_routine)(void *),
			  void *__restrict__ __arg) noexcept(true)
	__attribute((__nonnull__(1, 3)));
extern void pthread_exit(void *__retval) __attribute((__noreturn__));
extern int pthread_join(pthread_t __th, void **__thread_return);
extern int pthread_tryjoin_np(pthread_t __th,
			      void **__thread_return) noexcept(true);
extern int pthread_timedjoin_np(pthread_t __th, void **__thread_return,
				const timespec *__abstime);
extern int pthread_clockjoin_np(pthread_t __th, void **__thread_return,
				clockid_t __clockid, const timespec *__abstime);
extern int pthread_detach(pthread_t __th) noexcept(true);
extern pthread_t pthread_self() noexcept(true) __attribute((const));
extern int pthread_equal(pthread_t __thread1,
			 pthread_t __thread2) noexcept(true)
	__attribute((const));
extern int pthread_attr_init(pthread_attr_t *__attr) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_attr_destroy(pthread_attr_t *__attr) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_attr_getdetachstate(const pthread_attr_t *__attr,
				       int *__detachstate) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int pthread_attr_setdetachstate(pthread_attr_t *__attr,
				       int __detachstate) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_attr_getguardsize(const pthread_attr_t *__attr,
				     size_t *__guardsize) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int pthread_attr_setguardsize(pthread_attr_t *__attr,
				     size_t __guardsize) noexcept(true)
	__attribute((__nonnull__(1)));
extern int
pthread_attr_getschedparam(const pthread_attr_t *__restrict__ __attr,
			   sched_param *__restrict__ __param) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int pthread_attr_setschedparam(
	pthread_attr_t *__restrict__ __attr,
	const sched_param *__restrict__ __param) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int
pthread_attr_getschedpolicy(const pthread_attr_t *__restrict__ __attr,
			    int *__restrict__ __policy) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int pthread_attr_setschedpolicy(pthread_attr_t *__attr,
				       int __policy) noexcept(true)
	__attribute((__nonnull__(1)));
extern int
pthread_attr_getinheritsched(const pthread_attr_t *__restrict__ __attr,
			     int *__restrict__ __inherit) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int pthread_attr_setinheritsched(pthread_attr_t *__attr,
					int __inherit) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_attr_getscope(const pthread_attr_t *__restrict__ __attr,
				 int *__restrict__ __scope) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int pthread_attr_setscope(pthread_attr_t *__attr,
				 int __scope) noexcept(true)
	__attribute((__nonnull__(1)));
extern int
pthread_attr_getstackaddr(const pthread_attr_t *__restrict__ __attr,
			  void **__restrict__ __stackaddr) noexcept(true)
	__attribute((__nonnull__(1, 2))) __attribute((__deprecated__));
extern int pthread_attr_setstackaddr(pthread_attr_t *__attr,
				     void *__stackaddr) noexcept(true)
	__attribute((__nonnull__(1))) __attribute((__deprecated__));
extern int
pthread_attr_getstacksize(const pthread_attr_t *__restrict__ __attr,
			  size_t *__restrict__ __stacksize) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int pthread_attr_setstacksize(pthread_attr_t *__attr,
				     size_t __stacksize) noexcept(true)
	__attribute((__nonnull__(1)));
extern int
pthread_attr_getstack(const pthread_attr_t *__restrict__ __attr,
		      void **__restrict__ __stackaddr,
		      size_t *__restrict__ __stacksize) noexcept(true)
	__attribute((__nonnull__(1, 2, 3)));
extern int pthread_attr_setstack(pthread_attr_t *__attr, void *__stackaddr,
				 size_t __stacksize) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_attr_setaffinity_np(pthread_attr_t *__attr,
				       size_t __cpusetsize,
				       const cpu_set_t *__cpuset) noexcept(true)
	__attribute((__nonnull__(1, 3)));
extern int pthread_attr_getaffinity_np(const pthread_attr_t *__attr,
				       size_t __cpusetsize,
				       cpu_set_t *__cpuset) noexcept(true)
	__attribute((__nonnull__(1, 3)));
extern int pthread_getattr_default_np(pthread_attr_t *__attr) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_attr_setsigmask_np(pthread_attr_t *__attr,
				      const __sigset_t *sigmask);
extern int pthread_attr_getsigmask_np(const pthread_attr_t *__attr,
				      __sigset_t *sigmask);
extern int
pthread_setattr_default_np(const pthread_attr_t *__attr) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_getattr_np(pthread_t __th,
			      pthread_attr_t *__attr) noexcept(true)
	__attribute((__nonnull__(2)));
extern int pthread_setschedparam(pthread_t __target_thread, int __policy,
				 const sched_param *__param) noexcept(true)
	__attribute((__nonnull__(3)));
extern int
pthread_getschedparam(pthread_t __target_thread, int *__restrict__ __policy,
		      sched_param *__restrict__ __param) noexcept(true)
	__attribute((__nonnull__(2, 3)));
extern int pthread_setschedprio(pthread_t __target_thread,
				int __prio) noexcept(true);
extern int pthread_getname_np(pthread_t __target_thread, char *__buf,
			      size_t __buflen) noexcept(true)
	__attribute((__nonnull__(2)));
extern int pthread_setname_np(pthread_t __target_thread,
			      const char *__name) noexcept(true)
	__attribute((__nonnull__(2)));
extern int pthread_getconcurrency() noexcept(true);
extern int pthread_setconcurrency(int __level) noexcept(true);
extern int pthread_yield() noexcept(true) __asm__("sched_yield");
extern int pthread_yield() noexcept(true) __asm__("sched_yield")
	__attribute((__deprecated__(
		"pthread_yield is deprecated, use sched_yield instead")));
extern int pthread_setaffinity_np(pthread_t __th, size_t __cpusetsize,
				  const cpu_set_t *__cpuset) noexcept(true)
	__attribute((__nonnull__(3)));
extern int pthread_getaffinity_np(pthread_t __th, size_t __cpusetsize,
				  cpu_set_t *__cpuset) noexcept(true)
	__attribute((__nonnull__(3)));
extern int pthread_once(pthread_once_t *__once_control,
			void (*__init_routine)(void))
	__attribute((__nonnull__(1, 2)));
extern int pthread_setcancelstate(int __state, int *__oldstate);
extern int pthread_setcanceltype(int __type, int *__oldtype);
extern int pthread_cancel(pthread_t __th);
extern void pthread_testcancel();
struct __cancel_jmp_buf_tag {
	__jmp_buf __cancel_jmp_buf;
	int __mask_was_saved;
};
typedef struct {
	__cancel_jmp_buf_tag __cancel_jmp_buf[1];
	void *__pad[4];
} __pthread_unwind_buf_t __attribute((__aligned__));
struct __pthread_cleanup_frame {
	void (*__cancel_routine)(void *);
	void *__cancel_arg;
	int __do_it;
	int __cancel_type;
};
class __pthread_cleanup_class {
	void (*__cancel_routine)(void *);
	void *__cancel_arg;
	int __do_it;
	int __cancel_type;

    public:
	__pthread_cleanup_class(void (*__fct)(void *), void *__arg)
		: __cancel_routine(__fct), __cancel_arg(__arg), __do_it(1)
	{
	}
	~__pthread_cleanup_class()
	{
		if (__do_it) {
			(__cancel_routine)(__cancel_arg);
		}
	}
	void __setdoit(int __newval)
	{
		(__do_it) = __newval;
	}
	void __defer()
	{
		pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED,
				      &(__cancel_type));
	}
	void __restore() const
	{
		pthread_setcanceltype(__cancel_type, 0);
	}
};
extern int
__sigsetjmp_cancel(__cancel_jmp_buf_tag __env[1],
		   int __savemask) noexcept(true) __asm__("__sigsetjmp")
	__attribute((__returns_twice__));
extern int
pthread_mutex_init(pthread_mutex_t *__mutex,
		   const pthread_mutexattr_t *__mutexattr) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_mutex_destroy(pthread_mutex_t *__mutex) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_mutex_trylock(pthread_mutex_t *__mutex) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_mutex_lock(pthread_mutex_t *__mutex) noexcept(true)
	__attribute((__nonnull__(1)));
extern int
pthread_mutex_timedlock(pthread_mutex_t *__restrict__ __mutex,
			const timespec *__restrict__ __abstime) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int
pthread_mutex_clocklock(pthread_mutex_t *__restrict__ __mutex,
			clockid_t __clockid,
			const timespec *__restrict__ __abstime) noexcept(true)
	__attribute((__nonnull__(1, 3)));
extern int pthread_mutex_unlock(pthread_mutex_t *__mutex) noexcept(true)
	__attribute((__nonnull__(1)));
extern int
pthread_mutex_getprioceiling(const pthread_mutex_t *__restrict__ __mutex,
			     int *__restrict__ __prioceiling) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int
pthread_mutex_setprioceiling(pthread_mutex_t *__restrict__ __mutex,
			     int __prioceiling,
			     int *__restrict__ __old_ceiling) noexcept(true)
	__attribute((__nonnull__(1, 3)));
extern int pthread_mutex_consistent(pthread_mutex_t *__mutex) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_mutex_consistent_np(pthread_mutex_t *) noexcept(
	true) __asm__("pthread_mutex_consistent") __attribute((__nonnull__(1)))
__attribute((__deprecated__(
	"pthread_mutex_consistent_np is deprecated, use pthread_mutex_consistent")));
extern int pthread_mutexattr_init(pthread_mutexattr_t *__attr) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr) noexcept(true)
	__attribute((__nonnull__(1)));
extern int
pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict__ __attr,
			     int *__restrict__ __pshared) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr,
					int __pshared) noexcept(true)
	__attribute((__nonnull__(1)));
extern int
pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict__ __attr,
			  int *__restrict__ __kind) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int pthread_mutexattr_settype(pthread_mutexattr_t *__attr,
				     int __kind) noexcept(true)
	__attribute((__nonnull__(1)));
extern int
pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict__ __attr,
			      int *__restrict__ __protocol) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr,
					 int __protocol) noexcept(true)
	__attribute((__nonnull__(1)));
extern int
pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict__ __attr,
				 int *__restrict__ __prioceiling) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr,
					    int __prioceiling) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__attr,
				       int *__robustness) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int
pthread_mutexattr_getrobust_np(pthread_mutexattr_t *, int *) noexcept(
	true) __asm__("pthread_mutexattr_getrobust") __attribute((__nonnull__(1)))
__attribute((__deprecated__(
	"pthread_mutexattr_getrobust_np is deprecated, use pthread_mutexattr_getrobust")));
extern int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr,
				       int __robustness) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_mutexattr_setrobust_np(pthread_mutexattr_t *, int) noexcept(
	true) __asm__("pthread_mutexattr_setrobust") __attribute((__nonnull__(1)))
__attribute((__deprecated__(
	"pthread_mutexattr_setrobust_np is deprecated, use pthread_mutexattr_setrobust")));
extern int pthread_rwlock_init(
	pthread_rwlock_t *__restrict__ __rwlock,
	const pthread_rwlockattr_t *__restrict__ __attr) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_rwlock_timedrdlock(
	pthread_rwlock_t *__restrict__ __rwlock,
	const timespec *__restrict__ __abstime) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int pthread_rwlock_clockrdlock(
	pthread_rwlock_t *__restrict__ __rwlock, clockid_t __clockid,
	const timespec *__restrict__ __abstime) noexcept(true)
	__attribute((__nonnull__(1, 3)));
extern int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_rwlock_timedwrlock(
	pthread_rwlock_t *__restrict__ __rwlock,
	const timespec *__restrict__ __abstime) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int pthread_rwlock_clockwrlock(
	pthread_rwlock_t *__restrict__ __rwlock, clockid_t __clockid,
	const timespec *__restrict__ __abstime) noexcept(true)
	__attribute((__nonnull__(1, 3)));
extern int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_rwlockattr_init(pthread_rwlockattr_t *__attr) noexcept(true)
	__attribute((__nonnull__(1)));
extern int
pthread_rwlockattr_destroy(pthread_rwlockattr_t *__attr) noexcept(true)
	__attribute((__nonnull__(1)));
extern int
pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__restrict__ __attr,
			      int *__restrict__ __pshared) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *__attr,
					 int __pshared) noexcept(true)
	__attribute((__nonnull__(1)));
extern int
pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *__restrict__ __attr,
			      int *__restrict__ __pref) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *__attr,
					 int __pref) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_cond_init(
	pthread_cond_t *__restrict__ __cond,
	const pthread_condattr_t *__restrict__ __cond_attr) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_cond_destroy(pthread_cond_t *__cond) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_cond_signal(pthread_cond_t *__cond) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_cond_broadcast(pthread_cond_t *__cond) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_cond_wait(pthread_cond_t *__restrict__ __cond,
			     pthread_mutex_t *__restrict__ __mutex)
	__attribute((__nonnull__(1, 2)));
extern int pthread_cond_timedwait(pthread_cond_t *__restrict__ __cond,
				  pthread_mutex_t *__restrict__ __mutex,
				  const timespec *__restrict__ __abstime)
	__attribute((__nonnull__(1, 2, 3)));
extern int pthread_cond_clockwait(pthread_cond_t *__restrict__ __cond,
				  pthread_mutex_t *__restrict__ __mutex,
				  __clockid_t __clock_id,
				  const timespec *__restrict__ __abstime)
	__attribute((__nonnull__(1, 2, 4)));
extern int pthread_condattr_init(pthread_condattr_t *__attr) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_condattr_destroy(pthread_condattr_t *__attr) noexcept(true)
	__attribute((__nonnull__(1)));
extern int
pthread_condattr_getpshared(const pthread_condattr_t *__restrict__ __attr,
			    int *__restrict__ __pshared) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int pthread_condattr_setpshared(pthread_condattr_t *__attr,
				       int __pshared) noexcept(true)
	__attribute((__nonnull__(1)));
extern int
pthread_condattr_getclock(const pthread_condattr_t *__restrict__ __attr,
			  __clockid_t *__restrict__ __clock_id) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int pthread_condattr_setclock(pthread_condattr_t *__attr,
				     __clockid_t __clock_id) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_spin_init(pthread_spinlock_t *__lock,
			     int __pshared) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_spin_destroy(pthread_spinlock_t *__lock) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_spin_lock(pthread_spinlock_t *__lock) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_spin_trylock(pthread_spinlock_t *__lock) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_spin_unlock(pthread_spinlock_t *__lock) noexcept(true)
	__attribute((__nonnull__(1)));
extern int
pthread_barrier_init(pthread_barrier_t *__restrict__ __barrier,
		     const pthread_barrierattr_t *__restrict__ __attr,
		     unsigned __count) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_barrier_destroy(pthread_barrier_t *__barrier) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_barrier_wait(pthread_barrier_t *__barrier) noexcept(true)
	__attribute((__nonnull__(1)));
extern int
pthread_barrierattr_init(pthread_barrierattr_t *__attr) noexcept(true)
	__attribute((__nonnull__(1)));
extern int
pthread_barrierattr_destroy(pthread_barrierattr_t *__attr) noexcept(true)
	__attribute((__nonnull__(1)));
extern int
pthread_barrierattr_getpshared(const pthread_barrierattr_t *__restrict__ __attr,
			       int *__restrict__ __pshared) noexcept(true)
	__attribute((__nonnull__(1, 2)));
extern int pthread_barrierattr_setpshared(pthread_barrierattr_t *__attr,
					  int __pshared) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_key_create(pthread_key_t *__key,
			      void (*__destr_function)(void *)) noexcept(true)
	__attribute((__nonnull__(1)));
extern int pthread_key_delete(pthread_key_t __key) noexcept(true);
extern void *pthread_getspecific(pthread_key_t __key) noexcept(true);
extern int pthread_setspecific(pthread_key_t __key,
			       const void *__pointer) noexcept(true)
	__attribute((__access__(__none__, 2)));
extern int pthread_getcpuclockid(pthread_t __thread_id,
				 __clockid_t *__clock_id) noexcept(true)
	__attribute((__nonnull__(2)));
extern int pthread_atfork(void (*__prepare)(void), void (*__parent)(void),
			  void (*__child)(void)) noexcept(true);
}
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef timespec __gthread_time_t;
static inline int __gthread_active_p()
{
	return 1;
}
static inline int __gthread_create(__gthread_t *__threadid,
				   void *(*__func)(void *), void *__args)
{
	return pthread_create(__threadid, __null, __func, __args);
}
static inline int __gthread_join(__gthread_t __threadid, void **__value_ptr)
{
	return pthread_join(__threadid, __value_ptr);
}
static inline int __gthread_detach(__gthread_t __threadid)
{
	return pthread_detach(__threadid);
}
static inline int __gthread_equal(__gthread_t __t1, __gthread_t __t2)
{
	return pthread_equal(__t1, __t2);
}
static inline __gthread_t __gthread_self()
{
	return pthread_self();
}
static inline int __gthread_yield()
{
	return sched_yield();
}
static inline int __gthread_once(__gthread_once_t *__once, void (*__func)(void))
{
	if (__gthread_active_p()) {
		return pthread_once(__once, __func);
	} else {
		return -1;
	}
}
static inline int __gthread_key_create(__gthread_key_t *__key,
				       void (*__dtor)(void *))
{
	return pthread_key_create(__key, __dtor);
}
static inline int __gthread_key_delete(__gthread_key_t __key)
{
	return pthread_key_delete(__key);
}
static inline void *__gthread_getspecific(__gthread_key_t __key)
{
	return pthread_getspecific(__key);
}
static inline int __gthread_setspecific(__gthread_key_t __key,
					const void *__ptr)
{
	return pthread_setspecific(__key, __ptr);
}
static inline void __gthread_mutex_init_function(__gthread_mutex_t *__mutex)
{
	if (__gthread_active_p()) {
		pthread_mutex_init(__mutex, __null);
	}
}
static inline int __gthread_mutex_destroy(__gthread_mutex_t *__mutex)
{
	if (__gthread_active_p()) {
		return pthread_mutex_destroy(__mutex);
	} else {
		return 0;
	}
}
static inline int __gthread_mutex_lock(__gthread_mutex_t *__mutex)
{
	if (__gthread_active_p()) {
		return pthread_mutex_lock(__mutex);
	} else {
		return 0;
	}
}
static inline int __gthread_mutex_trylock(__gthread_mutex_t *__mutex)
{
	if (__gthread_active_p()) {
		return pthread_mutex_trylock(__mutex);
	} else {
		return 0;
	}
}
static inline int
__gthread_mutex_timedlock(__gthread_mutex_t *__mutex,
			  const __gthread_time_t *__abs_timeout)
{
	if (__gthread_active_p()) {
		return pthread_mutex_timedlock(__mutex, __abs_timeout);
	} else {
		return 0;
	}
}
static inline int __gthread_mutex_unlock(__gthread_mutex_t *__mutex)
{
	if (__gthread_active_p()) {
		return pthread_mutex_unlock(__mutex);
	} else {
		return 0;
	}
}
static inline int
__gthread_recursive_mutex_lock(__gthread_recursive_mutex_t *__mutex)
{
	return __gthread_mutex_lock(__mutex);
}
static inline int
__gthread_recursive_mutex_trylock(__gthread_recursive_mutex_t *__mutex)
{
	return __gthread_mutex_trylock(__mutex);
}
static inline int
__gthread_recursive_mutex_timedlock(__gthread_recursive_mutex_t *__mutex,
				    const __gthread_time_t *__abs_timeout)
{
	return __gthread_mutex_timedlock(__mutex, __abs_timeout);
}
static inline int
__gthread_recursive_mutex_unlock(__gthread_recursive_mutex_t *__mutex)
{
	return __gthread_mutex_unlock(__mutex);
}
static inline int
__gthread_recursive_mutex_destroy(__gthread_recursive_mutex_t *__mutex)
{
	return __gthread_mutex_destroy(__mutex);
}
static inline int __gthread_cond_broadcast(__gthread_cond_t *__cond)
{
	return pthread_cond_broadcast(__cond);
}
static inline int __gthread_cond_signal(__gthread_cond_t *__cond)
{
	return pthread_cond_signal(__cond);
}
static inline int __gthread_cond_wait(__gthread_cond_t *__cond,
				      __gthread_mutex_t *__mutex)
{
	return pthread_cond_wait(__cond, __mutex);
}
static inline int
__gthread_cond_timedwait(__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
			 const __gthread_time_t *__abs_timeout)
{
	return pthread_cond_timedwait(__cond, __mutex, __abs_timeout);
}
static inline int
__gthread_cond_wait_recursive(__gthread_cond_t *__cond,
			      __gthread_recursive_mutex_t *__mutex)
{
	return __gthread_cond_wait(__cond, __mutex);
}
static inline int __gthread_cond_destroy(__gthread_cond_t *__cond)
{
	return pthread_cond_destroy(__cond);
}
typedef int _Atomic_word;
extern "C" {
extern char __libc_single_threaded;
}
namespace __gnu_cxx __attribute((__visibility__("default")))
{
	__attribute((__always_inline__)) inline bool
	__is_single_threaded() noexcept
	{
		return ::__libc_single_threaded;
	}
	__attribute((__always_inline__)) inline _Atomic_word __exchange_and_add(
		volatile _Atomic_word * __mem, int __val)
	{
		return __atomic_fetch_add(__mem, __val, 4);
	}
	__attribute((__always_inline__)) inline void __atomic_add(
		volatile _Atomic_word * __mem, int __val)
	{
		__atomic_fetch_add(__mem, __val, 4);
	}
	__attribute((__always_inline__)) inline _Atomic_word
	__exchange_and_add_single(_Atomic_word * __mem, int __val)
	{
		_Atomic_word __result = *__mem;
		(*__mem) += __val;
		return __result;
	}
	__attribute((__always_inline__)) inline void __atomic_add_single(
		_Atomic_word * __mem, int __val)
	{
		(*__mem) += __val;
	}
	__attribute((__always_inline__)) inline _Atomic_word
	__exchange_and_add_dispatch(_Atomic_word * __mem, int __val)
	{
		if (__is_single_threaded()) {
			return __exchange_and_add_single(__mem, __val);
		} else {
			return __exchange_and_add(__mem, __val);
		}
	}
	__attribute((__always_inline__)) inline void __atomic_add_dispatch(
		_Atomic_word * __mem, int __val)
	{
		if (__is_single_threaded()) {
			__atomic_add_single(__mem, __val);
		} else {
			__atomic_add(__mem, __val);
		}
	}
} // namespace )
namespace __cxxabiv1
{
class __forced_unwind {
	virtual ~__forced_unwind() throw();
	virtual void __pure_dummy() = 0;
};
} // namespace __cxxabiv1
namespace std __attribute((__visibility__("default")))
{
	template <class _CharT, class _Traits>
	inline void __ostream_write(basic_ostream<_CharT, _Traits> & __out,
				    const _CharT *__s, streamsize __n)
	{
		typedef basic_ostream<_CharT, _Traits> __ostream_type;
		typedef typename basic_ostream<_CharT, _Traits>::ios_base
			__ios_base;
		const streamsize __put = __out.rdbuf()->sputn(__s, __n);
		if (__put != __n) {
			__out.setstate(__ios_base::badbit);
		}
	}
	template <class _CharT, class _Traits>
	inline void __ostream_fill(basic_ostream<_CharT, _Traits> & __out,
				   streamsize __n)
	{
		typedef basic_ostream<_CharT, _Traits> __ostream_type;
		typedef typename basic_ostream<_CharT, _Traits>::ios_base
			__ios_base;
		const _CharT __c = __out.fill();
		for (; __n > (0); --__n) {
			const typename _Traits::int_type __put =
				__out.rdbuf()->sputc(__c);
			if (_Traits::eq_int_type(__put, _Traits::eof())) {
				__out.setstate(__ios_base::badbit);
				break;
			}
		}
	}
	template <class _CharT, class _Traits>
	basic_ostream<_CharT, _Traits> &__ostream_insert(
		basic_ostream<_CharT, _Traits> & __out, const _CharT *__s,
		streamsize __n)
	{
		typedef basic_ostream<_CharT, _Traits> __ostream_type;
		typedef typename basic_ostream<_CharT, _Traits>::ios_base
			__ios_base;
		typename basic_ostream<_CharT, _Traits>::sentry __cerb(__out);
		if (__cerb) {
			try {
				const streamsize __w = __out.width();
				if (__w > __n) {
					const bool __left =
						(__out.flags() &
						 __ios_base::adjustfield) ==
						__ios_base::left;
					if (!__left) {
						__ostream_fill(__out,
							       __w - __n);
					}
					if (__out.good()) {
						__ostream_write(__out, __s,
								__n);
					}
					if (__left && __out.good()) {
						__ostream_fill(__out,
							       __w - __n);
					}
				} else {
					__ostream_write(__out, __s, __n);
				}
				__out.width(0);
			} catch (__cxxabiv1::__forced_unwind &) {
				__out._M_setstate(__ios_base::badbit);
				throw;
			} catch (...) {
				__out._M_setstate(__ios_base::badbit);
			}
		}
		return __out;
	}
	extern template basic_ostream<char> &__ostream_insert(
		basic_ostream<char> & __out, const char *__s, streamsize __n);
	extern template basic_ostream<wchar_t> &__ostream_insert(
		basic_ostream<wchar_t> & __out, const wchar_t *__s,
		streamsize __n);
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	constexpr size_t __sv_check(size_t __size, size_t __pos,
				    const char *__s)
	{
		if (__pos > __size) {
			__throw_out_of_range_fmt(
				"%s: __pos (which is %zu) > __size (which is %zu)",
				__s, __pos, __size);
		}
		return __pos;
	}
	constexpr size_t __sv_limit(size_t __size, size_t __pos,
				    size_t __off) noexcept
	{
		const bool __testoff = __off < (__size - __pos);
		return __testoff ? __off : (__size - __pos);
	}
	template <class _CharT, class _Traits = char_traits<_CharT>>
	class basic_string_view {
		static_assert((!is_array_v<_CharT>));
		static_assert((is_trivial_v<_CharT> &&
			       is_standard_layout_v<_CharT>));
		static_assert((is_same_v<_CharT, typename _Traits::char_type>));

	    public:
		using traits_type = _Traits;
		using value_type = _CharT;
		using pointer = value_type *;
		using const_pointer = const value_type *;
		using reference = value_type &;
		using const_reference = const value_type &;
		using const_iterator = const value_type *;
		using iterator = const_iterator;
		using const_reverse_iterator =
			std::reverse_iterator<const_iterator>;
		using reverse_iterator = const_reverse_iterator;
		using size_type = size_t;
		using difference_type = ptrdiff_t;
		static constexpr inline size_type npos = ((size_type)(-1));
		constexpr basic_string_view() noexcept
			: _M_len{ (0) }, _M_str{ (nullptr) }
		{
		}
		constexpr basic_string_view(
			const basic_string_view &) noexcept = default;
		__attribute((__nonnull__)) constexpr basic_string_view(
			const _CharT *__str) noexcept
			: _M_len{ traits_type::length(__str) }, _M_str{ __str }
		{
		}
		constexpr basic_string_view(const _CharT *__str,
					    size_type __len) noexcept
			: _M_len{ __len }, _M_str{ __str }
		{
		}
		constexpr basic_string_view &
		operator=(const basic_string_view &) noexcept = default;
		constexpr const_iterator begin() const noexcept
		{
			return this->_M_str;
		}
		constexpr const_iterator end() const noexcept
		{
			return (this->_M_str) + (this->_M_len);
		}
		constexpr const_iterator cbegin() const noexcept
		{
			return this->_M_str;
		}
		constexpr const_iterator cend() const noexcept
		{
			return (this->_M_str) + (this->_M_len);
		}
		constexpr const_reverse_iterator rbegin() const noexcept
		{
			return ((std::reverse_iterator<const_iterator>)(end()));
		}
		constexpr const_reverse_iterator rend() const noexcept
		{
			return ((
				std::reverse_iterator<const_iterator>)(begin()));
		}
		constexpr const_reverse_iterator crbegin() const noexcept
		{
			return ((std::reverse_iterator<const_iterator>)(end()));
		}
		constexpr const_reverse_iterator crend() const noexcept
		{
			return ((
				std::reverse_iterator<const_iterator>)(begin()));
		}
		constexpr size_type size() const noexcept
		{
			return this->_M_len;
		}
		constexpr size_type length() const noexcept
		{
			return _M_len;
		}
		constexpr size_type max_size() const noexcept
		{
			return (((npos - sizeof(size_type)) - sizeof(void *)) /
				sizeof(value_type)) /
			       (4);
		}
		[[nodiscard]] constexpr bool empty() const noexcept
		{
			return (this->_M_len) == (0);
		}
		constexpr const_reference
		operator[](size_type __pos) const noexcept
		{
			do {
				if (std::__is_constant_evaluated() &&
				    (!((bool)(__pos < (this->_M_len))))) {
					__builtin_unreachable();
				}
			} while (false);
			return *((this->_M_str) + __pos);
		}
		constexpr const_reference at(size_type __pos) const
		{
			if (__pos >= (_M_len)) {
				__throw_out_of_range_fmt(
					"basic_string_view::at: __pos (which is %zu) >= this->size() (which is %zu)",
					__pos, size());
			}
			return *((this->_M_str) + __pos);
		}
		constexpr const_reference front() const noexcept
		{
			do {
				if (std::__is_constant_evaluated() &&
				    (!((bool)((this->_M_len) > (0))))) {
					__builtin_unreachable();
				}
			} while (false);
			return *(this->_M_str);
		}
		constexpr const_reference back() const noexcept
		{
			do {
				if (std::__is_constant_evaluated() &&
				    (!((bool)((this->_M_len) > (0))))) {
					__builtin_unreachable();
				}
			} while (false);
			return *(((this->_M_str) + (this->_M_len)) - 1);
		}
		constexpr const_pointer data() const noexcept
		{
			return this->_M_str;
		}
		constexpr void remove_prefix(size_type __n) noexcept
		{
			do {
				if (std::__is_constant_evaluated() &&
				    (!((bool)((this->_M_len) >= __n)))) {
					__builtin_unreachable();
				}
			} while (false);
			(this->_M_str) += __n;
			(this->_M_len) -= __n;
		}
		constexpr void remove_suffix(size_type __n) noexcept
		{
			(this->_M_len) -= __n;
		}
		constexpr void swap(basic_string_view &__sv) noexcept
		{
			auto __tmp = *this;
			(*this) = __sv;
			__sv = __tmp;
		}
		size_type copy(_CharT *__str, size_type __n,
			       size_type __pos = 0) const
		{
			;
			__pos = std::__sv_check(size(), __pos,
						"basic_string_view::copy");
			const size_type __rlen = std::min(__n, (_M_len)-__pos);
			traits_type::copy(__str, data() + __pos, __rlen);
			return __rlen;
		}
		constexpr basic_string_view substr(size_type __pos = 0,
						   size_type __n = npos) const
			noexcept(false)
		{
			__pos = std::__sv_check(size(), __pos,
						"basic_string_view::substr");
			const size_type __rlen = std::min(__n, (_M_len)-__pos);
			return basic_string_view{ (_M_str) + __pos, __rlen };
		}
		constexpr int compare(basic_string_view __str) const noexcept
		{
			const size_type __rlen =
				std::min(this->_M_len, __str._M_len);
			int __ret = traits_type::compare(this->_M_str,
							 __str._M_str, __rlen);
			if (__ret == 0) {
				__ret = (_S_compare)(this->_M_len,
						     __str._M_len);
			}
			return __ret;
		}
		constexpr int compare(size_type __pos1, size_type __n1,
				      basic_string_view __str) const
		{
			return substr(__pos1, __n1).compare(__str);
		}
		constexpr int compare(size_type __pos1, size_type __n1,
				      basic_string_view __str, size_type __pos2,
				      size_type __n2) const
		{
			return substr(__pos1, __n1)
				.compare(__str.substr(__pos2, __n2));
		}
		__attribute((__nonnull__)) constexpr int
		compare(const _CharT *__str) const noexcept
		{
			return this->compare(basic_string_view{ __str });
		}
		__attribute((__nonnull__)) constexpr int
		compare(size_type __pos1, size_type __n1,
			const _CharT *__str) const
		{
			return substr(__pos1, __n1)
				.compare(basic_string_view{ __str });
		}
		constexpr int compare(size_type __pos1, size_type __n1,
				      const _CharT *__str, size_type __n2) const
			noexcept(false)
		{
			return substr(__pos1, __n1)
				.compare(basic_string_view(__str, __n2));
		}
		constexpr size_type find(basic_string_view __str,
					 size_type __pos = 0) const noexcept
		{
			return this->find(__str._M_str, __pos, __str._M_len);
		}
		constexpr size_type find(_CharT __c,
					 size_type __pos = 0) const noexcept;
		constexpr size_type find(const _CharT *__str, size_type __pos,
					 size_type __n) const noexcept;
		__attribute((__nonnull__)) constexpr size_type
		find(const _CharT *__str, size_type __pos = 0) const noexcept
		{
			return this->find(__str, __pos,
					  traits_type::length(__str));
		}
		constexpr size_type rfind(basic_string_view __str,
					  size_type __pos = npos) const noexcept
		{
			return this->rfind(__str._M_str, __pos, __str._M_len);
		}
		constexpr size_type
		rfind(_CharT __c, size_type __pos = npos) const noexcept;
		constexpr size_type rfind(const _CharT *__str, size_type __pos,
					  size_type __n) const noexcept;
		__attribute((__nonnull__)) constexpr size_type
		rfind(const _CharT *__str,
		      size_type __pos = npos) const noexcept
		{
			return this->rfind(__str, __pos,
					   traits_type::length(__str));
		}
		constexpr size_type
		find_first_of(basic_string_view __str,
			      size_type __pos = 0) const noexcept
		{
			return this->find_first_of(__str._M_str, __pos,
						   __str._M_len);
		}
		constexpr size_type
		find_first_of(_CharT __c, size_type __pos = 0) const noexcept
		{
			return this->find(__c, __pos);
		}
		constexpr size_type find_first_of(const _CharT *__str,
						  size_type __pos,
						  size_type __n) const noexcept;
		__attribute((__nonnull__)) constexpr size_type
		find_first_of(const _CharT *__str,
			      size_type __pos = 0) const noexcept
		{
			return this->find_first_of(__str, __pos,
						   traits_type::length(__str));
		}
		constexpr size_type
		find_last_of(basic_string_view __str,
			     size_type __pos = npos) const noexcept
		{
			return this->find_last_of(__str._M_str, __pos,
						  __str._M_len);
		}
		constexpr size_type
		find_last_of(_CharT __c, size_type __pos = npos) const noexcept
		{
			return this->rfind(__c, __pos);
		}
		constexpr size_type find_last_of(const _CharT *__str,
						 size_type __pos,
						 size_type __n) const noexcept;
		__attribute((__nonnull__)) constexpr size_type
		find_last_of(const _CharT *__str,
			     size_type __pos = npos) const noexcept
		{
			return this->find_last_of(__str, __pos,
						  traits_type::length(__str));
		}
		constexpr size_type
		find_first_not_of(basic_string_view __str,
				  size_type __pos = 0) const noexcept
		{
			return this->find_first_not_of(__str._M_str, __pos,
						       __str._M_len);
		}
		constexpr size_type
		find_first_not_of(_CharT __c,
				  size_type __pos = 0) const noexcept;
		constexpr size_type
		find_first_not_of(const _CharT *__str, size_type __pos,
				  size_type __n) const noexcept;
		__attribute((__nonnull__)) constexpr size_type
		find_first_not_of(const _CharT *__str,
				  size_type __pos = 0) const noexcept
		{
			return this->find_first_not_of(
				__str, __pos, traits_type::length(__str));
		}
		constexpr size_type
		find_last_not_of(basic_string_view __str,
				 size_type __pos = npos) const noexcept
		{
			return this->find_last_not_of(__str._M_str, __pos,
						      __str._M_len);
		}
		constexpr size_type
		find_last_not_of(_CharT __c,
				 size_type __pos = npos) const noexcept;
		constexpr size_type
		find_last_not_of(const _CharT *__str, size_type __pos,
				 size_type __n) const noexcept;
		__attribute((__nonnull__)) constexpr size_type
		find_last_not_of(const _CharT *__str,
				 size_type __pos = npos) const noexcept
		{
			return this->find_last_not_of(
				__str, __pos, traits_type::length(__str));
		}

	    private:
		static constexpr int _S_compare(size_type __n1,
						size_type __n2) noexcept
		{
			using __limits = __gnu_cxx::__int_traits<int>;
			const difference_type __diff = __n1 - __n2;
			if (__diff > __limits::__max) {
				return __limits::__max;
			}
			if (__diff < __limits::__min) {
				return __limits::__min;
			}
			return static_cast<int>(__diff);
		}
		size_t _M_len;
		const _CharT *_M_str;
	};
	template <class _CharT, class _Traits>
	constexpr bool operator==(
		basic_string_view<_CharT, _Traits> __x,
		basic_string_view<_CharT, _Traits> __y) noexcept
	{
		return (__x.size() == __y.size()) && (__x.compare(__y) == 0);
	}
	template <class _CharT, class _Traits>
	constexpr bool operator==(
		basic_string_view<_CharT, _Traits> __x,
		__type_identity_t<basic_string_view<_CharT, _Traits>>
			__y) noexcept
	{
		return (__x.size() == __y.size()) && (__x.compare(__y) == 0);
	}
	template <class _CharT, class _Traits>
	constexpr bool operator==(
		__type_identity_t<basic_string_view<_CharT, _Traits>> __x,
		basic_string_view<_CharT, _Traits> __y) noexcept
	{
		return (__x.size() == __y.size()) && (__x.compare(__y) == 0);
	}
	template <class _CharT, class _Traits>
	constexpr bool operator!=(
		basic_string_view<_CharT, _Traits> __x,
		basic_string_view<_CharT, _Traits> __y) noexcept
	{
		return !(__x == __y);
	}
	template <class _CharT, class _Traits>
	constexpr bool operator!=(
		basic_string_view<_CharT, _Traits> __x,
		__type_identity_t<basic_string_view<_CharT, _Traits>>
			__y) noexcept
	{
		return !(__x == __y);
	}
	template <class _CharT, class _Traits>
	constexpr bool operator!=(
		__type_identity_t<basic_string_view<_CharT, _Traits>> __x,
		basic_string_view<_CharT, _Traits> __y) noexcept
	{
		return !(__x == __y);
	}
	template <class _CharT, class _Traits>
	constexpr bool operator<(
		basic_string_view<_CharT, _Traits> __x,
		basic_string_view<_CharT, _Traits> __y) noexcept
	{
		return __x.compare(__y) < 0;
	}
	template <class _CharT, class _Traits>
	constexpr bool operator<(
		basic_string_view<_CharT, _Traits> __x,
		__type_identity_t<basic_string_view<_CharT, _Traits>>
			__y) noexcept
	{
		return __x.compare(__y) < 0;
	}
	template <class _CharT, class _Traits>
	constexpr bool operator<(
		__type_identity_t<basic_string_view<_CharT, _Traits>> __x,
		basic_string_view<_CharT, _Traits> __y) noexcept
	{
		return __x.compare(__y) < 0;
	}
	template <class _CharT, class _Traits>
	constexpr bool operator>(
		basic_string_view<_CharT, _Traits> __x,
		basic_string_view<_CharT, _Traits> __y) noexcept
	{
		return __x.compare(__y) > 0;
	}
	template <class _CharT, class _Traits>
	constexpr bool operator>(
		basic_string_view<_CharT, _Traits> __x,
		__type_identity_t<basic_string_view<_CharT, _Traits>>
			__y) noexcept
	{
		return __x.compare(__y) > 0;
	}
	template <class _CharT, class _Traits>
	constexpr bool operator>(
		__type_identity_t<basic_string_view<_CharT, _Traits>> __x,
		basic_string_view<_CharT, _Traits> __y) noexcept
	{
		return __x.compare(__y) > 0;
	}
	template <class _CharT, class _Traits>
	constexpr bool operator<=(
		basic_string_view<_CharT, _Traits> __x,
		basic_string_view<_CharT, _Traits> __y) noexcept
	{
		return __x.compare(__y) <= 0;
	}
	template <class _CharT, class _Traits>
	constexpr bool operator<=(
		basic_string_view<_CharT, _Traits> __x,
		__type_identity_t<basic_string_view<_CharT, _Traits>>
			__y) noexcept
	{
		return __x.compare(__y) <= 0;
	}
	template <class _CharT, class _Traits>
	constexpr bool operator<=(
		__type_identity_t<basic_string_view<_CharT, _Traits>> __x,
		basic_string_view<_CharT, _Traits> __y) noexcept
	{
		return __x.compare(__y) <= 0;
	}
	template <class _CharT, class _Traits>
	constexpr bool operator>=(
		basic_string_view<_CharT, _Traits> __x,
		basic_string_view<_CharT, _Traits> __y) noexcept
	{
		return __x.compare(__y) >= 0;
	}
	template <class _CharT, class _Traits>
	constexpr bool operator>=(
		basic_string_view<_CharT, _Traits> __x,
		__type_identity_t<basic_string_view<_CharT, _Traits>>
			__y) noexcept
	{
		return __x.compare(__y) >= 0;
	}
	template <class _CharT, class _Traits>
	constexpr bool operator>=(
		__type_identity_t<basic_string_view<_CharT, _Traits>> __x,
		basic_string_view<_CharT, _Traits> __y) noexcept
	{
		return __x.compare(__y) >= 0;
	}
	template <class _CharT, class _Traits>
	inline basic_ostream<_CharT, _Traits> &operator<<(
		basic_ostream<_CharT, _Traits> &__os,
		basic_string_view<_CharT, _Traits> __str)
	{
		return __ostream_insert(__os, __str.data(), __str.size());
	}
	using string_view = basic_string_view<char>;
	using wstring_view = basic_string_view<wchar_t>;
	using u16string_view = basic_string_view<char16_t>;
	using u32string_view = basic_string_view<char32_t>;
	template <class _Tp> struct hash;
	template <>
	struct hash<basic_string_view<char>>
		: public __hash_base<unsigned long, basic_string_view<char>> {
		size_t operator()(const string_view &__str) const noexcept
		{
			return std::_Hash_impl::hash(__str.data(),
						     __str.length());
		}
	};
	template <>
	struct __is_fast_hash<hash<basic_string_view<char>>>
		: public false_type {
	};
	template <>
	struct hash<basic_string_view<wchar_t>>
		: public __hash_base<unsigned long, basic_string_view<wchar_t>> {
		size_t operator()(const wstring_view &__s) const noexcept
		{
			return std::_Hash_impl::hash(
				__s.data(), __s.length() * sizeof(wchar_t));
		}
	};
	template <>
	struct __is_fast_hash<hash<basic_string_view<wchar_t>>>
		: public false_type {
	};
	template <>
	struct hash<basic_string_view<char16_t>>
		: public __hash_base<unsigned long, basic_string_view<char16_t>> {
		size_t operator()(const u16string_view &__s) const noexcept
		{
			return std::_Hash_impl::hash(
				__s.data(), __s.length() * sizeof(char16_t));
		}
	};
	template <>
	struct __is_fast_hash<hash<basic_string_view<char16_t>>>
		: public false_type {
	};
	template <>
	struct hash<basic_string_view<char32_t>>
		: public __hash_base<unsigned long, basic_string_view<char32_t>> {
		size_t operator()(const u32string_view &__s) const noexcept
		{
			return std::_Hash_impl::hash(
				__s.data(), __s.length() * sizeof(char32_t));
		}
	};
	template <>
	struct __is_fast_hash<hash<basic_string_view<char32_t>>>
		: public false_type {
	};
	inline namespace literals
	{
	inline namespace string_view_literals
	{
	constexpr basic_string_view<char> operator""sv(const char *__str,
						       size_t __len) noexcept
	{
		return basic_string_view<char>{ __str, __len };
	}
	constexpr basic_string_view<wchar_t> operator""sv(const wchar_t *__str,
							  size_t __len) noexcept
	{
		return basic_string_view<wchar_t>{ __str, __len };
	}
	constexpr basic_string_view<char16_t>
	operator""sv(const char16_t *__str, size_t __len) noexcept
	{
		return basic_string_view<char16_t>{ __str, __len };
	}
	constexpr basic_string_view<char32_t>
	operator""sv(const char32_t *__str, size_t __len) noexcept
	{
		return basic_string_view<char32_t>{ __str, __len };
	}
	} // namespace string_view_literals
	} // namespace literals
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _CharT, class _Traits>
	constexpr typename basic_string_view<_CharT, _Traits>::size_type
	basic_string_view<_CharT, _Traits>::find(const _CharT *__str,
						 size_type __pos, size_type __n)
		const noexcept
	{
		;
		if (__n == (0)) {
			return (__pos <= (_M_len)) ? __pos : npos;
		}
		if (__pos >= (_M_len)) {
			return npos;
		}
		const _CharT __elem0 = __str[0];
		const _CharT *__first = (_M_str) + __pos;
		const _CharT *const __last = (_M_str) + (_M_len);
		size_type __len = (_M_len)-__pos;
		while (__len >= __n) {
			__first = traits_type::find(
				__first, (__len - __n) + (1), __elem0);
			if (!__first) {
				return npos;
			}
			if (traits_type::compare(__first, __str, __n) == 0) {
				return __first - (_M_str);
			}
			__len = (__last - (++__first));
		}
		return npos;
	}
	template <class _CharT, class _Traits>
	constexpr typename basic_string_view<_CharT, _Traits>::size_type
	basic_string_view<_CharT, _Traits>::find(_CharT __c, size_type __pos)
		const noexcept
	{
		size_type __ret = npos;
		if (__pos < (this->_M_len)) {
			const size_type __n = (this->_M_len) - __pos;
			const _CharT *__p = traits_type::find(
				(this->_M_str) + __pos, __n, __c);
			if (__p) {
				__ret = (__p - (this->_M_str));
			}
		}
		return __ret;
	}
	template <class _CharT, class _Traits>
	constexpr typename basic_string_view<_CharT, _Traits>::size_type
	basic_string_view<_CharT, _Traits>::rfind(const _CharT *__str,
						  size_type __pos,
						  size_type __n) const noexcept
	{
		;
		if (__n <= (this->_M_len)) {
			__pos = std::min((size_type)((this->_M_len) - __n),
					 __pos);
			do {
				if (traits_type::compare((this->_M_str) + __pos,
							 __str, __n) == 0) {
					return __pos;
				}
			} while ((__pos--) > (0));
		}
		return npos;
	}
	template <class _CharT, class _Traits>
	constexpr typename basic_string_view<_CharT, _Traits>::size_type
	basic_string_view<_CharT, _Traits>::rfind(_CharT __c, size_type __pos)
		const noexcept
	{
		size_type __size = this->_M_len;
		if (__size > (0)) {
			if ((--__size) > __pos) {
				__size = __pos;
			}
			for (++__size; (__size--) > (0);) {
				if (traits_type::eq((this->_M_str)[__size],
						    __c)) {
					return __size;
				}
			}
		}
		return npos;
	}
	template <class _CharT, class _Traits>
	constexpr typename basic_string_view<_CharT, _Traits>::size_type
	basic_string_view<_CharT, _Traits>::find_first_of(
		const _CharT *__str, size_type __pos, size_type __n)
		const noexcept
	{
		;
		for (; __n && (__pos < (this->_M_len)); ++__pos) {
			const _CharT *__p = traits_type::find(
				__str, __n, (this->_M_str)[__pos]);
			if (__p) {
				return __pos;
			}
		}
		return npos;
	}
	template <class _CharT, class _Traits>
	constexpr typename basic_string_view<_CharT, _Traits>::size_type
	basic_string_view<_CharT, _Traits>::find_last_of(
		const _CharT *__str, size_type __pos, size_type __n)
		const noexcept
	{
		;
		size_type __size = size();
		if (__size && __n) {
			if ((--__size) > __pos) {
				__size = __pos;
			}
			do {
				if (traits_type::find(__str, __n,
						      (this->_M_str)[__size])) {
					return __size;
				}
			} while ((__size--) != (0));
		}
		return npos;
	}
	template <class _CharT, class _Traits>
	constexpr typename basic_string_view<_CharT, _Traits>::size_type
	basic_string_view<_CharT, _Traits>::find_first_not_of(
		const _CharT *__str, size_type __pos, size_type __n)
		const noexcept
	{
		;
		for (; __pos < (this->_M_len); ++__pos) {
			if (!traits_type::find(__str, __n,
					       (this->_M_str)[__pos])) {
				return __pos;
			}
		}
		return npos;
	}
	template <class _CharT, class _Traits>
	constexpr typename basic_string_view<_CharT, _Traits>::size_type
	basic_string_view<_CharT, _Traits>::find_first_not_of(_CharT __c,
							      size_type __pos)
		const noexcept
	{
		for (; __pos < (this->_M_len); ++__pos) {
			if (!traits_type::eq((this->_M_str)[__pos], __c)) {
				return __pos;
			}
		}
		return npos;
	}
	template <class _CharT, class _Traits>
	constexpr typename basic_string_view<_CharT, _Traits>::size_type
	basic_string_view<_CharT, _Traits>::find_last_not_of(
		const _CharT *__str, size_type __pos, size_type __n)
		const noexcept
	{
		;
		size_type __size = this->_M_len;
		if (__size) {
			if ((--__size) > __pos) {
				__size = __pos;
			}
			do {
				if (!traits_type::find(__str, __n,
						       (this->_M_str)[__size])) {
					return __size;
				}
			} while (__size--);
		}
		return npos;
	}
	template <class _CharT, class _Traits>
	constexpr typename basic_string_view<_CharT, _Traits>::size_type
	basic_string_view<_CharT, _Traits>::find_last_not_of(_CharT __c,
							     size_type __pos)
		const noexcept
	{
		size_type __size = this->_M_len;
		if (__size) {
			if ((--__size) > __pos) {
				__size = __pos;
			}
			do {
				if (!traits_type::eq((this->_M_str)[__size],
						     __c)) {
					return __size;
				}
			} while (__size--);
		}
		return npos;
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	inline namespace __cxx11
	{
	template <class _CharT, class _Traits, class _Alloc>
	class basic_string {
		typedef typename __gnu_cxx::__alloc_traits<
			_Alloc>::template rebind<_CharT>::other _Char_alloc_type;
		typedef __gnu_cxx::__alloc_traits<_Char_alloc_type>
			_Alloc_traits;

	    public:
		typedef _Traits traits_type;
		typedef typename _Traits::char_type value_type;
		typedef _Char_alloc_type allocator_type;
		typedef typename __gnu_cxx::__alloc_traits<
			_Char_alloc_type>::size_type size_type;
		typedef typename __gnu_cxx::__alloc_traits<
			_Char_alloc_type>::difference_type difference_type;
		typedef typename __gnu_cxx::__alloc_traits<
			_Char_alloc_type>::reference reference;
		typedef typename __gnu_cxx::__alloc_traits<
			_Char_alloc_type>::const_reference const_reference;
		typedef typename __gnu_cxx::__alloc_traits<
			_Char_alloc_type>::pointer pointer;
		typedef typename __gnu_cxx::__alloc_traits<
			_Char_alloc_type>::const_pointer const_pointer;
		typedef __gnu_cxx::__normal_iterator<pointer, basic_string>
			iterator;
		typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
			const_iterator;
		typedef std::reverse_iterator<const_iterator>
			const_reverse_iterator;
		typedef std::reverse_iterator<iterator> reverse_iterator;
		static const size_type npos = (static_cast<size_type>(-1));

	    protected:
		typedef const_iterator __const_iterator;

	    private:
		typedef basic_string_view<_CharT, _Traits> __sv_type;
		template <class _Tp, class _Res>
		using _If_sv = enable_if_t<
			__and_<is_convertible<const _Tp &, __sv_type>,
			       __not_<is_convertible<const _Tp *,
						     const basic_string *>>,
			       __not_<is_convertible<const _Tp &,
						     const _CharT *>>>::value,
			_Res>;
		static __sv_type _S_to_string_view(__sv_type __svt) noexcept
		{
			return __svt;
		}
		struct __sv_wrapper {
			explicit __sv_wrapper(__sv_type __sv) noexcept
				: _M_sv(__sv)
			{
			}
			__sv_type _M_sv;
		};
		explicit basic_string(__sv_wrapper __svw, const _Alloc &__a)
			: basic_string((__svw._M_sv).data(),
				       (__svw._M_sv).size(), __a)
		{
		}
		struct _Alloc_hider : public allocator_type {
			_Alloc_hider(
				typename basic_string<_CharT, _Traits,
						      _Alloc>::pointer __dat,
				const _Alloc &__a)
				: basic_string<_CharT, _Traits,
					       _Alloc>::allocator_type(__a),
				  _M_p(__dat)
			{
			}
			_Alloc_hider(
				typename basic_string<_CharT, _Traits,
						      _Alloc>::pointer __dat,
				_Alloc &&__a = _Alloc())
				: basic_string<_CharT, _Traits, _Alloc>::
					  allocator_type(std::move(__a)),
				  _M_p(__dat)
			{
			}
			typename basic_string<_CharT, _Traits, _Alloc>::pointer
				_M_p;
		};
		_Alloc_hider _M_dataplus;
		size_type _M_string_length;
		enum { _S_local_capacity = (15) / sizeof(_CharT) };
		union {
			_CharT _M_local_buf[_S_local_capacity + 1];
			size_type _M_allocated_capacity;
		};
		void _M_data(pointer __p)
		{
			((_M_dataplus)._M_p) = __p;
		}
		void _M_length(size_type __length)
		{
			(_M_string_length) = __length;
		}
		pointer _M_data() const
		{
			return (_M_dataplus)._M_p;
		}
		pointer _M_local_data()
		{
			return std::template pointer_traits<pointer>::pointer_to(
				*(_M_local_buf));
		}
		const_pointer _M_local_data() const
		{
			return std::template pointer_traits<
				const_pointer>::pointer_to(*(_M_local_buf));
		}
		void _M_capacity(size_type __capacity)
		{
			(_M_allocated_capacity) = __capacity;
		}
		void _M_set_length(size_type __n)
		{
			_M_length(__n);
			traits_type::assign(_M_data()[__n], _CharT());
		}
		bool _M_is_local() const
		{
			return _M_data() == _M_local_data();
		}
		pointer _M_create(size_type &, size_type);
		void _M_dispose()
		{
			if (!_M_is_local()) {
				_M_destroy(_M_allocated_capacity);
			}
		}
		void _M_destroy(size_type __size) throw()
		{
			_Alloc_traits::deallocate(_M_get_allocator(), _M_data(),
						  __size + 1);
		}
		template <class _InIterator>
		void _M_construct(_InIterator __beg, _InIterator __end,
				  input_iterator_tag);
		template <class _FwdIterator>
		void _M_construct(_FwdIterator __beg, _FwdIterator __end,
				  forward_iterator_tag);
		void _M_construct(size_type __req, _CharT __c);
		allocator_type &_M_get_allocator()
		{
			return _M_dataplus;
		}
		const allocator_type &_M_get_allocator() const
		{
			return _M_dataplus;
		}
		__attribute((__always_inline__)) constexpr pointer
		_M_use_local_data() noexcept
		{
			return _M_local_data();
		}
		size_type _M_check(size_type __pos, const char *__s) const
		{
			if (__pos > size()) {
				__throw_out_of_range_fmt(
					"%s: __pos (which is %zu) > this->size() (which is %zu)",
					__s, __pos, size());
			}
			return __pos;
		}
		void _M_check_length(size_type __n1, size_type __n2,
				     const char *__s) const
		{
			if ((max_size() - (size() - __n1)) < __n2) {
				__throw_length_error(__s);
			}
		}
		size_type _M_limit(size_type __pos,
				   size_type __off) const noexcept
		{
			const bool __testoff = __off < (size() - __pos);
			return __testoff ? __off : (size() - __pos);
		}
		bool _M_disjunct(const _CharT *__s) const noexcept
		{
			return (less<const _CharT *>()(__s, _M_data()) ||
				less<const _CharT *>()(_M_data() + size(),
						       __s));
		}
		static void _S_copy(_CharT *__d, const _CharT *__s,
				    size_type __n)
		{
			if (__n == 1) {
				traits_type::assign(*__d, *__s);
			} else {
				traits_type::copy(__d, __s, __n);
			}
		}
		static void _S_move(_CharT *__d, const _CharT *__s,
				    size_type __n)
		{
			if (__n == 1) {
				traits_type::assign(*__d, *__s);
			} else {
				traits_type::move(__d, __s, __n);
			}
		}
		static void _S_assign(_CharT *__d, size_type __n, _CharT __c)
		{
			if (__n == 1) {
				traits_type::assign(*__d, __c);
			} else {
				traits_type::assign(__d, __n, __c);
			}
		}
		template <class _Iterator>
		static void _S_copy_chars(_CharT *__p, _Iterator __k1,
					  _Iterator __k2)
		{
			for (; __k1 != __k2; (++__k1), ((void)(++__p))) {
				traits_type::assign(*__p, *__k1);
			}
		}
		static void _S_copy_chars(_CharT *__p, iterator __k1,
					  iterator __k2) noexcept
		{
			_S_copy_chars(__p, __k1.base(), __k2.base());
		}
		static void _S_copy_chars(_CharT *__p, const_iterator __k1,
					  const_iterator __k2) noexcept
		{
			_S_copy_chars(__p, __k1.base(), __k2.base());
		}
		static void _S_copy_chars(_CharT *__p, _CharT *__k1,
					  _CharT *__k2) noexcept
		{
			(_S_copy)(__p, __k1, __k2 - __k1);
		}
		static void _S_copy_chars(_CharT *__p, const _CharT *__k1,
					  const _CharT *__k2) noexcept
		{
			(_S_copy)(__p, __k1, __k2 - __k1);
		}
		static int _S_compare(size_type __n1, size_type __n2) noexcept
		{
			const difference_type __d =
				(difference_type)(__n1 - __n2);
			if (__d > __gnu_cxx::__numeric_traits<int>::__max) {
				return __gnu_cxx::__numeric_traits<int>::__max;
			} else {
				if (__d <
				    __gnu_cxx::__numeric_traits<int>::__min) {
					return __gnu_cxx::__numeric_traits<
						int>::__min;
				} else {
					return (int)__d;
				}
			}
		}
		void _M_assign(const basic_string &);
		void _M_mutate(size_type __pos, size_type __len1,
			       const _CharT *__s, size_type __len2);
		void _M_erase(size_type __pos, size_type __n);

	    public:
		basic_string() noexcept(
			is_nothrow_default_constructible<_Alloc>::value)
			: _M_dataplus(_M_local_data())
		{
			_M_use_local_data();
			_M_set_length(0);
		}
		explicit basic_string(const _Alloc &__a) noexcept
			: _M_dataplus(_M_local_data(), __a)
		{
			_M_use_local_data();
			_M_set_length(0);
		}
		basic_string(const basic_string &__str)
			: _M_dataplus(_M_local_data(),
				      _Alloc_traits::_S_select_on_copy(
					      __str._M_get_allocator()))
		{
			_M_construct(__str._M_data(),
				     __str._M_data() + __str.length(),
				     forward_iterator_tag());
		}
		basic_string(const basic_string &__str, size_type __pos,
			     const _Alloc &__a = _Alloc())
			: _M_dataplus(_M_local_data(), __a)
		{
			const _CharT *__start =
				__str._M_data() +
				__str._M_check(__pos,
					       "basic_string::basic_string");
			_M_construct(__start,
				     __start + __str._M_limit(__pos, npos),
				     forward_iterator_tag());
		}
		basic_string(const basic_string &__str, size_type __pos,
			     size_type __n)
			: _M_dataplus(_M_local_data())
		{
			const _CharT *__start =
				__str._M_data() +
				__str._M_check(__pos,
					       "basic_string::basic_string");
			_M_construct(__start,
				     __start + __str._M_limit(__pos, __n),
				     forward_iterator_tag());
		}
		basic_string(const basic_string &__str, size_type __pos,
			     size_type __n, const _Alloc &__a)
			: _M_dataplus(_M_local_data(), __a)
		{
			const _CharT *__start =
				__str._M_data() +
				__str._M_check(__pos, "string::string");
			_M_construct(__start,
				     __start + __str._M_limit(__pos, __n),
				     forward_iterator_tag());
		}
		basic_string(const _CharT *__s, size_type __n,
			     const _Alloc &__a = _Alloc())
			: _M_dataplus(_M_local_data(), __a)
		{
			if ((__s == 0) && (__n > 0)) {
				std::__throw_logic_error(
					"basic_string: construction from null is not valid");
			}
			_M_construct(__s, __s + __n, forward_iterator_tag());
		}
		template <class = _RequireAllocator<_Alloc>>
		basic_string(const _CharT *__s, const _Alloc &__a = _Alloc())
			: _M_dataplus(_M_local_data(), __a)
		{
			if (__s == 0) {
				std::__throw_logic_error(
					"basic_string: construction from null is not valid");
			}
			const _CharT *__end = __s + traits_type::length(__s);
			_M_construct(__s, __end, forward_iterator_tag());
		}
		template <class = _RequireAllocator<_Alloc>>
		basic_string(size_type __n, _CharT __c,
			     const _Alloc &__a = _Alloc())
			: _M_dataplus(_M_local_data(), __a)
		{
			_M_construct(__n, __c);
		}
		basic_string(basic_string &&__str) noexcept
			: _M_dataplus(_M_local_data(),
				      std::move(__str._M_get_allocator()))
		{
			if (__str._M_is_local()) {
				traits_type::copy(_M_local_buf,
						  __str._M_local_buf,
						  __str.length() + 1);
			} else {
				_M_data(__str._M_data());
				_M_capacity(__str._M_allocated_capacity);
			}
			_M_length(__str.length());
			__str._M_data(__str._M_local_data());
			__str._M_set_length(0);
		}
		basic_string(initializer_list<_CharT> __l,
			     const _Alloc &__a = _Alloc())
			: _M_dataplus(_M_local_data(), __a)
		{
			_M_construct(__l.begin(), __l.end(),
				     forward_iterator_tag());
		}
		basic_string(const basic_string &__str, const _Alloc &__a)
			: _M_dataplus(_M_local_data(), __a)
		{
			_M_construct(__str.begin(), __str.end(),
				     forward_iterator_tag());
		}
		basic_string(basic_string &&__str, const _Alloc &__a) noexcept(
			_Alloc_traits::_S_always_equal())
			: _M_dataplus(_M_local_data(), __a)
		{
			if (__str._M_is_local()) {
				traits_type::copy(_M_local_buf,
						  __str._M_local_buf,
						  __str.length() + 1);
				_M_length(__str.length());
				__str._M_set_length(0);
			} else {
				if (_Alloc_traits::_S_always_equal() ||
				    (__str.get_allocator() == __a)) {
					_M_data(__str._M_data());
					_M_length(__str.length());
					_M_capacity(
						__str._M_allocated_capacity);
					__str._M_data(__str._M_local_buf);
					__str._M_set_length(0);
				} else {
					_M_construct(__str.begin(), __str.end(),
						     forward_iterator_tag());
				}
			}
		}
		template <class _InputIterator,
			  class = _RequireInputIter<_InputIterator>>
		basic_string(_InputIterator __beg, _InputIterator __end,
			     const _Alloc &__a = _Alloc())
			: _M_dataplus(_M_local_data(), __a)
		{
			_M_construct(__beg, __end,
				     std::__iterator_category(__beg));
		}
		template <class _Tp, class = enable_if_t<is_convertible_v<
					     const _Tp &, __sv_type>>>
		basic_string(const _Tp &__t, size_type __pos, size_type __n,
			     const _Alloc &__a = _Alloc())
			: basic_string((_S_to_string_view)(__t).substr(__pos,
								       __n),
				       __a)
		{
		}
		template <class _Tp, class = _If_sv<_Tp, void>>
		explicit basic_string(const _Tp &__t,
				      const _Alloc &__a = _Alloc())
			: basic_string((__sv_wrapper)(_S_to_string_view)(__t),
				       __a)
		{
		}
		~basic_string()
		{
			_M_dispose();
		}
		basic_string &operator=(const basic_string &__str)
		{
			return this->assign(__str);
		}
		basic_string &operator=(const _CharT *__s)
		{
			return this->assign(__s);
		}
		basic_string &operator=(_CharT __c)
		{
			this->assign(1, __c);
			return *this;
		}
		basic_string &operator=(basic_string &&__str) noexcept(
			_Alloc_traits::_S_nothrow_move())
		{
			if ((!_M_is_local()) &&
			    _Alloc_traits::_S_propagate_on_move_assign() &&
			    (!_Alloc_traits::_S_always_equal()) &&
			    (_M_get_allocator() != __str._M_get_allocator())) {
				_M_destroy(_M_allocated_capacity);
				_M_data(_M_local_data());
				_M_set_length(0);
			}
			std::__alloc_on_move(_M_get_allocator(),
					     __str._M_get_allocator());
			if (__str._M_is_local()) {
				if (__builtin_expect(std::__addressof(__str) !=
							     this,
						     true)) {
					if (__str.size()) {
						this->_S_copy(_M_data(),
							      __str._M_data(),
							      __str.size());
					}
					_M_set_length(__str.size());
				}
			} else {
				if ((_Alloc_traits::_S_propagate_on_move_assign() ||
				     _Alloc_traits::_S_always_equal()) ||
				    (_M_get_allocator() ==
				     __str._M_get_allocator())) {
					pointer __data = (nullptr);
					size_type __capacity;
					if (!_M_is_local()) {
						if (_Alloc_traits::
							    _S_always_equal()) {
							__data = _M_data();
							__capacity =
								(_M_allocated_capacity);
						} else {
							_M_destroy(
								_M_allocated_capacity);
						}
					}
					_M_data(__str._M_data());
					_M_length(__str.length());
					_M_capacity(
						__str._M_allocated_capacity);
					if (__data) {
						__str._M_data(__data);
						__str._M_capacity(__capacity);
					} else {
						__str._M_data(
							__str._M_local_buf);
					}
				} else {
					assign(__str);
				}
			}
			__str.clear();
			return *this;
		}
		basic_string &operator=(initializer_list<_CharT> __l)
		{
			this->assign(__l.begin(), __l.size());
			return *this;
		}
		template <class _Tp>
		_If_sv<_Tp, basic_string &> operator=(const _Tp &__svt)
		{
			return this->assign(__svt);
		}
		operator __sv_type() const noexcept
		{
			return __sv_type(data(), size());
		}
		iterator begin() noexcept
		{
			return ((__gnu_cxx::__normal_iterator<
				 pointer, basic_string>)(_M_data()));
		}
		const_iterator begin() const noexcept
		{
			return ((__gnu_cxx::__normal_iterator<
				 const_pointer, basic_string>)(_M_data()));
		}
		iterator end() noexcept
		{
			return ((__gnu_cxx::__normal_iterator<
				 pointer, basic_string>)(_M_data() + size()));
		}
		const_iterator end() const noexcept
		{
			return ((__gnu_cxx::__normal_iterator<
				 const_pointer, basic_string>)(_M_data() +
							       size()));
		}
		reverse_iterator rbegin() noexcept
		{
			return ((std::reverse_iterator<iterator>)(this->end()));
		}
		const_reverse_iterator rbegin() const noexcept
		{
			return ((std::reverse_iterator<
				 const_iterator>)(this->end()));
		}
		reverse_iterator rend() noexcept
		{
			return ((
				std::reverse_iterator<iterator>)(this->begin()));
		}
		const_reverse_iterator rend() const noexcept
		{
			return ((std::reverse_iterator<
				 const_iterator>)(this->begin()));
		}
		const_iterator cbegin() const noexcept
		{
			return ((__gnu_cxx::__normal_iterator<
				 const_pointer, basic_string>)(this->_M_data()));
		}
		const_iterator cend() const noexcept
		{
			return ((__gnu_cxx::__normal_iterator<
				 const_pointer, basic_string>)(this->_M_data() +
							       size()));
		}
		const_reverse_iterator crbegin() const noexcept
		{
			return ((std::reverse_iterator<
				 const_iterator>)(this->end()));
		}
		const_reverse_iterator crend() const noexcept
		{
			return ((std::reverse_iterator<
				 const_iterator>)(this->begin()));
		}
		size_type size() const noexcept
		{
			return _M_string_length;
		}
		size_type length() const noexcept
		{
			return _M_string_length;
		}
		size_type max_size() const noexcept
		{
			return (_Alloc_traits::max_size(_M_get_allocator()) -
				1) /
			       2;
		}
		void resize(size_type __n, _CharT __c);
		void resize(size_type __n)
		{
			this->resize(__n, _CharT());
		}
		void shrink_to_fit() noexcept
		{
			reserve();
		}
		size_type capacity() const noexcept
		{
			return (_M_is_local()) ? (size_type)_S_local_capacity :
						 (_M_allocated_capacity);
		}
		void reserve(size_type __res_arg);
		void reserve();
		void clear() noexcept
		{
			_M_set_length(0);
		}
		[[__nodiscard__]] bool empty() const noexcept
		{
			return size() == 0;
		}
		const_reference operator[](size_type __pos) const noexcept
		{
			do {
				if (std::__is_constant_evaluated() &&
				    (!((bool)(__pos <= size())))) {
					__builtin_unreachable();
				}
			} while (false);
			return _M_data()[__pos];
		}
		reference operator[](size_type __pos)
		{
			do {
				if (std::__is_constant_evaluated() &&
				    (!((bool)(__pos <= size())))) {
					__builtin_unreachable();
				}
			} while (false);
			;
			return _M_data()[__pos];
		}
		const_reference at(size_type __n) const
		{
			if (__n >= size()) {
				__throw_out_of_range_fmt(
					"basic_string::at: __n (which is %zu) >= this->size() (which is %zu)",
					__n, size());
			}
			return _M_data()[__n];
		}
		reference at(size_type __n)
		{
			if (__n >= size()) {
				__throw_out_of_range_fmt(
					"basic_string::at: __n (which is %zu) >= this->size() (which is %zu)",
					__n, size());
			}
			return _M_data()[__n];
		}
		reference front() noexcept
		{
			do {
				if (std::__is_constant_evaluated() &&
				    (!((bool)(!empty())))) {
					__builtin_unreachable();
				}
			} while (false);
			return operator[](0);
		}
		const_reference front() const noexcept
		{
			do {
				if (std::__is_constant_evaluated() &&
				    (!((bool)(!empty())))) {
					__builtin_unreachable();
				}
			} while (false);
			return operator[](0);
		}
		reference back() noexcept
		{
			do {
				if (std::__is_constant_evaluated() &&
				    (!((bool)(!empty())))) {
					__builtin_unreachable();
				}
			} while (false);
			return operator[](size() - 1);
		}
		const_reference back() const noexcept
		{
			do {
				if (std::__is_constant_evaluated() &&
				    (!((bool)(!empty())))) {
					__builtin_unreachable();
				}
			} while (false);
			return operator[](size() - 1);
		}
		basic_string &operator+=(const basic_string &__str)
		{
			return this->append(__str);
		}
		basic_string &operator+=(const _CharT *__s)
		{
			return this->append(__s);
		}
		basic_string &operator+=(_CharT __c)
		{
			push_back(__c);
			return *this;
		}
		basic_string &operator+=(initializer_list<_CharT> __l)
		{
			return this->append(__l.begin(), __l.size());
		}
		template <class _Tp>
		_If_sv<_Tp, basic_string &> operator+=(const _Tp &__svt)
		{
			return this->append(__svt);
		}
		basic_string &append(const basic_string &__str)
		{
			return this->append(__str._M_data(), __str.size());
		}
		basic_string &append(const basic_string &__str, size_type __pos,
				     size_type __n = npos)
		{
			return this->append(
				__str._M_data() +
					__str._M_check(__pos,
						       "basic_string::append"),
				__str._M_limit(__pos, __n));
		}
		basic_string &append(const _CharT *__s, size_type __n)
		{
			;
			_M_check_length((size_type)0, __n,
					"basic_string::append");
			return _M_append(__s, __n);
		}
		basic_string &append(const _CharT *__s)
		{
			;
			const size_type __n = traits_type::length(__s);
			_M_check_length((size_type)0, __n,
					"basic_string::append");
			return _M_append(__s, __n);
		}
		basic_string &append(size_type __n, _CharT __c)
		{
			return _M_replace_aux(size(), (size_type)0, __n, __c);
		}
		basic_string &append(initializer_list<_CharT> __l)
		{
			return this->append(__l.begin(), __l.size());
		}
		template <class _InputIterator,
			  class = _RequireInputIter<_InputIterator>>
		basic_string &append(_InputIterator __first,
				     _InputIterator __last)
		{
			return this->replace(end(), end(), __first, __last);
		}
		template <class _Tp>
		_If_sv<_Tp, basic_string &> append(const _Tp &__svt)
		{
			__sv_type __sv = __svt;
			return this->append(__sv.data(), __sv.size());
		}
		template <class _Tp>
		_If_sv<_Tp, basic_string &>
		append(const _Tp &__svt, size_type __pos, size_type __n = npos)
		{
			__sv_type __sv = __svt;
			return _M_append(
				__sv.data() +
					std::__sv_check(__sv.size(), __pos,
							"basic_string::append"),
				std::__sv_limit(__sv.size(), __pos, __n));
		}
		void push_back(_CharT __c)
		{
			const size_type __size = size();
			if ((__size + 1) > capacity()) {
				_M_mutate(__size, (size_type)0, 0,
					  (size_type)1);
			}
			traits_type::assign(this->_M_data()[__size], __c);
			_M_set_length(__size + 1);
		}
		basic_string &assign(const basic_string &__str)
		{
			if (_Alloc_traits::_S_propagate_on_copy_assign()) {
				if ((!_Alloc_traits::_S_always_equal()) &&
				    (!_M_is_local()) &&
				    (_M_get_allocator() !=
				     __str._M_get_allocator())) {
					if (__str.size() <= _S_local_capacity) {
						_M_destroy(
							_M_allocated_capacity);
						_M_data(_M_use_local_data());
						_M_set_length(0);
					} else {
						const auto __len = __str.size();
						auto __alloc =
							__str._M_get_allocator();
						auto __ptr =
							_Alloc_traits::allocate(
								__alloc,
								__len + 1);
						_M_destroy(
							_M_allocated_capacity);
						_M_data(__ptr);
						_M_capacity(__len);
						_M_set_length(__len);
					}
				}
				std::__alloc_on_copy(_M_get_allocator(),
						     __str._M_get_allocator());
			}
			_M_assign(__str);
			return *this;
		}
		basic_string &assign(basic_string &&__str) noexcept(
			_Alloc_traits::_S_nothrow_move())
		{
			return (*this) = std::move(__str);
		}
		basic_string &assign(const basic_string &__str, size_type __pos,
				     size_type __n = npos)
		{
			return _M_replace(
				(size_type)0, size(),
				__str._M_data() +
					__str._M_check(__pos,
						       "basic_string::assign"),
				__str._M_limit(__pos, __n));
		}
		basic_string &assign(const _CharT *__s, size_type __n)
		{
			;
			return _M_replace((size_type)0, size(), __s, __n);
		}
		basic_string &assign(const _CharT *__s)
		{
			;
			return _M_replace((size_type)0, size(), __s,
					  traits_type::length(__s));
		}
		basic_string &assign(size_type __n, _CharT __c)
		{
			return _M_replace_aux((size_type)0, size(), __n, __c);
		}
		template <class _InputIterator,
			  class = _RequireInputIter<_InputIterator>>
		basic_string &assign(_InputIterator __first,
				     _InputIterator __last)
		{
			return this->replace(begin(), end(), __first, __last);
		}
		basic_string &assign(initializer_list<_CharT> __l)
		{
			return this->assign(__l.begin(), __l.size());
		}
		template <class _Tp>
		_If_sv<_Tp, basic_string &> assign(const _Tp &__svt)
		{
			__sv_type __sv = __svt;
			return this->assign(__sv.data(), __sv.size());
		}
		template <class _Tp>
		_If_sv<_Tp, basic_string &>
		assign(const _Tp &__svt, size_type __pos, size_type __n = npos)
		{
			__sv_type __sv = __svt;
			return _M_replace(
				(size_type)0, size(),
				__sv.data() +
					std::__sv_check(__sv.size(), __pos,
							"basic_string::assign"),
				std::__sv_limit(__sv.size(), __pos, __n));
		}
		iterator insert(const_iterator __p, size_type __n, _CharT __c)
		{
			;
			const size_type __pos = __p - begin();
			this->replace(__p, __p, __n, __c);
			return ((__gnu_cxx::__normal_iterator<
				 pointer, basic_string>)(this->_M_data() +
							 __pos));
		}
		template <class _InputIterator,
			  class = _RequireInputIter<_InputIterator>>
		iterator insert(const_iterator __p, _InputIterator __beg,
				_InputIterator __end)
		{
			;
			const size_type __pos = __p - begin();
			this->replace(__p, __p, __beg, __end);
			return ((__gnu_cxx::__normal_iterator<
				 pointer, basic_string>)(this->_M_data() +
							 __pos));
		}
		iterator insert(const_iterator __p,
				initializer_list<_CharT> __l)
		{
			return this->insert(__p, __l.begin(), __l.end());
		}
		basic_string &insert(size_type __pos1,
				     const basic_string &__str)
		{
			return this->replace(__pos1, (size_type)0,
					     __str._M_data(), __str.size());
		}
		basic_string &insert(size_type __pos1,
				     const basic_string &__str,
				     size_type __pos2, size_type __n = npos)
		{
			return this->replace(
				__pos1, (size_type)0,
				__str._M_data() +
					__str._M_check(__pos2,
						       "basic_string::insert"),
				__str._M_limit(__pos2, __n));
		}
		basic_string &insert(size_type __pos, const _CharT *__s,
				     size_type __n)
		{
			return this->replace(__pos, (size_type)0, __s, __n);
		}
		basic_string &insert(size_type __pos, const _CharT *__s)
		{
			;
			return this->replace(__pos, (size_type)0, __s,
					     traits_type::length(__s));
		}
		basic_string &insert(size_type __pos, size_type __n, _CharT __c)
		{
			return _M_replace_aux(_M_check(__pos,
						       "basic_string::insert"),
					      (size_type)0, __n, __c);
		}
		iterator insert(__const_iterator __p, _CharT __c)
		{
			;
			const size_type __pos = __p - begin();
			_M_replace_aux(__pos, (size_type)0, (size_type)1, __c);
			return ((__gnu_cxx::__normal_iterator<
				 pointer, basic_string>)(_M_data() + __pos));
		}
		template <class _Tp>
		_If_sv<_Tp, basic_string &> insert(size_type __pos,
						   const _Tp &__svt)
		{
			__sv_type __sv = __svt;
			return this->insert(__pos, __sv.data(), __sv.size());
		}
		template <class _Tp>
		_If_sv<_Tp, basic_string &>
		insert(size_type __pos1, const _Tp &__svt, size_type __pos2,
		       size_type __n = npos)
		{
			__sv_type __sv = __svt;
			return this->replace(
				__pos1, (size_type)0,
				__sv.data() +
					std::__sv_check(__sv.size(), __pos2,
							"basic_string::insert"),
				std::__sv_limit(__sv.size(), __pos2, __n));
		}
		basic_string &erase(size_type __pos = 0, size_type __n = npos)
		{
			_M_check(__pos, "basic_string::erase");
			if (__n == npos) {
				_M_set_length(__pos);
			} else {
				if (__n != 0) {
					_M_erase(__pos, _M_limit(__pos, __n));
				}
			}
			return *this;
		}
		iterator erase(__const_iterator __position)
		{
			;
			const size_type __pos = __position - begin();
			_M_erase(__pos, (size_type)1);
			return ((__gnu_cxx::__normal_iterator<
				 pointer, basic_string>)(_M_data() + __pos));
		}
		iterator erase(__const_iterator __first,
			       __const_iterator __last)
		{
			;
			const size_type __pos = __first - begin();
			if (__last == end()) {
				_M_set_length(__pos);
			} else {
				_M_erase(__pos, __last - __first);
			}
			return ((__gnu_cxx::__normal_iterator<
				 pointer, basic_string>)(this->_M_data() +
							 __pos));
		}
		void pop_back() noexcept
		{
			do {
				if (std::__is_constant_evaluated() &&
				    (!((bool)(!empty())))) {
					__builtin_unreachable();
				}
			} while (false);
			_M_erase(size() - 1, 1);
		}
		basic_string &replace(size_type __pos, size_type __n,
				      const basic_string &__str)
		{
			return this->replace(__pos, __n, __str._M_data(),
					     __str.size());
		}
		basic_string &replace(size_type __pos1, size_type __n1,
				      const basic_string &__str,
				      size_type __pos2, size_type __n2 = npos)
		{
			return this->replace(
				__pos1, __n1,
				__str._M_data() +
					__str._M_check(__pos2,
						       "basic_string::replace"),
				__str._M_limit(__pos2, __n2));
		}
		basic_string &replace(size_type __pos, size_type __n1,
				      const _CharT *__s, size_type __n2)
		{
			;
			return _M_replace(_M_check(__pos,
						   "basic_string::replace"),
					  _M_limit(__pos, __n1), __s, __n2);
		}
		basic_string &replace(size_type __pos, size_type __n1,
				      const _CharT *__s)
		{
			;
			return this->replace(__pos, __n1, __s,
					     traits_type::length(__s));
		}
		basic_string &replace(size_type __pos, size_type __n1,
				      size_type __n2, _CharT __c)
		{
			return _M_replace_aux(_M_check(__pos,
						       "basic_string::replace"),
					      _M_limit(__pos, __n1), __n2, __c);
		}
		basic_string &replace(__const_iterator __i1,
				      __const_iterator __i2,
				      const basic_string &__str)
		{
			return this->replace(__i1, __i2, __str._M_data(),
					     __str.size());
		}
		basic_string &replace(__const_iterator __i1,
				      __const_iterator __i2, const _CharT *__s,
				      size_type __n)
		{
			;
			return this->replace(__i1 - begin(), __i2 - __i1, __s,
					     __n);
		}
		basic_string &replace(__const_iterator __i1,
				      __const_iterator __i2, const _CharT *__s)
		{
			;
			return this->replace(__i1, __i2, __s,
					     traits_type::length(__s));
		}
		basic_string &replace(__const_iterator __i1,
				      __const_iterator __i2, size_type __n,
				      _CharT __c)
		{
			;
			return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n,
					      __c);
		}
		template <class _InputIterator,
			  class = _RequireInputIter<_InputIterator>>
		basic_string &replace(const_iterator __i1, const_iterator __i2,
				      _InputIterator __k1, _InputIterator __k2)
		{
			;
			;
			return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
							 __false_type());
		}
		basic_string &replace(__const_iterator __i1,
				      __const_iterator __i2, _CharT *__k1,
				      _CharT *__k2)
		{
			;
			;
			return this->replace(__i1 - begin(), __i2 - __i1, __k1,
					     __k2 - __k1);
		}
		basic_string &replace(__const_iterator __i1,
				      __const_iterator __i2, const _CharT *__k1,
				      const _CharT *__k2)
		{
			;
			;
			return this->replace(__i1 - begin(), __i2 - __i1, __k1,
					     __k2 - __k1);
		}
		basic_string &replace(__const_iterator __i1,
				      __const_iterator __i2, iterator __k1,
				      iterator __k2)
		{
			;
			;
			return this->replace(__i1 - begin(), __i2 - __i1,
					     __k1.base(), __k2 - __k1);
		}
		basic_string &replace(__const_iterator __i1,
				      __const_iterator __i2,
				      const_iterator __k1, const_iterator __k2)
		{
			;
			;
			return this->replace(__i1 - begin(), __i2 - __i1,
					     __k1.base(), __k2 - __k1);
		}
		basic_string &replace(const_iterator __i1, const_iterator __i2,
				      initializer_list<_CharT> __l)
		{
			return this->replace(__i1, __i2, __l.begin(),
					     __l.size());
		}
		template <class _Tp>
		_If_sv<_Tp, basic_string &>
		replace(size_type __pos, size_type __n, const _Tp &__svt)
		{
			__sv_type __sv = __svt;
			return this->replace(__pos, __n, __sv.data(),
					     __sv.size());
		}
		template <class _Tp>
		_If_sv<_Tp, basic_string &>
		replace(size_type __pos1, size_type __n1, const _Tp &__svt,
			size_type __pos2, size_type __n2 = npos)
		{
			__sv_type __sv = __svt;
			return this->replace(
				__pos1, __n1,
				__sv.data() + std::__sv_check(
						      __sv.size(), __pos2,
						      "basic_string::replace"),
				std::__sv_limit(__sv.size(), __pos2, __n2));
		}
		template <class _Tp>
		_If_sv<_Tp, basic_string &> replace(const_iterator __i1,
						    const_iterator __i2,
						    const _Tp &__svt)
		{
			__sv_type __sv = __svt;
			return this->replace(__i1 - begin(), __i2 - __i1, __sv);
		}

	    private:
		template <class _Integer>
		basic_string &
		_M_replace_dispatch(const_iterator __i1, const_iterator __i2,
				    _Integer __n, _Integer __val, __true_type)
		{
			return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n,
					      __val);
		}
		template <class _InputIterator>
		basic_string &
		_M_replace_dispatch(const_iterator __i1, const_iterator __i2,
				    _InputIterator __k1, _InputIterator __k2,
				    __false_type);
		basic_string &_M_replace_aux(size_type __pos1, size_type __n1,
					     size_type __n2, _CharT __c);
		basic_string &_M_replace(size_type __pos, size_type __len1,
					 const _CharT *__s,
					 const size_type __len2);
		basic_string &_M_append(const _CharT *__s, size_type __n);

	    public:
		size_type copy(_CharT *__s, size_type __n,
			       size_type __pos = 0) const;
		void swap(basic_string &__s) noexcept;
		const _CharT *c_str() const noexcept
		{
			return _M_data();
		}
		const _CharT *data() const noexcept
		{
			return _M_data();
		}
		_CharT *data() noexcept
		{
			return _M_data();
		}
		allocator_type get_allocator() const noexcept
		{
			return _M_get_allocator();
		}
		size_type find(const _CharT *__s, size_type __pos,
			       size_type __n) const noexcept;
		size_type find(const basic_string &__str,
			       size_type __pos = 0) const noexcept
		{
			return this->find(__str.data(), __pos, __str.size());
		}
		template <class _Tp>
		_If_sv<_Tp, size_type> find(const _Tp &__svt,
					    size_type __pos = 0) const
			noexcept(is_same<_Tp, __sv_type>::value)
		{
			__sv_type __sv = __svt;
			return this->find(__sv.data(), __pos, __sv.size());
		}
		size_type find(const _CharT *__s,
			       size_type __pos = 0) const noexcept
		{
			;
			return this->find(__s, __pos, traits_type::length(__s));
		}
		size_type find(_CharT __c, size_type __pos = 0) const noexcept;
		size_type rfind(const basic_string &__str,
				size_type __pos = npos) const noexcept
		{
			return this->rfind(__str.data(), __pos, __str.size());
		}
		template <class _Tp>
		_If_sv<_Tp, size_type> rfind(const _Tp &__svt,
					     size_type __pos = npos) const
			noexcept(is_same<_Tp, __sv_type>::value)
		{
			__sv_type __sv = __svt;
			return this->rfind(__sv.data(), __pos, __sv.size());
		}
		size_type rfind(const _CharT *__s, size_type __pos,
				size_type __n) const noexcept;
		size_type rfind(const _CharT *__s, size_type __pos = npos) const
		{
			;
			return this->rfind(__s, __pos,
					   traits_type::length(__s));
		}
		size_type rfind(_CharT __c,
				size_type __pos = npos) const noexcept;
		size_type find_first_of(const basic_string &__str,
					size_type __pos = 0) const noexcept
		{
			return this->find_first_of(__str.data(), __pos,
						   __str.size());
		}
		template <class _Tp>
		_If_sv<_Tp, size_type> find_first_of(const _Tp &__svt,
						     size_type __pos = 0) const
			noexcept(is_same<_Tp, __sv_type>::value)
		{
			__sv_type __sv = __svt;
			return this->find_first_of(__sv.data(), __pos,
						   __sv.size());
		}
		size_type find_first_of(const _CharT *__s, size_type __pos,
					size_type __n) const noexcept;
		size_type find_first_of(const _CharT *__s,
					size_type __pos = 0) const noexcept
		{
			;
			return this->find_first_of(__s, __pos,
						   traits_type::length(__s));
		}
		size_type find_first_of(_CharT __c,
					size_type __pos = 0) const noexcept
		{
			return this->find(__c, __pos);
		}
		size_type find_last_of(const basic_string &__str,
				       size_type __pos = npos) const noexcept
		{
			return this->find_last_of(__str.data(), __pos,
						  __str.size());
		}
		template <class _Tp>
		_If_sv<_Tp, size_type>
		find_last_of(const _Tp &__svt, size_type __pos = npos) const
			noexcept(is_same<_Tp, __sv_type>::value)
		{
			__sv_type __sv = __svt;
			return this->find_last_of(__sv.data(), __pos,
						  __sv.size());
		}
		size_type find_last_of(const _CharT *__s, size_type __pos,
				       size_type __n) const noexcept;
		size_type find_last_of(const _CharT *__s,
				       size_type __pos = npos) const noexcept
		{
			;
			return this->find_last_of(__s, __pos,
						  traits_type::length(__s));
		}
		size_type find_last_of(_CharT __c,
				       size_type __pos = npos) const noexcept
		{
			return this->rfind(__c, __pos);
		}
		size_type find_first_not_of(const basic_string &__str,
					    size_type __pos = 0) const noexcept
		{
			return this->find_first_not_of(__str.data(), __pos,
						       __str.size());
		}
		template <class _Tp>
		_If_sv<_Tp, size_type>
		find_first_not_of(const _Tp &__svt, size_type __pos = 0) const
			noexcept(is_same<_Tp, __sv_type>::value)
		{
			__sv_type __sv = __svt;
			return this->find_first_not_of(__sv.data(), __pos,
						       __sv.size());
		}
		size_type find_first_not_of(const _CharT *__s, size_type __pos,
					    size_type __n) const noexcept;
		size_type find_first_not_of(const _CharT *__s,
					    size_type __pos = 0) const noexcept
		{
			;
			return this->find_first_not_of(
				__s, __pos, traits_type::length(__s));
		}
		size_type find_first_not_of(_CharT __c,
					    size_type __pos = 0) const noexcept;
		size_type
		find_last_not_of(const basic_string &__str,
				 size_type __pos = npos) const noexcept
		{
			return this->find_last_not_of(__str.data(), __pos,
						      __str.size());
		}
		template <class _Tp>
		_If_sv<_Tp, size_type>
		find_last_not_of(const _Tp &__svt, size_type __pos = npos) const
			noexcept(is_same<_Tp, __sv_type>::value)
		{
			__sv_type __sv = __svt;
			return this->find_last_not_of(__sv.data(), __pos,
						      __sv.size());
		}
		size_type find_last_not_of(const _CharT *__s, size_type __pos,
					   size_type __n) const noexcept;
		size_type
		find_last_not_of(const _CharT *__s,
				 size_type __pos = npos) const noexcept
		{
			;
			return this->find_last_not_of(__s, __pos,
						      traits_type::length(__s));
		}
		size_type
		find_last_not_of(_CharT __c,
				 size_type __pos = npos) const noexcept;
		basic_string substr(size_type __pos = 0,
				    size_type __n = npos) const
		{
			return basic_string(
				*this, _M_check(__pos, "basic_string::substr"),
				__n);
		}
		int compare(const basic_string &__str) const
		{
			const size_type __size = size();
			const size_type __osize = __str.size();
			const size_type __len = std::min(__size, __osize);
			int __r = traits_type::compare(_M_data(), __str.data(),
						       __len);
			if (!__r) {
				__r = (_S_compare)(__size, __osize);
			}
			return __r;
		}
		template <class _Tp>
		_If_sv<_Tp, int> compare(const _Tp &__svt) const
			noexcept(is_same<_Tp, __sv_type>::value)
		{
			__sv_type __sv = __svt;
			const size_type __size = size();
			const size_type __osize = __sv.size();
			const size_type __len = std::min(__size, __osize);
			int __r = traits_type::compare(_M_data(), __sv.data(),
						       __len);
			if (!__r) {
				__r = (_S_compare)(__size, __osize);
			}
			return __r;
		}
		template <class _Tp>
		_If_sv<_Tp, int> compare(size_type __pos, size_type __n,
					 const _Tp &__svt) const
			noexcept(is_same<_Tp, __sv_type>::value)
		{
			__sv_type __sv = __svt;
			return ((basic_string_view<_CharT, _Traits>)(*this))
				.substr(__pos, __n)
				.compare(__sv);
		}
		template <class _Tp>
		_If_sv<_Tp, int> compare(size_type __pos1, size_type __n1,
					 const _Tp &__svt, size_type __pos2,
					 size_type __n2 = npos) const
			noexcept(is_same<_Tp, __sv_type>::value)
		{
			__sv_type __sv = __svt;
			return ((basic_string_view<_CharT, _Traits>)(*this))
				.substr(__pos1, __n1)
				.compare(__sv.substr(__pos2, __n2));
		}
		int compare(size_type __pos, size_type __n,
			    const basic_string &__str) const;
		int compare(size_type __pos1, size_type __n1,
			    const basic_string &__str, size_type __pos2,
			    size_type __n2 = npos) const;
		int compare(const _CharT *__s) const noexcept;
		int compare(size_type __pos, size_type __n1,
			    const _CharT *__s) const;
		int compare(size_type __pos, size_type __n1, const _CharT *__s,
			    size_type __n2) const;
		template <class, class, class> friend class basic_stringbuf;
	};
	} // namespace __cxx11
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	inline namespace __cxx11
	{
	template <class _InputIterator,
		  class _CharT =
			  typename iterator_traits<_InputIterator>::value_type,
		  class _Allocator = allocator<_CharT>,
		  class = _RequireInputIter<_InputIterator>,
		  class = _RequireAllocator<_Allocator>>
	basic_string(_InputIterator, _InputIterator, _Allocator = _Allocator())
		-> basic_string<_CharT, char_traits<_CharT>, _Allocator>;
	template <class _CharT, class _Traits,
		  class _Allocator = allocator<_CharT>,
		  class = _RequireAllocator<_Allocator>>
	basic_string(basic_string_view<_CharT, _Traits>,
		     const _Allocator & = _Allocator())
		-> basic_string<_CharT, _Traits, _Allocator>;
	template <class _CharT, class _Traits,
		  class _Allocator = allocator<_CharT>,
		  class = _RequireAllocator<_Allocator>>
	basic_string(
		basic_string_view<_CharT, _Traits>,
		typename basic_string<_CharT, _Traits, _Allocator>::size_type,
		typename basic_string<_CharT, _Traits, _Allocator>::size_type,
		const _Allocator & = _Allocator())
		-> basic_string<_CharT, _Traits, _Allocator>;
	} // namespace __cxx11
	template <class _CharT, class _Traits, class _Alloc>
	__cxx11::basic_string<_CharT, _Traits, _Alloc> operator+(
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs,
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
	{
		__cxx11::basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
		__str.append(__rhs);
		return __str;
	}
	template <class _CharT, class _Traits, class _Alloc>
	__cxx11::basic_string<_CharT, _Traits, _Alloc> operator+(
		const _CharT *__lhs,
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
	template <class _CharT, class _Traits, class _Alloc>
	__cxx11::basic_string<_CharT, _Traits, _Alloc> operator+(
		_CharT __lhs,
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
	template <class _CharT, class _Traits, class _Alloc>
	inline __cxx11::basic_string<_CharT, _Traits, _Alloc> operator+(
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs,
		const _CharT *__rhs)
	{
		__cxx11::basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
		__str.append(__rhs);
		return __str;
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline __cxx11::basic_string<_CharT, _Traits, _Alloc> operator+(
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs,
		_CharT __rhs)
	{
		typedef __cxx11::basic_string<_CharT, _Traits, _Alloc>
			__string_type;
		typedef typename __cxx11::basic_string<
			_CharT, _Traits, _Alloc>::size_type __size_type;
		__string_type __str(__lhs);
		__str.append((__size_type)1, __rhs);
		return __str;
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline __cxx11::basic_string<_CharT, _Traits, _Alloc> operator+(
		__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__lhs,
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
	{
		return std::move(__lhs.append(__rhs));
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline __cxx11::basic_string<_CharT, _Traits, _Alloc> operator+(
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs,
		__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__rhs)
	{
		return std::move(__rhs.insert(0, __lhs));
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline __cxx11::basic_string<_CharT, _Traits, _Alloc> operator+(
		__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__lhs,
		__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__rhs)
	{
		using _Alloc_traits = allocator_traits<_Alloc>;
		bool __use_rhs = false;
		if constexpr (typename allocator_traits<
				      _Alloc>::is_always_equal{}) {
			__use_rhs = true;
		} else {
			if (__lhs.get_allocator() == __rhs.get_allocator()) {
				__use_rhs = true;
			}
		}
		if (__use_rhs) {
			const auto __size = __lhs.size() + __rhs.size();
			if ((__size > __lhs.capacity()) &&
			    (__size <= __rhs.capacity())) {
				return std::move(__rhs.insert(0, __lhs));
			}
		}
		return std::move(__lhs.append(__rhs));
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline __cxx11::basic_string<_CharT, _Traits, _Alloc> operator+(
		const _CharT *__lhs,
		__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__rhs)
	{
		return std::move(__rhs.insert(0, __lhs));
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline __cxx11::basic_string<_CharT, _Traits, _Alloc> operator+(
		_CharT __lhs,
		__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__rhs)
	{
		return std::move(__rhs.insert(0, 1, __lhs));
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline __cxx11::basic_string<_CharT, _Traits, _Alloc> operator+(
		__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__lhs,
		const _CharT *__rhs)
	{
		return std::move(__lhs.append(__rhs));
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline __cxx11::basic_string<_CharT, _Traits, _Alloc> operator+(
		__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__lhs,
		_CharT __rhs)
	{
		return std::move(__lhs.append(1, __rhs));
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline bool operator==(
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs,
		const __cxx11::basic_string<_CharT, _Traits, _Alloc>
			&__rhs) noexcept
	{
		return __lhs.compare(__rhs) == 0;
	}
	template <class _CharT>
	inline typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
					       bool>::__type
	operator==(const __cxx11::basic_string<_CharT> &__lhs,
		   const __cxx11::basic_string<_CharT> &__rhs) noexcept
	{
		return ((__lhs.size() == __rhs.size()) &&
			(!std::template char_traits<_CharT>::compare(
				__lhs.data(), __rhs.data(), __lhs.size())));
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline bool operator==(
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs,
		const _CharT *__rhs)
	{
		return __lhs.compare(__rhs) == 0;
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline bool operator==(
		const _CharT *__lhs,
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
	{
		return __rhs.compare(__lhs) == 0;
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline bool operator!=(
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs,
		const __cxx11::basic_string<_CharT, _Traits, _Alloc>
			&__rhs) noexcept
	{
		return !(__lhs == __rhs);
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline bool operator!=(
		const _CharT *__lhs,
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
	{
		return !(__lhs == __rhs);
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline bool operator!=(
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs,
		const _CharT *__rhs)
	{
		return !(__lhs == __rhs);
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline bool operator<(
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs,
		const __cxx11::basic_string<_CharT, _Traits, _Alloc>
			&__rhs) noexcept
	{
		return __lhs.compare(__rhs) < 0;
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline bool operator<(
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs,
		const _CharT *__rhs)
	{
		return __lhs.compare(__rhs) < 0;
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline bool operator<(
		const _CharT *__lhs,
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
	{
		return __rhs.compare(__lhs) > 0;
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline bool operator>(
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs,
		const __cxx11::basic_string<_CharT, _Traits, _Alloc>
			&__rhs) noexcept
	{
		return __lhs.compare(__rhs) > 0;
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline bool operator>(
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs,
		const _CharT *__rhs)
	{
		return __lhs.compare(__rhs) > 0;
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline bool operator>(
		const _CharT *__lhs,
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
	{
		return __rhs.compare(__lhs) < 0;
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline bool operator<=(
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs,
		const __cxx11::basic_string<_CharT, _Traits, _Alloc>
			&__rhs) noexcept
	{
		return __lhs.compare(__rhs) <= 0;
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline bool operator<=(
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs,
		const _CharT *__rhs)
	{
		return __lhs.compare(__rhs) <= 0;
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline bool operator<=(
		const _CharT *__lhs,
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
	{
		return __rhs.compare(__lhs) >= 0;
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline bool operator>=(
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs,
		const __cxx11::basic_string<_CharT, _Traits, _Alloc>
			&__rhs) noexcept
	{
		return __lhs.compare(__rhs) >= 0;
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline bool operator>=(
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs,
		const _CharT *__rhs)
	{
		return __lhs.compare(__rhs) >= 0;
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline bool operator>=(
		const _CharT *__lhs,
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
	{
		return __rhs.compare(__lhs) <= 0;
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline void swap(__cxx11::basic_string<_CharT, _Traits, _Alloc> & __lhs,
			 __cxx11::basic_string<_CharT, _Traits, _Alloc> &
				 __rhs) noexcept(noexcept(__lhs.swap(__rhs)))
	{
		__lhs.swap(__rhs);
	}
	template <class _CharT, class _Traits, class _Alloc>
	basic_istream<_CharT, _Traits> &operator>>(
		basic_istream<_CharT, _Traits> &__is,
		__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str);
	template <>
	basic_istream<char> &operator>>(basic_istream<char> &__is,
					__cxx11::basic_string<char> &__str);
	template <class _CharT, class _Traits, class _Alloc>
	inline basic_ostream<_CharT, _Traits> &operator<<(
		basic_ostream<_CharT, _Traits> &__os,
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
	{
		return __ostream_insert(__os, __str.data(), __str.size());
	}
	template <class _CharT, class _Traits, class _Alloc>
	basic_istream<_CharT, _Traits> &getline(
		basic_istream<_CharT, _Traits> & __is,
		__cxx11::basic_string<_CharT, _Traits, _Alloc> & __str,
		_CharT __delim);
	template <class _CharT, class _Traits, class _Alloc>
	inline basic_istream<_CharT, _Traits> &getline(
		basic_istream<_CharT, _Traits> & __is,
		__cxx11::basic_string<_CharT, _Traits, _Alloc> & __str)
	{
		return std::getline(__is, __str, __is.widen('\n'));
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline basic_istream<_CharT, _Traits> &getline(
		basic_istream<_CharT, _Traits> && __is,
		__cxx11::basic_string<_CharT, _Traits, _Alloc> & __str,
		_CharT __delim)
	{
		return std::getline(__is, __str, __delim);
	}
	template <class _CharT, class _Traits, class _Alloc>
	inline basic_istream<_CharT, _Traits> &getline(
		basic_istream<_CharT, _Traits> && __is,
		__cxx11::basic_string<_CharT, _Traits, _Alloc> & __str)
	{
		return std::getline(__is, __str);
	}
	template <>
	basic_istream<char> &getline(basic_istream<char> & __in,
				     __cxx11::basic_string<char> & __str,
				     char __delim);
	template <>
	basic_istream<wchar_t> &getline(basic_istream<wchar_t> & __in,
					__cxx11::basic_string<wchar_t> & __str,
					wchar_t __delim);
} // namespace )
extern "C" {
extern int *__errno_location() noexcept(true) __attribute((const));
extern char *program_invocation_name;
extern char *program_invocation_short_name;
typedef int error_t;
}
namespace __gnu_cxx __attribute((__visibility__("default")))
{
	template <class _TRet, class _Ret = _TRet, class _CharT, class... _Base>
	_Ret __stoa(_TRet(*__convf)(const _CharT *, _CharT **, _Base...),
		    const char *__name, const _CharT *__str, std::size_t *__idx,
		    _Base... __base)
	{
		_Ret __ret;
		_CharT *__endptr;
		const struct _Save_errno {
			_Save_errno() : _M_errno(*__errno_location())
			{
				(*__errno_location()) = 0;
			}
			~_Save_errno()
			{
				if ((*__errno_location()) == 0) {
					(*__errno_location()) = (_M_errno);
				}
			}
			int _M_errno;
		} __save_errno;
		struct _Range_chk {
			static bool _S_chk(_TRet, std::false_type)
			{
				return false;
			}
			static bool _S_chk(_TRet __val, std::true_type)
			{
				return (__val <
					((_TRet)__numeric_traits<int>::__min)) ||
				       (__val >
					((_TRet)__numeric_traits<int>::__max));
			}
		};
		const _TRet __tmp = __convf(__str, &__endptr, __base...);
		if (__endptr == __str) {
			std::__throw_invalid_argument(__name);
		} else {
			if (((*__errno_location()) == 34) ||
			    _Range_chk::_S_chk(__tmp,
					       std::is_same<_Ret, int>{})) {
				std::__throw_out_of_range(__name);
			} else {
				__ret = __tmp;
			}
		}
		if (__idx) {
			(*__idx) = (__endptr - __str);
		}
		return __ret;
	}
	template <class _String, class _CharT = typename _String::value_type>
	_String __to_xstring(int (*__convf)(_CharT *, std::size_t,
					    const _CharT *, __builtin_va_list),
			     std::size_t __n, const _CharT *__fmt, ...)
	{
		_CharT *__s = static_cast<_CharT *>(
			__builtin_alloca(sizeof(_CharT) * __n));
		__builtin_va_list __args;
		__builtin_va_start((__args), __fmt);
		const int __len = __convf(__s, __n, __fmt, __args);
		__builtin_va_end(__args);
		return _String(__s, __s + __len);
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	namespace __detail
	{
	template <class _Tp>
	constexpr unsigned __to_chars_len(_Tp __value, int __base = 10) noexcept
	{
		static_assert((is_integral<_Tp>::value), "implementation bug");
		static_assert((is_unsigned<_Tp>::value), "implementation bug");
		unsigned __n = (1);
		const unsigned __b2 = __base * __base;
		const unsigned __b3 = __b2 * __base;
		const unsigned long __b4 = __b3 * __base;
		for (;;) {
			if (__value < ((unsigned)__base)) {
				return __n;
			}
			if (__value < __b2) {
				return __n + (1);
			}
			if (__value < __b3) {
				return __n + (2);
			}
			if (__value < __b4) {
				return __n + (3);
			}
			__value /= __b4;
			__n += (4);
		}
	}
	template <class _Tp>
	void __to_chars_10_impl(char *__first, unsigned __len,
				_Tp __val) noexcept
	{
		static_assert((is_integral<_Tp>::value), "implementation bug");
		static_assert((is_unsigned<_Tp>::value), "implementation bug");
		static constexpr char __digits[201] =
			"00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263"
			"646566676869707172737475767778798081828384858687888990919293949596979899";
		unsigned __pos = __len - (1);
		while (__val >= 100) {
			const auto __num = (__val % 100) * 2;
			__val /= 100;
			(__first[__pos]) = (__digits[__num + 1]);
			(__first[__pos - (1)]) = (__digits[__num]);
			__pos -= (2);
		}
		if (__val >= 10) {
			const auto __num = __val * 2;
			(__first[1]) = (__digits[__num + 1]);
			(__first[0]) = (__digits[__num]);
		} else {
			(__first[0]) = ('0' + __val);
		}
	}
	} // namespace __detail
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	inline namespace __cxx11
	{
	inline int stoi(const string &__str, size_t *__idx = 0, int __base = 10)
	{
		return __gnu_cxx::__stoa<long, int>(
			&std::strtol, "stoi", __str.c_str(), __idx, __base);
	}
	inline long stol(const string &__str, size_t *__idx = 0,
			 int __base = 10)
	{
		return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
					 __idx, __base);
	}
	inline unsigned long stoul(const string &__str, size_t *__idx = 0,
				   int __base = 10)
	{
		return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
					 __idx, __base);
	}
	inline long long stoll(const string &__str, size_t *__idx = 0,
			       int __base = 10)
	{
		return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
					 __idx, __base);
	}
	inline unsigned long long stoull(const string &__str, size_t *__idx = 0,
					 int __base = 10)
	{
		return __gnu_cxx::__stoa(&std::strtoull, "stoull",
					 __str.c_str(), __idx, __base);
	}
	inline float stof(const string &__str, size_t *__idx = 0)
	{
		return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(),
					 __idx);
	}
	inline double stod(const string &__str, size_t *__idx = 0)
	{
		return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(),
					 __idx);
	}
	inline long double stold(const string &__str, size_t *__idx = 0)
	{
		return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(),
					 __idx);
	}
	inline string to_string(int __val) noexcept
	{
		const bool __neg = __val < 0;
		const unsigned __uval =
			__neg ? ((unsigned)(~__val)) + 1U : __val;
		const auto __len = __detail::__to_chars_len(__uval);
		string __str(__neg + __len, '-');
		__detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
		return __str;
	}
	inline string to_string(unsigned __val) noexcept
	{
		string __str(__detail::__to_chars_len(__val), '\000');
		__detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
		return __str;
	}
	inline string to_string(long __val)
	{
		const bool __neg = __val < (0);
		const unsigned long __uval =
			__neg ? ((unsigned long)(~__val)) + 1UL : __val;
		const auto __len = __detail::__to_chars_len(__uval);
		string __str(__neg + __len, '-');
		__detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
		return __str;
	}
	inline string to_string(unsigned long __val)
	{
		string __str(__detail::__to_chars_len(__val), '\000');
		__detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
		return __str;
	}
	inline string to_string(long long __val)
	{
		const bool __neg = __val < (0);
		const unsigned long long __uval =
			__neg ? ((unsigned long long)(~__val)) + 1ULL : __val;
		const auto __len = __detail::__to_chars_len(__uval);
		string __str(__neg + __len, '-');
		__detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
		return __str;
	}
	inline string to_string(unsigned long long __val)
	{
		string __str(__detail::__to_chars_len(__val), '\000');
		__detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
		return __str;
	}
	inline string to_string(float __val)
	{
		const int __n =
			(__gnu_cxx::__numeric_traits<float>::__max_exponent10 +
			 20);
		return __gnu_cxx::__to_xstring<basic_string<char>>(
			&std::vsnprintf, __n, "%f", __val);
	}
	inline string to_string(double __val)
	{
		const int __n =
			(__gnu_cxx::__numeric_traits<double>::__max_exponent10 +
			 20);
		return __gnu_cxx::__to_xstring<basic_string<char>>(
			&std::vsnprintf, __n, "%f", __val);
	}
	inline string to_string(long double __val)
	{
		const int __n = (__gnu_cxx::__numeric_traits<
					 long double>::__max_exponent10 +
				 20);
		return __gnu_cxx::__to_xstring<basic_string<char>>(
			&std::vsnprintf, __n, "%Lf", __val);
	}
	inline int stoi(const wstring &__str, size_t *__idx = 0,
			int __base = 10)
	{
		return __gnu_cxx::__stoa<long, int>(
			&std::wcstol, "stoi", __str.c_str(), __idx, __base);
	}
	inline long stol(const wstring &__str, size_t *__idx = 0,
			 int __base = 10)
	{
		return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
					 __idx, __base);
	}
	inline unsigned long stoul(const wstring &__str, size_t *__idx = 0,
				   int __base = 10)
	{
		return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
					 __idx, __base);
	}
	inline long long stoll(const wstring &__str, size_t *__idx = 0,
			       int __base = 10)
	{
		return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
					 __idx, __base);
	}
	inline unsigned long long stoull(const wstring &__str,
					 size_t *__idx = 0, int __base = 10)
	{
		return __gnu_cxx::__stoa(&std::wcstoull, "stoull",
					 __str.c_str(), __idx, __base);
	}
	inline float stof(const wstring &__str, size_t *__idx = 0)
	{
		return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(),
					 __idx);
	}
	inline double stod(const wstring &__str, size_t *__idx = 0)
	{
		return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(),
					 __idx);
	}
	inline long double stold(const wstring &__str, size_t *__idx = 0)
	{
		return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(),
					 __idx);
	}
	inline wstring to_wstring(int __val)
	{
		return __gnu_cxx::__to_xstring<basic_string<wchar_t>>(
			&std::vswprintf, (4) * sizeof(int), L"\x25\x64", __val);
	}
	inline wstring to_wstring(unsigned __val)
	{
		return __gnu_cxx::__to_xstring<basic_string<wchar_t>>(
			&std::vswprintf, (4) * sizeof(unsigned), L"\x25\x75",
			__val);
	}
	inline wstring to_wstring(long __val)
	{
		return __gnu_cxx::__to_xstring<basic_string<wchar_t>>(
			&std::vswprintf, (4) * sizeof(long), L"\x25\x6c\x64",
			__val);
	}
	inline wstring to_wstring(unsigned long __val)
	{
		return __gnu_cxx::__to_xstring<basic_string<wchar_t>>(
			&std::vswprintf, (4) * sizeof(unsigned long),
			L"\x25\x6c\x75", __val);
	}
	inline wstring to_wstring(long long __val)
	{
		return __gnu_cxx::__to_xstring<basic_string<wchar_t>>(
			&std::vswprintf, (4) * sizeof(long long),
			L"\x25\x6c\x6c\x64", __val);
	}
	inline wstring to_wstring(unsigned long long __val)
	{
		return __gnu_cxx::__to_xstring<basic_string<wchar_t>>(
			&std::vswprintf, (4) * sizeof(unsigned long long),
			L"\x25\x6c\x6c\x75", __val);
	}
	inline wstring to_wstring(float __val)
	{
		const int __n =
			(__gnu_cxx::__numeric_traits<float>::__max_exponent10 +
			 20);
		return __gnu_cxx::__to_xstring<basic_string<wchar_t>>(
			&std::vswprintf, __n, L"\x25\x66", __val);
	}
	inline wstring to_wstring(double __val)
	{
		const int __n =
			(__gnu_cxx::__numeric_traits<double>::__max_exponent10 +
			 20);
		return __gnu_cxx::__to_xstring<basic_string<wchar_t>>(
			&std::vswprintf, __n, L"\x25\x66", __val);
	}
	inline wstring to_wstring(long double __val)
	{
		const int __n = (__gnu_cxx::__numeric_traits<
					 long double>::__max_exponent10 +
				 20);
		return __gnu_cxx::__to_xstring<basic_string<wchar_t>>(
			&std::vswprintf, __n, L"\x25\x4c\x66", __val);
	}
	} // namespace __cxx11
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <>
	struct hash<__cxx11::basic_string<char>>
		: public __hash_base<unsigned long, __cxx11::basic_string<char>> {
		size_t operator()(const string &__s) const noexcept
		{
			return std::_Hash_impl::hash(__s.data(), __s.length());
		}
	};
	template <>
	struct __is_fast_hash<hash<__cxx11::basic_string<char>>>
		: public false_type {
	};
	template <>
	struct hash<__cxx11::basic_string<wchar_t>>
		: public __hash_base<unsigned long,
				     __cxx11::basic_string<wchar_t>> {
		size_t operator()(const wstring &__s) const noexcept
		{
			return std::_Hash_impl::hash(
				__s.data(), __s.length() * sizeof(wchar_t));
		}
	};
	template <>
	struct __is_fast_hash<hash<__cxx11::basic_string<wchar_t>>>
		: public false_type {
	};
	template <>
	struct hash<__cxx11::basic_string<char16_t>>
		: public __hash_base<unsigned long,
				     __cxx11::basic_string<char16_t>> {
		size_t operator()(const u16string &__s) const noexcept
		{
			return std::_Hash_impl::hash(
				__s.data(), __s.length() * sizeof(char16_t));
		}
	};
	template <>
	struct __is_fast_hash<hash<__cxx11::basic_string<char16_t>>>
		: public false_type {
	};
	template <>
	struct hash<__cxx11::basic_string<char32_t>>
		: public __hash_base<unsigned long,
				     __cxx11::basic_string<char32_t>> {
		size_t operator()(const u32string &__s) const noexcept
		{
			return std::_Hash_impl::hash(
				__s.data(), __s.length() * sizeof(char32_t));
		}
	};
	template <>
	struct __is_fast_hash<hash<__cxx11::basic_string<char32_t>>>
		: public false_type {
	};
	inline namespace literals
	{
	inline namespace string_literals
	{
	__attribute((__abi_tag__("cxx11"))) inline __cxx11::basic_string<char>
	operator""s(const char *__str, size_t __len)
	{
		return __cxx11::basic_string<char>{ __str, __len };
	}
	__attribute((__abi_tag__("cxx11"))) inline __cxx11::basic_string<wchar_t>
	operator""s(const wchar_t *__str, size_t __len)
	{
		return __cxx11::basic_string<wchar_t>{ __str, __len };
	}
	__attribute((
		__abi_tag__("cxx11"))) inline __cxx11::basic_string<char16_t>
	operator""s(const char16_t *__str, size_t __len)
	{
		return __cxx11::basic_string<char16_t>{ __str, __len };
	}
	__attribute((
		__abi_tag__("cxx11"))) inline __cxx11::basic_string<char32_t>
	operator""s(const char32_t *__str, size_t __len)
	{
		return __cxx11::basic_string<char32_t>{ __str, __len };
	}
	} // namespace string_literals
	} // namespace literals
	namespace __detail
	{
	namespace __variant
	{
	template <class> struct _Never_valueless_alt;
	template <class _Tp, class _Traits, class _Alloc>
	struct _Never_valueless_alt<__cxx11::basic_string<_Tp, _Traits, _Alloc>>
		: public __and_<
			  is_nothrow_move_constructible<
				  __cxx11::basic_string<_Tp, _Traits, _Alloc>>,
			  is_nothrow_move_assignable<__cxx11::basic_string<
				  _Tp, _Traits, _Alloc>>>::type {
	};
	} // namespace __variant
	} // namespace __detail
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _CharT, class _Traits, class _Alloc>
	const typename __cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type
		__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
	template <class _CharT, class _Traits, class _Alloc>
	void __cxx11::basic_string<_CharT, _Traits, _Alloc>::swap(basic_string &
								  __s) noexcept
	{
		if (this == std::__addressof(__s)) {
			return;
		}
		_Alloc_traits::_S_on_swap(_M_get_allocator(),
					  __s._M_get_allocator());
		if (_M_is_local()) {
			if (__s._M_is_local()) {
				if (length() && __s.length()) {
					_CharT __tmp_data[_S_local_capacity + 1];
					traits_type::copy(__tmp_data,
							  __s._M_local_buf,
							  __s.length() + 1);
					traits_type::copy(__s._M_local_buf,
							  _M_local_buf,
							  length() + 1);
					traits_type::copy(_M_local_buf,
							  __tmp_data,
							  __s.length() + 1);
				} else {
					if (__s.length()) {
						traits_type::copy(
							_M_local_buf,
							__s._M_local_buf,
							__s.length() + 1);
						_M_length(__s.length());
						__s._M_set_length(0);
						return;
					} else {
						if (length()) {
							traits_type::copy(
								__s._M_local_buf,
								_M_local_buf,
								length() + 1);
							__s._M_length(length());
							_M_set_length(0);
							return;
						}
					}
				}
			} else {
				const size_type __tmp_capacity =
					__s._M_allocated_capacity;
				traits_type::copy(__s._M_local_buf,
						  _M_local_buf, length() + 1);
				_M_data(__s._M_data());
				__s._M_data(__s._M_local_buf);
				_M_capacity(__tmp_capacity);
			}
		} else {
			const size_type __tmp_capacity = _M_allocated_capacity;
			if (__s._M_is_local()) {
				traits_type::copy(_M_local_buf,
						  __s._M_local_buf,
						  __s.length() + 1);
				__s._M_data(_M_data());
				_M_data(_M_local_buf);
			} else {
				pointer __tmp_ptr = _M_data();
				_M_data(__s._M_data());
				__s._M_data(__tmp_ptr);
				_M_capacity(__s._M_allocated_capacity);
			}
			__s._M_capacity(__tmp_capacity);
		}
		const size_type __tmp_length = length();
		_M_length(__s.length());
		__s._M_length(__tmp_length);
	}
	template <class _CharT, class _Traits, class _Alloc>
	typename __cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer
	__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_create(
		size_type & __capacity, size_type __old_capacity)
	{
		if (__capacity > max_size()) {
			std::__throw_length_error("basic_string::_M_create");
		}
		if ((__capacity > __old_capacity) &&
		    (__capacity < (2 * __old_capacity))) {
			__capacity = (2 * __old_capacity);
			if (__capacity > max_size()) {
				__capacity = max_size();
			}
		}
		return _Alloc_traits::allocate(_M_get_allocator(),
					       __capacity + 1);
	}
	template <class _CharT, class _Traits, class _Alloc>
	template <class _InIterator>
	void __cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(
		_InIterator __beg, _InIterator __end, input_iterator_tag)
	{
		size_type __len = (0);
		size_type __capacity = ((size_type)_S_local_capacity);
		pointer __p = _M_use_local_data();
		while ((__beg != __end) && (__len < __capacity)) {
			(__p[__len++]) = (*__beg);
			++__beg;
		}
		struct _Guard {
			explicit _Guard(basic_string *__s) : _M_guarded(__s)
			{
			}
			~_Guard()
			{
				if (_M_guarded) {
					(_M_guarded)->_M_dispose();
				}
			}
			basic_string *_M_guarded;
		} __guard(this);
		while (__beg != __end) {
			if (__len == __capacity) {
				__capacity = (__len + 1);
				pointer __another =
					_M_create(__capacity, __len);
				this->_S_copy(__another, _M_data(), __len);
				_M_dispose();
				_M_data(__another);
				_M_capacity(__capacity);
			}
			traits_type::assign(_M_data()[__len++], *__beg);
			++__beg;
		}
		(__guard._M_guarded) = 0;
		_M_set_length(__len);
	}
	template <class _CharT, class _Traits, class _Alloc>
	template <class _InIterator>
	void __cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(
		_InIterator __beg, _InIterator __end, forward_iterator_tag)
	{
		size_type __dnew =
			static_cast<size_type>(std::distance(__beg, __end));
		if (__dnew > ((size_type)_S_local_capacity)) {
			_M_data(_M_create(__dnew, (size_type)0));
			_M_capacity(__dnew);
		} else {
			_M_use_local_data();
		}
		struct _Guard {
			explicit _Guard(basic_string *__s) : _M_guarded(__s)
			{
			}
			~_Guard()
			{
				if (_M_guarded) {
					(_M_guarded)->_M_dispose();
				}
			}
			basic_string *_M_guarded;
		} __guard(this);
		this->_S_copy_chars(_M_data(), __beg, __end);
		(__guard._M_guarded) = 0;
		_M_set_length(__dnew);
	}
	template <class _CharT, class _Traits, class _Alloc>
	void __cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(
		size_type __n, _CharT __c)
	{
		if (__n > ((size_type)_S_local_capacity)) {
			_M_data(_M_create(__n, (size_type)0));
			_M_capacity(__n);
		} else {
			_M_use_local_data();
		}
		if (__n) {
			this->_S_assign(_M_data(), __n, __c);
		}
		_M_set_length(__n);
	}
	template <class _CharT, class _Traits, class _Alloc>
	void __cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_assign(
		const basic_string &__str)
	{
		if (this != std::__addressof(__str)) {
			const size_type __rsize = __str.length();
			const size_type __capacity = capacity();
			if (__rsize > __capacity) {
				size_type __new_capacity = __rsize;
				pointer __tmp =
					_M_create(__new_capacity, __capacity);
				_M_dispose();
				_M_data(__tmp);
				_M_capacity(__new_capacity);
			}
			if (__rsize) {
				this->_S_copy(_M_data(), __str._M_data(),
					      __rsize);
			}
			_M_set_length(__rsize);
		}
	}
	template <class _CharT, class _Traits, class _Alloc>
	void __cxx11::basic_string<_CharT, _Traits, _Alloc>::reserve(
		size_type __res)
	{
		const size_type __capacity = capacity();
		if (__res <= __capacity) {
			return;
		}
		pointer __tmp = _M_create(__res, __capacity);
		this->_S_copy(__tmp, _M_data(), length() + 1);
		_M_dispose();
		_M_data(__tmp);
		_M_capacity(__res);
	}
	template <class _CharT, class _Traits, class _Alloc>
	void __cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_mutate(
		size_type __pos, size_type __len1, const _CharT *__s,
		size_type __len2)
	{
		const size_type __how_much = (length() - __pos) - __len1;
		size_type __new_capacity = (length() + __len2) - __len1;
		pointer __r = _M_create(__new_capacity, capacity());
		if (__pos) {
			this->_S_copy(__r, _M_data(), __pos);
		}
		if (__s && __len2) {
			this->_S_copy(__r + __pos, __s, __len2);
		}
		if (__how_much) {
			this->_S_copy((__r + __pos) + __len2,
				      (_M_data() + __pos) + __len1, __how_much);
		}
		_M_dispose();
		_M_data(__r);
		_M_capacity(__new_capacity);
	}
	template <class _CharT, class _Traits, class _Alloc>
	void __cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_erase(
		size_type __pos, size_type __n)
	{
		const size_type __how_much = (length() - __pos) - __n;
		if (__how_much && __n) {
			this->_S_move(_M_data() + __pos,
				      (_M_data() + __pos) + __n, __how_much);
		}
		_M_set_length(length() - __n);
	}
	template <class _CharT, class _Traits, class _Alloc>
	void __cxx11::basic_string<_CharT, _Traits, _Alloc>::reserve()
	{
		if (_M_is_local()) {
			return;
		}
		const size_type __length = length();
		const size_type __capacity = _M_allocated_capacity;
		if (__length <= ((size_type)_S_local_capacity)) {
			this->_S_copy(_M_use_local_data(), _M_data(),
				      __length + 1);
			_M_destroy(__capacity);
			_M_data(_M_local_data());
		} else {
			if (__length < __capacity) {
				try {
					pointer __tmp = _Alloc_traits::allocate(
						_M_get_allocator(),
						__length + 1);
					this->_S_copy(__tmp, _M_data(),
						      __length + 1);
					_M_dispose();
					_M_data(__tmp);
					_M_capacity(__length);
				} catch (const __cxxabiv1::__forced_unwind &) {
					throw;
				} catch (...) {
				}
			}
		}
	}
	template <class _CharT, class _Traits, class _Alloc>
	void __cxx11::basic_string<_CharT, _Traits, _Alloc>::resize(
		size_type __n, _CharT __c)
	{
		const size_type __size = size();
		if (__size < __n) {
			this->append(__n - __size, __c);
		} else {
			if (__n < __size) {
				_M_set_length(__n);
			}
		}
	}
	template <class _CharT, class _Traits, class _Alloc>
	__cxx11::basic_string<_CharT, _Traits, _Alloc>
		&__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_append(
			const _CharT *__s, size_type __n)
	{
		const size_type __len = __n + size();
		if (__len <= capacity()) {
			if (__n) {
				this->_S_copy(this->_M_data() + size(), __s,
					      __n);
			}
		} else {
			_M_mutate(size(), (size_type)0, __s, __n);
		}
		_M_set_length(__len);
		return *this;
	}
	template <class _CharT, class _Traits, class _Alloc>
	template <class _InputIterator>
	__cxx11::basic_string<_CharT, _Traits, _Alloc> &
	__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_replace_dispatch(
		const_iterator __i1, const_iterator __i2, _InputIterator __k1,
		_InputIterator __k2, __false_type)
	{
		const basic_string __s(__k1, __k2, get_allocator());
		const size_type __n1 = __i2 - __i1;
		return _M_replace(__i1 - begin(), __n1, __s._M_data(),
				  __s.size());
	}
	template <class _CharT, class _Traits, class _Alloc>
	__cxx11::basic_string<_CharT, _Traits, _Alloc> &
	__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_replace_aux(
		size_type __pos1, size_type __n1, size_type __n2, _CharT __c)
	{
		_M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
		const size_type __old_size = size();
		const size_type __new_size = (__old_size + __n2) - __n1;
		if (__new_size <= capacity()) {
			pointer __p = this->_M_data() + __pos1;
			const size_type __how_much =
				(__old_size - __pos1) - __n1;
			if (__how_much && (__n1 != __n2)) {
				this->_S_move(__p + __n2, __p + __n1,
					      __how_much);
			}
		} else {
			_M_mutate(__pos1, __n1, 0, __n2);
		}
		if (__n2) {
			this->_S_assign(this->_M_data() + __pos1, __n2, __c);
		}
		_M_set_length(__new_size);
		return *this;
	}
	template <class _CharT, class _Traits, class _Alloc>
	__cxx11::basic_string<_CharT, _Traits, _Alloc>
		&__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_replace(
			size_type __pos, size_type __len1, const _CharT *__s,
			const size_type __len2)
	{
		_M_check_length(__len1, __len2, "basic_string::_M_replace");
		const size_type __old_size = size();
		const size_type __new_size = (__old_size + __len2) - __len1;
		if (__new_size <= capacity()) {
			pointer __p = this->_M_data() + __pos;
			const size_type __how_much =
				(__old_size - __pos) - __len1;
			if (_M_disjunct(__s)) {
				if (__how_much && (__len1 != __len2)) {
					this->_S_move(__p + __len2,
						      __p + __len1, __how_much);
				}
				if (__len2) {
					this->_S_copy(__p, __s, __len2);
				}
			} else {
				if (__len2 && (__len2 <= __len1)) {
					this->_S_move(__p, __s, __len2);
				}
				if (__how_much && (__len1 != __len2)) {
					this->_S_move(__p + __len2,
						      __p + __len1, __how_much);
				}
				if (__len2 > __len1) {
					if ((__s + __len2) <= (__p + __len1)) {
						this->_S_move(__p, __s, __len2);
					} else {
						if (__s >= (__p + __len1)) {
							const size_type __poff =
								(__s - __p) +
								(__len2 -
								 __len1);
							this->_S_copy(
								__p,
								__p + __poff,
								__len2);
						} else {
							const size_type __nleft =
								(__p + __len1) -
								__s;
							this->_S_move(__p, __s,
								      __nleft);
							this->_S_copy(
								__p + __nleft,
								__p + __len2,
								__len2 -
									__nleft);
						}
					}
				}
			}
		} else {
			_M_mutate(__pos, __len1, __s, __len2);
		}
		_M_set_length(__new_size);
		return *this;
	}
	template <class _CharT, class _Traits, class _Alloc>
	typename __cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type
	__cxx11::basic_string<_CharT, _Traits, _Alloc>::copy(
		_CharT * __s, size_type __n, size_type __pos) const
	{
		_M_check(__pos, "basic_string::copy");
		__n = _M_limit(__pos, __n);
		;
		if (__n) {
			(_S_copy)(__s, _M_data() + __pos, __n);
		}
		return __n;
	}
	template <class _CharT, class _Traits, class _Alloc>
	__cxx11::basic_string<_CharT, _Traits, _Alloc> operator+(
		const _CharT *__lhs,
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
	{
		;
		typedef __cxx11::basic_string<_CharT, _Traits, _Alloc>
			__string_type;
		typedef typename __cxx11::basic_string<
			_CharT, _Traits, _Alloc>::size_type __size_type;
		typedef typename __gnu_cxx::__alloc_traits<
			_Alloc>::template rebind<_CharT>::other _Char_alloc_type;
		typedef __gnu_cxx::__alloc_traits<
			typename __gnu_cxx::__alloc_traits<
				_Alloc>::template rebind<_CharT>::other>
			_Alloc_traits;
		const __size_type __len = _Traits::length(__lhs);
		__string_type __str(_Alloc_traits::_S_select_on_copy(
			__rhs.get_allocator()));
		__str.reserve(__len + __rhs.size());
		__str.append(__lhs, __len);
		__str.append(__rhs);
		return __str;
	}
	template <class _CharT, class _Traits, class _Alloc>
	__cxx11::basic_string<_CharT, _Traits, _Alloc> operator+(
		_CharT __lhs,
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
	{
		typedef __cxx11::basic_string<_CharT, _Traits, _Alloc>
			__string_type;
		typedef typename __cxx11::basic_string<
			_CharT, _Traits, _Alloc>::size_type __size_type;
		typedef typename __gnu_cxx::__alloc_traits<
			_Alloc>::template rebind<_CharT>::other _Char_alloc_type;
		typedef __gnu_cxx::__alloc_traits<
			typename __gnu_cxx::__alloc_traits<
				_Alloc>::template rebind<_CharT>::other>
			_Alloc_traits;
		__string_type __str(_Alloc_traits::_S_select_on_copy(
			__rhs.get_allocator()));
		const __size_type __len = __rhs.size();
		__str.reserve(__len + 1);
		__str.append((__size_type)1, __lhs);
		__str.append(__rhs);
		return __str;
	}
	template <class _CharT, class _Traits, class _Alloc>
	typename __cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type
	__cxx11::basic_string<_CharT, _Traits, _Alloc>::find(
		const _CharT *__s, size_type __pos, size_type __n)
		const noexcept
	{
		;
		const size_type __size = size();
		if (__n == 0) {
			return (__pos <= __size) ? __pos : npos;
		}
		if (__pos >= __size) {
			return npos;
		}
		const _CharT __elem0 = __s[0];
		const _CharT *const __data = data();
		const _CharT *__first = __data + __pos;
		const _CharT *const __last = __data + __size;
		size_type __len = __size - __pos;
		while (__len >= __n) {
			__first = traits_type::find(__first, (__len - __n) + 1,
						    __elem0);
			if (!__first) {
				return npos;
			}
			if (traits_type::compare(__first, __s, __n) == 0) {
				return __first - __data;
			}
			__len = (__last - (++__first));
		}
		return npos;
	}
	template <class _CharT, class _Traits, class _Alloc>
	typename __cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type
	__cxx11::basic_string<_CharT, _Traits, _Alloc>::find(_CharT __c,
							     size_type __pos)
		const noexcept
	{
		size_type __ret = npos;
		const size_type __size = size();
		if (__pos < __size) {
			const _CharT *__data = _M_data();
			const size_type __n = __size - __pos;
			const _CharT *__p =
				traits_type::find(__data + __pos, __n, __c);
			if (__p) {
				__ret = (__p - __data);
			}
		}
		return __ret;
	}
	template <class _CharT, class _Traits, class _Alloc>
	typename __cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type
	__cxx11::basic_string<_CharT, _Traits, _Alloc>::rfind(
		const _CharT *__s, size_type __pos, size_type __n)
		const noexcept
	{
		;
		const size_type __size = size();
		if (__n <= __size) {
			__pos = std::min((size_type)(__size - __n), __pos);
			const _CharT *__data = _M_data();
			do {
				if (traits_type::compare(__data + __pos, __s,
							 __n) == 0) {
					return __pos;
				}
			} while ((__pos--) > 0);
		}
		return npos;
	}
	template <class _CharT, class _Traits, class _Alloc>
	typename __cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type
	__cxx11::basic_string<_CharT, _Traits, _Alloc>::rfind(_CharT __c,
							      size_type __pos)
		const noexcept
	{
		size_type __size = size();
		if (__size) {
			if ((--__size) > __pos) {
				__size = __pos;
			}
			for (++__size; (__size--) > 0;) {
				if (traits_type::eq(_M_data()[__size], __c)) {
					return __size;
				}
			}
		}
		return npos;
	}
	template <class _CharT, class _Traits, class _Alloc>
	typename __cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type
	__cxx11::basic_string<_CharT, _Traits, _Alloc>::find_first_of(
		const _CharT *__s, size_type __pos, size_type __n)
		const noexcept
	{
		;
		for (; __n && (__pos < size()); ++__pos) {
			const _CharT *__p =
				traits_type::find(__s, __n, _M_data()[__pos]);
			if (__p) {
				return __pos;
			}
		}
		return npos;
	}
	template <class _CharT, class _Traits, class _Alloc>
	typename __cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type
	__cxx11::basic_string<_CharT, _Traits, _Alloc>::find_last_of(
		const _CharT *__s, size_type __pos, size_type __n)
		const noexcept
	{
		;
		size_type __size = size();
		if (__size && __n) {
			if ((--__size) > __pos) {
				__size = __pos;
			}
			do {
				if (traits_type::find(__s, __n,
						      _M_data()[__size])) {
					return __size;
				}
			} while ((__size--) != 0);
		}
		return npos;
	}
	template <class _CharT, class _Traits, class _Alloc>
	typename __cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type
	__cxx11::basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(
		const _CharT *__s, size_type __pos, size_type __n)
		const noexcept
	{
		;
		for (; __pos < size(); ++__pos) {
			if (!traits_type::find(__s, __n, _M_data()[__pos])) {
				return __pos;
			}
		}
		return npos;
	}
	template <class _CharT, class _Traits, class _Alloc>
	typename __cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type
	__cxx11::basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(
		_CharT __c, size_type __pos) const noexcept
	{
		for (; __pos < size(); ++__pos) {
			if (!traits_type::eq(_M_data()[__pos], __c)) {
				return __pos;
			}
		}
		return npos;
	}
	template <class _CharT, class _Traits, class _Alloc>
	typename __cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type
	__cxx11::basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(
		const _CharT *__s, size_type __pos, size_type __n)
		const noexcept
	{
		;
		size_type __size = size();
		if (__size) {
			if ((--__size) > __pos) {
				__size = __pos;
			}
			do {
				if (!traits_type::find(__s, __n,
						       _M_data()[__size])) {
					return __size;
				}
			} while (__size--);
		}
		return npos;
	}
	template <class _CharT, class _Traits, class _Alloc>
	typename __cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type
	__cxx11::basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(
		_CharT __c, size_type __pos) const noexcept
	{
		size_type __size = size();
		if (__size) {
			if ((--__size) > __pos) {
				__size = __pos;
			}
			do {
				if (!traits_type::eq(_M_data()[__size], __c)) {
					return __size;
				}
			} while (__size--);
		}
		return npos;
	}
	template <class _CharT, class _Traits, class _Alloc>
	int __cxx11::basic_string<_CharT, _Traits, _Alloc>::compare(
		size_type __pos, size_type __n, const basic_string &__str) const
	{
		_M_check(__pos, "basic_string::compare");
		__n = _M_limit(__pos, __n);
		const size_type __osize = __str.size();
		const size_type __len = std::min(__n, __osize);
		int __r = traits_type::compare(_M_data() + __pos, __str.data(),
					       __len);
		if (!__r) {
			__r = (_S_compare)(__n, __osize);
		}
		return __r;
	}
	template <class _CharT, class _Traits, class _Alloc>
	int __cxx11::basic_string<_CharT, _Traits, _Alloc>::compare(
		size_type __pos1, size_type __n1, const basic_string &__str,
		size_type __pos2, size_type __n2) const
	{
		_M_check(__pos1, "basic_string::compare");
		__str._M_check(__pos2, "basic_string::compare");
		__n1 = _M_limit(__pos1, __n1);
		__n2 = __str._M_limit(__pos2, __n2);
		const size_type __len = std::min(__n1, __n2);
		int __r = traits_type::compare(_M_data() + __pos1,
					       __str.data() + __pos2, __len);
		if (!__r) {
			__r = (_S_compare)(__n1, __n2);
		}
		return __r;
	}
	template <class _CharT, class _Traits, class _Alloc>
	int __cxx11::basic_string<_CharT, _Traits, _Alloc>::compare(
		const _CharT *__s) const noexcept
	{
		;
		const size_type __size = size();
		const size_type __osize = traits_type::length(__s);
		const size_type __len = std::min(__size, __osize);
		int __r = traits_type::compare(_M_data(), __s, __len);
		if (!__r) {
			__r = (_S_compare)(__size, __osize);
		}
		return __r;
	}
	template <class _CharT, class _Traits, class _Alloc>
	int __cxx11::basic_string<_CharT, _Traits, _Alloc>::compare(
		size_type __pos, size_type __n1, const _CharT *__s) const
	{
		;
		_M_check(__pos, "basic_string::compare");
		__n1 = _M_limit(__pos, __n1);
		const size_type __osize = traits_type::length(__s);
		const size_type __len = std::min(__n1, __osize);
		int __r = traits_type::compare(_M_data() + __pos, __s, __len);
		if (!__r) {
			__r = (_S_compare)(__n1, __osize);
		}
		return __r;
	}
	template <class _CharT, class _Traits, class _Alloc>
	int __cxx11::basic_string<_CharT, _Traits, _Alloc>::compare(
		size_type __pos, size_type __n1, const _CharT *__s,
		size_type __n2) const
	{
		;
		_M_check(__pos, "basic_string::compare");
		__n1 = _M_limit(__pos, __n1);
		const size_type __len = std::min(__n1, __n2);
		int __r = traits_type::compare(_M_data() + __pos, __s, __len);
		if (!__r) {
			__r = (_S_compare)(__n1, __n2);
		}
		return __r;
	}
	template <class _CharT, class _Traits, class _Alloc>
	basic_istream<_CharT, _Traits> &operator>>(
		basic_istream<_CharT, _Traits> &__in,
		__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
	{
		typedef basic_istream<_CharT, _Traits> __istream_type;
		typedef __cxx11::basic_string<_CharT, _Traits, _Alloc>
			__string_type;
		typedef typename basic_istream<_CharT, _Traits>::ios_base
			__ios_base;
		typedef typename basic_istream<_CharT, _Traits>::int_type
			__int_type;
		typedef typename __cxx11::basic_string<
			_CharT, _Traits, _Alloc>::size_type __size_type;
		typedef ctype<_CharT> __ctype_type;
		typedef typename ctype<_CharT>::ctype_base __ctype_base;
		__size_type __extracted = (0);
		typename basic_istream<_CharT, _Traits>::ios_base::iostate
			__err = (__ios_base::goodbit);
		typename basic_istream<_CharT, _Traits>::sentry __cerb(__in,
								       false);
		if (__cerb) {
			try {
				__str.erase();
				_CharT __buf[128];
				__size_type __len = (0);
				const streamsize __w = __in.width();
				const __size_type __n =
					(__w > (0)) ?
						static_cast<__size_type>(__w) :
						__str.max_size();
				const __ctype_type &__ct =
					use_facet<ctype<_CharT>>(__in.getloc());
				const __int_type __eof = _Traits::eof();
				__int_type __c = __in.rdbuf()->sgetc();
				while ((__extracted < __n) &&
				       (!_Traits::eq_int_type(__c, __eof)) &&
				       (!__ct.is(__ctype_base::space,
						 _Traits::to_char_type(__c)))) {
					if (__len ==
					    (sizeof(__buf) / sizeof(_CharT))) {
						__str.append(
							__buf,
							sizeof(__buf) /
								sizeof(_CharT));
						__len = 0;
					}
					(__buf[__len++]) =
						_Traits::to_char_type(__c);
					++__extracted;
					__c = __in.rdbuf()->snextc();
				}
				__str.append(__buf, __len);
				if ((__extracted < __n) &&
				    _Traits::eq_int_type(__c, __eof)) {
					__err |= __ios_base::eofbit;
				}
				__in.width(0);
			} catch (__cxxabiv1::__forced_unwind &) {
				__in._M_setstate(__ios_base::badbit);
				throw;
			} catch (...) {
				__in._M_setstate(__ios_base::badbit);
			}
		}
		if (!__extracted) {
			__err |= __ios_base::failbit;
		}
		if (__err) {
			__in.setstate(__err);
		}
		return __in;
	}
	template <class _CharT, class _Traits, class _Alloc>
	basic_istream<_CharT, _Traits> &getline(
		basic_istream<_CharT, _Traits> & __in,
		__cxx11::basic_string<_CharT, _Traits, _Alloc> & __str,
		_CharT __delim)
	{
		typedef basic_istream<_CharT, _Traits> __istream_type;
		typedef __cxx11::basic_string<_CharT, _Traits, _Alloc>
			__string_type;
		typedef typename basic_istream<_CharT, _Traits>::ios_base
			__ios_base;
		typedef typename basic_istream<_CharT, _Traits>::int_type
			__int_type;
		typedef typename __cxx11::basic_string<
			_CharT, _Traits, _Alloc>::size_type __size_type;
		__size_type __extracted = (0);
		const __size_type __n = __str.max_size();
		typename basic_istream<_CharT, _Traits>::ios_base::iostate
			__err = (__ios_base::goodbit);
		typename basic_istream<_CharT, _Traits>::sentry __cerb(__in,
								       true);
		if (__cerb) {
			try {
				__str.erase();
				const __int_type __idelim =
					_Traits::to_int_type(__delim);
				const __int_type __eof = _Traits::eof();
				__int_type __c = __in.rdbuf()->sgetc();
				while ((__extracted < __n) &&
				       (!_Traits::eq_int_type(__c, __eof)) &&
				       (!_Traits::eq_int_type(__c, __idelim))) {
					__str += _Traits::to_char_type(__c);
					++__extracted;
					__c = __in.rdbuf()->snextc();
				}
				if (_Traits::eq_int_type(__c, __eof)) {
					__err |= __ios_base::eofbit;
				} else {
					if (_Traits::eq_int_type(__c,
								 __idelim)) {
						++__extracted;
						__in.rdbuf()->sbumpc();
					} else {
						__err |= __ios_base::failbit;
					}
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				__in._M_setstate(__ios_base::badbit);
				throw;
			} catch (...) {
				__in._M_setstate(__ios_base::badbit);
			}
		}
		if (!__extracted) {
			__err |= __ios_base::failbit;
		}
		if (__err) {
			__in.setstate(__err);
		}
		return __in;
	}
	extern template class __cxx11::basic_string<char>;
	extern template basic_istream<char> &operator>>(
		basic_istream<char> &__is, __cxx11::basic_string<char> &__str);
	extern template basic_ostream<char> &operator<<(
		basic_ostream<char> &__os,
		const __cxx11::basic_string<char> &__str);
	extern template basic_istream<char> &getline(
		basic_istream<char> & __is, __cxx11::basic_string<char> & __str,
		char __delim);
	extern template basic_istream<char> &getline(
		basic_istream<char> & __is,
		__cxx11::basic_string<char> & __str);
	extern template class __cxx11::basic_string<wchar_t>;
	extern template basic_istream<wchar_t> &operator>>(
		basic_istream<wchar_t> &__is,
		__cxx11::basic_string<wchar_t> &__str);
	extern template basic_ostream<wchar_t> &operator<<(
		basic_ostream<wchar_t> &__os,
		const __cxx11::basic_string<wchar_t> &__str);
	extern template basic_istream<wchar_t> &getline(
		basic_istream<wchar_t> & __is,
		__cxx11::basic_string<wchar_t> & __str, wchar_t __delim);
	extern template basic_istream<wchar_t> &getline(
		basic_istream<wchar_t> & __is,
		__cxx11::basic_string<wchar_t> & __str);
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	namespace pmr
	{
	template <class _Tp> class polymorphic_allocator;
	template <class _CharT, class _Traits = char_traits<_CharT>>
	using basic_string =
		__cxx11::basic_string<_CharT, _Traits,
				      polymorphic_allocator<_CharT>>;
	using string = basic_string<char>;
	using u16string = basic_string<char16_t>;
	using u32string = basic_string<char32_t>;
	using wstring = basic_string<wchar_t>;
	} // namespace pmr
	template <class _Str>
	struct __hash_string_base : public __hash_base<unsigned long, _Str> {
		std::size_t operator()(const _Str &__s) const noexcept
		{
			return hash<
				basic_string_view<typename _Str::value_type>>{}(
				__s);
		}
	};
	template <>
	struct hash<__cxx11::basic_string<char, char_traits<char>,
					  pmr::polymorphic_allocator<char>>>
		: public __hash_string_base<__cxx11::basic_string<
			  char, char_traits<char>,
			  pmr::polymorphic_allocator<char>>> {
	};
	template <>
	struct hash<__cxx11::basic_string<char16_t, char_traits<char16_t>,
					  pmr::polymorphic_allocator<char16_t>>>
		: public __hash_string_base<__cxx11::basic_string<
			  char16_t, char_traits<char16_t>,
			  pmr::polymorphic_allocator<char16_t>>> {
	};
	template <>
	struct hash<__cxx11::basic_string<char32_t, char_traits<char32_t>,
					  pmr::polymorphic_allocator<char32_t>>>
		: public __hash_string_base<__cxx11::basic_string<
			  char32_t, char_traits<char32_t>,
			  pmr::polymorphic_allocator<char32_t>>> {
	};
	template <>
	struct hash<__cxx11::basic_string<wchar_t, char_traits<wchar_t>,
					  pmr::polymorphic_allocator<wchar_t>>>
		: public __hash_string_base<__cxx11::basic_string<
			  wchar_t, char_traits<wchar_t>,
			  pmr::polymorphic_allocator<wchar_t>>> {
	};
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	class locale {
	    public:
		typedef int category;
		class facet;
		class id;
		class _Impl;
		friend class facet;
		friend class _Impl;
		template <class _Facet>
		friend bool has_facet(const locale &) throw();
		template <class _Facet>
		friend const _Facet &use_facet(const locale &);
		template <class _Cache> friend struct __use_cache;
		static const category none = 0;
		static const category ctype = (1L << 0);
		static const category numeric = (1L << 1);
		static const category collate = (1L << 2);
		static const category time = (1L << 3);
		static const category monetary = (1L << 4);
		static const category messages = (1L << 5);
		static const category all =
			(((((ctype | numeric) | collate) | time) | monetary) |
			 messages);
		locale() throw();
		locale(const locale &__other) throw();
		explicit locale(const char *__s);
		locale(const locale &__base, const char *__s, category __cat);
		explicit locale(const string &__s) : locale(__s.c_str())
		{
		}
		locale(const locale &__base, const string &__s, category __cat)
			: locale(__base, __s.c_str(), __cat)
		{
		}
		locale(const locale &__base, const locale &__add,
		       category __cat);
		template <class _Facet>
		locale(const locale &__other, _Facet *__f);
		~locale() throw();
		const locale &operator=(const locale &__other) throw();
		template <class _Facet>
		locale combine(const locale &__other) const;
		__attribute((__abi_tag__("cxx11"))) string name() const;
		bool operator==(const locale &__other) const throw();
		bool operator!=(const locale &__other) const throw()
		{
			return !this->operator==(__other);
		}
		template <class _Char, class _Traits, class _Alloc>
		bool
		operator()(const __cxx11::basic_string<_Char, _Traits, _Alloc>
				   &__s1,
			   const __cxx11::basic_string<_Char, _Traits, _Alloc>
				   &__s2) const;
		static locale global(const locale &__loc);
		static const locale &classic();

	    private:
		_Impl *_M_impl;
		static _Impl *_S_classic;
		static _Impl *_S_global;
		static const char *const *const _S_categories;
		enum { _S_categories_size = (6 + 6) };
		static __gthread_once_t _S_once;
		explicit locale(_Impl *) throw();
		static void _S_initialize();
		static void _S_initialize_once() throw();
		static category _S_normalize_category(category);
		void _M_coalesce(const locale &__base, const locale &__add,
				 category __cat);
		static const id *const _S_twinned_facets[];
	};
	class locale::facet {
		friend class locale;
		friend class _Impl;
		mutable _Atomic_word _M_refcount;
		static __c_locale _S_c_locale;
		static const char _S_c_name[2];
		static __gthread_once_t _S_once;
		static void _S_initialize_once();

	    protected:
		explicit facet(size_t __refs = 0) throw()
			: _M_refcount((__refs) ? 1 : 0)
		{
		}
		virtual ~facet();
		static void _S_create_c_locale(__c_locale &__cloc,
					       const char *__s,
					       __c_locale __old = 0);
		static __c_locale _S_clone_c_locale(__c_locale &__cloc) throw();
		static void _S_destroy_c_locale(__c_locale &__cloc);
		static __c_locale _S_lc_ctype_c_locale(__c_locale __cloc,
						       const char *__s);
		static __c_locale _S_get_c_locale();
		__attribute((const)) static const char *_S_get_c_name() throw();
		facet(const facet &) = delete;
		facet &operator=(const facet &) = delete;

	    private:
		void _M_add_reference() const throw()
		{
			__gnu_cxx::__atomic_add_dispatch(&(_M_refcount), 1);
		}
		void _M_remove_reference() const throw()
		{
			;
			if (__gnu_cxx::__exchange_and_add_dispatch(
				    &(_M_refcount), -1) == 1) {
				;
				try {
					delete this;
				} catch (...) {
				}
			}
		}
		const facet *_M_sso_shim(const id *) const;
		const facet *_M_cow_shim(const id *) const;

	    protected:
		class __shim;
	};
	class locale::id {
		friend class locale;
		friend class _Impl;
		template <class _Facet>
		friend const _Facet &use_facet(const std::locale &);
		template <class _Facet>
		friend bool has_facet(const std::locale &) throw();
		mutable size_t _M_index;
		static _Atomic_word _S_refcount;
		void operator=(const id &);
		id(const id &);

	    public:
		id()
		{
		}
		size_t _M_id() const throw();
	};
	class locale::_Impl {
		friend class locale;
		friend class facet;
		template <class _Facet>
		friend bool has_facet(const std::locale &) throw();
		template <class _Facet>
		friend const _Facet &use_facet(const std::locale &);
		template <class _Cache> friend struct __use_cache;
		_Atomic_word _M_refcount;
		const facet **_M_facets;
		size_t _M_facets_size;
		const facet **_M_caches;
		char **_M_names;
		static const id *const _S_id_ctype[];
		static const id *const _S_id_numeric[];
		static const id *const _S_id_collate[];
		static const id *const _S_id_time[];
		static const id *const _S_id_monetary[];
		static const id *const _S_id_messages[];
		static const id *const *const _S_facet_categories[];
		void _M_add_reference() throw()
		{
			__gnu_cxx::__atomic_add_dispatch(&(_M_refcount), 1);
		}
		void _M_remove_reference() throw()
		{
			;
			if (__gnu_cxx::__exchange_and_add_dispatch(
				    &(_M_refcount), -1) == 1) {
				;
				try {
					delete this;
				} catch (...) {
				}
			}
		}
		_Impl(const _Impl &, size_t);
		_Impl(const char *, size_t);
		_Impl(size_t) throw();
		~_Impl() throw();
		_Impl(const _Impl &);
		void operator=(const _Impl &);
		bool _M_check_same_name()
		{
			bool __ret = true;
			if ((_M_names)[1]) {
				for (size_t __i = (0);
				     __ret && (__i < ((_S_categories_size)-1));
				     ++__i) {
					__ret = (__builtin_strcmp(
							 (_M_names)[__i],
							 (_M_names)[__i + (1)]) ==
						 0);
				}
			}
			return __ret;
		}
		void _M_replace_categories(const _Impl *, category);
		void _M_replace_category(const _Impl *, const id *const *);
		void _M_replace_facet(const _Impl *, const id *);
		void _M_install_facet(const id *, const facet *);
		template <class _Facet> void _M_init_facet(_Facet *__facet)
		{
			this->_M_install_facet(&_Facet::id, __facet);
		}
		template <class _Facet>
		void _M_init_facet_unchecked(_Facet *__facet)
		{
			__facet->_M_add_reference();
			((_M_facets)[(_Facet::id._M_id)()]) = __facet;
		}
		void _M_install_cache(const facet *, size_t);
		void _M_init_extra(facet **);
		void _M_init_extra(void *, void *, const char *, const char *);
	};
	template <class _CharT> class __cxx11::collate : public locale::facet {
	    public:
		typedef _CharT char_type;
		typedef basic_string<_CharT> string_type;

	    protected:
		__c_locale _M_c_locale_collate;

	    public:
		static locale::id id;
		explicit collate(size_t __refs = 0)
			: locale::facet(__refs),
			  _M_c_locale_collate(_S_get_c_locale())
		{
		}
		explicit collate(__c_locale __cloc, size_t __refs = 0)
			: locale::facet(__refs),
			  _M_c_locale_collate(_S_clone_c_locale(__cloc))
		{
		}
		int compare(const _CharT *__lo1, const _CharT *__hi1,
			    const _CharT *__lo2, const _CharT *__hi2) const
		{
			return do_compare(__lo1, __hi1, __lo2, __hi2);
		}
		string_type transform(const _CharT *__lo,
				      const _CharT *__hi) const
		{
			return do_transform(__lo, __hi);
		}
		long hash(const _CharT *__lo, const _CharT *__hi) const
		{
			return do_hash(__lo, __hi);
		}
		int _M_compare(const _CharT *, const _CharT *) const throw();
		size_t _M_transform(_CharT *, const _CharT *, size_t) const
			throw();

	    protected:
		virtual ~collate()
		{
			_S_destroy_c_locale(_M_c_locale_collate);
		}
		virtual int do_compare(const _CharT *__lo1, const _CharT *__hi1,
				       const _CharT *__lo2,
				       const _CharT *__hi2) const;
		virtual string_type do_transform(const _CharT *__lo,
						 const _CharT *__hi) const;
		virtual long do_hash(const _CharT *__lo,
				     const _CharT *__hi) const;
	};
	template <class _CharT> locale::id __cxx11::collate<_CharT>::id;
	template <>
	int collate<char>::_M_compare(const char *, const char *) const throw();
	template <>
	size_t collate<char>::_M_transform(char *, const char *, size_t)
		const throw();
	template <>
	int collate<wchar_t>::_M_compare(const wchar_t *, const wchar_t *)
		const throw();
	template <>
	size_t collate<wchar_t>::_M_transform(wchar_t *, const wchar_t *,
					      size_t) const throw();
	template <class _CharT>
	class __cxx11::collate_byname : public collate<_CharT> {
	    public:
		typedef _CharT char_type;
		typedef basic_string<_CharT> string_type;
		explicit collate_byname(const char *__s, std::size_t __refs = 0)
			: collate<_CharT>(__refs)
		{
			if ((__builtin_strcmp(__s, "C") != 0) &&
			    (__builtin_strcmp(__s, "POSIX") != 0)) {
				this->_S_destroy_c_locale(
					(this->_M_c_locale_collate));
				this->_S_create_c_locale(
					(this->_M_c_locale_collate), __s);
			}
		}
		explicit collate_byname(const std::string &__s,
					std::size_t __refs = 0)
			: collate_byname(__s.c_str(), __refs)
		{
		}

	    protected:
		virtual ~collate_byname()
		{
		}
	};
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _Facet>
	locale::locale(const locale &__other, _Facet *__f)
	{
		(_M_impl) = (new _Impl(*(__other._M_impl), 1));
		try {
			(_M_impl)->_M_install_facet(&_Facet::id, __f);
		} catch (...) {
			(_M_impl)->_M_remove_reference();
			throw;
		}
		delete[](((_M_impl)->_M_names)[0]);
		(((_M_impl)->_M_names)[0]) = (0);
	}
	template <class _Facet>
	locale locale::combine(const locale &__other) const
	{
		_Impl *__tmp = new _Impl(*(_M_impl), 1);
		try {
			__tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
		} catch (...) {
			__tmp->_M_remove_reference();
			throw;
		}
		return ((locale)(__tmp));
	}
	template <class _CharT, class _Traits, class _Alloc>
	bool locale::operator()(
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__s1,
		const __cxx11::basic_string<_CharT, _Traits, _Alloc> &__s2)
		const
	{
		typedef __cxx11::collate<_CharT> __collate_type;
		const __collate_type &__collate =
			use_facet<__cxx11::collate<_CharT>>(*this);
		return (__collate.compare(
				__s1.data(), __s1.data() + __s1.length(),
				__s2.data(), __s2.data() + __s2.length()) < 0);
	}
	template <class _Facet> bool has_facet(const locale &__loc) throw()
	{
		const size_t __i = (_Facet::id._M_id)();
		const locale::facet **__facets = (__loc._M_impl)->_M_facets;
		return ((__i < ((__loc._M_impl)->_M_facets_size)) &&
			(dynamic_cast<const _Facet *>(__facets[__i])));
	}
	template <class _Facet> const _Facet &use_facet(const locale &__loc)
	{
		const size_t __i = (_Facet::id._M_id)();
		const locale::facet **__facets = (__loc._M_impl)->_M_facets;
		if ((__i >= ((__loc._M_impl)->_M_facets_size)) ||
		    (!(__facets[__i]))) {
			__throw_bad_cast();
		}
		return dynamic_cast<const _Facet &>(*(__facets[__i]));
	}
	template <class _CharT>
	int __cxx11::collate<_CharT>::_M_compare(const _CharT *, const _CharT *)
		const throw()
	{
		return 0;
	}
	template <class _CharT>
	size_t __cxx11::collate<_CharT>::_M_transform(_CharT *, const _CharT *,
						      size_t) const throw()
	{
		return 0;
	}
	template <class _CharT>
	int __cxx11::collate<_CharT>::do_compare(const _CharT *__lo1,
						 const _CharT *__hi1,
						 const _CharT *__lo2,
						 const _CharT *__hi2) const
	{
		const string_type __one(__lo1, __hi1);
		const string_type __two(__lo2, __hi2);
		const _CharT *__p = __one.c_str();
		const _CharT *__pend = __one.data() + __one.length();
		const _CharT *__q = __two.c_str();
		const _CharT *__qend = __two.data() + __two.length();
		for (;;) {
			const int __res = _M_compare(__p, __q);
			if (__res) {
				return __res;
			}
			__p += char_traits<_CharT>::length(__p);
			__q += char_traits<_CharT>::length(__q);
			if ((__p == __pend) && (__q == __qend)) {
				return 0;
			} else {
				if (__p == __pend) {
					return -1;
				} else {
					if (__q == __qend) {
						return 1;
					}
				}
			}
			__p++;
			__q++;
		}
	}
	template <class _CharT>
	typename __cxx11::collate<_CharT>::string_type
	__cxx11::collate<_CharT>::do_transform(const _CharT *__lo,
					       const _CharT *__hi) const
	{
		string_type __ret;
		const string_type __str(__lo, __hi);
		const _CharT *__p = __str.c_str();
		const _CharT *__pend = __str.data() + __str.length();
		size_t __len = (__hi - __lo) * 2;
		_CharT *__c = new _CharT[__len];
		try {
			for (;;) {
				size_t __res = _M_transform(__c, __p, __len);
				if (__res >= __len) {
					__len = (__res + (1));
					(delete[] __c), (__c = 0);
					__c = (new _CharT[__len]);
					__res = _M_transform(__c, __p, __len);
				}
				__ret.append(__c, __res);
				__p += char_traits<_CharT>::length(__p);
				if (__p == __pend) {
					break;
				}
				__p++;
				__ret.push_back(_CharT());
			}
		} catch (...) {
			delete[] __c;
			throw;
		}
		delete[] __c;
		return __ret;
	}
	template <class _CharT>
	long __cxx11::collate<_CharT>::do_hash(const _CharT *__lo,
					       const _CharT *__hi) const
	{
		unsigned long __val = (0);
		for (; __lo < __hi; ++__lo) {
			__val = ((*__lo) +
				 ((__val << 7) |
				  (__val >> (__gnu_cxx::__numeric_traits<
						     unsigned long>::__digits -
					     7))));
		}
		return static_cast<long>(__val);
	}
	extern template class __cxx11::collate<char>;
	extern template class __cxx11::collate_byname<char>;
	extern template const __cxx11::collate<char>
		&use_facet<__cxx11::collate<char>>(const locale &);
	extern template bool has_facet<__cxx11::collate<char>>(
		const locale &) throw();
	extern template class __cxx11::collate<wchar_t>;
	extern template class __cxx11::collate_byname<wchar_t>;
	extern template const __cxx11::collate<wchar_t>
		&use_facet<__cxx11::collate<wchar_t>>(const locale &);
	extern template bool has_facet<__cxx11::collate<wchar_t>>(
		const locale &) throw();
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	enum class errc {
		address_family_not_supported = 97,
		address_in_use,
		address_not_available,
		already_connected = 106,
		argument_list_too_long = 7,
		argument_out_of_domain = 33,
		bad_address = 14,
		bad_file_descriptor = 9,
		bad_message = 74,
		broken_pipe = 32,
		connection_aborted = 103,
		connection_already_in_progress = 114,
		connection_refused = 111,
		connection_reset = 104,
		cross_device_link = 18,
		destination_address_required = 89,
		device_or_resource_busy = 16,
		directory_not_empty = 39,
		executable_format_error = 8,
		file_exists = 17,
		file_too_large = 27,
		filename_too_long = 36,
		function_not_supported = 38,
		host_unreachable = 113,
		identifier_removed = 43,
		illegal_byte_sequence = 84,
		inappropriate_io_control_operation = 25,
		interrupted = 4,
		invalid_argument = 22,
		invalid_seek = 29,
		io_error = 5,
		is_a_directory = 21,
		message_size = 90,
		network_down = 100,
		network_reset = 102,
		network_unreachable = 101,
		no_buffer_space = 105,
		no_child_process = 10,
		no_link = 67,
		no_lock_available = 37,
		no_message_available = 61,
		no_message = 42,
		no_protocol_option = 92,
		no_space_on_device = 28,
		no_stream_resources = 63,
		no_such_device_or_address = 6,
		no_such_device = 19,
		no_such_file_or_directory = 2,
		no_such_process,
		not_a_directory = 20,
		not_a_socket = 88,
		not_a_stream = 60,
		not_connected = 107,
		not_enough_memory = 12,
		not_supported = 95,
		operation_canceled = 125,
		operation_in_progress = 115,
		operation_not_permitted = 1,
		operation_not_supported = 95,
		operation_would_block = 11,
		owner_dead = 130,
		permission_denied = 13,
		protocol_error = 71,
		protocol_not_supported = 93,
		read_only_file_system = 30,
		resource_deadlock_would_occur = 35,
		resource_unavailable_try_again = 11,
		result_out_of_range = 34,
		state_not_recoverable = 131,
		stream_timeout = 62,
		text_file_busy = 26,
		timed_out = 110,
		too_many_files_open_in_system = 23,
		too_many_files_open,
		too_many_links = 31,
		too_many_symbolic_link_levels = 40,
		value_too_large = 75,
		wrong_protocol_type = 91
	};
}
namespace std __attribute((__visibility__("default")))
{
	struct __cow_string {
		union {
			const char *_M_p;
			char _M_bytes[sizeof(const char *)];
		};
		__cow_string();
		__cow_string(const string &);
		__cow_string(const char *, size_t);
		__cow_string(const __cow_string &) noexcept;
		__cow_string &operator=(const __cow_string &) noexcept;
		~__cow_string();
		__cow_string(__cow_string &&) noexcept;
		__cow_string &operator=(__cow_string &&) noexcept;
	};
	typedef __cxx11::basic_string<char> __sso_string;
	class logic_error : public exception {
		__cow_string _M_msg;

	    public:
		explicit logic_error(const string &__arg);
		explicit logic_error(const char *);
		logic_error(logic_error &&) noexcept;
		logic_error &operator=(logic_error &&) noexcept;
		logic_error(const logic_error &) noexcept;
		logic_error &operator=(const logic_error &) noexcept;
		virtual ~logic_error() noexcept;
		virtual const char *what() const noexcept;
	};
	class domain_error : public logic_error {
	    public:
		explicit domain_error(const string &__arg);
		explicit domain_error(const char *);
		domain_error(const domain_error &) = default;
		domain_error &operator=(const domain_error &) = default;
		domain_error(domain_error &&) = default;
		domain_error &operator=(domain_error &&) = default;
		virtual ~domain_error() noexcept;
	};
	class invalid_argument : public logic_error {
	    public:
		explicit invalid_argument(const string &__arg);
		explicit invalid_argument(const char *);
		invalid_argument(const invalid_argument &) = default;
		invalid_argument &operator=(const invalid_argument &) = default;
		invalid_argument(invalid_argument &&) = default;
		invalid_argument &operator=(invalid_argument &&) = default;
		virtual ~invalid_argument() noexcept;
	};
	class length_error : public logic_error {
	    public:
		explicit length_error(const string &__arg);
		explicit length_error(const char *);
		length_error(const length_error &) = default;
		length_error &operator=(const length_error &) = default;
		length_error(length_error &&) = default;
		length_error &operator=(length_error &&) = default;
		virtual ~length_error() noexcept;
	};
	class out_of_range : public logic_error {
	    public:
		explicit out_of_range(const string &__arg);
		explicit out_of_range(const char *);
		out_of_range(const out_of_range &) = default;
		out_of_range &operator=(const out_of_range &) = default;
		out_of_range(out_of_range &&) = default;
		out_of_range &operator=(out_of_range &&) = default;
		virtual ~out_of_range() noexcept;
	};
	class runtime_error : public exception {
		__cow_string _M_msg;

	    public:
		explicit runtime_error(const string &__arg);
		explicit runtime_error(const char *);
		runtime_error(runtime_error &&) noexcept;
		runtime_error &operator=(runtime_error &&) noexcept;
		runtime_error(const runtime_error &) noexcept;
		runtime_error &operator=(const runtime_error &) noexcept;
		virtual ~runtime_error() noexcept;
		virtual const char *what() const noexcept;
	};
	class range_error : public runtime_error {
	    public:
		explicit range_error(const string &__arg);
		explicit range_error(const char *);
		range_error(const range_error &) = default;
		range_error &operator=(const range_error &) = default;
		range_error(range_error &&) = default;
		range_error &operator=(range_error &&) = default;
		virtual ~range_error() noexcept;
	};
	class overflow_error : public runtime_error {
	    public:
		explicit overflow_error(const string &__arg);
		explicit overflow_error(const char *);
		overflow_error(const overflow_error &) = default;
		overflow_error &operator=(const overflow_error &) = default;
		overflow_error(overflow_error &&) = default;
		overflow_error &operator=(overflow_error &&) = default;
		virtual ~overflow_error() noexcept;
	};
	class underflow_error : public runtime_error {
	    public:
		explicit underflow_error(const string &__arg);
		explicit underflow_error(const char *);
		underflow_error(const underflow_error &) = default;
		underflow_error &operator=(const underflow_error &) = default;
		underflow_error(underflow_error &&) = default;
		underflow_error &operator=(underflow_error &&) = default;
		virtual ~underflow_error() noexcept;
	};
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	class error_code;
	class error_condition;
	class system_error;
	template <class _Tp> struct is_error_code_enum : public false_type {
	};
	template <class _Tp>
	struct is_error_condition_enum : public false_type {
	};
	template <> struct is_error_condition_enum<errc> : public true_type {
	};
	template <class _Tp>
	constexpr inline bool is_error_code_enum_v =
		(is_error_code_enum<_Tp>::value);
	template <class _Tp>
	constexpr inline bool is_error_condition_enum_v =
		(is_error_condition_enum<_Tp>::value);
	inline namespace _V2
	{
	class error_category {
	    public:
		constexpr error_category() noexcept = default;
		virtual ~error_category();
		error_category(const error_category &) = delete;
		error_category &operator=(const error_category &) = delete;
		virtual const char *name() const noexcept = 0;

	    private:
		__attribute((__abi_tag__("cxx11"))) virtual __cow_string
		_M_message(int) const;

	    public:
		__attribute((__abi_tag__("cxx11"))) virtual string
		message(int) const = 0;
		virtual error_condition
		default_error_condition(int __i) const noexcept;
		virtual bool
		equivalent(int __i,
			   const error_condition &__cond) const noexcept;
		virtual bool equivalent(const error_code &__code,
					int __i) const noexcept;
		bool operator==(const error_category &__other) const noexcept
		{
			return this == (&__other);
		}
		bool operator!=(const error_category &__other) const noexcept
		{
			return this != (&__other);
		}
		bool operator<(const error_category &__other) const noexcept
		{
			return less<const error_category *>()(this, &__other);
		}
	};
	__attribute((const)) const error_category &generic_category() noexcept;
	__attribute((const)) const error_category &system_category() noexcept;
	} // namespace _V2
	inline error_code make_error_code(errc) noexcept;
	class error_code {
	    public:
		error_code() noexcept : _M_value(0), _M_cat(&system_category())
		{
		}
		error_code(int __v, const _V2::error_category &__cat) noexcept
			: _M_value(__v), _M_cat(&__cat)
		{
		}
		template <class _ErrorCodeEnum,
			  class = typename enable_if<is_error_code_enum<
				  _ErrorCodeEnum>::value>::type>
		error_code(_ErrorCodeEnum __e) noexcept
		{
			(*this) = make_error_code(__e);
		}
		void assign(int __v, const _V2::error_category &__cat) noexcept
		{
			(_M_value) = __v;
			(_M_cat) = (&__cat);
		}
		void clear() noexcept
		{
			this->assign(0, system_category());
		}
		template <class _ErrorCodeEnum>
		typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value,
				   error_code &>::type
		operator=(_ErrorCodeEnum __e) noexcept
		{
			return (*this) = make_error_code(__e);
		}
		int value() const noexcept
		{
			return _M_value;
		}
		const _V2::error_category &category() const noexcept
		{
			return *(_M_cat);
		}
		error_condition default_error_condition() const noexcept;
		__attribute((__abi_tag__("cxx11"))) string message() const
		{
			return this->category().message(this->value());
		}
		explicit operator bool() const noexcept
		{
			return (_M_value) != 0;
		}

	    private:
		int _M_value;
		const _V2::error_category *_M_cat;
	};
	inline error_code make_error_code(errc __e) noexcept
	{
		return error_code(static_cast<int>(__e), generic_category());
	}
	inline bool operator<(const error_code &__lhs,
			      const error_code &__rhs) noexcept
	{
		return (((__lhs.category()) < (__rhs.category())) ||
			(((__lhs.category()) == (__rhs.category())) &&
			 (__lhs.value() < __rhs.value())));
	}
	template <class _CharT, class _Traits>
	basic_ostream<_CharT, _Traits> &operator<<(
		basic_ostream<_CharT, _Traits> &__os, const error_code &__e)
	{
		return (((__os << __e.category().name()) << ':')
			<< __e.value());
	}
	inline error_condition make_error_condition(errc) noexcept;
	class error_condition {
	    public:
		error_condition() noexcept
			: _M_value(0), _M_cat(&generic_category())
		{
		}
		error_condition(int __v,
				const _V2::error_category &__cat) noexcept
			: _M_value(__v), _M_cat(&__cat)
		{
		}
		template <class _ErrorConditionEnum,
			  class = typename enable_if<is_error_condition_enum<
				  _ErrorConditionEnum>::value>::type>
		error_condition(_ErrorConditionEnum __e) noexcept
		{
			(*this) = make_error_condition(__e);
		}
		void assign(int __v, const _V2::error_category &__cat) noexcept
		{
			(_M_value) = __v;
			(_M_cat) = (&__cat);
		}
		template <class _ErrorConditionEnum>
		typename enable_if<
			is_error_condition_enum<_ErrorConditionEnum>::value,
			error_condition &>::type
		operator=(_ErrorConditionEnum __e) noexcept
		{
			return (*this) = make_error_condition(__e);
		}
		void clear() noexcept
		{
			this->assign(0, generic_category());
		}
		int value() const noexcept
		{
			return _M_value;
		}
		const _V2::error_category &category() const noexcept
		{
			return *(_M_cat);
		}
		__attribute((__abi_tag__("cxx11"))) string message() const
		{
			return this->category().message(this->value());
		}
		explicit operator bool() const noexcept
		{
			return (_M_value) != 0;
		}

	    private:
		int _M_value;
		const _V2::error_category *_M_cat;
	};
	inline error_condition make_error_condition(errc __e) noexcept
	{
		return error_condition(static_cast<int>(__e),
				       generic_category());
	}
	inline bool operator==(const error_code &__lhs,
			       const error_code &__rhs) noexcept
	{
		return (((__lhs.category()) == (__rhs.category())) &&
			(__lhs.value() == __rhs.value()));
	}
	inline bool operator==(const error_code &__lhs,
			       const error_condition &__rhs) noexcept
	{
		return (__lhs.category().equivalent(__lhs.value(), __rhs) ||
			__rhs.category().equivalent(__lhs, __rhs.value()));
	}
	inline bool operator==(const error_condition &__lhs,
			       const error_condition &__rhs) noexcept
	{
		return (((__lhs.category()) == (__rhs.category())) &&
			(__lhs.value() == __rhs.value()));
	}
	inline bool operator<(const error_condition &__lhs,
			      const error_condition &__rhs) noexcept
	{
		return (((__lhs.category()) < (__rhs.category())) ||
			(((__lhs.category()) == (__rhs.category())) &&
			 (__lhs.value() < __rhs.value())));
	}
	inline bool operator==(const error_condition &__lhs,
			       const error_code &__rhs) noexcept
	{
		return (__rhs.category().equivalent(__rhs.value(), __lhs) ||
			__lhs.category().equivalent(__rhs, __lhs.value()));
	}
	inline bool operator!=(const error_code &__lhs,
			       const error_code &__rhs) noexcept
	{
		return !(__lhs == __rhs);
	}
	inline bool operator!=(const error_code &__lhs,
			       const error_condition &__rhs) noexcept
	{
		return !(__lhs == __rhs);
	}
	inline bool operator!=(const error_condition &__lhs,
			       const error_code &__rhs) noexcept
	{
		return !(__lhs == __rhs);
	}
	inline bool operator!=(const error_condition &__lhs,
			       const error_condition &__rhs) noexcept
	{
		return !(__lhs == __rhs);
	}
	class system_error : public runtime_error {
		error_code _M_code;

	    public:
		system_error(error_code __ec = error_code())
			: runtime_error(__ec.message()), _M_code(__ec)
		{
		}
		system_error(error_code __ec, const string &__what)
			: runtime_error(
				  (((__what + (": "))) + (__ec.message()))),
			  _M_code(__ec)
		{
		}
		system_error(error_code __ec, const char *__what)
			: runtime_error(
				  (__what + (((": ") + (__ec.message()))))),
			  _M_code(__ec)
		{
		}
		system_error(int __v, const _V2::error_category &__ecat,
			     const char *__what)
			: system_error(error_code(__v, __ecat), __what)
		{
		}
		system_error(int __v, const _V2::error_category &__ecat)
			: runtime_error(error_code(__v, __ecat).message()),
			  _M_code(__v, __ecat)
		{
		}
		system_error(int __v, const _V2::error_category &__ecat,
			     const string &__what)
			: runtime_error((((__what + (": "))) +
					 (error_code(__v, __ecat).message()))),
			  _M_code(__v, __ecat)
		{
		}
		system_error(const system_error &) = default;
		system_error &operator=(const system_error &) = default;
		virtual ~system_error() noexcept;
		const error_code &code() const noexcept
		{
			return _M_code;
		}
	};
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <>
	struct hash<error_code>
		: public __hash_base<unsigned long, error_code> {
		size_t operator()(const error_code &__e) const noexcept
		{
			const size_t __tmp = std::_Hash_impl::hash(__e.value());
			return std::_Hash_impl::__hash_combine(&__e.category(),
							       __tmp);
		}
	};
	template <>
	struct hash<error_condition>
		: public __hash_base<unsigned long, error_condition> {
		size_t operator()(const error_condition &__e) const noexcept
		{
			const size_t __tmp = std::_Hash_impl::hash(__e.value());
			return std::_Hash_impl::__hash_combine(&__e.category(),
							       __tmp);
		}
	};
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	enum _Ios_Fmtflags {
		_S_boolalpha = (1L << 0),
		_S_dec,
		_S_fixed = (1L << 2),
		_S_hex = (1L << 3),
		_S_internal = (1L << 4),
		_S_left = (1L << 5),
		_S_oct = (1L << 6),
		_S_right = (1L << 7),
		_S_scientific = (1L << 8),
		_S_showbase = (1L << 9),
		_S_showpoint = (1L << 10),
		_S_showpos = (1L << 11),
		_S_skipws = (1L << 12),
		_S_unitbuf = (1L << 13),
		_S_uppercase = (1L << 14),
		_S_adjustfield = ((_S_left | _S_right) | _S_internal),
		_S_basefield = ((_S_dec | _S_oct) | _S_hex),
		_S_floatfield = (_S_scientific | _S_fixed),
		_S_ios_fmtflags_end = (1L << 16),
		_S_ios_fmtflags_max = 2147483647,
		_S_ios_fmtflags_min = (~2147483647)
	};
	constexpr _Ios_Fmtflags operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
	{
		return (_Ios_Fmtflags)((static_cast<int>(__a)) &
				       (static_cast<int>(__b)));
	}
	constexpr _Ios_Fmtflags operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
	{
		return (_Ios_Fmtflags)((static_cast<int>(__a)) |
				       (static_cast<int>(__b)));
	}
	constexpr _Ios_Fmtflags operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
	{
		return (_Ios_Fmtflags)((static_cast<int>(__a)) ^
				       (static_cast<int>(__b)));
	}
	constexpr _Ios_Fmtflags operator~(_Ios_Fmtflags __a)
	{
		return (_Ios_Fmtflags)(~(static_cast<int>(__a)));
	}
	inline const _Ios_Fmtflags &operator|=(_Ios_Fmtflags &__a,
					       _Ios_Fmtflags __b)
	{
		return __a = (__a | __b);
	}
	inline const _Ios_Fmtflags &operator&=(_Ios_Fmtflags &__a,
					       _Ios_Fmtflags __b)
	{
		return __a = (__a & __b);
	}
	inline const _Ios_Fmtflags &operator^=(_Ios_Fmtflags &__a,
					       _Ios_Fmtflags __b)
	{
		return __a = (__a ^ __b);
	}
	enum _Ios_Openmode {
		_S_app = (1L << 0),
		_S_ate,
		_S_bin = (1L << 2),
		_S_in = (1L << 3),
		_S_out = (1L << 4),
		_S_trunc = (1L << 5),
		_S_noreplace = (1L << 6),
		_S_ios_openmode_end = (1L << 16),
		_S_ios_openmode_max = 2147483647,
		_S_ios_openmode_min = (~2147483647)
	};
	constexpr _Ios_Openmode operator&(_Ios_Openmode __a, _Ios_Openmode __b)
	{
		return (_Ios_Openmode)((static_cast<int>(__a)) &
				       (static_cast<int>(__b)));
	}
	constexpr _Ios_Openmode operator|(_Ios_Openmode __a, _Ios_Openmode __b)
	{
		return (_Ios_Openmode)((static_cast<int>(__a)) |
				       (static_cast<int>(__b)));
	}
	constexpr _Ios_Openmode operator^(_Ios_Openmode __a, _Ios_Openmode __b)
	{
		return (_Ios_Openmode)((static_cast<int>(__a)) ^
				       (static_cast<int>(__b)));
	}
	constexpr _Ios_Openmode operator~(_Ios_Openmode __a)
	{
		return (_Ios_Openmode)(~(static_cast<int>(__a)));
	}
	inline const _Ios_Openmode &operator|=(_Ios_Openmode &__a,
					       _Ios_Openmode __b)
	{
		return __a = (__a | __b);
	}
	inline const _Ios_Openmode &operator&=(_Ios_Openmode &__a,
					       _Ios_Openmode __b)
	{
		return __a = (__a & __b);
	}
	inline const _Ios_Openmode &operator^=(_Ios_Openmode &__a,
					       _Ios_Openmode __b)
	{
		return __a = (__a ^ __b);
	}
	enum _Ios_Iostate {
		_S_goodbit,
		_S_badbit,
		_S_eofbit,
		_S_failbit = (1L << 2),
		_S_ios_iostate_end = (1L << 16),
		_S_ios_iostate_max = 2147483647,
		_S_ios_iostate_min = (~2147483647)
	};
	constexpr _Ios_Iostate operator&(_Ios_Iostate __a, _Ios_Iostate __b)
	{
		return (_Ios_Iostate)((static_cast<int>(__a)) &
				      (static_cast<int>(__b)));
	}
	constexpr _Ios_Iostate operator|(_Ios_Iostate __a, _Ios_Iostate __b)
	{
		return (_Ios_Iostate)((static_cast<int>(__a)) |
				      (static_cast<int>(__b)));
	}
	constexpr _Ios_Iostate operator^(_Ios_Iostate __a, _Ios_Iostate __b)
	{
		return (_Ios_Iostate)((static_cast<int>(__a)) ^
				      (static_cast<int>(__b)));
	}
	constexpr _Ios_Iostate operator~(_Ios_Iostate __a)
	{
		return (_Ios_Iostate)(~(static_cast<int>(__a)));
	}
	inline const _Ios_Iostate &operator|=(_Ios_Iostate &__a,
					      _Ios_Iostate __b)
	{
		return __a = (__a | __b);
	}
	inline const _Ios_Iostate &operator&=(_Ios_Iostate &__a,
					      _Ios_Iostate __b)
	{
		return __a = (__a & __b);
	}
	inline const _Ios_Iostate &operator^=(_Ios_Iostate &__a,
					      _Ios_Iostate __b)
	{
		return __a = (__a ^ __b);
	}
	enum _Ios_Seekdir {
		_S_beg,
		_S_cur,
		_S_end,
		_S_ios_seekdir_end = (1L << 16)
	};
	enum class io_errc { stream = 1 };
	template <> struct is_error_code_enum<io_errc> : public true_type {
	};
	const _V2::error_category &iostream_category() noexcept;
	inline error_code make_error_code(io_errc __e) noexcept
	{
		return error_code(static_cast<int>(__e), iostream_category());
	}
	inline error_condition make_error_condition(io_errc __e) noexcept
	{
		return error_condition(static_cast<int>(__e),
				       iostream_category());
	}
	class ios_base {
	    public:
		class __attribute((__abi_tag__("cxx11"))) failure
			: public system_error {
		    public:
			explicit failure(const string &__str);
			explicit failure(const string &, const error_code &);
			explicit failure(const char *,
					 const error_code & = io_errc::stream);
			virtual ~failure() throw();
			virtual const char *what() const throw();
		};
		typedef _Ios_Fmtflags fmtflags;
		static const fmtflags boolalpha = _S_boolalpha;
		static const fmtflags dec = _S_dec;
		static const fmtflags fixed = _S_fixed;
		static const fmtflags hex = _S_hex;
		static const fmtflags internal = _S_internal;
		static const fmtflags left = _S_left;
		static const fmtflags oct = _S_oct;
		static const fmtflags right = _S_right;
		static const fmtflags scientific = _S_scientific;
		static const fmtflags showbase = _S_showbase;
		static const fmtflags showpoint = _S_showpoint;
		static const fmtflags showpos = _S_showpos;
		static const fmtflags skipws = _S_skipws;
		static const fmtflags unitbuf = _S_unitbuf;
		static const fmtflags uppercase = _S_uppercase;
		static const fmtflags adjustfield = _S_adjustfield;
		static const fmtflags basefield = _S_basefield;
		static const fmtflags floatfield = _S_floatfield;
		typedef _Ios_Iostate iostate;
		static const iostate badbit = _S_badbit;
		static const iostate eofbit = _S_eofbit;
		static const iostate failbit = _S_failbit;
		static const iostate goodbit = _S_goodbit;
		typedef _Ios_Openmode openmode;
		static const openmode app = _S_app;
		static const openmode ate = _S_ate;
		static const openmode binary = _S_bin;
		static const openmode in = _S_in;
		static const openmode out = _S_out;
		static const openmode trunc = _S_trunc;
		static const openmode __noreplace = _S_noreplace;
		typedef _Ios_Seekdir seekdir;
		static const seekdir beg = _S_beg;
		static const seekdir cur = _S_cur;
		static const seekdir end = _S_end;
		enum event { erase_event, imbue_event, copyfmt_event };
		typedef void (*event_callback)(event __e, ios_base &__b,
					       int __i);
		void register_callback(event_callback __fn, int __index);

	    protected:
		streamsize _M_precision;
		streamsize _M_width;
		fmtflags _M_flags;
		iostate _M_exception;
		iostate _M_streambuf_state;
		struct _Callback_list {
			_Callback_list *_M_next;
			event_callback _M_fn;
			int _M_index;
			_Atomic_word _M_refcount;
			_Callback_list(event_callback __fn, int __index,
				       _Callback_list *__cb)
				: _M_next(__cb), _M_fn(__fn), _M_index(__index),
				  _M_refcount(0)
			{
			}
			void _M_add_reference()
			{
				__gnu_cxx::__atomic_add_dispatch(&(_M_refcount),
								 1);
			}
			int _M_remove_reference()
			{
				;
				int __res =
					__gnu_cxx::__exchange_and_add_dispatch(
						&(_M_refcount), -1);
				if (__res == 0) {
					;
				}
				return __res;
			}
		};
		_Callback_list *_M_callbacks;
		void _M_call_callbacks(event __ev) throw();
		void _M_dispose_callbacks() throw();
		struct _Words {
			void *_M_pword;
			long _M_iword;
			_Words() : _M_pword((0)), _M_iword((0))
			{
			}
		};
		_Words _M_word_zero;
		enum { _S_local_word_size = 8 };
		_Words _M_local_word[_S_local_word_size];
		int _M_word_size;
		_Words *_M_word;
		_Words &_M_grow_words(int __index, bool __iword);
		locale _M_ios_locale;
		void _M_init() throw();

	    public:
		class Init {
			friend class ios_base;

		    public:
			Init();
			~Init();
			Init(const Init &) = default;
			Init &operator=(const Init &) = default;

		    private:
			static _Atomic_word _S_refcount;
			static bool _S_synced_with_stdio;
		};
		fmtflags flags() const
		{
			return _M_flags;
		}
		fmtflags flags(fmtflags __fmtfl)
		{
			fmtflags __old = _M_flags;
			(_M_flags) = __fmtfl;
			return __old;
		}
		fmtflags setf(fmtflags __fmtfl)
		{
			fmtflags __old = _M_flags;
			((_M_flags) |= __fmtfl);
			return __old;
		}
		fmtflags setf(fmtflags __fmtfl, fmtflags __mask)
		{
			fmtflags __old = _M_flags;
			((_M_flags) &= ((~__mask)));
			((_M_flags) |= ((__fmtfl & __mask)));
			return __old;
		}
		void unsetf(fmtflags __mask)
		{
			((_M_flags) &= ((~__mask)));
		}
		streamsize precision() const
		{
			return _M_precision;
		}
		streamsize precision(streamsize __prec)
		{
			streamsize __old = _M_precision;
			(_M_precision) = __prec;
			return __old;
		}
		streamsize width() const
		{
			return _M_width;
		}
		streamsize width(streamsize __wide)
		{
			streamsize __old = _M_width;
			(_M_width) = __wide;
			return __old;
		}
		static bool sync_with_stdio(bool __sync = true);
		locale imbue(const locale &__loc) throw();
		locale getloc() const
		{
			return _M_ios_locale;
		}
		const locale &_M_getloc() const
		{
			return _M_ios_locale;
		}
		static int xalloc() throw();
		long &iword(int __ix)
		{
			_Words &__word =
				(((unsigned)__ix) <
				 ((unsigned)(_M_word_size))) ?
					(_M_word)[__ix] :
					this->_M_grow_words(__ix, true);
			return __word._M_iword;
		}
		void *&pword(int __ix)
		{
			_Words &__word =
				(((unsigned)__ix) <
				 ((unsigned)(_M_word_size))) ?
					(_M_word)[__ix] :
					this->_M_grow_words(__ix, false);
			return __word._M_pword;
		}
		virtual ~ios_base();

	    protected:
		ios_base() throw();

	    public:
		ios_base(const ios_base &) = delete;
		ios_base &operator=(const ios_base &) = delete;

	    protected:
		void _M_move(ios_base &) noexcept;
		void _M_swap(ios_base &__rhs) noexcept;
	};
	inline ios_base &boolalpha(ios_base & __base)
	{
		__base.setf(ios_base::boolalpha);
		return __base;
	}
	inline ios_base &noboolalpha(ios_base & __base)
	{
		__base.unsetf(ios_base::boolalpha);
		return __base;
	}
	inline ios_base &showbase(ios_base & __base)
	{
		__base.setf(ios_base::showbase);
		return __base;
	}
	inline ios_base &noshowbase(ios_base & __base)
	{
		__base.unsetf(ios_base::showbase);
		return __base;
	}
	inline ios_base &showpoint(ios_base & __base)
	{
		__base.setf(ios_base::showpoint);
		return __base;
	}
	inline ios_base &noshowpoint(ios_base & __base)
	{
		__base.unsetf(ios_base::showpoint);
		return __base;
	}
	inline ios_base &showpos(ios_base & __base)
	{
		__base.setf(ios_base::showpos);
		return __base;
	}
	inline ios_base &noshowpos(ios_base & __base)
	{
		__base.unsetf(ios_base::showpos);
		return __base;
	}
	inline ios_base &skipws(ios_base & __base)
	{
		__base.setf(ios_base::skipws);
		return __base;
	}
	inline ios_base &noskipws(ios_base & __base)
	{
		__base.unsetf(ios_base::skipws);
		return __base;
	}
	inline ios_base &uppercase(ios_base & __base)
	{
		__base.setf(ios_base::uppercase);
		return __base;
	}
	inline ios_base &nouppercase(ios_base & __base)
	{
		__base.unsetf(ios_base::uppercase);
		return __base;
	}
	inline ios_base &unitbuf(ios_base & __base)
	{
		__base.setf(ios_base::unitbuf);
		return __base;
	}
	inline ios_base &nounitbuf(ios_base & __base)
	{
		__base.unsetf(ios_base::unitbuf);
		return __base;
	}
	inline ios_base &internal(ios_base & __base)
	{
		__base.setf(ios_base::internal, ios_base::adjustfield);
		return __base;
	}
	inline ios_base &left(ios_base & __base)
	{
		__base.setf(ios_base::left, ios_base::adjustfield);
		return __base;
	}
	inline ios_base &right(ios_base & __base)
	{
		__base.setf(ios_base::right, ios_base::adjustfield);
		return __base;
	}
	inline ios_base &dec(ios_base & __base)
	{
		__base.setf(ios_base::dec, ios_base::basefield);
		return __base;
	}
	inline ios_base &hex(ios_base & __base)
	{
		__base.setf(ios_base::hex, ios_base::basefield);
		return __base;
	}
	inline ios_base &oct(ios_base & __base)
	{
		__base.setf(ios_base::oct, ios_base::basefield);
		return __base;
	}
	inline ios_base &fixed(ios_base & __base)
	{
		__base.setf(ios_base::fixed, ios_base::floatfield);
		return __base;
	}
	inline ios_base &scientific(ios_base & __base)
	{
		__base.setf(ios_base::scientific, ios_base::floatfield);
		return __base;
	}
	inline ios_base &hexfloat(ios_base & __base)
	{
		__base.setf((ios_base::fixed | ios_base::scientific),
			    ios_base::floatfield);
		return __base;
	}
	inline ios_base &defaultfloat(ios_base & __base)
	{
		__base.unsetf(ios_base::floatfield);
		return __base;
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _CharT, class _Traits>
	streamsize __copy_streambufs_eof(basic_streambuf<_CharT, _Traits> *,
					 basic_streambuf<_CharT, _Traits> *,
					 bool &);
	template <class _CharT, class _Traits> class basic_streambuf {
	    public:
		typedef _CharT char_type;
		typedef _Traits traits_type;
		typedef typename _Traits::int_type int_type;
		typedef typename _Traits::pos_type pos_type;
		typedef typename _Traits::off_type off_type;
		typedef basic_streambuf __streambuf_type;
		friend class basic_ios<char_type, traits_type>;
		friend class basic_istream<char_type, traits_type>;
		friend class basic_ostream<char_type, traits_type>;
		friend class istreambuf_iterator<char_type, traits_type>;
		friend class ostreambuf_iterator<char_type, traits_type>;
		friend streamsize
		__copy_streambufs_eof<>(basic_streambuf<_CharT, _Traits> *,
					basic_streambuf<_CharT, _Traits> *,
					bool &);
		template <bool _IsMove, class _CharT2>
		friend typename __gnu_cxx::__enable_if<
			__is_char<_CharT2>::__value, _CharT2 *>::__type
		__copy_move_a2(std::istreambuf_iterator<_CharT2>,
			       std::istreambuf_iterator<_CharT2>, _CharT2 *);
		template <class _CharT2>
		friend typename __gnu_cxx::__enable_if<
			__is_char<_CharT2>::__value,
			istreambuf_iterator<_CharT2>>::__type
		find(std::istreambuf_iterator<_CharT2>,
		     std::istreambuf_iterator<_CharT2>, const _CharT2 &);
		template <class _CharT2, class _Distance>
		friend typename __gnu_cxx::__enable_if<
			__is_char<_CharT2>::__value, void>::__type
		advance(std::istreambuf_iterator<_CharT2> &, _Distance);
		friend void __istream_extract(std::istream &, char *,
					      std::streamsize);
		template <class _CharT2, class _Traits2, class _Alloc>
		friend basic_istream<_CharT2, _Traits2> &operator>>(
			std::basic_istream<_CharT2, _Traits2> &,
			std::__cxx11::basic_string<_CharT2, _Traits2, _Alloc> &);
		template <class _CharT2, class _Traits2, class _Alloc>
		friend basic_istream<_CharT2, _Traits2> &
		getline(std::basic_istream<_CharT2, _Traits2> &,
			std::__cxx11::basic_string<_CharT2, _Traits2, _Alloc> &,
			_CharT2);

	    protected:
		char_type *_M_in_beg;
		char_type *_M_in_cur;
		char_type *_M_in_end;
		char_type *_M_out_beg;
		char_type *_M_out_cur;
		char_type *_M_out_end;
		locale _M_buf_locale;

	    public:
		virtual ~basic_streambuf()
		{
		}
		locale pubimbue(const locale &__loc)
		{
			locale __tmp(getloc());
			imbue(__loc);
			((_M_buf_locale) = __loc);
			return __tmp;
		}
		locale getloc() const
		{
			return _M_buf_locale;
		}
		basic_streambuf *pubsetbuf(char_type *__s, streamsize __n)
		{
			return setbuf(__s, __n);
		}
		pos_type pubseekoff(off_type __off, ios_base::seekdir __way,
				    ios_base::openmode __mode = (ios_base::in |
								 ios_base::out))
		{
			return seekoff(__off, __way, __mode);
		}
		pos_type pubseekpos(pos_type __sp,
				    ios_base::openmode __mode = (ios_base::in |
								 ios_base::out))
		{
			return seekpos(__sp, __mode);
		}
		int pubsync()
		{
			return sync();
		}
		streamsize in_avail()
		{
			const streamsize __ret = egptr() - gptr();
			return (__ret) ? __ret : showmanyc();
		}
		int_type snextc()
		{
			int_type __ret = traits_type::eof();
			if (__builtin_expect(!traits_type::eq_int_type(sbumpc(),
								       __ret),
					     true)) {
				__ret = sgetc();
			}
			return __ret;
		}
		int_type sbumpc()
		{
			int_type __ret;
			if (__builtin_expect(gptr() < egptr(), true)) {
				__ret = traits_type::to_int_type(*gptr());
				gbump(1);
			} else {
				__ret = uflow();
			}
			return __ret;
		}
		int_type sgetc()
		{
			int_type __ret;
			if (__builtin_expect(gptr() < egptr(), true)) {
				__ret = traits_type::to_int_type(*gptr());
			} else {
				__ret = underflow();
			}
			return __ret;
		}
		streamsize sgetn(char_type *__s, streamsize __n)
		{
			return xsgetn(__s, __n);
		}
		int_type sputbackc(char_type __c)
		{
			int_type __ret;
			const bool __testpos = eback() < gptr();
			if (__builtin_expect(
				    (!__testpos) ||
					    (!traits_type::eq(__c, gptr()[-1])),
				    false)) {
				__ret = pbackfail(
					traits_type::to_int_type(__c));
			} else {
				gbump(-1);
				__ret = traits_type::to_int_type(*gptr());
			}
			return __ret;
		}
		int_type sungetc()
		{
			int_type __ret;
			if (__builtin_expect(eback() < gptr(), true)) {
				gbump(-1);
				__ret = traits_type::to_int_type(*gptr());
			} else {
				__ret = pbackfail();
			}
			return __ret;
		}
		int_type sputc(char_type __c)
		{
			int_type __ret;
			if (__builtin_expect(pptr() < epptr(), true)) {
				(*pptr()) = __c;
				pbump(1);
				__ret = traits_type::to_int_type(__c);
			} else {
				__ret = overflow(traits_type::to_int_type(__c));
			}
			return __ret;
		}
		streamsize sputn(const char_type *__s, streamsize __n)
		{
			return xsputn(__s, __n);
		}

	    protected:
		basic_streambuf()
			: _M_in_beg((0)), _M_in_cur((0)), _M_in_end((0)),
			  _M_out_beg((0)), _M_out_cur((0)), _M_out_end((0)),
			  _M_buf_locale(locale())
		{
		}
		char_type *eback() const
		{
			return _M_in_beg;
		}
		char_type *gptr() const
		{
			return _M_in_cur;
		}
		char_type *egptr() const
		{
			return _M_in_end;
		}
		void gbump(int __n)
		{
			(_M_in_cur) += __n;
		}
		void setg(char_type *__gbeg, char_type *__gnext,
			  char_type *__gend)
		{
			(_M_in_beg) = __gbeg;
			(_M_in_cur) = __gnext;
			(_M_in_end) = __gend;
		}
		char_type *pbase() const
		{
			return _M_out_beg;
		}
		char_type *pptr() const
		{
			return _M_out_cur;
		}
		char_type *epptr() const
		{
			return _M_out_end;
		}
		void pbump(int __n)
		{
			(_M_out_cur) += __n;
		}
		void setp(char_type *__pbeg, char_type *__pend)
		{
			(_M_out_beg) = ((_M_out_cur) = __pbeg);
			(_M_out_end) = __pend;
		}
		virtual void imbue(const locale &__loc
				   __attribute((__unused__)))
		{
		}
		virtual basic_streambuf *setbuf(char_type *, streamsize)
		{
			return this;
		}
		virtual pos_type seekoff(off_type, ios_base::seekdir,
					 ios_base::openmode = (ios_base::in |
							       ios_base::out))
		{
			return (pos_type)((off_type)(-1));
		}
		virtual pos_type seekpos(pos_type,
					 ios_base::openmode = (ios_base::in |
							       ios_base::out))
		{
			return (pos_type)((off_type)(-1));
		}
		virtual int sync()
		{
			return 0;
		}
		virtual streamsize showmanyc()
		{
			return 0;
		}
		virtual streamsize xsgetn(char_type *__s, streamsize __n);
		virtual int_type underflow()
		{
			return traits_type::eof();
		}
		virtual int_type uflow()
		{
			int_type __ret = traits_type::eof();
			const bool __testeof =
				traits_type::eq_int_type(underflow(), __ret);
			if (!__testeof) {
				__ret = traits_type::to_int_type(*gptr());
				gbump(1);
			}
			return __ret;
		}
		virtual int_type
		pbackfail(int_type __c
			  __attribute((__unused__)) = traits_type::eof())
		{
			return traits_type::eof();
		}
		virtual streamsize xsputn(const char_type *__s, streamsize __n);
		virtual int_type
		overflow(int_type __c
			 __attribute((__unused__)) = traits_type::eof())
		{
			return traits_type::eof();
		}
		void __safe_gbump(streamsize __n)
		{
			(_M_in_cur) += __n;
		}
		void __safe_pbump(streamsize __n)
		{
			(_M_out_cur) += __n;
		}
		basic_streambuf(const basic_streambuf &);
		basic_streambuf &operator=(const basic_streambuf &);
		void swap(basic_streambuf &__sb)
		{
			std::swap(_M_in_beg, __sb._M_in_beg);
			std::swap(_M_in_cur, __sb._M_in_cur);
			std::swap(_M_in_end, __sb._M_in_end);
			std::swap(_M_out_beg, __sb._M_out_beg);
			std::swap(_M_out_cur, __sb._M_out_cur);
			std::swap(_M_out_end, __sb._M_out_end);
			std::swap(_M_buf_locale, __sb._M_buf_locale);
		}
	};
	template <typename _CharT, typename _Traits>
	std ::basic_streambuf<_CharT, _Traits>::basic_streambuf(
		const basic_streambuf &) = default;
	template <typename _CharT, typename _Traits>
	std ::basic_streambuf<_CharT, _Traits>
		&std ::basic_streambuf<_CharT, _Traits>::operator=(
			const basic_streambuf &) = default;
	template <>
	streamsize __copy_streambufs_eof(basic_streambuf<char> * __sbin,
					 basic_streambuf<char> * __sbout,
					 bool &__ineof);
	template <>
	streamsize __copy_streambufs_eof(basic_streambuf<wchar_t> * __sbin,
					 basic_streambuf<wchar_t> * __sbout,
					 bool &__ineof);
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _CharT, class _Traits>
	streamsize basic_streambuf<_CharT, _Traits>::xsgetn(char_type * __s,
							    streamsize __n)
	{
		streamsize __ret = (0);
		while (__ret < __n) {
			const streamsize __buf_len = egptr() - gptr();
			if (__buf_len) {
				const streamsize __remaining = __n - __ret;
				const streamsize __len =
					std::min(__buf_len, __remaining);
				traits_type::copy(__s, gptr(), __len);
				__ret += __len;
				__s += __len;
				__safe_gbump(__len);
			}
			if (__ret < __n) {
				const int_type __c = uflow();
				if (!traits_type::eq_int_type(
					    __c, traits_type::eof())) {
					traits_type::assign(
						*(__s++),
						traits_type::to_char_type(__c));
					++__ret;
				} else {
					break;
				}
			}
		}
		return __ret;
	}
	template <class _CharT, class _Traits>
	streamsize basic_streambuf<_CharT, _Traits>::xsputn(
		const char_type *__s, streamsize __n)
	{
		streamsize __ret = (0);
		while (__ret < __n) {
			const streamsize __buf_len = epptr() - pptr();
			if (__buf_len) {
				const streamsize __remaining = __n - __ret;
				const streamsize __len =
					std::min(__buf_len, __remaining);
				traits_type::copy(pptr(), __s, __len);
				__ret += __len;
				__s += __len;
				__safe_pbump(__len);
			}
			if (__ret < __n) {
				int_type __c = overflow(
					traits_type::to_int_type(*__s));
				if (!traits_type::eq_int_type(
					    __c, traits_type::eof())) {
					++__ret;
					++__s;
				} else {
					break;
				}
			}
		}
		return __ret;
	}
	template <class _CharT, class _Traits>
	streamsize __copy_streambufs_eof(
		basic_streambuf<_CharT, _Traits> * __sbin,
		basic_streambuf<_CharT, _Traits> * __sbout, bool &__ineof)
	{
		streamsize __ret = (0);
		__ineof = true;
		typename _Traits::int_type __c = __sbin->sgetc();
		while (!_Traits::eq_int_type(__c, _Traits::eof())) {
			__c = __sbout->sputc(_Traits::to_char_type(__c));
			if (_Traits::eq_int_type(__c, _Traits::eof())) {
				__ineof = false;
				break;
			}
			++__ret;
			__c = __sbin->snextc();
		}
		return __ret;
	}
	template <class _CharT, class _Traits>
	inline streamsize __copy_streambufs(
		basic_streambuf<_CharT, _Traits> * __sbin,
		basic_streambuf<_CharT, _Traits> * __sbout)
	{
		bool __ineof;
		return __copy_streambufs_eof(__sbin, __sbout, __ineof);
	}
	extern template class basic_streambuf<char>;
	extern template streamsize __copy_streambufs(
		basic_streambuf<char> * __sbin,
		basic_streambuf<char> * __sbout);
	extern template class basic_streambuf<wchar_t>;
	extern template streamsize __copy_streambufs(
		basic_streambuf<wchar_t> * __sbin,
		basic_streambuf<wchar_t> * __sbout);
} // namespace )
typedef unsigned long wctype_t;
enum {
	__ISwupper,
	__ISwlower,
	__ISwalpha,
	__ISwdigit,
	__ISwxdigit,
	__ISwspace,
	__ISwprint,
	__ISwgraph,
	__ISwblank,
	__ISwcntrl,
	__ISwpunct,
	__ISwalnum,
	_ISwupper =
		((__ISwupper < 8) ?
			 (int)((1UL << __ISwupper) << 24) :
			 ((__ISwupper < 16) ?
				  (int)((1UL << __ISwupper) << 8) :
				  ((__ISwupper < 24) ?
					   (int)((1UL << __ISwupper) >> 8) :
					   ((int)((1UL << __ISwupper) >> 24))))),
	_ISwlower =
		((__ISwlower < 8) ?
			 (int)((1UL << __ISwlower) << 24) :
			 ((__ISwlower < 16) ?
				  (int)((1UL << __ISwlower) << 8) :
				  ((__ISwlower < 24) ?
					   (int)((1UL << __ISwlower) >> 8) :
					   ((int)((1UL << __ISwlower) >> 24))))),
	_ISwalpha =
		((__ISwalpha < 8) ?
			 (int)((1UL << __ISwalpha) << 24) :
			 ((__ISwalpha < 16) ?
				  (int)((1UL << __ISwalpha) << 8) :
				  ((__ISwalpha < 24) ?
					   (int)((1UL << __ISwalpha) >> 8) :
					   ((int)((1UL << __ISwalpha) >> 24))))),
	_ISwdigit =
		((__ISwdigit < 8) ?
			 (int)((1UL << __ISwdigit) << 24) :
			 ((__ISwdigit < 16) ?
				  (int)((1UL << __ISwdigit) << 8) :
				  ((__ISwdigit < 24) ?
					   (int)((1UL << __ISwdigit) >> 8) :
					   ((int)((1UL << __ISwdigit) >> 24))))),
	_ISwxdigit =
		((__ISwxdigit < 8) ?
			 (int)((1UL << __ISwxdigit) << 24) :
			 ((__ISwxdigit < 16) ?
				  (int)((1UL << __ISwxdigit) << 8) :
				  ((__ISwxdigit < 24) ?
					   (int)((1UL << __ISwxdigit) >> 8) :
					   ((int)((1UL << __ISwxdigit) >>
						  24))))),
	_ISwspace =
		((__ISwspace < 8) ?
			 (int)((1UL << __ISwspace) << 24) :
			 ((__ISwspace < 16) ?
				  (int)((1UL << __ISwspace) << 8) :
				  ((__ISwspace < 24) ?
					   (int)((1UL << __ISwspace) >> 8) :
					   ((int)((1UL << __ISwspace) >> 24))))),
	_ISwprint =
		((__ISwprint < 8) ?
			 (int)((1UL << __ISwprint) << 24) :
			 ((__ISwprint < 16) ?
				  (int)((1UL << __ISwprint) << 8) :
				  ((__ISwprint < 24) ?
					   (int)((1UL << __ISwprint) >> 8) :
					   ((int)((1UL << __ISwprint) >> 24))))),
	_ISwgraph =
		((__ISwgraph < 8) ?
			 (int)((1UL << __ISwgraph) << 24) :
			 ((__ISwgraph < 16) ?
				  (int)((1UL << __ISwgraph) << 8) :
				  ((__ISwgraph < 24) ?
					   (int)((1UL << __ISwgraph) >> 8) :
					   ((int)((1UL << __ISwgraph) >> 24))))),
	_ISwblank =
		((__ISwblank < 8) ?
			 (int)((1UL << __ISwblank) << 24) :
			 ((__ISwblank < 16) ?
				  (int)((1UL << __ISwblank) << 8) :
				  ((__ISwblank < 24) ?
					   (int)((1UL << __ISwblank) >> 8) :
					   ((int)((1UL << __ISwblank) >> 24))))),
	_ISwcntrl =
		((__ISwcntrl < 8) ?
			 (int)((1UL << __ISwcntrl) << 24) :
			 ((__ISwcntrl < 16) ?
				  (int)((1UL << __ISwcntrl) << 8) :
				  ((__ISwcntrl < 24) ?
					   (int)((1UL << __ISwcntrl) >> 8) :
					   ((int)((1UL << __ISwcntrl) >> 24))))),
	_ISwpunct =
		((__ISwpunct < 8) ?
			 (int)((1UL << __ISwpunct) << 24) :
			 ((__ISwpunct < 16) ?
				  (int)((1UL << __ISwpunct) << 8) :
				  ((__ISwpunct < 24) ?
					   (int)((1UL << __ISwpunct) >> 8) :
					   ((int)((1UL << __ISwpunct) >> 24))))),
	_ISwalnum =
		((__ISwalnum < 8) ?
			 (int)((1UL << __ISwalnum) << 24) :
			 ((__ISwalnum < 16) ?
				  (int)((1UL << __ISwalnum) << 8) :
				  ((__ISwalnum < 24) ?
					   (int)((1UL << __ISwalnum) >> 8) :
					   ((int)((1UL << __ISwalnum) >> 24)))))
};
extern "C" {
extern int iswalnum(wint_t __wc) noexcept(true);
extern int iswalpha(wint_t __wc) noexcept(true);
extern int iswcntrl(wint_t __wc) noexcept(true);
extern int iswdigit(wint_t __wc) noexcept(true);
extern int iswgraph(wint_t __wc) noexcept(true);
extern int iswlower(wint_t __wc) noexcept(true);
extern int iswprint(wint_t __wc) noexcept(true);
extern int iswpunct(wint_t __wc) noexcept(true);
extern int iswspace(wint_t __wc) noexcept(true);
extern int iswupper(wint_t __wc) noexcept(true);
extern int iswxdigit(wint_t __wc) noexcept(true);
extern int iswblank(wint_t __wc) noexcept(true);
extern wctype_t wctype(const char *__property) noexcept(true);
extern int iswctype(wint_t __wc, wctype_t __desc) noexcept(true);
extern wint_t towlower(wint_t __wc) noexcept(true);
extern wint_t towupper(wint_t __wc) noexcept(true);
}
extern "C" {
typedef const __int32_t *wctrans_t;
extern wctrans_t wctrans(const char *__property) noexcept(true);
extern wint_t towctrans(wint_t __wc, wctrans_t __desc) noexcept(true);
extern int iswalnum_l(wint_t __wc, locale_t __locale) noexcept(true);
extern int iswalpha_l(wint_t __wc, locale_t __locale) noexcept(true);
extern int iswcntrl_l(wint_t __wc, locale_t __locale) noexcept(true);
extern int iswdigit_l(wint_t __wc, locale_t __locale) noexcept(true);
extern int iswgraph_l(wint_t __wc, locale_t __locale) noexcept(true);
extern int iswlower_l(wint_t __wc, locale_t __locale) noexcept(true);
extern int iswprint_l(wint_t __wc, locale_t __locale) noexcept(true);
extern int iswpunct_l(wint_t __wc, locale_t __locale) noexcept(true);
extern int iswspace_l(wint_t __wc, locale_t __locale) noexcept(true);
extern int iswupper_l(wint_t __wc, locale_t __locale) noexcept(true);
extern int iswxdigit_l(wint_t __wc, locale_t __locale) noexcept(true);
extern int iswblank_l(wint_t __wc, locale_t __locale) noexcept(true);
extern wctype_t wctype_l(const char *__property,
			 locale_t __locale) noexcept(true);
extern int iswctype_l(wint_t __wc, wctype_t __desc,
		      locale_t __locale) noexcept(true);
extern wint_t towlower_l(wint_t __wc, locale_t __locale) noexcept(true);
extern wint_t towupper_l(wint_t __wc, locale_t __locale) noexcept(true);
extern wctrans_t wctrans_l(const char *__property,
			   locale_t __locale) noexcept(true);
extern wint_t towctrans_l(wint_t __wc, wctrans_t __desc,
			  locale_t __locale) noexcept(true);
}
namespace std
{
using ::iswalnum;
using ::iswalpha;
using ::iswblank;
using ::iswcntrl;
using ::iswctype;
using ::iswdigit;
using ::iswgraph;
using ::iswlower;
using ::iswprint;
using ::iswpunct;
using ::iswspace;
using ::iswupper;
using ::iswxdigit;
using ::towctrans;
using ::towlower;
using ::towupper;
using ::wctrans;
using ::wctrans_t;
using ::wctype;
using ::wctype_t;
} // namespace std
namespace std __attribute((__visibility__("default")))
{
	struct ctype_base {
		typedef const int *__to_type;
		typedef unsigned short mask;
		static const mask upper = (_ISupper);
		static const mask lower = (_ISlower);
		static const mask alpha = (_ISalpha);
		static const mask digit = (_ISdigit);
		static const mask xdigit = (_ISxdigit);
		static const mask space = (_ISspace);
		static const mask print = (_ISprint);
		static const mask graph =
			(((_ISalpha) | (_ISdigit)) | (_ISpunct));
		static const mask cntrl = (_IScntrl);
		static const mask punct = (_ISpunct);
		static const mask alnum = ((_ISalpha) | (_ISdigit));
		static const mask blank = (_ISblank);
	};
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _CharT, class _Traits>
	class istreambuf_iterator
		: public iterator<input_iterator_tag, _CharT,
				  typename _Traits::off_type, _CharT *, _CharT> {
	    public:
		typedef _CharT char_type;
		typedef _Traits traits_type;
		typedef typename _Traits::int_type int_type;
		typedef basic_streambuf<_CharT, _Traits> streambuf_type;
		typedef basic_istream<_CharT, _Traits> istream_type;
		template <class _CharT2>
		friend typename __gnu_cxx::__enable_if<
			__is_char<_CharT2>::__value,
			ostreambuf_iterator<_CharT2>>::__type
			copy(std::istreambuf_iterator<_CharT2>,
			     std::istreambuf_iterator<_CharT2>,
			     std::ostreambuf_iterator<_CharT2>);
		template <bool _IsMove, class _CharT2>
		friend typename __gnu_cxx::__enable_if<
			__is_char<_CharT2>::__value, _CharT2 *>::__type
		__copy_move_a2(std::istreambuf_iterator<_CharT2>,
			       std::istreambuf_iterator<_CharT2>, _CharT2 *);
		template <class _CharT2, class _Size>
		friend typename __gnu_cxx::__enable_if<
			__is_char<_CharT2>::__value, _CharT2 *>::__type
		__copy_n_a(std::istreambuf_iterator<_CharT2>, _Size, _CharT2 *,
			   bool);
		template <class _CharT2>
		friend typename __gnu_cxx::__enable_if<
			__is_char<_CharT2>::__value,
			istreambuf_iterator<_CharT2>>::__type
		find(std::istreambuf_iterator<_CharT2>,
		     std::istreambuf_iterator<_CharT2>, const _CharT2 &);
		template <class _CharT2, class _Distance>
		friend typename __gnu_cxx::__enable_if<
			__is_char<_CharT2>::__value, void>::__type
		advance(std::istreambuf_iterator<_CharT2> &, _Distance);

	    private:
		mutable streambuf_type *_M_sbuf;
		int_type _M_c;

	    public:
		constexpr istreambuf_iterator() noexcept
			: _M_sbuf((0)), _M_c(traits_type::eof())
		{
		}
		istreambuf_iterator(const istreambuf_iterator &) noexcept =
			default;
		~istreambuf_iterator() = default;
		istreambuf_iterator(istream_type &__s) noexcept
			: _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof())
		{
		}
		istreambuf_iterator(streambuf_type *__s) noexcept
			: _M_sbuf(__s), _M_c(traits_type::eof())
		{
		}
		istreambuf_iterator &
		operator=(const istreambuf_iterator &) noexcept = default;
		[[__nodiscard__]] char_type operator*() const
		{
			int_type __c = _M_get();
			return traits_type::to_char_type(__c);
		}
		istreambuf_iterator &operator++()
		{
			;
			(_M_sbuf)->sbumpc();
			(_M_c) = traits_type::eof();
			return *this;
		}
		istreambuf_iterator operator++(int)
		{
			;
			istreambuf_iterator __old = *this;
			(__old._M_c) = (_M_sbuf)->sbumpc();
			(_M_c) = traits_type::eof();
			return __old;
		}
		[[__nodiscard__]] bool
		equal(const istreambuf_iterator &__b) const
		{
			return _M_at_eof() == __b._M_at_eof();
		}

	    private:
		int_type _M_get() const
		{
			int_type __ret = _M_c;
			if ((_M_sbuf) && (_S_is_eof)(__ret) &&
			    (_S_is_eof)(__ret = (_M_sbuf)->sgetc())) {
				(_M_sbuf) = 0;
			}
			return __ret;
		}
		bool _M_at_eof() const
		{
			return (_S_is_eof)(_M_get());
		}
		static bool _S_is_eof(int_type __c)
		{
			const int_type __eof = traits_type::eof();
			return traits_type::eq_int_type(__c, __eof);
		}
	};
	template <class _CharT, class _Traits>
	[[__nodiscard__]] inline bool operator==(
		const istreambuf_iterator<_CharT, _Traits> &__a,
		const istreambuf_iterator<_CharT, _Traits> &__b)
	{
		return __a.equal(__b);
	}
	template <class _CharT, class _Traits>
	[[__nodiscard__]] inline bool operator!=(
		const istreambuf_iterator<_CharT, _Traits> &__a,
		const istreambuf_iterator<_CharT, _Traits> &__b)
	{
		return !__a.equal(__b);
	}
	template <class _CharT, class _Traits>
	class ostreambuf_iterator
		: public iterator<output_iterator_tag, void, void, void, void> {
	    public:
		typedef _CharT char_type;
		typedef _Traits traits_type;
		typedef basic_streambuf<_CharT, _Traits> streambuf_type;
		typedef basic_ostream<_CharT, _Traits> ostream_type;
		template <class _CharT2>
		friend typename __gnu_cxx::__enable_if<
			__is_char<_CharT2>::__value,
			ostreambuf_iterator<_CharT2>>::__type
			copy(std::istreambuf_iterator<_CharT2>,
			     std::istreambuf_iterator<_CharT2>,
			     std::ostreambuf_iterator<_CharT2>);

	    private:
		streambuf_type *_M_sbuf;
		bool _M_failed;

	    public:
		ostreambuf_iterator(ostream_type &__s) noexcept
			: _M_sbuf(__s.rdbuf()), _M_failed((!(_M_sbuf)))
		{
		}
		ostreambuf_iterator(streambuf_type *__s) noexcept
			: _M_sbuf(__s), _M_failed((!(_M_sbuf)))
		{
		}
		ostreambuf_iterator &operator=(_CharT __c)
		{
			if ((!(_M_failed)) &&
			    _Traits::eq_int_type((_M_sbuf)->sputc(__c),
						 _Traits::eof())) {
				(_M_failed) = true;
			}
			return *this;
		}
		[[__nodiscard__]] ostreambuf_iterator &operator*()
		{
			return *this;
		}
		ostreambuf_iterator &operator++(int)
		{
			return *this;
		}
		ostreambuf_iterator &operator++()
		{
			return *this;
		}
		[[__nodiscard__]] bool failed() const noexcept
		{
			return _M_failed;
		}
		ostreambuf_iterator &_M_put(const _CharT *__ws,
					    streamsize __len)
		{
			if ((__builtin_expect(!(_M_failed), true)) &&
			    (__builtin_expect(
				    (this->_M_sbuf)->sputn(__ws, __len) != __len,
				    false))) {
				(_M_failed) = true;
			}
			return *this;
		}
	};
	template <class _CharT>
	typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
					ostreambuf_iterator<_CharT>>::__type
	copy(istreambuf_iterator<_CharT> __first,
	     istreambuf_iterator<_CharT> __last,
	     ostreambuf_iterator<_CharT> __result)
	{
		if ((__first._M_sbuf) && (!(__last._M_sbuf)) &&
		    (!(__result._M_failed))) {
			bool __ineof;
			__copy_streambufs_eof((__first._M_sbuf),
					      (__result._M_sbuf), __ineof);
			if (!__ineof) {
				(__result._M_failed) = true;
			}
		}
		return __result;
	}
	template <bool _IsMove, class _CharT>
	typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
					ostreambuf_iterator<_CharT>>::__type
	__copy_move_a2(_CharT * __first, _CharT * __last,
		       ostreambuf_iterator<_CharT> __result)
	{
		const streamsize __num = __last - __first;
		if (__num > (0)) {
			__result._M_put(__first, __num);
		}
		return __result;
	}
	template <bool _IsMove, class _CharT>
	typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
					ostreambuf_iterator<_CharT>>::__type
	__copy_move_a2(const _CharT *__first, const _CharT *__last,
		       ostreambuf_iterator<_CharT> __result)
	{
		const streamsize __num = __last - __first;
		if (__num > (0)) {
			__result._M_put(__first, __num);
		}
		return __result;
	}
	template <bool _IsMove, class _CharT>
	typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
					_CharT *>::__type
	__copy_move_a2(istreambuf_iterator<_CharT> __first,
		       istreambuf_iterator<_CharT> __last, _CharT * __result)
	{
		typedef istreambuf_iterator<_CharT> __is_iterator_type;
		typedef typename istreambuf_iterator<_CharT>::traits_type
			traits_type;
		typedef typename istreambuf_iterator<_CharT>::streambuf_type
			streambuf_type;
		typedef typename istreambuf_iterator<
			_CharT>::traits_type::int_type int_type;
		if ((__first._M_sbuf) && (!(__last._M_sbuf))) {
			streambuf_type *__sb = ((__first._M_sbuf));
			int_type __c = __sb->sgetc();
			while (!traits_type::eq_int_type(__c,
							 traits_type::eof())) {
				const streamsize __n =
					__sb->egptr() - __sb->gptr();
				if (__n > (1)) {
					traits_type::copy(__result,
							  __sb->gptr(), __n);
					__sb->__safe_gbump(__n);
					__result += __n;
					__c = __sb->underflow();
				} else {
					(*(__result++)) =
						traits_type::to_char_type(__c);
					__c = __sb->snextc();
				}
			}
		}
		return __result;
	}
	template <class _CharT, class _Size>
	typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
					_CharT *>::__type
	__copy_n_a(istreambuf_iterator<_CharT> __it, _Size __n,
		   _CharT * __result, bool __strict __attribute((__unused__)))
	{
		if (__n == 0) {
			return __result;
		};
		_CharT *__beg = __result;
		__result += (__it._M_sbuf)->sgetn(__beg, __n);
		;
		return __result;
	}
	template <class _CharT>
	typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
					istreambuf_iterator<_CharT>>::__type
	find(istreambuf_iterator<_CharT> __first,
	     istreambuf_iterator<_CharT> __last, const _CharT &__val)
	{
		typedef istreambuf_iterator<_CharT> __is_iterator_type;
		typedef typename istreambuf_iterator<_CharT>::traits_type
			traits_type;
		typedef typename istreambuf_iterator<_CharT>::streambuf_type
			streambuf_type;
		typedef typename istreambuf_iterator<
			_CharT>::traits_type::int_type int_type;
		const int_type __eof = traits_type::eof();
		if ((__first._M_sbuf) && (!(__last._M_sbuf))) {
			const int_type __ival = traits_type::to_int_type(__val);
			streambuf_type *__sb = ((__first._M_sbuf));
			int_type __c = __sb->sgetc();
			while ((!traits_type::eq_int_type(__c, __eof)) &&
			       (!traits_type::eq_int_type(__c, __ival))) {
				streamsize __n = __sb->egptr() - __sb->gptr();
				if (__n > (1)) {
					const _CharT *__p = traits_type::find(
						__sb->gptr(), __n, __val);
					if (__p) {
						__n = (__p - __sb->gptr());
					}
					__sb->__safe_gbump(__n);
					__c = __sb->sgetc();
				} else {
					__c = __sb->snextc();
				}
			}
			(__first._M_c) = __eof;
		}
		return __first;
	}
	template <class _CharT, class _Distance>
	typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, void>::__type
	advance(istreambuf_iterator<_CharT> & __i, _Distance __n)
	{
		if (__n == 0) {
			return;
		}
		do {
			if (std::__is_constant_evaluated() &&
			    (!((bool)(__n > 0)))) {
				__builtin_unreachable();
			}
		} while (false);
		;
		typedef istreambuf_iterator<_CharT> __is_iterator_type;
		typedef typename istreambuf_iterator<_CharT>::traits_type
			traits_type;
		typedef typename istreambuf_iterator<_CharT>::streambuf_type
			streambuf_type;
		typedef typename istreambuf_iterator<
			_CharT>::traits_type::int_type int_type;
		const int_type __eof = traits_type::eof();
		streambuf_type *__sb = ((__i._M_sbuf));
		while (__n > 0) {
			streamsize __size = __sb->egptr() - __sb->gptr();
			if (__size > __n) {
				__sb->__safe_gbump(__n);
				break;
			}
			__sb->__safe_gbump(__size);
			__n -= __size;
			if (traits_type::eq_int_type(__sb->underflow(),
						     __eof)) {
				;
				break;
			}
		}
		(__i._M_c) = __eof;
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _Tp>
	void __convert_to_v(const char *, _Tp &, ios_base::iostate &,
			    const __c_locale &) throw();
	template <>
	void __convert_to_v(const char *, float &, ios_base::iostate &,
			    const __c_locale &) throw();
	template <>
	void __convert_to_v(const char *, double &, ios_base::iostate &,
			    const __c_locale &) throw();
	template <>
	void __convert_to_v(const char *, long double &, ios_base::iostate &,
			    const __c_locale &) throw();
	template <class _CharT, class _Traits> struct __pad {
		static void _S_pad(ios_base &__io, _CharT __fill,
				   _CharT *__news, const _CharT *__olds,
				   streamsize __newlen, streamsize __oldlen);
	};
	template <class _CharT>
	_CharT *__add_grouping(_CharT * __s, _CharT __sep, const char *__gbeg,
			       size_t __gsize, const _CharT *__first,
			       const _CharT *__last);
	template <class _CharT>
	inline ostreambuf_iterator<_CharT> __write(
		ostreambuf_iterator<_CharT> __s, const _CharT *__ws, int __len)
	{
		__s._M_put(__ws, __len);
		return __s;
	}
	template <class _CharT, class _OutIter>
	inline _OutIter __write(_OutIter __s, const _CharT *__ws, int __len)
	{
		for (int __j = 0; __j < __len; (__j++), (++__s)) {
			(*__s) = (__ws[__j]);
		}
		return __s;
	}
	template <class _CharT>
	class __ctype_abstract_base : public locale::facet, public ctype_base {
	    public:
		typedef _CharT char_type;
		bool is(mask __m, char_type __c) const
		{
			return this->do_is(__m, __c);
		}
		const char_type *is(const char_type *__lo,
				    const char_type *__hi, mask *__vec) const
		{
			return this->do_is(__lo, __hi, __vec);
		}
		const char_type *scan_is(mask __m, const char_type *__lo,
					 const char_type *__hi) const
		{
			return do_scan_is(__m, __lo, __hi);
		}
		const char_type *scan_not(mask __m, const char_type *__lo,
					  const char_type *__hi) const
		{
			return do_scan_not(__m, __lo, __hi);
		}
		char_type toupper(char_type __c) const
		{
			return this->do_toupper(__c);
		}
		const char_type *toupper(char_type *__lo,
					 const char_type *__hi) const
		{
			return this->do_toupper(__lo, __hi);
		}
		char_type tolower(char_type __c) const
		{
			return this->do_tolower(__c);
		}
		const char_type *tolower(char_type *__lo,
					 const char_type *__hi) const
		{
			return this->do_tolower(__lo, __hi);
		}
		char_type widen(char __c) const
		{
			return this->do_widen(__c);
		}
		const char *widen(const char *__lo, const char *__hi,
				  char_type *__to) const
		{
			return this->do_widen(__lo, __hi, __to);
		}
		char narrow(char_type __c, char __dfault) const
		{
			return this->do_narrow(__c, __dfault);
		}
		const char_type *narrow(const char_type *__lo,
					const char_type *__hi, char __dfault,
					char *__to) const
		{
			return this->do_narrow(__lo, __hi, __dfault, __to);
		}

	    protected:
		explicit __ctype_abstract_base(size_t __refs = 0)
			: locale::facet(__refs)
		{
		}
		virtual ~__ctype_abstract_base()
		{
		}
		virtual bool do_is(mask __m, char_type __c) const = 0;
		virtual const char_type *do_is(const char_type *__lo,
					       const char_type *__hi,
					       mask *__vec) const = 0;
		virtual const char_type *
		do_scan_is(mask __m, const char_type *__lo,
			   const char_type *__hi) const = 0;
		virtual const char_type *
		do_scan_not(mask __m, const char_type *__lo,
			    const char_type *__hi) const = 0;
		virtual char_type do_toupper(char_type __c) const = 0;
		virtual const char_type *
		do_toupper(char_type *__lo, const char_type *__hi) const = 0;
		virtual char_type do_tolower(char_type __c) const = 0;
		virtual const char_type *
		do_tolower(char_type *__lo, const char_type *__hi) const = 0;
		virtual char_type do_widen(char __c) const = 0;
		virtual const char *do_widen(const char *__lo, const char *__hi,
					     char_type *__to) const = 0;
		virtual char do_narrow(char_type __c, char __dfault) const = 0;
		virtual const char_type *do_narrow(const char_type *__lo,
						   const char_type *__hi,
						   char __dfault,
						   char *__to) const = 0;
	};
	template <class _CharT>
	class ctype : public __ctype_abstract_base<_CharT> {
	    public:
		typedef _CharT char_type;
		typedef typename __ctype_abstract_base<_CharT>::mask mask;
		static std::locale::id id;
		explicit ctype(std::size_t __refs = 0)
			: __ctype_abstract_base<_CharT>(__refs)
		{
		}

	    protected:
		virtual ~ctype();
		virtual bool do_is(mask __m, char_type __c) const;
		virtual const char_type *do_is(const char_type *__lo,
					       const char_type *__hi,
					       mask *__vec) const;
		virtual const char_type *
		do_scan_is(mask __m, const char_type *__lo,
			   const char_type *__hi) const;
		virtual const char_type *
		do_scan_not(mask __m, const char_type *__lo,
			    const char_type *__hi) const;
		virtual char_type do_toupper(char_type __c) const;
		virtual const char_type *
		do_toupper(char_type *__lo, const char_type *__hi) const;
		virtual char_type do_tolower(char_type __c) const;
		virtual const char_type *
		do_tolower(char_type *__lo, const char_type *__hi) const;
		virtual char_type do_widen(char __c) const;
		virtual const char *do_widen(const char *__lo, const char *__hi,
					     char_type *__dest) const;
		virtual char do_narrow(char_type, char __dfault) const;
		virtual const char_type *do_narrow(const char_type *__lo,
						   const char_type *__hi,
						   char __dfault,
						   char *__to) const;
	};
	template <class _CharT> locale::id ctype<_CharT>::id;
	template <class _CharT, class _Traits, class _Alloc>
	class ctype<__cxx11::basic_string<_CharT, _Traits, _Alloc>>;
	template <>
	class ctype<char> : public locale::facet, public ctype_base {
	    public:
		typedef char char_type;

	    protected:
		__c_locale _M_c_locale_ctype;
		bool _M_del;
		__to_type _M_toupper;
		__to_type _M_tolower;
		const mask *_M_table;
		mutable char _M_widen_ok;
		mutable char _M_widen[1 + (static_cast<unsigned char>(-1))];
		mutable char _M_narrow[1 + (static_cast<unsigned char>(-1))];
		mutable char _M_narrow_ok;

	    public:
		static locale::id id;
		static const size_t table_size =
			(1 + (static_cast<unsigned char>(-1)));
		explicit ctype(const mask *__table = 0, bool __del = false,
			       size_t __refs = 0);
		explicit ctype(__c_locale __cloc, const mask *__table = 0,
			       bool __del = false, size_t __refs = 0);
		inline bool is(mask __m, char __c) const;
		inline const char *is(const char *__lo, const char *__hi,
				      mask *__vec) const;
		inline const char *scan_is(mask __m, const char *__lo,
					   const char *__hi) const;
		inline const char *scan_not(mask __m, const char *__lo,
					    const char *__hi) const;
		char_type toupper(char_type __c) const
		{
			return this->do_toupper(__c);
		}
		const char_type *toupper(char_type *__lo,
					 const char_type *__hi) const
		{
			return this->do_toupper(__lo, __hi);
		}
		char_type tolower(char_type __c) const
		{
			return this->do_tolower(__c);
		}
		const char_type *tolower(char_type *__lo,
					 const char_type *__hi) const
		{
			return this->do_tolower(__lo, __hi);
		}
		char_type widen(char __c) const
		{
			if (_M_widen_ok) {
				return (_M_widen)[static_cast<unsigned char>(
					__c)];
			}
			this->_M_widen_init();
			return this->do_widen(__c);
		}
		const char *widen(const char *__lo, const char *__hi,
				  char_type *__to) const
		{
			if ((_M_widen_ok) == 1) {
				if (__builtin_expect(__hi != __lo, true)) {
					__builtin_memcpy(__to, __lo,
							 __hi - __lo);
				}
				return __hi;
			}
			if (!(_M_widen_ok)) {
				this->_M_widen_init();
			}
			return this->do_widen(__lo, __hi, __to);
		}
		char narrow(char_type __c, char __dfault) const
		{
			if ((_M_narrow)[static_cast<unsigned char>(__c)]) {
				return (_M_narrow)[static_cast<unsigned char>(
					__c)];
			}
			const char __t = this->do_narrow(__c, __dfault);
			if (__t != __dfault) {
				((_M_narrow)[static_cast<unsigned char>(__c)]) =
					__t;
			}
			return __t;
		}
		const char_type *narrow(const char_type *__lo,
					const char_type *__hi, char __dfault,
					char *__to) const
		{
			if (__builtin_expect((_M_narrow_ok) == 1, true)) {
				if (__builtin_expect(__hi != __lo, true)) {
					__builtin_memcpy(__to, __lo,
							 __hi - __lo);
				}
				return __hi;
			}
			if (!(_M_narrow_ok)) {
				this->_M_narrow_init();
			}
			return this->do_narrow(__lo, __hi, __dfault, __to);
		}
		const mask *table() const throw()
		{
			return _M_table;
		}
		static const mask *classic_table() throw();

	    protected:
		virtual ~ctype();
		virtual char_type do_toupper(char_type __c) const;
		virtual const char_type *
		do_toupper(char_type *__lo, const char_type *__hi) const;
		virtual char_type do_tolower(char_type __c) const;
		virtual const char_type *
		do_tolower(char_type *__lo, const char_type *__hi) const;
		virtual char_type do_widen(char __c) const
		{
			return __c;
		}
		virtual const char *do_widen(const char *__lo, const char *__hi,
					     char_type *__to) const
		{
			if (__builtin_expect(__hi != __lo, true)) {
				__builtin_memcpy(__to, __lo, __hi - __lo);
			}
			return __hi;
		}
		virtual char do_narrow(char_type __c, char __dfault
				       __attribute((__unused__))) const
		{
			return __c;
		}
		virtual const char_type *do_narrow(const char_type *__lo,
						   const char_type *__hi,
						   char __dfault
						   __attribute((__unused__)),
						   char *__to) const
		{
			if (__builtin_expect(__hi != __lo, true)) {
				__builtin_memcpy(__to, __lo, __hi - __lo);
			}
			return __hi;
		}

	    private:
		void _M_narrow_init() const;
		void _M_widen_init() const;
	};
	template <>
	class ctype<wchar_t> : public __ctype_abstract_base<wchar_t> {
	    public:
		typedef wchar_t char_type;
		typedef wctype_t __wmask_type;

	    protected:
		__c_locale _M_c_locale_ctype;
		bool _M_narrow_ok;
		char _M_narrow[128];
		wint_t _M_widen[1 + (static_cast<unsigned char>(-1))];
		mask _M_bit[16];
		__wmask_type _M_wmask[16];

	    public:
		static locale::id id;
		explicit ctype(size_t __refs = 0);
		explicit ctype(__c_locale __cloc, size_t __refs = 0);

	    protected:
		__wmask_type _M_convert_to_wmask(const mask __m) const throw();
		virtual ~ctype();
		virtual bool do_is(mask __m, char_type __c) const;
		virtual const char_type *do_is(const char_type *__lo,
					       const char_type *__hi,
					       mask *__vec) const;
		virtual const char_type *
		do_scan_is(mask __m, const char_type *__lo,
			   const char_type *__hi) const;
		virtual const char_type *
		do_scan_not(mask __m, const char_type *__lo,
			    const char_type *__hi) const;
		virtual char_type do_toupper(char_type __c) const;
		virtual const char_type *
		do_toupper(char_type *__lo, const char_type *__hi) const;
		virtual char_type do_tolower(char_type __c) const;
		virtual const char_type *
		do_tolower(char_type *__lo, const char_type *__hi) const;
		virtual char_type do_widen(char __c) const;
		virtual const char *do_widen(const char *__lo, const char *__hi,
					     char_type *__to) const;
		virtual char do_narrow(char_type __c, char __dfault) const;
		virtual const char_type *do_narrow(const char_type *__lo,
						   const char_type *__hi,
						   char __dfault,
						   char *__to) const;
		void _M_initialize_ctype() throw();
	};
	template <class _CharT> class ctype_byname : public ctype<_CharT> {
	    public:
		typedef typename ctype<_CharT>::mask mask;
		explicit ctype_byname(const char *__s, std::size_t __refs = 0);
		explicit ctype_byname(const std::string &__s,
				      std::size_t __refs = 0)
			: ctype_byname(__s.c_str(), __refs)
		{
		}

	    protected:
		virtual ~ctype_byname()
		{
		}
	};
	template <> class ctype_byname<char> : public ctype<char> {
	    public:
		explicit ctype_byname(const char *__s, size_t __refs = 0);
		explicit ctype_byname(const string &__s, size_t __refs = 0);

	    protected:
		virtual ~ctype_byname();
	};
	template <> class ctype_byname<wchar_t> : public ctype<wchar_t> {
	    public:
		explicit ctype_byname(const char *__s, size_t __refs = 0);
		explicit ctype_byname(const string &__s, size_t __refs = 0);

	    protected:
		virtual ~ctype_byname();
	};
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	inline bool ctype<char>::is(mask __m, char __c) const
	{
		return ((_M_table)[static_cast<unsigned char>(__c)]) & __m;
	}
	inline const char *ctype<char>::is(
		const char *__low, const char *__high, mask *__vec) const
	{
		while (__low < __high) {
			(*(__vec++)) = ((_M_table)[static_cast<unsigned char>(
				*(__low++))]);
		}
		return __high;
	}
	inline const char *ctype<char>::scan_is(mask __m, const char *__low,
						const char *__high) const
	{
		while ((__low < __high) &&
		       (!(((_M_table)[static_cast<unsigned char>(*__low)]) &
			  __m))) {
			++__low;
		}
		return __low;
	}
	inline const char *ctype<char>::scan_not(mask __m, const char *__low,
						 const char *__high) const
	{
		while ((__low < __high) &&
		       ((((_M_table)[static_cast<unsigned char>(*__low)]) &
			 __m) != 0)) {
			++__low;
		}
		return __low;
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	class __num_base {
	    public:
		enum {
			_S_ominus,
			_S_oplus,
			_S_ox,
			_S_oX,
			_S_odigits,
			_S_odigits_end = (_S_odigits + 16),
			_S_oudigits = _S_odigits_end,
			_S_oudigits_end = (_S_oudigits + 16),
			_S_oe = (_S_odigits + 14),
			_S_oE = (_S_oudigits + 14),
			_S_oend = _S_oudigits_end
		};
		static const char *_S_atoms_out;
		static const char *_S_atoms_in;
		enum {
			_S_iminus,
			_S_iplus,
			_S_ix,
			_S_iX,
			_S_izero,
			_S_ie = (_S_izero + 14),
			_S_iE = (_S_izero + 20),
			_S_iend = 26
		};
		static void _S_format_float(const ios_base &__io, char *__fptr,
					    char __mod) throw();
	};
	template <class _CharT> struct __numpunct_cache : public locale::facet {
		const char *_M_grouping;
		size_t _M_grouping_size;
		bool _M_use_grouping;
		const _CharT *_M_truename;
		size_t _M_truename_size;
		const _CharT *_M_falsename;
		size_t _M_falsename_size;
		_CharT _M_decimal_point;
		_CharT _M_thousands_sep;
		_CharT _M_atoms_out[__num_base::_S_oend];
		_CharT _M_atoms_in[__num_base::_S_iend];
		bool _M_allocated;
		__numpunct_cache(size_t __refs = 0)
			: locale::facet(__refs), _M_grouping((0)),
			  _M_grouping_size((0)), _M_use_grouping(false),
			  _M_truename((0)), _M_truename_size((0)),
			  _M_falsename((0)), _M_falsename_size((0)),
			  _M_decimal_point(_CharT()),
			  _M_thousands_sep(_CharT()), _M_allocated(false)
		{
		}
		virtual ~__numpunct_cache();
		void _M_cache(const locale &__loc);

	    private:
		__numpunct_cache &operator=(const __numpunct_cache &);
		explicit __numpunct_cache(const __numpunct_cache &);
	};
	template <class _CharT> __numpunct_cache<_CharT>::~__numpunct_cache()
	{
		if (_M_allocated) {
			delete[](_M_grouping);
			delete[](_M_truename);
			delete[](_M_falsename);
		}
	}
	inline namespace __cxx11
	{
	template <class _CharT> class numpunct : public locale::facet {
	    public:
		typedef _CharT char_type;
		typedef basic_string<_CharT> string_type;
		typedef __numpunct_cache<_CharT> __cache_type;

	    protected:
		__cache_type *_M_data;

	    public:
		static locale::id id;
		explicit numpunct(size_t __refs = 0)
			: locale::facet(__refs), _M_data((0))
		{
			_M_initialize_numpunct();
		}
		explicit numpunct(__cache_type *__cache, size_t __refs = 0)
			: locale::facet(__refs), _M_data(__cache)
		{
			_M_initialize_numpunct();
		}
		explicit numpunct(__c_locale __cloc, size_t __refs = 0)
			: locale::facet(__refs), _M_data((0))
		{
			_M_initialize_numpunct(__cloc);
		}
		char_type decimal_point() const
		{
			return do_decimal_point();
		}
		char_type thousands_sep() const
		{
			return do_thousands_sep();
		}
		string grouping() const
		{
			return do_grouping();
		}
		string_type truename() const
		{
			return do_truename();
		}
		string_type falsename() const
		{
			return do_falsename();
		}

	    protected:
		virtual ~numpunct();
		virtual char_type do_decimal_point() const
		{
			return (_M_data)->_M_decimal_point;
		}
		virtual char_type do_thousands_sep() const
		{
			return (_M_data)->_M_thousands_sep;
		}
		virtual string do_grouping() const
		{
			return (_M_data)->_M_grouping;
		}
		virtual string_type do_truename() const
		{
			return (_M_data)->_M_truename;
		}
		virtual string_type do_falsename() const
		{
			return (_M_data)->_M_falsename;
		}
		void _M_initialize_numpunct(__c_locale __cloc = 0);
	};
	template <class _CharT> locale::id numpunct<_CharT>::id;
	template <> numpunct<char>::~numpunct();
	template <>
	void numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);
	template <> numpunct<wchar_t>::~numpunct();
	template <>
	void numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);
	template <class _CharT>
	class numpunct_byname : public numpunct<_CharT> {
	    public:
		typedef _CharT char_type;
		typedef basic_string<_CharT> string_type;
		explicit numpunct_byname(const char *__s,
					 std::size_t __refs = 0)
			: numpunct<_CharT>(__refs)
		{
			if ((__builtin_strcmp(__s, "C") != 0) &&
			    (__builtin_strcmp(__s, "POSIX") != 0)) {
				std::__c_locale __tmp;
				this->_S_create_c_locale(__tmp, __s);
				this->_M_initialize_numpunct(__tmp);
				this->_S_destroy_c_locale(__tmp);
			}
		}
		explicit numpunct_byname(const std::string &__s,
					 std::size_t __refs = 0)
			: numpunct_byname(__s.c_str(), __refs)
		{
		}

	    protected:
		virtual ~numpunct_byname()
		{
		}
	};
	} // namespace __cxx11
	template <class _CharT, class _InIter>
	class num_get : public locale::facet {
	    public:
		typedef _CharT char_type;
		typedef _InIter iter_type;
		static locale::id id;
		explicit num_get(size_t __refs = 0) : locale::facet(__refs)
		{
		}
		iter_type get(iter_type __in, iter_type __end, ios_base &__io,
			      ios_base::iostate &__err, bool &__v) const
		{
			return this->do_get(__in, __end, __io, __err, __v);
		}
		iter_type get(iter_type __in, iter_type __end, ios_base &__io,
			      ios_base::iostate &__err, long &__v) const
		{
			return this->do_get(__in, __end, __io, __err, __v);
		}
		iter_type get(iter_type __in, iter_type __end, ios_base &__io,
			      ios_base::iostate &__err,
			      unsigned short &__v) const
		{
			return this->do_get(__in, __end, __io, __err, __v);
		}
		iter_type get(iter_type __in, iter_type __end, ios_base &__io,
			      ios_base::iostate &__err, unsigned &__v) const
		{
			return this->do_get(__in, __end, __io, __err, __v);
		}
		iter_type get(iter_type __in, iter_type __end, ios_base &__io,
			      ios_base::iostate &__err,
			      unsigned long &__v) const
		{
			return this->do_get(__in, __end, __io, __err, __v);
		}
		iter_type get(iter_type __in, iter_type __end, ios_base &__io,
			      ios_base::iostate &__err, long long &__v) const
		{
			return this->do_get(__in, __end, __io, __err, __v);
		}
		iter_type get(iter_type __in, iter_type __end, ios_base &__io,
			      ios_base::iostate &__err,
			      unsigned long long &__v) const
		{
			return this->do_get(__in, __end, __io, __err, __v);
		}
		iter_type get(iter_type __in, iter_type __end, ios_base &__io,
			      ios_base::iostate &__err, float &__v) const
		{
			return this->do_get(__in, __end, __io, __err, __v);
		}
		iter_type get(iter_type __in, iter_type __end, ios_base &__io,
			      ios_base::iostate &__err, double &__v) const
		{
			return this->do_get(__in, __end, __io, __err, __v);
		}
		iter_type get(iter_type __in, iter_type __end, ios_base &__io,
			      ios_base::iostate &__err, long double &__v) const
		{
			return this->do_get(__in, __end, __io, __err, __v);
		}
		iter_type get(iter_type __in, iter_type __end, ios_base &__io,
			      ios_base::iostate &__err, void *&__v) const
		{
			return this->do_get(__in, __end, __io, __err, __v);
		}

	    protected:
		virtual ~num_get()
		{
		}
		__attribute((__abi_tag__("cxx11"))) iter_type
		_M_extract_float(iter_type, iter_type, ios_base &,
				 ios_base::iostate &, string &) const;
		template <class _ValueT>
		__attribute((__abi_tag__("cxx11"))) iter_type
		_M_extract_int(iter_type, iter_type, ios_base &,
			       ios_base::iostate &, _ValueT &) const;
		template <class _CharT2>
		typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
						int>::__type
		_M_find(const _CharT2 *, size_t __len, _CharT2 __c) const
		{
			int __ret = (-1);
			if (__len <= (10)) {
				if ((__c >= ((_CharT2)'0')) &&
				    (__c <
				     ((_CharT2)(((_CharT2)'0') + __len)))) {
					__ret = (__c - ((_CharT2)'0'));
				}
			} else {
				if ((__c >= ((_CharT2)'0')) &&
				    (__c <= ((_CharT2)'9'))) {
					__ret = (__c - ((_CharT2)'0'));
				} else {
					if ((__c >= ((_CharT2)'a')) &&
					    (__c <= ((_CharT2)'f'))) {
						__ret = (10 + (__c -
							       ((_CharT2)'a')));
					} else {
						if ((__c >= ((_CharT2)'A')) &&
						    (__c <= ((_CharT2)'F'))) {
							__ret = (10 +
								 (__c -
								  ((_CharT2)'A')));
						}
					}
				}
			}
			return __ret;
		}
		template <class _CharT2>
		typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
						int>::__type
		_M_find(const _CharT2 *__zero, size_t __len, _CharT2 __c) const
		{
			int __ret = (-1);
			const char_type *__q =
				char_traits<_CharT2>::find(__zero, __len, __c);
			if (__q) {
				__ret = (__q - __zero);
				if (__ret > 15) {
					__ret -= 6;
				}
			}
			return __ret;
		}
		virtual iter_type do_get(iter_type, iter_type, ios_base &,
					 ios_base::iostate &, bool &) const;
		virtual iter_type do_get(iter_type __beg, iter_type __end,
					 ios_base &__io,
					 ios_base::iostate &__err,
					 long &__v) const
		{
			return _M_extract_int(__beg, __end, __io, __err, __v);
		}
		virtual iter_type do_get(iter_type __beg, iter_type __end,
					 ios_base &__io,
					 ios_base::iostate &__err,
					 unsigned short &__v) const
		{
			return _M_extract_int(__beg, __end, __io, __err, __v);
		}
		virtual iter_type do_get(iter_type __beg, iter_type __end,
					 ios_base &__io,
					 ios_base::iostate &__err,
					 unsigned &__v) const
		{
			return _M_extract_int(__beg, __end, __io, __err, __v);
		}
		virtual iter_type do_get(iter_type __beg, iter_type __end,
					 ios_base &__io,
					 ios_base::iostate &__err,
					 unsigned long &__v) const
		{
			return _M_extract_int(__beg, __end, __io, __err, __v);
		}
		virtual iter_type do_get(iter_type __beg, iter_type __end,
					 ios_base &__io,
					 ios_base::iostate &__err,
					 long long &__v) const
		{
			return _M_extract_int(__beg, __end, __io, __err, __v);
		}
		virtual iter_type do_get(iter_type __beg, iter_type __end,
					 ios_base &__io,
					 ios_base::iostate &__err,
					 unsigned long long &__v) const
		{
			return _M_extract_int(__beg, __end, __io, __err, __v);
		}
		virtual iter_type do_get(iter_type, iter_type, ios_base &,
					 ios_base::iostate &, float &) const;
		virtual iter_type do_get(iter_type, iter_type, ios_base &,
					 ios_base::iostate &, double &) const;
		virtual iter_type do_get(iter_type, iter_type, ios_base &,
					 ios_base::iostate &,
					 long double &) const;
		virtual iter_type do_get(iter_type, iter_type, ios_base &,
					 ios_base::iostate &, void *&) const;
	};
	template <class _CharT, class _InIter>
	locale::id num_get<_CharT, _InIter>::id;
	template <class _CharT, class _OutIter>
	class num_put : public locale::facet {
	    public:
		typedef _CharT char_type;
		typedef _OutIter iter_type;
		static locale::id id;
		explicit num_put(size_t __refs = 0) : locale::facet(__refs)
		{
		}
		iter_type put(iter_type __s, ios_base &__io, char_type __fill,
			      bool __v) const
		{
			return this->do_put(__s, __io, __fill, __v);
		}
		iter_type put(iter_type __s, ios_base &__io, char_type __fill,
			      long __v) const
		{
			return this->do_put(__s, __io, __fill, __v);
		}
		iter_type put(iter_type __s, ios_base &__io, char_type __fill,
			      unsigned long __v) const
		{
			return this->do_put(__s, __io, __fill, __v);
		}
		iter_type put(iter_type __s, ios_base &__io, char_type __fill,
			      long long __v) const
		{
			return this->do_put(__s, __io, __fill, __v);
		}
		iter_type put(iter_type __s, ios_base &__io, char_type __fill,
			      unsigned long long __v) const
		{
			return this->do_put(__s, __io, __fill, __v);
		}
		iter_type put(iter_type __s, ios_base &__io, char_type __fill,
			      double __v) const
		{
			return this->do_put(__s, __io, __fill, __v);
		}
		iter_type put(iter_type __s, ios_base &__io, char_type __fill,
			      long double __v) const
		{
			return this->do_put(__s, __io, __fill, __v);
		}
		iter_type put(iter_type __s, ios_base &__io, char_type __fill,
			      const void *__v) const
		{
			return this->do_put(__s, __io, __fill, __v);
		}

	    protected:
		template <class _ValueT>
		iter_type _M_insert_float(iter_type, ios_base &__io,
					  char_type __fill, char __mod,
					  _ValueT __v) const;
		void _M_group_float(const char *__grouping,
				    size_t __grouping_size, char_type __sep,
				    const char_type *__p, char_type *__new,
				    char_type *__cs, int &__len) const;
		template <class _ValueT>
		iter_type _M_insert_int(iter_type, ios_base &__io,
					char_type __fill, _ValueT __v) const;
		void _M_group_int(const char *__grouping,
				  size_t __grouping_size, char_type __sep,
				  ios_base &__io, char_type *__new,
				  char_type *__cs, int &__len) const;
		void _M_pad(char_type __fill, streamsize __w, ios_base &__io,
			    char_type *__new, const char_type *__cs,
			    int &__len) const;
		virtual ~num_put()
		{
		}
		virtual iter_type do_put(iter_type __s, ios_base &__io,
					 char_type __fill, bool __v) const;
		virtual iter_type do_put(iter_type __s, ios_base &__io,
					 char_type __fill, long __v) const
		{
			return _M_insert_int(__s, __io, __fill, __v);
		}
		virtual iter_type do_put(iter_type __s, ios_base &__io,
					 char_type __fill,
					 unsigned long __v) const
		{
			return _M_insert_int(__s, __io, __fill, __v);
		}
		virtual iter_type do_put(iter_type __s, ios_base &__io,
					 char_type __fill, long long __v) const
		{
			return _M_insert_int(__s, __io, __fill, __v);
		}
		virtual iter_type do_put(iter_type __s, ios_base &__io,
					 char_type __fill,
					 unsigned long long __v) const
		{
			return _M_insert_int(__s, __io, __fill, __v);
		}
		virtual iter_type do_put(iter_type, ios_base &, char_type,
					 double) const;
		virtual iter_type do_put(iter_type, ios_base &, char_type,
					 long double) const;
		virtual iter_type do_put(iter_type, ios_base &, char_type,
					 const void *) const;
	};
	template <class _CharT, class _OutIter>
	locale::id num_put<_CharT, _OutIter>::id;
	template <class _CharT>
	inline bool isspace(_CharT __c, const locale &__loc)
	{
		return use_facet<ctype<_CharT>>(__loc).is(ctype_base::space,
							  __c);
	}
	template <class _CharT>
	inline bool isprint(_CharT __c, const locale &__loc)
	{
		return use_facet<ctype<_CharT>>(__loc).is(ctype_base::print,
							  __c);
	}
	template <class _CharT>
	inline bool iscntrl(_CharT __c, const locale &__loc)
	{
		return use_facet<ctype<_CharT>>(__loc).is(ctype_base::cntrl,
							  __c);
	}
	template <class _CharT>
	inline bool isupper(_CharT __c, const locale &__loc)
	{
		return use_facet<ctype<_CharT>>(__loc).is(ctype_base::upper,
							  __c);
	}
	template <class _CharT>
	inline bool islower(_CharT __c, const locale &__loc)
	{
		return use_facet<ctype<_CharT>>(__loc).is(ctype_base::lower,
							  __c);
	}
	template <class _CharT>
	inline bool isalpha(_CharT __c, const locale &__loc)
	{
		return use_facet<ctype<_CharT>>(__loc).is(ctype_base::alpha,
							  __c);
	}
	template <class _CharT>
	inline bool isdigit(_CharT __c, const locale &__loc)
	{
		return use_facet<ctype<_CharT>>(__loc).is(ctype_base::digit,
							  __c);
	}
	template <class _CharT>
	inline bool ispunct(_CharT __c, const locale &__loc)
	{
		return use_facet<ctype<_CharT>>(__loc).is(ctype_base::punct,
							  __c);
	}
	template <class _CharT>
	inline bool isxdigit(_CharT __c, const locale &__loc)
	{
		return use_facet<ctype<_CharT>>(__loc).is(ctype_base::xdigit,
							  __c);
	}
	template <class _CharT>
	inline bool isalnum(_CharT __c, const locale &__loc)
	{
		return use_facet<ctype<_CharT>>(__loc).is(ctype_base::alnum,
							  __c);
	}
	template <class _CharT>
	inline bool isgraph(_CharT __c, const locale &__loc)
	{
		return use_facet<ctype<_CharT>>(__loc).is(ctype_base::graph,
							  __c);
	}
	template <class _CharT>
	inline bool isblank(_CharT __c, const locale &__loc)
	{
		return use_facet<ctype<_CharT>>(__loc).is(ctype_base::blank,
							  __c);
	}
	template <class _CharT>
	inline _CharT toupper(_CharT __c, const locale &__loc)
	{
		return use_facet<ctype<_CharT>>(__loc).toupper(__c);
	}
	template <class _CharT>
	inline _CharT tolower(_CharT __c, const locale &__loc)
	{
		return use_facet<ctype<_CharT>>(__loc).tolower(__c);
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _Facet> struct __use_cache {
		const _Facet *operator()(const locale &__loc) const;
	};
	template <class _CharT> struct __use_cache<__numpunct_cache<_CharT>> {
		const __numpunct_cache<_CharT> *
		operator()(const locale &__loc) const
		{
			const size_t __i = (numpunct<_CharT>::id._M_id)();
			const locale::facet **__caches =
				(__loc._M_impl)->_M_caches;
			if (!(__caches[__i])) {
				__numpunct_cache<_CharT> *__tmp = (0);
				try {
					__tmp = (new __numpunct_cache<_CharT>);
					__tmp->_M_cache(__loc);
				} catch (...) {
					delete __tmp;
					throw;
				}
				(__loc._M_impl)->_M_install_cache(__tmp, __i);
			}
			return static_cast<const __numpunct_cache<_CharT> *>(
				__caches[__i]);
		}
	};
	template <class _CharT>
	void __numpunct_cache<_CharT>::_M_cache(const locale &__loc)
	{
		const __cxx11::numpunct<_CharT> &__np =
			use_facet<__cxx11::numpunct<_CharT>>(__loc);
		char *__grouping = (0);
		_CharT *__truename = (0);
		_CharT *__falsename = (0);
		try {
			const string &__g = __np.grouping();
			(_M_grouping_size) = __g.size();
			__grouping = (new char[_M_grouping_size]);
			__g.copy(__grouping, _M_grouping_size);
			(_M_use_grouping) =
				((_M_grouping_size) &&
				 ((static_cast<signed char>(__grouping[0])) >
				  0) &&
				 ((__grouping[0]) !=
				  __gnu_cxx::__numeric_traits<char>::__max));
			const __cxx11::basic_string<_CharT> &__tn =
				__np.truename();
			(_M_truename_size) = __tn.size();
			__truename = (new _CharT[_M_truename_size]);
			__tn.copy(__truename, _M_truename_size);
			const __cxx11::basic_string<_CharT> &__fn =
				__np.falsename();
			(_M_falsename_size) = __fn.size();
			__falsename = (new _CharT[_M_falsename_size]);
			__fn.copy(__falsename, _M_falsename_size);
			(_M_decimal_point) = __np.decimal_point();
			(_M_thousands_sep) = __np.thousands_sep();
			const ctype<_CharT> &__ct =
				use_facet<ctype<_CharT>>(__loc);
			__ct.widen(__num_base::_S_atoms_out,
				   __num_base::_S_atoms_out +
					   __num_base::_S_oend,
				   _M_atoms_out);
			__ct.widen(__num_base::_S_atoms_in,
				   __num_base::_S_atoms_in +
					   __num_base::_S_iend,
				   _M_atoms_in);
			(_M_grouping) = __grouping;
			(_M_truename) = __truename;
			(_M_falsename) = __falsename;
			(_M_allocated) = true;
		} catch (...) {
			delete[] __grouping;
			delete[] __truename;
			delete[] __falsename;
			throw;
		}
	}
	__attribute((__pure__)) bool __verify_grouping(
		const char *__grouping, size_t __grouping_size,
		const string &__grouping_tmp) throw();
	template <class _CharT, class _InIter>
	__attribute((__abi_tag__("cxx11"))) _InIter
	num_get<_CharT, _InIter>::_M_extract_float(_InIter __beg, _InIter __end,
						   ios_base & __io,
						   ios_base::iostate & __err,
						   string & __xtrc) const
	{
		typedef char_traits<_CharT> __traits_type;
		typedef __numpunct_cache<_CharT> __cache_type;
		__use_cache<__numpunct_cache<_CharT>> __uc;
		const locale &__loc = __io._M_getloc();
		const __cache_type *__lc = __uc(__loc);
		const _CharT *__lit = ((__lc->_M_atoms_in));
		char_type __c = char_type();
		bool __testeof = __beg == __end;
		if (!__testeof) {
			__c = (*__beg);
			const bool __plus =
				__c == (__lit[__num_base::_S_iplus]);
			if ((__plus ||
			     (__c == (__lit[__num_base::_S_iminus]))) &&
			    (!((__lc->_M_use_grouping) &&
			       (__c == (__lc->_M_thousands_sep)))) &&
			    (!(__c == (__lc->_M_decimal_point)))) {
				(__xtrc += (__plus ? '+' : '-'));
				if ((++__beg) != __end) {
					__c = (*__beg);
				} else {
					__testeof = true;
				}
			}
		}
		bool __found_mantissa = false;
		int __sep_pos = 0;
		while (!__testeof) {
			if (((__lc->_M_use_grouping) &&
			     (__c == (__lc->_M_thousands_sep))) ||
			    (__c == (__lc->_M_decimal_point))) {
				break;
			} else {
				if (__c == (__lit[__num_base::_S_izero])) {
					if (!__found_mantissa) {
						(__xtrc += ('0'));
						__found_mantissa = true;
					}
					++__sep_pos;
					if ((++__beg) != __end) {
						__c = (*__beg);
					} else {
						__testeof = true;
					}
				} else {
					break;
				}
			}
		}
		bool __found_dec = false;
		bool __found_sci = false;
		string __found_grouping;
		if (__lc->_M_use_grouping) {
			__found_grouping.reserve(32);
		}
		const char_type *__lit_zero = __lit + __num_base::_S_izero;
		if (!(__lc->_M_allocated)) {
			while (!__testeof) {
				const int __digit =
					_M_find(__lit_zero, 10, __c);
				if (__digit != (-1)) {
					(__xtrc += (('0') + __digit));
					__found_mantissa = true;
				} else {
					if ((__c == (__lc->_M_decimal_point)) &&
					    (!__found_dec) && (!__found_sci)) {
						(__xtrc += ('.'));
						__found_dec = true;
					} else {
						if (((__c ==
						      (__lit[__num_base::_S_ie])) ||
						     (__c ==
						      (__lit[__num_base::_S_iE]))) &&
						    (!__found_sci) &&
						    __found_mantissa) {
							(__xtrc += ('e'));
							__found_sci = true;
							if ((++__beg) !=
							    __end) {
								__c = (*__beg);
								const bool __plus =
									__c ==
									(__lit[__num_base::
										       _S_iplus]);
								if (__plus ||
								    (__c ==
								     (__lit[__num_base::
										    _S_iminus]))) {
									(__xtrc +=
									 (__plus ?
										  '+' :
										  '-'));
								} else {
									continue;
								}
							} else {
								__testeof =
									true;
								break;
							}
						} else {
							break;
						}
					}
				}
				if ((++__beg) != __end) {
					__c = (*__beg);
				} else {
					__testeof = true;
				}
			}
		} else {
			while (!__testeof) {
				if ((__lc->_M_use_grouping) &&
				    (__c == (__lc->_M_thousands_sep))) {
					if ((!__found_dec) && (!__found_sci)) {
						if (__sep_pos) {
							(__found_grouping +=
							 (static_cast<char>(
								 __sep_pos)));
							__sep_pos = 0;
						} else {
							__xtrc.clear();
							break;
						}
					} else {
						break;
					}
				} else {
					if (__c == (__lc->_M_decimal_point)) {
						if ((!__found_dec) &&
						    (!__found_sci)) {
							if (__found_grouping
								    .size()) {
								(__found_grouping +=
								 (static_cast<
									 char>(
									 __sep_pos)));
							}
							(__xtrc += ('.'));
							__found_dec = true;
						} else {
							break;
						}
					} else {
						const char_type *__q =
							__traits_type::find(
								__lit_zero, 10,
								__c);
						if (__q) {
							__xtrc +=
								('0' +
								 (__q -
								  __lit_zero));
							__found_mantissa = true;
							++__sep_pos;
						} else {
							if (((__c ==
							      (__lit[__num_base::
									     _S_ie])) ||
							     (__c ==
							      (__lit[__num_base::
									     _S_iE]))) &&
							    (!__found_sci) &&
							    __found_mantissa) {
								if ((__found_grouping
									     .size()) &&
								    (!__found_dec)) {
									(__found_grouping +=
									 (static_cast<
										 char>(
										 __sep_pos)));
								}
								(__xtrc +=
								 ('e'));
								__found_sci =
									true;
								if ((++__beg) !=
								    __end) {
									__c = (*__beg);
									const bool __plus =
										__c ==
										(__lit[__num_base::
											       _S_iplus]);
									if ((__plus ||
									     (__c ==
									      (__lit[__num_base::
											     _S_iminus]))) &&
									    (!((__lc->_M_use_grouping) &&
									       (__c ==
										(__lc->_M_thousands_sep)))) &&
									    (!(__c ==
									       (__lc->_M_decimal_point)))) {
										(__xtrc +=
										 (__plus ?
											  '+' :
											  '-'));
									} else {
										continue;
									}
								} else {
									__testeof =
										true;
									break;
								}
							} else {
								break;
							}
						}
					}
				}
				if ((++__beg) != __end) {
					__c = (*__beg);
				} else {
					__testeof = true;
				}
			}
		}
		if (__found_grouping.size()) {
			if ((!__found_dec) && (!__found_sci)) {
				(__found_grouping +=
				 (static_cast<char>(__sep_pos)));
			}
			if (!std::__verify_grouping((__lc->_M_grouping),
						    (__lc->_M_grouping_size),
						    __found_grouping)) {
				__err = ios_base::failbit;
			}
		}
		return __beg;
	}
	template <class _CharT, class _InIter>
	template <class _ValueT>
	__attribute((__abi_tag__("cxx11"))) _InIter
	num_get<_CharT, _InIter>::_M_extract_int(_InIter __beg, _InIter __end,
						 ios_base & __io,
						 ios_base::iostate & __err,
						 _ValueT & __v) const
	{
		typedef char_traits<_CharT> __traits_type;
		using __gnu_cxx::__add_unsigned;
		typedef typename __gnu_cxx::__add_unsigned<_ValueT>::__type
			__unsigned_type;
		typedef __numpunct_cache<_CharT> __cache_type;
		__use_cache<__numpunct_cache<_CharT>> __uc;
		const locale &__loc = __io._M_getloc();
		const __cache_type *__lc = __uc(__loc);
		const _CharT *__lit = ((__lc->_M_atoms_in));
		char_type __c = char_type();
		const ios_base::fmtflags __basefield =
			((__io.flags()) & ios_base::basefield);
		const bool __oct = __basefield == ios_base::oct;
		int __base =
			__oct ? 8 : ((__basefield == ios_base::hex) ? 16 : 10);
		bool __testeof = __beg == __end;
		bool __negative = false;
		if (!__testeof) {
			__c = (*__beg);
			__negative = (__c == (__lit[__num_base::_S_iminus]));
			if ((__negative ||
			     (__c == (__lit[__num_base::_S_iplus]))) &&
			    (!((__lc->_M_use_grouping) &&
			       (__c == (__lc->_M_thousands_sep)))) &&
			    (!(__c == (__lc->_M_decimal_point)))) {
				if ((++__beg) != __end) {
					__c = (*__beg);
				} else {
					__testeof = true;
				}
			}
		}
		bool __found_zero = false;
		int __sep_pos = 0;
		while (!__testeof) {
			if (((__lc->_M_use_grouping) &&
			     (__c == (__lc->_M_thousands_sep))) ||
			    (__c == (__lc->_M_decimal_point))) {
				break;
			} else {
				if ((__c == (__lit[__num_base::_S_izero])) &&
				    ((!__found_zero) || (__base == 10))) {
					__found_zero = true;
					++__sep_pos;
					if (__basefield == 0) {
						__base = 8;
					}
					if (__base == 8) {
						__sep_pos = 0;
					}
				} else {
					if (__found_zero &&
					    ((__c ==
					      (__lit[__num_base::_S_ix])) ||
					     (__c ==
					      (__lit[__num_base::_S_iX])))) {
						if (__basefield == 0) {
							__base = 16;
						}
						if (__base == 16) {
							__found_zero = false;
							__sep_pos = 0;
						} else {
							break;
						}
					} else {
						break;
					}
				}
			}
			if ((++__beg) != __end) {
				__c = (*__beg);
				if (!__found_zero) {
					break;
				}
			} else {
				__testeof = true;
			}
		}
		const size_t __len =
			(__base == 16) ?
				(__num_base::_S_iend) - (__num_base::_S_izero) :
				__base;
		typedef __gnu_cxx::__numeric_traits<_ValueT> __num_traits;
		string __found_grouping;
		if (__lc->_M_use_grouping) {
			__found_grouping.reserve(32);
		}
		bool __testfail = false;
		bool __testoverflow = false;
		const __unsigned_type __max =
			(__negative && __num_traits::__is_signed) ?
				-(static_cast<__unsigned_type>(
					__num_traits::__min)) :
				__num_traits::__max;
		const __unsigned_type __smax = __max / __base;
		__unsigned_type __result = (0);
		int __digit = 0;
		const char_type *__lit_zero = __lit + __num_base::_S_izero;
		if (!(__lc->_M_allocated)) {
			while (!__testeof) {
				__digit = _M_find(__lit_zero, __len, __c);
				if (__digit == (-1)) {
					break;
				}
				if (__result > __smax) {
					__testoverflow = true;
				} else {
					__result *= __base;
					__testoverflow |=
						(__result > (__max - __digit));
					__result += __digit;
					++__sep_pos;
				}
				if ((++__beg) != __end) {
					__c = (*__beg);
				} else {
					__testeof = true;
				}
			}
		} else {
			while (!__testeof) {
				if ((__lc->_M_use_grouping) &&
				    (__c == (__lc->_M_thousands_sep))) {
					if (__sep_pos) {
						(__found_grouping +=
						 (static_cast<char>(__sep_pos)));
						__sep_pos = 0;
					} else {
						__testfail = true;
						break;
					}
				} else {
					if (__c == (__lc->_M_decimal_point)) {
						break;
					} else {
						const char_type *__q =
							__traits_type::find(
								__lit_zero,
								__len, __c);
						if (!__q) {
							break;
						}
						__digit = (__q - __lit_zero);
						if (__digit > 15) {
							__digit -= 6;
						}
						if (__result > __smax) {
							__testoverflow = true;
						} else {
							__result *= __base;
							__testoverflow |=
								(__result >
								 (__max -
								  __digit));
							__result += __digit;
							++__sep_pos;
						}
					}
				}
				if ((++__beg) != __end) {
					__c = (*__beg);
				} else {
					__testeof = true;
				}
			}
		}
		if (__found_grouping.size()) {
			(__found_grouping += (static_cast<char>(__sep_pos)));
			if (!std::__verify_grouping((__lc->_M_grouping),
						    (__lc->_M_grouping_size),
						    __found_grouping)) {
				__err = ios_base::failbit;
			}
		}
		if (((!__sep_pos) && (!__found_zero) &&
		     (!(__found_grouping.size()))) ||
		    __testfail) {
			__v = 0;
			__err = ios_base::failbit;
		} else {
			if (__testoverflow) {
				if (__negative && __num_traits::__is_signed) {
					__v = __num_traits::__min;
				} else {
					__v = __num_traits::__max;
				}
				__err = ios_base::failbit;
			} else {
				__v = (__negative ? -__result : __result);
			}
		}
		if (__testeof) {
			(__err |= ios_base::eofbit);
		}
		return __beg;
	}
	template <class _CharT, class _InIter>
	_InIter num_get<_CharT, _InIter>::do_get(
		iter_type __beg, iter_type __end, ios_base & __io,
		ios_base::iostate & __err, bool &__v) const
	{
		if (!(((__io.flags()) & ios_base::boolalpha))) {
			long __l = (-1);
			__beg = _M_extract_int(__beg, __end, __io, __err, __l);
			if ((__l == (0)) || (__l == (1))) {
				__v = ((bool)__l);
			} else {
				__v = true;
				__err = ios_base::failbit;
				if (__beg == __end) {
					(__err |= ios_base::eofbit);
				}
			}
		} else {
			typedef __numpunct_cache<_CharT> __cache_type;
			__use_cache<__numpunct_cache<_CharT>> __uc;
			const locale &__loc = __io._M_getloc();
			const __cache_type *__lc = __uc(__loc);
			bool __testf = true;
			bool __testt = true;
			bool __donef = (__lc->_M_falsename_size) == 0;
			bool __donet = (__lc->_M_truename_size) == 0;
			bool __testeof = false;
			size_t __n = (0);
			while ((!__donef) || (!__donet)) {
				if (__beg == __end) {
					__testeof = true;
					break;
				}
				const char_type __c = (*__beg);
				if (!__donef) {
					__testf = (__c ==
						   ((__lc->_M_falsename)[__n]));
				}
				if ((!__testf) && __donet) {
					break;
				}
				if (!__donet) {
					__testt = (__c ==
						   ((__lc->_M_truename)[__n]));
				}
				if ((!__testt) && __donef) {
					break;
				}
				if ((!__testt) && (!__testf)) {
					break;
				}
				++__n;
				++__beg;
				__donef = ((!__testf) ||
					   (__n >= (__lc->_M_falsename_size)));
				__donet = ((!__testt) ||
					   (__n >= (__lc->_M_truename_size)));
			}
			if (__testf && (__n == (__lc->_M_falsename_size)) &&
			    __n) {
				__v = false;
				if (__testt &&
				    (__n == (__lc->_M_truename_size))) {
					__err = ios_base::failbit;
				} else {
					__err = (__testeof ? ios_base::eofbit :
							     ios_base::goodbit);
				}
			} else {
				if (__testt &&
				    (__n == (__lc->_M_truename_size)) && __n) {
					__v = true;
					__err = (__testeof ? ios_base::eofbit :
							     ios_base::goodbit);
				} else {
					__v = false;
					__err = ios_base::failbit;
					if (__testeof) {
						(__err |= ios_base::eofbit);
					}
				}
			}
		}
		return __beg;
	}
	template <class _CharT, class _InIter>
	_InIter num_get<_CharT, _InIter>::do_get(
		iter_type __beg, iter_type __end, ios_base & __io,
		ios_base::iostate & __err, float &__v) const
	{
		string __xtrc;
		__xtrc.reserve(32);
		__beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
		std::__convert_to_v(__xtrc.c_str(), __v, __err,
				    _S_get_c_locale());
		if (__beg == __end) {
			(__err |= ios_base::eofbit);
		}
		return __beg;
	}
	template <class _CharT, class _InIter>
	_InIter num_get<_CharT, _InIter>::do_get(
		iter_type __beg, iter_type __end, ios_base & __io,
		ios_base::iostate & __err, double &__v) const
	{
		string __xtrc;
		__xtrc.reserve(32);
		__beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
		std::__convert_to_v(__xtrc.c_str(), __v, __err,
				    _S_get_c_locale());
		if (__beg == __end) {
			(__err |= ios_base::eofbit);
		}
		return __beg;
	}
	template <class _CharT, class _InIter>
	_InIter num_get<_CharT, _InIter>::do_get(
		iter_type __beg, iter_type __end, ios_base & __io,
		ios_base::iostate & __err, long double &__v) const
	{
		string __xtrc;
		__xtrc.reserve(32);
		__beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
		std::__convert_to_v(__xtrc.c_str(), __v, __err,
				    _S_get_c_locale());
		if (__beg == __end) {
			(__err |= ios_base::eofbit);
		}
		return __beg;
	}
	template <class _CharT, class _InIter>
	_InIter num_get<_CharT, _InIter>::do_get(
		iter_type __beg, iter_type __end, ios_base & __io,
		ios_base::iostate & __err, void *&__v) const
	{
		typedef ios_base::fmtflags fmtflags;
		const fmtflags __fmt = __io.flags();
		__io.flags(
			(((__fmt & ((~ios_base::basefield)))) | ios_base::hex));
		typedef __gnu_cxx::__conditional_type<
			sizeof(void *) <= sizeof(unsigned long), unsigned long,
			unsigned long long>::__type _UIntPtrType;
		_UIntPtrType __ul;
		__beg = _M_extract_int(__beg, __end, __io, __err, __ul);
		__io.flags(__fmt);
		__v = (reinterpret_cast<void *>(__ul));
		return __beg;
	}
	template <class _CharT, class _OutIter>
	void num_put<_CharT, _OutIter>::_M_pad(_CharT __fill, streamsize __w,
					       ios_base & __io, _CharT * __new,
					       const _CharT *__cs, int &__len)
		const
	{
		__pad<_CharT, char_traits<_CharT>>::_S_pad(__io, __fill, __new,
							   __cs, __w, __len);
		__len = (static_cast<int>(__w));
	}
	template <class _CharT, class _ValueT>
	int __int_to_char(_CharT * __bufend, _ValueT __v, const _CharT *__lit,
			  ios_base::fmtflags __flags, bool __dec)
	{
		_CharT *__buf = __bufend;
		if (__builtin_expect(__dec, true)) {
			do {
				(*(--__buf)) = (__lit[(__v % 10) +
						      __num_base::_S_odigits]);
				__v /= 10;
			} while (__v != 0);
		} else {
			if (((__flags & ios_base::basefield)) ==
			    ios_base::oct) {
				do {
					(*(--__buf)) =
						(__lit[(__v & 7) +
						       __num_base::_S_odigits]);
					__v >>= 3;
				} while (__v != 0);
			} else {
				const bool __uppercase =
					(__flags & ios_base::uppercase);
				const int __case_offset =
					__uppercase ? __num_base::_S_oudigits :
						      __num_base::_S_odigits;
				do {
					(*(--__buf)) = (__lit[(__v & 15) +
							      __case_offset]);
					__v >>= 4;
				} while (__v != 0);
			}
		}
		return __bufend - __buf;
	}
	template <class _CharT, class _OutIter>
	void num_put<_CharT, _OutIter>::_M_group_int(
		const char *__grouping, size_t __grouping_size, _CharT __sep,
		ios_base &, _CharT *__new, _CharT *__cs, int &__len) const
	{
		_CharT *__p = std::__add_grouping(__new, __sep, __grouping,
						  __grouping_size, __cs,
						  __cs + __len);
		__len = (__p - __new);
	}
	template <class _CharT, class _OutIter>
	template <class _ValueT>
	_OutIter num_put<_CharT, _OutIter>::_M_insert_int(
		_OutIter __s, ios_base & __io, _CharT __fill, _ValueT __v) const
	{
		using __gnu_cxx::__add_unsigned;
		typedef typename __gnu_cxx::__add_unsigned<_ValueT>::__type
			__unsigned_type;
		typedef __numpunct_cache<_CharT> __cache_type;
		__use_cache<__numpunct_cache<_CharT>> __uc;
		const locale &__loc = __io._M_getloc();
		const __cache_type *__lc = __uc(__loc);
		const _CharT *__lit = ((__lc->_M_atoms_out));
		const ios_base::fmtflags __flags = __io.flags();
		const int __ilen = ((5) * sizeof(_ValueT));
		_CharT *__cs = static_cast<_CharT *>(
			__builtin_alloca(sizeof(_CharT) * __ilen));
		const ios_base::fmtflags __basefield =
			(__flags & ios_base::basefield);
		const bool __dec = (__basefield != ios_base::oct) &&
				   (__basefield != ios_base::hex);
		const __unsigned_type __u = ((__v > 0) || (!__dec)) ?
						    (__unsigned_type)__v :
						    (-((__unsigned_type)__v));
		int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags,
					  __dec);
		__cs += (__ilen - __len);
		if (__lc->_M_use_grouping) {
			_CharT *__cs2 = static_cast<_CharT *>(__builtin_alloca(
				(sizeof(_CharT) * (__len + 1)) * (2)));
			_M_group_int((__lc->_M_grouping),
				     (__lc->_M_grouping_size),
				     (__lc->_M_thousands_sep), __io, __cs2 + 2,
				     __cs, __len);
			__cs = (__cs2 + 2);
		}
		if (__builtin_expect(__dec, true)) {
			if (__v >= 0) {
				if (((bool)(__flags & ios_base::showpos)) &&
				    __gnu_cxx::template __numeric_traits<
					    _ValueT>::__is_signed) {
					((*(--__cs)) =
						 (__lit[__num_base::_S_oplus])),
						(++__len);
				}
			} else {
				((*(--__cs)) = (__lit[__num_base::_S_ominus])),
					(++__len);
			}
		} else {
			if (((bool)(__flags & ios_base::showbase)) && __v) {
				if (__basefield == ios_base::oct) {
					((*(--__cs)) =
						 (__lit[__num_base::_S_odigits])),
						(++__len);
				} else {
					const bool __uppercase =
						(__flags & ios_base::uppercase);
					(*(--__cs)) =
						(__lit[(__num_base::_S_ox) +
						       __uppercase]);
					(*(--__cs)) =
						(__lit[__num_base::_S_odigits]);
					__len += 2;
				}
			}
		}
		const streamsize __w = __io.width();
		if (__w > (static_cast<streamsize>(__len))) {
			_CharT *__cs3 = static_cast<_CharT *>(
				__builtin_alloca(sizeof(_CharT) * __w));
			_M_pad(__fill, __w, __io, __cs3, __cs, __len);
			__cs = __cs3;
		}
		__io.width(0);
		return std::__write(__s, __cs, __len);
	}
	template <class _CharT, class _OutIter>
	void num_put<_CharT, _OutIter>::_M_group_float(
		const char *__grouping, size_t __grouping_size, _CharT __sep,
		const _CharT *__p, _CharT *__new, _CharT *__cs, int &__len)
		const
	{
		const int __declen = (__p) ? __p - __cs : __len;
		_CharT *__p2 = std::__add_grouping(__new, __sep, __grouping,
						   __grouping_size, __cs,
						   __cs + __declen);
		int __newlen = __p2 - __new;
		if (__p) {
			char_traits<_CharT>::copy(__p2, __p, __len - __declen);
			__newlen += (__len - __declen);
		}
		__len = __newlen;
	}
	template <class _CharT, class _OutIter>
	template <class _ValueT>
	_OutIter num_put<_CharT, _OutIter>::_M_insert_float(
		_OutIter __s, ios_base & __io, _CharT __fill, char __mod,
		_ValueT __v) const
	{
		typedef __numpunct_cache<_CharT> __cache_type;
		__use_cache<__numpunct_cache<_CharT>> __uc;
		const locale &__loc = __io._M_getloc();
		const __cache_type *__lc = __uc(__loc);
		const streamsize __prec =
			(__io.precision() < (0)) ? 6 : __io.precision();
		const int __max_digits = (__gnu_cxx::template __numeric_traits<
					  _ValueT>::__digits10);
		int __len;
		char __fbuf[16];
		__num_base::_S_format_float(__io, __fbuf, __mod);
		const bool __use_prec =
			(((__io.flags()) & ios_base::floatfield)) !=
			ios_base::floatfield;
		int __cs_size = (__max_digits * 3);
		char *__cs = static_cast<char *>(__builtin_alloca(__cs_size));
		if (__use_prec) {
			__len = std::__convert_from_v(_S_get_c_locale(), __cs,
						      __cs_size, __fbuf, __prec,
						      __v);
		} else {
			__len = std::__convert_from_v(_S_get_c_locale(), __cs,
						      __cs_size, __fbuf, __v);
		}
		if (__len >= __cs_size) {
			__cs_size = (__len + 1);
			__cs = (static_cast<char *>(
				__builtin_alloca(__cs_size)));
			if (__use_prec) {
				__len = std::__convert_from_v(_S_get_c_locale(),
							      __cs, __cs_size,
							      __fbuf, __prec,
							      __v);
			} else {
				__len = std::__convert_from_v(_S_get_c_locale(),
							      __cs, __cs_size,
							      __fbuf, __v);
			}
		}
		const ctype<_CharT> &__ctype = use_facet<ctype<_CharT>>(__loc);
		_CharT *__ws = static_cast<_CharT *>(
			__builtin_alloca(sizeof(_CharT) * __len));
		__ctype.widen(__cs, __cs + __len, __ws);
		_CharT *__wp = (0);
		const char *__p = char_traits<char>::find(__cs, __len, '.');
		if (__p) {
			__wp = (__ws + (__p - __cs));
			(*__wp) = (__lc->_M_decimal_point);
		}
		if ((__lc->_M_use_grouping) &&
		    ((__wp || (__len < 3)) ||
		     (((__cs[1]) <= ('9')) && ((__cs[2]) <= ('9')) &&
		      ((__cs[1]) >= ('0')) && ((__cs[2]) >= ('0'))))) {
			_CharT *__ws2 = static_cast<_CharT *>(__builtin_alloca(
				(sizeof(_CharT) * __len) * (2)));
			streamsize __off = (0);
			if (((__cs[0]) == ('-')) || ((__cs[0]) == ('+'))) {
				__off = (1);
				(__ws2[0]) = (__ws[0]);
				__len -= 1;
			}
			_M_group_float((__lc->_M_grouping),
				       (__lc->_M_grouping_size),
				       (__lc->_M_thousands_sep), __wp,
				       __ws2 + __off, __ws + __off, __len);
			__len += __off;
			__ws = __ws2;
		}
		const streamsize __w = __io.width();
		if (__w > (static_cast<streamsize>(__len))) {
			_CharT *__ws3 = static_cast<_CharT *>(
				__builtin_alloca(sizeof(_CharT) * __w));
			_M_pad(__fill, __w, __io, __ws3, __ws, __len);
			__ws = __ws3;
		}
		__io.width(0);
		return std::__write(__s, __ws, __len);
	}
	template <class _CharT, class _OutIter>
	_OutIter num_put<_CharT, _OutIter>::do_put(
		iter_type __s, ios_base & __io, char_type __fill, bool __v)
		const
	{
		const ios_base::fmtflags __flags = __io.flags();
		if (((__flags & ios_base::boolalpha)) == 0) {
			const long __l = __v;
			__s = _M_insert_int(__s, __io, __fill, __l);
		} else {
			typedef __numpunct_cache<_CharT> __cache_type;
			__use_cache<__numpunct_cache<_CharT>> __uc;
			const locale &__loc = __io._M_getloc();
			const __cache_type *__lc = __uc(__loc);
			const _CharT *__name =
				__v ? __lc->_M_truename : (__lc->_M_falsename);
			int __len = __v ? __lc->_M_truename_size :
					  (__lc->_M_falsename_size);
			const streamsize __w = __io.width();
			if (__w > (static_cast<streamsize>(__len))) {
				const streamsize __plen = __w - __len;
				_CharT *__ps =
					static_cast<_CharT *>(__builtin_alloca(
						sizeof(_CharT) * __plen));
				char_traits<_CharT>::assign(__ps, __plen,
							    __fill);
				__io.width(0);
				if (((__flags & ios_base::adjustfield)) ==
				    ios_base::left) {
					__s = std::__write(__s, __name, __len);
					__s = std::__write(__s, __ps, __plen);
				} else {
					__s = std::__write(__s, __ps, __plen);
					__s = std::__write(__s, __name, __len);
				}
				return __s;
			}
			__io.width(0);
			__s = std::__write(__s, __name, __len);
		}
		return __s;
	}
	template <class _CharT, class _OutIter>
	_OutIter num_put<_CharT, _OutIter>::do_put(
		iter_type __s, ios_base & __io, char_type __fill, double __v)
		const
	{
		return _M_insert_float(__s, __io, __fill, ((char)0), __v);
	}
	template <class _CharT, class _OutIter>
	_OutIter num_put<_CharT, _OutIter>::do_put(iter_type __s,
						   ios_base & __io,
						   char_type __fill,
						   long double __v) const
	{
		return _M_insert_float(__s, __io, __fill, 'L', __v);
	}
	template <class _CharT, class _OutIter>
	_OutIter num_put<_CharT, _OutIter>::do_put(iter_type __s,
						   ios_base & __io,
						   char_type __fill,
						   const void *__v) const
	{
		const ios_base::fmtflags __flags = __io.flags();
		const ios_base::fmtflags __fmt =
			(~((ios_base::basefield | ios_base::uppercase)));
		__io.flags((((__flags & __fmt)) |
			    ((ios_base::hex | ios_base::showbase))));
		typedef __gnu_cxx::__conditional_type<
			sizeof(void *) <= sizeof(unsigned long), unsigned long,
			unsigned long long>::__type _UIntPtrType;
		__s = _M_insert_int(__s, __io, __fill,
				    reinterpret_cast<_UIntPtrType>(__v));
		__io.flags(__flags);
		return __s;
	}
	template <class _CharT, class _Traits>
	void __pad<_CharT, _Traits>::_S_pad(
		ios_base & __io, _CharT __fill, _CharT * __news,
		const _CharT *__olds, streamsize __newlen, streamsize __oldlen)
	{
		const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
		const ios_base::fmtflags __adjust =
			((__io.flags()) & ios_base::adjustfield);
		if (__adjust == ios_base::left) {
			_Traits::copy(__news, __olds, __oldlen);
			_Traits::assign(__news + __oldlen, __plen, __fill);
			return;
		}
		size_t __mod = (0);
		if (__adjust == ios_base::internal) {
			const locale &__loc = __io._M_getloc();
			const ctype<_CharT> &__ctype =
				use_facet<ctype<_CharT>>(__loc);
			if ((__ctype.widen('-') == (__olds[0])) ||
			    (__ctype.widen('+') == (__olds[0]))) {
				(__news[0]) = (__olds[0]);
				__mod = (1);
				++__news;
			} else {
				if ((__ctype.widen('0') == (__olds[0])) &&
				    (__oldlen > (1)) &&
				    ((__ctype.widen('x') == (__olds[1])) ||
				     (__ctype.widen('X') == (__olds[1])))) {
					(__news[0]) = (__olds[0]);
					(__news[1]) = (__olds[1]);
					__mod = (2);
					__news += 2;
				}
			}
		}
		_Traits::assign(__news, __plen, __fill);
		_Traits::copy(__news + __plen, __olds + __mod,
			      __oldlen - __mod);
	}
	template <class _CharT>
	_CharT *__add_grouping(_CharT * __s, _CharT __sep, const char *__gbeg,
			       size_t __gsize, const _CharT *__first,
			       const _CharT *__last)
	{
		size_t __idx = (0);
		size_t __ctr = (0);
		while (((__last - __first) > (__gbeg[__idx])) &&
		       ((static_cast<signed char>(__gbeg[__idx])) > 0) &&
		       ((__gbeg[__idx]) !=
			__gnu_cxx::__numeric_traits<char>::__max)) {
			__last -= (__gbeg[__idx]);
			(__idx < (__gsize - (1))) ? ++__idx : (++__ctr);
		}
		while (__first != __last) {
			(*(__s++)) = (*(__first++));
		}
		while (__ctr--) {
			(*(__s++)) = __sep;
			for (char __i = __gbeg[__idx]; __i > 0; --__i) {
				(*(__s++)) = (*(__first++));
			}
		}
		while (__idx--) {
			(*(__s++)) = __sep;
			for (char __i = __gbeg[__idx]; __i > 0; --__i) {
				(*(__s++)) = (*(__first++));
			}
		}
		return __s;
	}
	extern template class __cxx11::numpunct<char>;
	extern template class __cxx11::numpunct_byname<char>;
	extern template class num_get<char>;
	extern template class num_put<char>;
	extern template const ctype<char> &use_facet<ctype<char>>(
		const locale &);
	extern template const __cxx11::numpunct<char>
		&use_facet<__cxx11::numpunct<char>>(const locale &);
	extern template const num_put<char> &use_facet<num_put<char>>(
		const locale &);
	extern template const num_get<char> &use_facet<num_get<char>>(
		const locale &);
	extern template bool has_facet<ctype<char>>(const locale &) throw();
	extern template bool has_facet<__cxx11::numpunct<char>>(
		const locale &) throw();
	extern template bool has_facet<num_put<char>>(const locale &) throw();
	extern template bool has_facet<num_get<char>>(const locale &) throw();
	extern template class __cxx11::numpunct<wchar_t>;
	extern template class __cxx11::numpunct_byname<wchar_t>;
	extern template class num_get<wchar_t>;
	extern template class num_put<wchar_t>;
	extern template const ctype<wchar_t> &use_facet<ctype<wchar_t>>(
		const locale &);
	extern template const __cxx11::numpunct<wchar_t>
		&use_facet<__cxx11::numpunct<wchar_t>>(const locale &);
	extern template const num_put<wchar_t> &use_facet<num_put<wchar_t>>(
		const locale &);
	extern template const num_get<wchar_t> &use_facet<num_get<wchar_t>>(
		const locale &);
	extern template bool has_facet<ctype<wchar_t>>(const locale &) throw();
	extern template bool has_facet<__cxx11::numpunct<wchar_t>>(
		const locale &) throw();
	extern template bool has_facet<num_put<wchar_t>>(
		const locale &) throw();
	extern template bool has_facet<num_get<wchar_t>>(
		const locale &) throw();
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _Facet>
	inline const _Facet &__check_facet(const _Facet *__f)
	{
		if (!__f) {
			__throw_bad_cast();
		}
		return *__f;
	}
	template <class _CharT, class _Traits>
	class basic_ios : public ios_base {
	    public:
		typedef _CharT char_type;
		typedef typename _Traits::int_type int_type;
		typedef typename _Traits::pos_type pos_type;
		typedef typename _Traits::off_type off_type;
		typedef _Traits traits_type;
		typedef ctype<_CharT> __ctype_type;
		typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits>>
			__num_put_type;
		typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits>>
			__num_get_type;

	    protected:
		basic_ostream<_CharT, _Traits> *_M_tie;
		mutable char_type _M_fill;
		mutable bool _M_fill_init;
		basic_streambuf<_CharT, _Traits> *_M_streambuf;
		const __ctype_type *_M_ctype;
		const __num_put_type *_M_num_put;
		const __num_get_type *_M_num_get;

	    public:
		explicit operator bool() const
		{
			return !fail();
		}
		bool operator!() const
		{
			return fail();
		}
		iostate rdstate() const
		{
			return _M_streambuf_state;
		}
		void clear(iostate __state = goodbit);
		void setstate(iostate __state)
		{
			clear(((rdstate()) | __state));
		}
		void _M_setstate(iostate __state)
		{
			((_M_streambuf_state) |= __state);
			if (this->exceptions() & __state) {
				throw;
			}
		}
		bool good() const
		{
			return (rdstate()) == 0;
		}
		bool eof() const
		{
			return (((rdstate()) & eofbit)) != 0;
		}
		bool fail() const
		{
			return (((rdstate()) & ((badbit | failbit)))) != 0;
		}
		bool bad() const
		{
			return (((rdstate()) & badbit)) != 0;
		}
		iostate exceptions() const
		{
			return _M_exception;
		}
		void exceptions(iostate __except)
		{
			(_M_exception) = __except;
			clear(_M_streambuf_state);
		}
		explicit basic_ios(basic_streambuf<_CharT, _Traits> *__sb)
			: ios_base(), _M_tie((0)), _M_fill(),
			  _M_fill_init(false), _M_streambuf((0)), _M_ctype((0)),
			  _M_num_put((0)), _M_num_get((0))
		{
			init(__sb);
		}
		virtual ~basic_ios()
		{
		}
		basic_ostream<_CharT, _Traits> *tie() const
		{
			return _M_tie;
		}
		basic_ostream<_CharT, _Traits> *
		tie(basic_ostream<_CharT, _Traits> *__tiestr)
		{
			basic_ostream<_CharT, _Traits> *__old = _M_tie;
			(_M_tie) = __tiestr;
			return __old;
		}
		basic_streambuf<_CharT, _Traits> *rdbuf() const
		{
			return _M_streambuf;
		}
		basic_streambuf<_CharT, _Traits> *
		rdbuf(basic_streambuf<_CharT, _Traits> *__sb);
		basic_ios &copyfmt(const basic_ios &__rhs);
		char_type fill() const
		{
			if (!(_M_fill_init)) {
				(_M_fill) = widen(' ');
				(_M_fill_init) = true;
			}
			return _M_fill;
		}
		char_type fill(char_type __ch)
		{
			char_type __old = this->fill();
			(_M_fill) = __ch;
			return __old;
		}
		locale imbue(const locale &__loc);
		char narrow(char_type __c, char __dfault) const
		{
			return __check_facet(_M_ctype).narrow(__c, __dfault);
		}
		char_type widen(char __c) const
		{
			return __check_facet(_M_ctype).widen(__c);
		}

	    protected:
		basic_ios()
			: ios_base(), _M_tie((0)), _M_fill(char_type()),
			  _M_fill_init(false), _M_streambuf((0)), _M_ctype((0)),
			  _M_num_put((0)), _M_num_get((0))
		{
		}
		void init(basic_streambuf<_CharT, _Traits> *__sb);
		basic_ios(const basic_ios &) = delete;
		basic_ios &operator=(const basic_ios &) = delete;
		void move(basic_ios &__rhs)
		{
			this->ios_base::_M_move(__rhs);
			_M_cache_locale(_M_ios_locale);
			this->tie(__rhs.tie(nullptr));
			(_M_fill) = (__rhs._M_fill);
			(_M_fill_init) = (__rhs._M_fill_init);
			(_M_streambuf) = nullptr;
		}
		void move(basic_ios &&__rhs)
		{
			this->move(__rhs);
		}
		void swap(basic_ios &__rhs) noexcept
		{
			this->ios_base::_M_swap(__rhs);
			_M_cache_locale(_M_ios_locale);
			__rhs._M_cache_locale(__rhs._M_ios_locale);
			std::swap(_M_tie, __rhs._M_tie);
			std::swap(_M_fill, __rhs._M_fill);
			std::swap(_M_fill_init, __rhs._M_fill_init);
		}
		void set_rdbuf(basic_streambuf<_CharT, _Traits> *__sb)
		{
			(_M_streambuf) = __sb;
		}
		void _M_cache_locale(const locale &__loc);
	};
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _CharT, class _Traits>
	void basic_ios<_CharT, _Traits>::clear(iostate __state)
	{
		if (this->rdbuf()) {
			(_M_streambuf_state) = __state;
		} else {
			(_M_streambuf_state) = (__state | badbit);
		}
		if (this->exceptions() & rdstate()) {
			__throw_ios_failure("basic_ios::clear");
		}
	}
	template <class _CharT, class _Traits>
	basic_streambuf<_CharT, _Traits> *basic_ios<_CharT, _Traits>::rdbuf(
		basic_streambuf<_CharT, _Traits> * __sb)
	{
		basic_streambuf<_CharT, _Traits> *__old = _M_streambuf;
		(_M_streambuf) = __sb;
		clear();
		return __old;
	}
	template <class _CharT, class _Traits>
	basic_ios<_CharT, _Traits> &basic_ios<_CharT, _Traits>::copyfmt(
		const basic_ios &__rhs)
	{
		if (this != std::__addressof(__rhs)) {
			_Words *__words =
				((__rhs._M_word_size) <= (_S_local_word_size)) ?
					_M_local_word :
					(new _Words[__rhs._M_word_size]);
			_Callback_list *__cb = __rhs._M_callbacks;
			if (__cb) {
				__cb->_M_add_reference();
			}
			this->ios_base::_M_call_callbacks(erase_event);
			if ((_M_word) != (_M_local_word)) {
				delete[](_M_word);
				(_M_word) = (0);
			}
			this->ios_base::_M_dispose_callbacks();
			(_M_callbacks) = __cb;
			for (int __i = 0; __i < (__rhs._M_word_size); ++__i) {
				(__words[__i]) = ((__rhs._M_word)[__i]);
			}
			(_M_word) = __words;
			(_M_word_size) = (__rhs._M_word_size);
			this->flags(__rhs.flags());
			this->width(__rhs.width());
			this->precision(__rhs.precision());
			this->tie(__rhs.tie());
			this->fill(__rhs.fill());
			((_M_ios_locale) = (__rhs.getloc()));
			_M_cache_locale(_M_ios_locale);
			this->ios_base::_M_call_callbacks(copyfmt_event);
			this->exceptions(__rhs.exceptions());
		}
		return *this;
	}
	template <class _CharT, class _Traits>
	locale basic_ios<_CharT, _Traits>::imbue(const locale &__loc)
	{
		locale __old(this->getloc());
		this->ios_base::imbue(__loc);
		_M_cache_locale(__loc);
		if (this->rdbuf() != 0) {
			this->rdbuf()->pubimbue(__loc);
		}
		return __old;
	}
	template <class _CharT, class _Traits>
	void basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits> *
					      __sb)
	{
		this->ios_base::_M_init();
		_M_cache_locale(_M_ios_locale);
		(_M_fill) = _CharT();
		(_M_fill_init) = false;
		(_M_tie) = 0;
		(_M_exception) = goodbit;
		(_M_streambuf) = __sb;
		(_M_streambuf_state) = ((__sb) ? goodbit : badbit);
	}
	template <class _CharT, class _Traits>
	void basic_ios<_CharT, _Traits>::_M_cache_locale(const locale &__loc)
	{
		if (__builtin_expect(has_facet<__ctype_type>(__loc), true)) {
			(_M_ctype) = std::__addressof(
				use_facet<__ctype_type>(__loc));
		} else {
			(_M_ctype) = 0;
		}
		if (__builtin_expect(has_facet<__num_put_type>(__loc), true)) {
			(_M_num_put) = std::__addressof(
				use_facet<__num_put_type>(__loc));
		} else {
			(_M_num_put) = 0;
		}
		if (__builtin_expect(has_facet<__num_get_type>(__loc), true)) {
			(_M_num_get) = std::__addressof(
				use_facet<__num_get_type>(__loc));
		} else {
			(_M_num_get) = 0;
		}
	}
	extern template class basic_ios<char>;
	extern template class basic_ios<wchar_t>;
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _CharT, class _Traits>
	class basic_ostream : virtual public basic_ios<_CharT, _Traits> {
	    public:
		typedef _CharT char_type;
		typedef typename _Traits::int_type int_type;
		typedef typename _Traits::pos_type pos_type;
		typedef typename _Traits::off_type off_type;
		typedef _Traits traits_type;
		typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
		typedef basic_ios<_CharT, _Traits> __ios_type;
		typedef basic_ostream __ostream_type;
		typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits>>
			__num_put_type;
		typedef ctype<_CharT> __ctype_type;
		explicit basic_ostream(__streambuf_type *__sb)
		{
			this->init(__sb);
		}
		virtual ~basic_ostream()
		{
		}
		class sentry;
		friend class sentry;
		__ostream_type &
		operator<<(__ostream_type &(*__pf)(__ostream_type &))
		{
			return __pf(*this);
		}
		__ostream_type &operator<<(__ios_type &(*__pf)(__ios_type &))
		{
			__pf(*this);
			return *this;
		}
		__ostream_type &
		operator<<(std::ios_base &(*__pf)(std::ios_base &))
		{
			__pf(*this);
			return *this;
		}
		__ostream_type &operator<<(long __n)
		{
			return _M_insert(__n);
		}
		__ostream_type &operator<<(unsigned long __n)
		{
			return _M_insert(__n);
		}
		__ostream_type &operator<<(bool __n)
		{
			return _M_insert(__n);
		}
		__ostream_type &operator<<(short __n);
		__ostream_type &operator<<(unsigned short __n)
		{
			return _M_insert(static_cast<unsigned long>(__n));
		}
		__ostream_type &operator<<(int __n);
		__ostream_type &operator<<(unsigned __n)
		{
			return _M_insert(static_cast<unsigned long>(__n));
		}
		__ostream_type &operator<<(long long __n)
		{
			return _M_insert(__n);
		}
		__ostream_type &operator<<(unsigned long long __n)
		{
			return _M_insert(__n);
		}
		__ostream_type &operator<<(double __f)
		{
			return _M_insert(__f);
		}
		__ostream_type &operator<<(float __f)
		{
			return _M_insert(static_cast<double>(__f));
		}
		__ostream_type &operator<<(long double __f)
		{
			return _M_insert(__f);
		}
		__ostream_type &operator<<(const void *__p)
		{
			return _M_insert(__p);
		}
		__ostream_type &operator<<(std::nullptr_t)
		{
			return (*this) << "nullptr";
		}
		__ostream_type &operator<<(__streambuf_type *__sb);
		__ostream_type &put(char_type __c);
		__ostream_type &write(const char_type *__s,
				      std::streamsize __n);
		__ostream_type &flush();
		pos_type tellp();
		__ostream_type &seekp(pos_type);
		__ostream_type &seekp(off_type, std::ios_base::seekdir);

	    protected:
		basic_ostream()
		{
			this->init(0);
		}
		basic_ostream(basic_iostream<_CharT, _Traits> &)
		{
		}
		basic_ostream(const basic_ostream &) = delete;
		basic_ostream(basic_ostream &&__rhs) : __ios_type()
		{
			__ios_type::move(__rhs);
		}
		basic_ostream &operator=(const basic_ostream &) = delete;
		basic_ostream &operator=(basic_ostream &&__rhs)
		{
			swap(__rhs);
			return *this;
		}
		void swap(basic_ostream &__rhs)
		{
			__ios_type::swap(__rhs);
		}
		template <class _ValueT> __ostream_type &_M_insert(_ValueT __v);

	    private:
		void _M_write(const char_type *__s, std::streamsize __n)
		{
			std::__ostream_insert(*this, __s, __n);
		}
	};
	template <class _CharT, class _Traits>
	class basic_ostream<_CharT, _Traits>::sentry {
		bool _M_ok;
		basic_ostream &_M_os;

	    public:
		explicit sentry(basic_ostream &__os);
		~sentry()
		{
			if (((bool)((_M_os).flags() & ios_base::unitbuf)) &&
			    (!uncaught_exception())) {
				if ((_M_os).rdbuf() &&
				    ((_M_os).rdbuf()->pubsync() == (-1))) {
					(_M_os).setstate(ios_base::badbit);
				}
			}
		}
		explicit operator bool() const
		{
			return _M_ok;
		}
	};
	template <class _CharT, class _Traits>
	inline basic_ostream<_CharT, _Traits> &operator<<(
		basic_ostream<_CharT, _Traits> &__out, _CharT __c)
	{
		if (__out.width() != 0) {
			return __ostream_insert(__out, &__c, 1);
		}
		__out.put(__c);
		return __out;
	}
	template <class _CharT, class _Traits>
	inline basic_ostream<_CharT, _Traits> &operator<<(
		basic_ostream<_CharT, _Traits> &__out, char __c)
	{
		return (__out << __out.widen(__c));
	}
	template <class _Traits>
	inline basic_ostream<char, _Traits> &operator<<(
		basic_ostream<char, _Traits> &__out, char __c)
	{
		if (__out.width() != 0) {
			return __ostream_insert(__out, &__c, 1);
		}
		__out.put(__c);
		return __out;
	}
	template <class _Traits>
	inline basic_ostream<char, _Traits> &operator<<(
		basic_ostream<char, _Traits> &__out, signed char __c)
	{
		return (__out << (static_cast<char>(__c)));
	}
	template <class _Traits>
	inline basic_ostream<char, _Traits> &operator<<(
		basic_ostream<char, _Traits> &__out, unsigned char __c)
	{
		return (__out << (static_cast<char>(__c)));
	}
	template <class _CharT, class _Traits>
	inline basic_ostream<_CharT, _Traits> &operator<<(
		basic_ostream<_CharT, _Traits> &__out, const _CharT *__s)
	{
		if (!__s) {
			__out.setstate(ios_base::badbit);
		} else {
			__ostream_insert(
				__out, __s,
				static_cast<streamsize>(_Traits::length(__s)));
		}
		return __out;
	}
	template <class _CharT, class _Traits>
	basic_ostream<_CharT, _Traits> &operator<<(
		basic_ostream<_CharT, _Traits> &__out, const char *__s);
	template <class _Traits>
	inline basic_ostream<char, _Traits> &operator<<(
		basic_ostream<char, _Traits> &__out, const char *__s)
	{
		if (!__s) {
			__out.setstate(ios_base::badbit);
		} else {
			__ostream_insert(
				__out, __s,
				static_cast<streamsize>(_Traits::length(__s)));
		}
		return __out;
	}
	template <class _Traits>
	inline basic_ostream<char, _Traits> &operator<<(
		basic_ostream<char, _Traits> &__out, const signed char *__s)
	{
		return (__out << (reinterpret_cast<const char *>(__s)));
	}
	template <class _Traits>
	inline basic_ostream<char, _Traits> &operator<<(
		basic_ostream<char, _Traits> &__out, const unsigned char *__s)
	{
		return (__out << (reinterpret_cast<const char *>(__s)));
	}
	template <class _CharT, class _Traits>
	inline basic_ostream<_CharT, _Traits> &endl(
		basic_ostream<_CharT, _Traits> & __os)
	{
		return flush(__os.put(__os.widen('\n')));
	}
	template <class _CharT, class _Traits>
	inline basic_ostream<_CharT, _Traits> &ends(
		basic_ostream<_CharT, _Traits> & __os)
	{
		return __os.put(_CharT());
	}
	template <class _CharT, class _Traits>
	inline basic_ostream<_CharT, _Traits> &flush(
		basic_ostream<_CharT, _Traits> & __os)
	{
		return __os.flush();
	}
	template <class _Tp>
	using _Require_derived_from_ios_base = _Require<
		is_class<_Tp>, __not_<is_same<_Tp, ios_base>>,
		is_convertible<typename add_pointer<_Tp>::type, ios_base *>>;
	template <class _Os, class _Tp,
		  class = _Require_derived_from_ios_base<_Os>,
		  class = __decltype((std::declval<_Os &>()
				      << std::declval<const _Tp &>()))>
	using __rvalue_stream_insertion_t = _Os &&;
	template <class _Ostream, class _Tp>
	inline __rvalue_stream_insertion_t<_Ostream, _Tp> operator<<(
		_Ostream &&__os, const _Tp &__x)
	{
		__os << __x;
		return std::move(__os);
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _CharT, class _Traits>
	basic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream & __os)
		: _M_ok(false), _M_os(__os)
	{
		if (__os.tie() && __os.good()) {
			__os.tie()->flush();
		}
		if (__os.good()) {
			(_M_ok) = true;
		} else {
			if (__os.bad()) {
				__os.setstate(ios_base::failbit);
			}
		}
	}
	template <class _CharT, class _Traits>
	template <class _ValueT>
	basic_ostream<_CharT, _Traits>
		&basic_ostream<_CharT, _Traits>::_M_insert(_ValueT __v)
	{
		sentry __cerb(*this);
		if (__cerb) {
			std::ios_base::iostate __err = ios_base::goodbit;
			try {
				const __num_put_type &__np =
					__check_facet((this->_M_num_put));
				if (__np.put(*this, *this, this->fill(), __v)
					    .failed()) {
					(__err |= ios_base::badbit);
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::badbit);
			}
			if (__err) {
				this->setstate(__err);
			}
		}
		return *this;
	}
	template <class _CharT, class _Traits>
	basic_ostream<_CharT, _Traits>
		&basic_ostream<_CharT, _Traits>::operator<<(short __n)
	{
		const std::ios_base::fmtflags __fmt =
			this->flags() & ios_base::basefield;
		if ((__fmt == ios_base::oct) || (__fmt == ios_base::hex)) {
			return _M_insert(static_cast<long>(
				static_cast<unsigned short>(__n)));
		} else {
			return _M_insert(static_cast<long>(__n));
		}
	}
	template <class _CharT, class _Traits>
	basic_ostream<_CharT, _Traits>
		&basic_ostream<_CharT, _Traits>::operator<<(int __n)
	{
		const std::ios_base::fmtflags __fmt =
			this->flags() & ios_base::basefield;
		if ((__fmt == ios_base::oct) || (__fmt == ios_base::hex)) {
			return _M_insert(
				static_cast<long>(static_cast<unsigned>(__n)));
		} else {
			return _M_insert(static_cast<long>(__n));
		}
	}
	template <class _CharT, class _Traits>
	basic_ostream<_CharT, _Traits> &
	basic_ostream<_CharT, _Traits>::operator<<(__streambuf_type *__sbin)
	{
		std::ios_base::iostate __err = ios_base::goodbit;
		sentry __cerb(*this);
		if (__cerb && __sbin) {
			try {
				if (!__copy_streambufs(__sbin, this->rdbuf())) {
					(__err |= ios_base::failbit);
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::failbit);
			}
		} else {
			if (!__sbin) {
				(__err |= ios_base::badbit);
			}
		}
		if (__err) {
			this->setstate(__err);
		}
		return *this;
	}
	template <class _CharT, class _Traits>
	basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::put(
		char_type __c)
	{
		sentry __cerb(*this);
		if (__cerb) {
			std::ios_base::iostate __err = ios_base::goodbit;
			try {
				const int_type __put =
					this->rdbuf()->sputc(__c);
				if (traits_type::eq_int_type(
					    __put, traits_type::eof())) {
					(__err |= ios_base::badbit);
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::badbit);
			}
			if (__err) {
				this->setstate(__err);
			}
		}
		return *this;
	}
	template <class _CharT, class _Traits>
	basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::write(
		const _CharT *__s, std::streamsize __n)
	{
		sentry __cerb(*this);
		if (__cerb) {
			std::ios_base::iostate __err = ios_base::goodbit;
			try {
				if (this->rdbuf()->sputn(__s, __n) != __n) {
					__err = ios_base::badbit;
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::badbit);
			}
			if (__err) {
				this->setstate(ios_base::badbit);
			}
		}
		return *this;
	}
	template <class _CharT, class _Traits>
	typename basic_ostream<_CharT, _Traits>::__ostream_type &
	basic_ostream<_CharT, _Traits>::flush()
	{
		if (__streambuf_type *__buf = this->rdbuf()) {
			sentry __cerb(*this);
			if (__cerb) {
				std::ios_base::iostate __err =
					ios_base::goodbit;
				try {
					if (this->rdbuf()->pubsync() == (-1)) {
						(__err |= ios_base::badbit);
					}
				} catch (__cxxabiv1::__forced_unwind &) {
					this->_M_setstate(ios_base::badbit);
					throw;
				} catch (...) {
					this->_M_setstate(ios_base::badbit);
				}
				if (__err) {
					this->setstate(__err);
				}
			}
		}
		return *this;
	}
	template <class _CharT, class _Traits>
	typename basic_ostream<_CharT, _Traits>::pos_type
	basic_ostream<_CharT, _Traits>::tellp()
	{
		sentry __cerb(*this);
		pos_type __ret = ((pos_type)(-1));
		if (!this->fail()) {
			__ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
							  ios_base::out);
		}
		return __ret;
	}
	template <class _CharT, class _Traits>
	basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::seekp(
		pos_type __pos)
	{
		sentry __cerb(*this);
		if (!this->fail()) {
			const pos_type __p =
				this->rdbuf()->pubseekpos(__pos, ios_base::out);
			if (__p == ((pos_type)((off_type)(-1)))) {
				this->setstate(ios_base::failbit);
			}
		}
		return *this;
	}
	template <class _CharT, class _Traits>
	basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::seekp(
		off_type __off, std::ios_base::seekdir __dir)
	{
		sentry __cerb(*this);
		if (!this->fail()) {
			const pos_type __p = this->rdbuf()->pubseekoff(
				__off, __dir, ios_base::out);
			if (__p == ((pos_type)((off_type)(-1)))) {
				this->setstate(ios_base::failbit);
			}
		}
		return *this;
	}
	template <class _CharT, class _Traits>
	basic_ostream<_CharT, _Traits> &operator<<(
		basic_ostream<_CharT, _Traits> &__out, const char *__s)
	{
		if (!__s) {
			__out.setstate(ios_base::badbit);
		} else {
			const size_t __clen = char_traits<char>::length(__s);
			try {
				struct __ptr_guard {
					_CharT *__p;
					__ptr_guard(_CharT *__ip) : __p(__ip)
					{
					}
					~__ptr_guard()
					{
						delete[](__p);
					}
					_CharT *__get()
					{
						return __p;
					}
				} __pg(new _CharT[__clen]);
				_CharT *__ws = __pg.__get();
				for (size_t __i = (0); __i < __clen; ++__i) {
					(__ws[__i]) = __out.widen(__s[__i]);
				}
				__ostream_insert(__out, __ws, __clen);
			} catch (__cxxabiv1::__forced_unwind &) {
				__out._M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				__out._M_setstate(ios_base::badbit);
			}
		}
		return __out;
	}
	extern template class basic_ostream<char>;
	extern template basic_ostream<char> &endl(basic_ostream<char> & __os);
	extern template basic_ostream<char> &ends(basic_ostream<char> & __os);
	extern template basic_ostream<char> &flush(basic_ostream<char> & __os);
	extern template basic_ostream<char> &operator<<(
		basic_ostream<char> &__out, char __c);
	extern template basic_ostream<char> &operator<<(
		basic_ostream<char> &__out, unsigned char __c);
	extern template basic_ostream<char> &operator<<(
		basic_ostream<char> &__out, signed char __c);
	extern template basic_ostream<char> &operator<<(
		basic_ostream<char> &__out, const char *__s);
	extern template basic_ostream<char> &operator<<(
		basic_ostream<char> &__out, const unsigned char *__s);
	extern template basic_ostream<char> &operator<<(
		basic_ostream<char> &__out, const signed char *__s);
	extern template basic_ostream<char>::__ostream_type &
	basic_ostream<char>::_M_insert(long __v);
	extern template basic_ostream<char>::__ostream_type &
	basic_ostream<char>::_M_insert(unsigned long __v);
	extern template basic_ostream<char>::__ostream_type &
	basic_ostream<char>::_M_insert(bool __v);
	extern template basic_ostream<char>::__ostream_type &
	basic_ostream<char>::_M_insert(long long __v);
	extern template basic_ostream<char>::__ostream_type &
	basic_ostream<char>::_M_insert(unsigned long long __v);
	extern template basic_ostream<char>::__ostream_type &
	basic_ostream<char>::_M_insert(double __v);
	extern template basic_ostream<char>::__ostream_type &
	basic_ostream<char>::_M_insert(long double __v);
	extern template basic_ostream<char>::__ostream_type &
	basic_ostream<char>::_M_insert(const void *__v);
	extern template class basic_ostream<wchar_t>;
	extern template basic_ostream<wchar_t> &endl(basic_ostream<wchar_t> &
						     __os);
	extern template basic_ostream<wchar_t> &ends(basic_ostream<wchar_t> &
						     __os);
	extern template basic_ostream<wchar_t> &flush(basic_ostream<wchar_t> &
						      __os);
	extern template basic_ostream<wchar_t> &operator<<(
		basic_ostream<wchar_t> &__out, wchar_t __c);
	extern template basic_ostream<wchar_t> &operator<<(
		basic_ostream<wchar_t> &__out, char __c);
	extern template basic_ostream<wchar_t> &operator<<(
		basic_ostream<wchar_t> &__out, const wchar_t *__s);
	extern template basic_ostream<wchar_t> &operator<<(
		basic_ostream<wchar_t> &__out, const char *__s);
	extern template basic_ostream<wchar_t>::__ostream_type &
	basic_ostream<wchar_t>::_M_insert(long __v);
	extern template basic_ostream<wchar_t>::__ostream_type &
	basic_ostream<wchar_t>::_M_insert(unsigned long __v);
	extern template basic_ostream<wchar_t>::__ostream_type &
	basic_ostream<wchar_t>::_M_insert(bool __v);
	extern template basic_ostream<wchar_t>::__ostream_type &
	basic_ostream<wchar_t>::_M_insert(long long __v);
	extern template basic_ostream<wchar_t>::__ostream_type &
	basic_ostream<wchar_t>::_M_insert(unsigned long long __v);
	extern template basic_ostream<wchar_t>::__ostream_type &
	basic_ostream<wchar_t>::_M_insert(double __v);
	extern template basic_ostream<wchar_t>::__ostream_type &
	basic_ostream<wchar_t>::_M_insert(long double __v);
	extern template basic_ostream<wchar_t>::__ostream_type &
	basic_ostream<wchar_t>::_M_insert(const void *__v);
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _CharT, class _Traits>
	class basic_istream : virtual public basic_ios<_CharT, _Traits> {
	    public:
		typedef _CharT char_type;
		typedef typename _Traits::int_type int_type;
		typedef typename _Traits::pos_type pos_type;
		typedef typename _Traits::off_type off_type;
		typedef _Traits traits_type;
		typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
		typedef basic_ios<_CharT, _Traits> __ios_type;
		typedef basic_istream __istream_type;
		typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits>>
			__num_get_type;
		typedef ctype<_CharT> __ctype_type;

	    protected:
		std::streamsize _M_gcount;

	    public:
		explicit basic_istream(__streambuf_type *__sb)
			: _M_gcount(((std::streamsize)0))
		{
			this->init(__sb);
		}
		virtual ~basic_istream()
		{
			(_M_gcount) = ((std::streamsize)0);
		}
		class sentry;
		friend class sentry;
		__istream_type &
		operator>>(__istream_type &(*__pf)(__istream_type &))
		{
			return __pf(*this);
		}
		__istream_type &operator>>(__ios_type &(*__pf)(__ios_type &))
		{
			__pf(*this);
			return *this;
		}
		__istream_type &
		operator>>(std::ios_base &(*__pf)(std::ios_base &))
		{
			__pf(*this);
			return *this;
		}
		__istream_type &operator>>(bool &__n)
		{
			return _M_extract(__n);
		}
		__istream_type &operator>>(short &__n);
		__istream_type &operator>>(unsigned short &__n)
		{
			return _M_extract(__n);
		}
		__istream_type &operator>>(int &__n);
		__istream_type &operator>>(unsigned &__n)
		{
			return _M_extract(__n);
		}
		__istream_type &operator>>(long &__n)
		{
			return _M_extract(__n);
		}
		__istream_type &operator>>(unsigned long &__n)
		{
			return _M_extract(__n);
		}
		__istream_type &operator>>(long long &__n)
		{
			return _M_extract(__n);
		}
		__istream_type &operator>>(unsigned long long &__n)
		{
			return _M_extract(__n);
		}
		__istream_type &operator>>(float &__f)
		{
			return _M_extract(__f);
		}
		__istream_type &operator>>(double &__f)
		{
			return _M_extract(__f);
		}
		__istream_type &operator>>(long double &__f)
		{
			return _M_extract(__f);
		}
		__istream_type &operator>>(void *&__p)
		{
			return _M_extract(__p);
		}
		__istream_type &operator>>(__streambuf_type *__sb);
		std::streamsize gcount() const
		{
			return _M_gcount;
		}
		int_type get();
		__istream_type &get(char_type &__c);
		__istream_type &get(char_type *__s, std::streamsize __n,
				    char_type __delim);
		__istream_type &get(char_type *__s, std::streamsize __n)
		{
			return this->get(__s, __n, this->widen('\n'));
		}
		__istream_type &get(__streambuf_type &__sb, char_type __delim);
		__istream_type &get(__streambuf_type &__sb)
		{
			return this->get(__sb, this->widen('\n'));
		}
		__istream_type &getline(char_type *__s, std::streamsize __n,
					char_type __delim);
		__istream_type &getline(char_type *__s, std::streamsize __n)
		{
			return this->getline(__s, __n, this->widen('\n'));
		}
		__istream_type &ignore(std::streamsize __n, int_type __delim);
		__istream_type &ignore(std::streamsize __n);
		__istream_type &ignore();
		int_type peek();
		__istream_type &read(char_type *__s, std::streamsize __n);
		std::streamsize readsome(char_type *__s, std::streamsize __n);
		__istream_type &putback(char_type __c);
		__istream_type &unget();
		int sync();
		pos_type tellg();
		__istream_type &seekg(pos_type);
		__istream_type &seekg(off_type, std::ios_base::seekdir);

	    protected:
		basic_istream() : _M_gcount(((std::streamsize)0))
		{
			this->init(0);
		}
		basic_istream(const basic_istream &) = delete;
		basic_istream(basic_istream &&__rhs)
			: __ios_type(), _M_gcount(__rhs._M_gcount)
		{
			__ios_type::move(__rhs);
			(__rhs._M_gcount) = (0);
		}
		basic_istream &operator=(const basic_istream &) = delete;
		basic_istream &operator=(basic_istream &&__rhs)
		{
			swap(__rhs);
			return *this;
		}
		void swap(basic_istream &__rhs)
		{
			__ios_type::swap(__rhs);
			std::swap(_M_gcount, __rhs._M_gcount);
		}
		template <class _ValueT>
		__istream_type &_M_extract(_ValueT &__v);
	};
	template <>
	basic_istream<char> &basic_istream<char>::getline(
		char_type * __s, streamsize __n, char_type __delim);
	template <>
	basic_istream<char> &basic_istream<char>::ignore(streamsize __n);
	template <>
	basic_istream<char> &basic_istream<char>::ignore(streamsize __n,
							 int_type __delim);
	template <>
	basic_istream<wchar_t> &basic_istream<wchar_t>::getline(
		char_type * __s, streamsize __n, char_type __delim);
	template <>
	basic_istream<wchar_t> &basic_istream<wchar_t>::ignore(streamsize __n);
	template <>
	basic_istream<wchar_t> &basic_istream<wchar_t>::ignore(
		streamsize __n, int_type __delim);
	template <class _CharT, class _Traits>
	class basic_istream<_CharT, _Traits>::sentry {
		bool _M_ok;

	    public:
		typedef _Traits traits_type;
		typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
		typedef basic_istream __istream_type;
		typedef typename basic_istream<_CharT, _Traits>::__ctype_type
			__ctype_type;
		typedef typename _Traits::int_type __int_type;
		explicit sentry(basic_istream &__is, bool __noskipws = false);
		explicit operator bool() const
		{
			return _M_ok;
		}
	};
	template <class _CharT, class _Traits>
	basic_istream<_CharT, _Traits> &operator>>(
		basic_istream<_CharT, _Traits> &__in, _CharT &__c);
	template <class _Traits>
	inline basic_istream<char, _Traits> &operator>>(
		basic_istream<char, _Traits> &__in, unsigned char &__c)
	{
		return (__in >> (reinterpret_cast<char &>(__c)));
	}
	template <class _Traits>
	inline basic_istream<char, _Traits> &operator>>(
		basic_istream<char, _Traits> &__in, signed char &__c)
	{
		return (__in >> (reinterpret_cast<char &>(__c)));
	}
	template <class _CharT, class _Traits>
	void __istream_extract(basic_istream<_CharT, _Traits> &, _CharT *,
			       streamsize);
	void __istream_extract(istream &, char *, streamsize);
	template <class _CharT, class _Traits>
	__attribute((__nonnull__(2),
		     __access__(__write_only__,
				2))) inline basic_istream<_CharT, _Traits>
		&operator>>(basic_istream<_CharT, _Traits> &__in, _CharT *__s)
	{
		{
			streamsize __n =
				__gnu_cxx::__numeric_traits<long>::__max;
			__n /= sizeof(_CharT);
			std::__istream_extract(__in, __s, __n);
		}
		return __in;
	}
	template <class _Traits>
	__attribute((__nonnull__(2),
		     __access__(__write_only__,
				2))) inline basic_istream<char, _Traits> &
	operator>>(basic_istream<char, _Traits> &__in, unsigned char *__s)
	{
		return __in >> (reinterpret_cast<char *>(__s));
	}
	template <class _Traits>
	__attribute((__nonnull__(2),
		     __access__(__write_only__,
				2))) inline basic_istream<char, _Traits> &
	operator>>(basic_istream<char, _Traits> &__in, signed char *__s)
	{
		return __in >> (reinterpret_cast<char *>(__s));
	}
	template <class _CharT, class _Traits>
	class basic_iostream : public basic_istream<_CharT, _Traits>,
			       public basic_ostream<_CharT, _Traits> {
	    public:
		typedef _CharT char_type;
		typedef typename _Traits::int_type int_type;
		typedef typename _Traits::pos_type pos_type;
		typedef typename _Traits::off_type off_type;
		typedef _Traits traits_type;
		typedef basic_istream<_CharT, _Traits> __istream_type;
		typedef basic_ostream<_CharT, _Traits> __ostream_type;
		explicit basic_iostream(basic_streambuf<_CharT, _Traits> *__sb)
			: __istream_type(__sb), __ostream_type(__sb)
		{
		}
		virtual ~basic_iostream()
		{
		}

	    protected:
		basic_iostream() : __istream_type(), __ostream_type()
		{
		}
		basic_iostream(const basic_iostream &) = delete;
		basic_iostream(basic_iostream &&__rhs)
			: __istream_type(std::move(__rhs)),
			  __ostream_type(*this)
		{
		}
		basic_iostream &operator=(const basic_iostream &) = delete;
		basic_iostream &operator=(basic_iostream &&__rhs)
		{
			swap(__rhs);
			return *this;
		}
		void swap(basic_iostream &__rhs)
		{
			__istream_type::swap(__rhs);
		}
	};
	template <class _CharT, class _Traits>
	basic_istream<_CharT, _Traits> &ws(basic_istream<_CharT, _Traits> &
					   __is);
	template <class _Is, class _Tp,
		  class = _Require_derived_from_ios_base<_Is>,
		  class = __decltype((std::declval<_Is &>() >>
				      std::declval<_Tp>()))>
	using __rvalue_stream_extraction_t = _Is &&;
	template <class _Istream, class _Tp>
	inline __rvalue_stream_extraction_t<_Istream, _Tp> operator>>(
		_Istream &&__is, _Tp &&__x)
	{
		__is >> std::forward<_Tp>(__x);
		return std::move(__is);
	}
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	template <class _CharT, class _Traits>
	basic_istream<_CharT, _Traits>::sentry::sentry(basic_istream & __in,
						       bool __noskip)
		: _M_ok(false)
	{
		std::ios_base::iostate __err = ios_base::goodbit;
		if (__in.good()) {
			try {
				if (__in.tie()) {
					__in.tie()->flush();
				}
				if ((!__noskip) &&
				    ((bool)(__in.flags() & ios_base::skipws))) {
					const __int_type __eof =
						traits_type::eof();
					__streambuf_type *__sb = __in.rdbuf();
					__int_type __c = __sb->sgetc();
					const __ctype_type &__ct =
						__check_facet((__in._M_ctype));
					while ((!traits_type::eq_int_type(
						       __c, __eof)) &&
					       __ct.is(ctype_base::space,
						       traits_type::to_char_type(
							       __c))) {
						__c = __sb->snextc();
					}
					if (traits_type::eq_int_type(__c,
								     __eof)) {
						(__err |= ios_base::eofbit);
					}
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				__in._M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				__in._M_setstate(ios_base::badbit);
			}
		}
		if (__in.good() && (__err == ios_base::goodbit)) {
			(_M_ok) = true;
		} else {
			(__err |= ios_base::failbit);
			__in.setstate(__err);
		}
	}
	template <class _CharT, class _Traits>
	template <class _ValueT>
	basic_istream<_CharT, _Traits>
		&basic_istream<_CharT, _Traits>::_M_extract(_ValueT & __v)
	{
		sentry __cerb(*this, false);
		if (__cerb) {
			std::ios_base::iostate __err = ios_base::goodbit;
			try {
				const __num_get_type &__ng =
					__check_facet((this->_M_num_get));
				__ng.get(*this, 0, *this, __err, __v);
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::badbit);
			}
			if (__err) {
				this->setstate(__err);
			}
		}
		return *this;
	}
	template <class _CharT, class _Traits>
	basic_istream<_CharT, _Traits>
		&basic_istream<_CharT, _Traits>::operator>>(short &__n)
	{
		sentry __cerb(*this, false);
		if (__cerb) {
			std::ios_base::iostate __err = ios_base::goodbit;
			try {
				long __l;
				const __num_get_type &__ng =
					__check_facet((this->_M_num_get));
				__ng.get(*this, 0, *this, __err, __l);
				if (__l <
				    __gnu_cxx::__numeric_traits<short>::__min) {
					(__err |= ios_base::failbit);
					__n = __gnu_cxx::__numeric_traits<
						short>::__min;
				} else {
					if (__l > __gnu_cxx::__numeric_traits<
							  short>::__max) {
						(__err |= ios_base::failbit);
						__n = __gnu_cxx::__numeric_traits<
							short>::__max;
					} else {
						__n = ((short)__l);
					}
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::badbit);
			}
			if (__err) {
				this->setstate(__err);
			}
		}
		return *this;
	}
	template <class _CharT, class _Traits>
	basic_istream<_CharT, _Traits>
		&basic_istream<_CharT, _Traits>::operator>>(int &__n)
	{
		sentry __cerb(*this, false);
		if (__cerb) {
			std::ios_base::iostate __err = ios_base::goodbit;
			try {
				long __l;
				const __num_get_type &__ng =
					__check_facet((this->_M_num_get));
				__ng.get(*this, 0, *this, __err, __l);
				if (__l <
				    __gnu_cxx::__numeric_traits<int>::__min) {
					(__err |= ios_base::failbit);
					__n = __gnu_cxx::__numeric_traits<
						int>::__min;
				} else {
					if (__l > __gnu_cxx::__numeric_traits<
							  int>::__max) {
						(__err |= ios_base::failbit);
						__n = __gnu_cxx::__numeric_traits<
							int>::__max;
					} else {
						__n = ((int)__l);
					}
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::badbit);
			}
			if (__err) {
				this->setstate(__err);
			}
		}
		return *this;
	}
	template <class _CharT, class _Traits>
	basic_istream<_CharT, _Traits> &
	basic_istream<_CharT, _Traits>::operator>>(__streambuf_type *__sbout)
	{
		std::ios_base::iostate __err = ios_base::goodbit;
		sentry __cerb(*this, false);
		if (__cerb && __sbout) {
			try {
				bool __ineof;
				if (!__copy_streambufs_eof(this->rdbuf(),
							   __sbout, __ineof)) {
					(__err |= ios_base::failbit);
				}
				if (__ineof) {
					(__err |= ios_base::eofbit);
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::failbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::failbit);
			}
		} else {
			if (!__sbout) {
				(__err |= ios_base::failbit);
			}
		}
		if (__err) {
			this->setstate(__err);
		}
		return *this;
	}
	template <class _CharT, class _Traits>
	typename basic_istream<_CharT, _Traits>::int_type
	basic_istream<_CharT, _Traits>::get()
	{
		const int_type __eof = traits_type::eof();
		int_type __c = __eof;
		(_M_gcount) = (0);
		std::ios_base::iostate __err = ios_base::goodbit;
		sentry __cerb(*this, true);
		if (__cerb) {
			try {
				__c = this->rdbuf()->sbumpc();
				if (!traits_type::eq_int_type(__c, __eof)) {
					(_M_gcount) = (1);
				} else {
					(__err |= ios_base::eofbit);
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::badbit);
			}
		}
		if (!(_M_gcount)) {
			(__err |= ios_base::failbit);
		}
		if (__err) {
			this->setstate(__err);
		}
		return __c;
	}
	template <class _CharT, class _Traits>
	basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::get(
		char_type & __c)
	{
		(_M_gcount) = (0);
		std::ios_base::iostate __err = ios_base::goodbit;
		sentry __cerb(*this, true);
		if (__cerb) {
			try {
				const int_type __cb = this->rdbuf()->sbumpc();
				if (!traits_type::eq_int_type(
					    __cb, traits_type::eof())) {
					(_M_gcount) = (1);
					__c = traits_type::to_char_type(__cb);
				} else {
					(__err |= ios_base::eofbit);
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::badbit);
			}
		}
		if (!(_M_gcount)) {
			(__err |= ios_base::failbit);
		}
		if (__err) {
			this->setstate(__err);
		}
		return *this;
	}
	template <class _CharT, class _Traits>
	basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::get(
		char_type * __s, std::streamsize __n, char_type __delim)
	{
		(_M_gcount) = (0);
		std::ios_base::iostate __err = ios_base::goodbit;
		sentry __cerb(*this, true);
		if (__cerb) {
			try {
				const int_type __idelim =
					traits_type::to_int_type(__delim);
				const int_type __eof = traits_type::eof();
				__streambuf_type *__sb = this->rdbuf();
				int_type __c = __sb->sgetc();
				while ((((_M_gcount) + (1)) < __n) &&
				       (!traits_type::eq_int_type(__c,
								  __eof)) &&
				       (!traits_type::eq_int_type(__c,
								  __idelim))) {
					(*(__s++)) =
						traits_type::to_char_type(__c);
					++(_M_gcount);
					__c = __sb->snextc();
				}
				if (traits_type::eq_int_type(__c, __eof)) {
					(__err |= ios_base::eofbit);
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::badbit);
			}
		}
		if (__n > (0)) {
			(*__s) = char_type();
		}
		if (!(_M_gcount)) {
			(__err |= ios_base::failbit);
		}
		if (__err) {
			this->setstate(__err);
		}
		return *this;
	}
	template <class _CharT, class _Traits>
	basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::get(
		__streambuf_type & __sb, char_type __delim)
	{
		(_M_gcount) = (0);
		std::ios_base::iostate __err = ios_base::goodbit;
		sentry __cerb(*this, true);
		if (__cerb) {
			try {
				const int_type __idelim =
					traits_type::to_int_type(__delim);
				const int_type __eof = traits_type::eof();
				__streambuf_type *__this_sb = this->rdbuf();
				int_type __c = __this_sb->sgetc();
				char_type __c2 = traits_type::to_char_type(__c);
				unsigned long long __gcount = (0);
				while ((!traits_type::eq_int_type(__c,
								  __eof)) &&
				       (!traits_type::eq_int_type(__c,
								  __idelim)) &&
				       (!traits_type::eq_int_type(
					       __sb.sputc(__c2), __eof))) {
					++__gcount;
					__c = __this_sb->snextc();
					__c2 = traits_type::to_char_type(__c);
				}
				if (traits_type::eq_int_type(__c, __eof)) {
					(__err |= ios_base::eofbit);
				}
				if (__gcount <=
				    __gnu_cxx::__numeric_traits<long>::__max) {
					(_M_gcount) = __gcount;
				} else {
					(_M_gcount) =
						__gnu_cxx::__numeric_traits<
							long>::__max;
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::badbit);
			}
		}
		if (!(_M_gcount)) {
			(__err |= ios_base::failbit);
		}
		if (__err) {
			this->setstate(__err);
		}
		return *this;
	}
	template <class _CharT, class _Traits>
	basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::getline(
		char_type * __s, std::streamsize __n, char_type __delim)
	{
		(_M_gcount) = (0);
		std::ios_base::iostate __err = ios_base::goodbit;
		sentry __cerb(*this, true);
		if (__cerb) {
			try {
				const int_type __idelim =
					traits_type::to_int_type(__delim);
				const int_type __eof = traits_type::eof();
				__streambuf_type *__sb = this->rdbuf();
				int_type __c = __sb->sgetc();
				while ((((_M_gcount) + (1)) < __n) &&
				       (!traits_type::eq_int_type(__c,
								  __eof)) &&
				       (!traits_type::eq_int_type(__c,
								  __idelim))) {
					(*(__s++)) =
						traits_type::to_char_type(__c);
					__c = __sb->snextc();
					++(_M_gcount);
				}
				if (traits_type::eq_int_type(__c, __eof)) {
					(__err |= ios_base::eofbit);
				} else {
					if (traits_type::eq_int_type(
						    __c, __idelim)) {
						__sb->sbumpc();
						++(_M_gcount);
					} else {
						(__err |= ios_base::failbit);
					}
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::badbit);
			}
		}
		if (__n > (0)) {
			(*__s) = char_type();
		}
		if (!(_M_gcount)) {
			(__err |= ios_base::failbit);
		}
		if (__err) {
			this->setstate(__err);
		}
		return *this;
	}
	template <class _CharT, class _Traits>
	typename basic_istream<_CharT, _Traits>::__istream_type &
	basic_istream<_CharT, _Traits>::ignore()
	{
		(_M_gcount) = (0);
		sentry __cerb(*this, true);
		if (__cerb) {
			std::ios_base::iostate __err = ios_base::goodbit;
			try {
				const int_type __eof = traits_type::eof();
				__streambuf_type *__sb = this->rdbuf();
				if (traits_type::eq_int_type(__sb->sbumpc(),
							     __eof)) {
					(__err |= ios_base::eofbit);
				} else {
					(_M_gcount) = (1);
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::badbit);
			}
			if (__err) {
				this->setstate(__err);
			}
		}
		return *this;
	}
	template <class _CharT, class _Traits>
	basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::ignore(
		std::streamsize __n)
	{
		(_M_gcount) = (0);
		sentry __cerb(*this, true);
		if (__cerb && (__n > (0))) {
			std::ios_base::iostate __err = ios_base::goodbit;
			try {
				const int_type __eof = traits_type::eof();
				__streambuf_type *__sb = this->rdbuf();
				int_type __c = __sb->sgetc();
				bool __large_ignore = false;
				while (true) {
					while (((_M_gcount) < __n) &&
					       (!traits_type::eq_int_type(
						       __c, __eof))) {
						++(_M_gcount);
						__c = __sb->snextc();
					}
					if ((__n == __gnu_cxx::__numeric_traits<
							    long>::__max) &&
					    (!traits_type::eq_int_type(
						    __c, __eof))) {
						(_M_gcount) = __gnu_cxx::
							__numeric_traits<
								long>::__min;
						__large_ignore = true;
					} else {
						break;
					}
				}
				if (__n ==
				    __gnu_cxx::__numeric_traits<long>::__max) {
					if (__large_ignore) {
						(_M_gcount) = __gnu_cxx::
							__numeric_traits<
								long>::__max;
					}
					if (traits_type::eq_int_type(__c,
								     __eof)) {
						(__err |= ios_base::eofbit);
					}
				} else {
					if ((_M_gcount) < __n) {
						if (traits_type::eq_int_type(
							    __c, __eof)) {
							(__err |=
							 ios_base::eofbit);
						}
					}
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::badbit);
			}
			if (__err) {
				this->setstate(__err);
			}
		}
		return *this;
	}
	template <class _CharT, class _Traits>
	basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::ignore(
		std::streamsize __n, int_type __delim)
	{
		(_M_gcount) = (0);
		sentry __cerb(*this, true);
		if (__cerb && (__n > (0))) {
			std::ios_base::iostate __err = ios_base::goodbit;
			try {
				const int_type __eof = traits_type::eof();
				__streambuf_type *__sb = this->rdbuf();
				int_type __c = __sb->sgetc();
				bool __large_ignore = false;
				while (true) {
					while (((_M_gcount) < __n) &&
					       (!traits_type::eq_int_type(
						       __c, __eof)) &&
					       (!traits_type::eq_int_type(
						       __c, __delim))) {
						++(_M_gcount);
						__c = __sb->snextc();
					}
					if ((__n == __gnu_cxx::__numeric_traits<
							    long>::__max) &&
					    (!traits_type::eq_int_type(
						    __c, __eof)) &&
					    (!traits_type::eq_int_type(
						    __c, __delim))) {
						(_M_gcount) = __gnu_cxx::
							__numeric_traits<
								long>::__min;
						__large_ignore = true;
					} else {
						break;
					}
				}
				if (__n ==
				    __gnu_cxx::__numeric_traits<long>::__max) {
					if (__large_ignore) {
						(_M_gcount) = __gnu_cxx::
							__numeric_traits<
								long>::__max;
					}
					if (traits_type::eq_int_type(__c,
								     __eof)) {
						(__err |= ios_base::eofbit);
					} else {
						if ((_M_gcount) != __n) {
							++(_M_gcount);
						}
						__sb->sbumpc();
					}
				} else {
					if ((_M_gcount) < __n) {
						if (traits_type::eq_int_type(
							    __c, __eof)) {
							(__err |=
							 ios_base::eofbit);
						} else {
							++(_M_gcount);
							__sb->sbumpc();
						}
					}
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::badbit);
			}
			if (__err) {
				this->setstate(__err);
			}
		}
		return *this;
	}
	template <class _CharT, class _Traits>
	typename basic_istream<_CharT, _Traits>::int_type
	basic_istream<_CharT, _Traits>::peek()
	{
		int_type __c = traits_type::eof();
		(_M_gcount) = (0);
		sentry __cerb(*this, true);
		if (__cerb) {
			std::ios_base::iostate __err = ios_base::goodbit;
			try {
				__c = this->rdbuf()->sgetc();
				if (traits_type::eq_int_type(
					    __c, traits_type::eof())) {
					(__err |= ios_base::eofbit);
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::badbit);
			}
			if (__err) {
				this->setstate(__err);
			}
		}
		return __c;
	}
	template <class _CharT, class _Traits>
	basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::read(
		char_type * __s, std::streamsize __n)
	{
		(_M_gcount) = (0);
		sentry __cerb(*this, true);
		if (__cerb) {
			std::ios_base::iostate __err = ios_base::goodbit;
			try {
				(_M_gcount) = this->rdbuf()->sgetn(__s, __n);
				if ((_M_gcount) != __n) {
					(__err |= ((ios_base::eofbit |
						    ios_base::failbit)));
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::badbit);
			}
			if (__err) {
				this->setstate(__err);
			}
		}
		return *this;
	}
	template <class _CharT, class _Traits>
	streamsize basic_istream<_CharT, _Traits>::readsome(char_type * __s,
							    std::streamsize __n)
	{
		(_M_gcount) = (0);
		sentry __cerb(*this, true);
		if (__cerb) {
			std::ios_base::iostate __err = ios_base::goodbit;
			try {
				const std::streamsize __num =
					this->rdbuf()->in_avail();
				if (__num > (0)) {
					(_M_gcount) = this->rdbuf()->sgetn(
						__s, std::min(__num, __n));
				} else {
					if (__num == (-1)) {
						(__err |= ios_base::eofbit);
					}
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::badbit);
			}
			if (__err) {
				this->setstate(__err);
			}
		}
		return _M_gcount;
	}
	template <class _CharT, class _Traits>
	basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::putback(
		char_type __c)
	{
		(_M_gcount) = (0);
		this->clear(this->rdstate() & (~ios_base::eofbit));
		sentry __cerb(*this, true);
		if (__cerb) {
			std::ios_base::iostate __err = ios_base::goodbit;
			try {
				const int_type __eof = traits_type::eof();
				__streambuf_type *__sb = this->rdbuf();
				if ((!__sb) ||
				    traits_type::eq_int_type(
					    __sb->sputbackc(__c), __eof)) {
					(__err |= ios_base::badbit);
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::badbit);
			}
			if (__err) {
				this->setstate(__err);
			}
		}
		return *this;
	}
	template <class _CharT, class _Traits>
	typename basic_istream<_CharT, _Traits>::__istream_type &
	basic_istream<_CharT, _Traits>::unget()
	{
		(_M_gcount) = (0);
		this->clear(this->rdstate() & (~ios_base::eofbit));
		sentry __cerb(*this, true);
		if (__cerb) {
			std::ios_base::iostate __err = ios_base::goodbit;
			try {
				const int_type __eof = traits_type::eof();
				__streambuf_type *__sb = this->rdbuf();
				if ((!__sb) ||
				    traits_type::eq_int_type(__sb->sungetc(),
							     __eof)) {
					(__err |= ios_base::badbit);
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::badbit);
			}
			if (__err) {
				this->setstate(__err);
			}
		}
		return *this;
	}
	template <class _CharT, class _Traits>
	int basic_istream<_CharT, _Traits>::sync()
	{
		int __ret = (-1);
		sentry __cerb(*this, true);
		if (__cerb) {
			std::ios_base::iostate __err = ios_base::goodbit;
			try {
				__streambuf_type *__sb = this->rdbuf();
				if (__sb) {
					if (__sb->pubsync() == (-1)) {
						(__err |= ios_base::badbit);
					} else {
						__ret = 0;
					}
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::badbit);
			}
			if (__err) {
				this->setstate(__err);
			}
		}
		return __ret;
	}
	template <class _CharT, class _Traits>
	typename basic_istream<_CharT, _Traits>::pos_type
	basic_istream<_CharT, _Traits>::tellg()
	{
		pos_type __ret = ((pos_type)(-1));
		sentry __cerb(*this, true);
		if (__cerb) {
			try {
				if (!this->fail()) {
					__ret = this->rdbuf()->pubseekoff(
						0, ios_base::cur, ios_base::in);
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::badbit);
			}
		}
		return __ret;
	}
	template <class _CharT, class _Traits>
	basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::seekg(
		pos_type __pos)
	{
		this->clear(this->rdstate() & (~ios_base::eofbit));
		sentry __cerb(*this, true);
		if (__cerb) {
			std::ios_base::iostate __err = ios_base::goodbit;
			try {
				if (!this->fail()) {
					const pos_type __p =
						this->rdbuf()->pubseekpos(
							__pos, ios_base::in);
					if (__p ==
					    ((pos_type)((off_type)(-1)))) {
						(__err |= ios_base::failbit);
					}
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::badbit);
			}
			if (__err) {
				this->setstate(__err);
			}
		}
		return *this;
	}
	template <class _CharT, class _Traits>
	basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::seekg(
		off_type __off, std::ios_base::seekdir __dir)
	{
		this->clear(this->rdstate() & (~ios_base::eofbit));
		sentry __cerb(*this, true);
		if (__cerb) {
			std::ios_base::iostate __err = ios_base::goodbit;
			try {
				if (!this->fail()) {
					const pos_type __p =
						this->rdbuf()->pubseekoff(
							__off, __dir,
							ios_base::in);
					if (__p ==
					    ((pos_type)((off_type)(-1)))) {
						(__err |= ios_base::failbit);
					}
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				this->_M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				this->_M_setstate(ios_base::badbit);
			}
			if (__err) {
				this->setstate(__err);
			}
		}
		return *this;
	}
	template <class _CharT, class _Traits>
	basic_istream<_CharT, _Traits> &operator>>(
		basic_istream<_CharT, _Traits> &__in, _CharT &__c)
	{
		typedef basic_istream<_CharT, _Traits> __istream_type;
		typedef typename basic_istream<_CharT, _Traits>::int_type
			__int_type;
		typename basic_istream<_CharT, _Traits>::sentry __cerb(__in,
								       false);
		if (__cerb) {
			ios_base::iostate __err = ios_base::goodbit;
			try {
				const __int_type __cb = __in.rdbuf()->sbumpc();
				if (!_Traits::eq_int_type(__cb,
							  _Traits::eof())) {
					__c = _Traits::to_char_type(__cb);
				} else {
					(__err |= ((ios_base::eofbit |
						    ios_base::failbit)));
				}
			} catch (__cxxabiv1::__forced_unwind &) {
				__in._M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				__in._M_setstate(ios_base::badbit);
			}
			if (__err) {
				__in.setstate(__err);
			}
		}
		return __in;
	}
	template <class _CharT, class _Traits>
	void __istream_extract(basic_istream<_CharT, _Traits> & __in,
			       _CharT * __s, streamsize __num)
	{
		typedef basic_istream<_CharT, _Traits> __istream_type;
		typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
		typedef typename _Traits::int_type int_type;
		typedef _CharT char_type;
		typedef ctype<_CharT> __ctype_type;
		streamsize __extracted = (0);
		ios_base::iostate __err = ios_base::goodbit;
		typename basic_istream<_CharT, _Traits>::sentry __cerb(__in,
								       false);
		if (__cerb) {
			try {
				streamsize __width = __in.width();
				if (((0) < __width) && (__width < __num)) {
					__num = __width;
				}
				const __ctype_type &__ct =
					use_facet<ctype<_CharT>>(__in.getloc());
				const int_type __eof = _Traits::eof();
				__streambuf_type *__sb = __in.rdbuf();
				int_type __c = __sb->sgetc();
				while ((__extracted < (__num - (1))) &&
				       (!_Traits::eq_int_type(__c, __eof)) &&
				       (!__ct.is(ctype_base::space,
						 _Traits::to_char_type(__c)))) {
					(*(__s++)) = _Traits::to_char_type(__c);
					++__extracted;
					__c = __sb->snextc();
				}
				if ((__extracted < (__num - (1))) &&
				    _Traits::eq_int_type(__c, __eof)) {
					(__err |= ios_base::eofbit);
				}
				(*__s) = char_type();
				__in.width(0);
			} catch (__cxxabiv1::__forced_unwind &) {
				__in._M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				__in._M_setstate(ios_base::badbit);
			}
		}
		if (!__extracted) {
			(__err |= ios_base::failbit);
		}
		if (__err) {
			__in.setstate(__err);
		}
	}
	template <class _CharT, class _Traits>
	basic_istream<_CharT, _Traits> &ws(basic_istream<_CharT, _Traits> &
					   __in)
	{
		typedef basic_istream<_CharT, _Traits> __istream_type;
		typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
		typedef typename basic_istream<_CharT, _Traits>::int_type
			__int_type;
		typedef ctype<_CharT> __ctype_type;
		typename basic_istream<_CharT, _Traits>::sentry __cerb(__in,
								       true);
		if (__cerb) {
			ios_base::iostate __err = ios_base::goodbit;
			try {
				const __ctype_type &__ct =
					use_facet<ctype<_CharT>>(__in.getloc());
				const __int_type __eof = _Traits::eof();
				__streambuf_type *__sb = __in.rdbuf();
				__int_type __c = __sb->sgetc();
				while (true) {
					if (_Traits::eq_int_type(__c, __eof)) {
						__err = ios_base::eofbit;
						break;
					}
					if (!__ct.is(ctype_base::space,
						     _Traits::to_char_type(
							     __c))) {
						break;
					}
					__c = __sb->snextc();
				}
			} catch (const __cxxabiv1::__forced_unwind &) {
				__in._M_setstate(ios_base::badbit);
				throw;
			} catch (...) {
				__in._M_setstate(ios_base::badbit);
			}
			if (__err) {
				__in.setstate(__err);
			}
		}
		return __in;
	}
	extern template class basic_istream<char>;
	extern template basic_istream<char> &ws(basic_istream<char> & __is);
	extern template basic_istream<char> &operator>>(
		basic_istream<char> &__in, char &__c);
	extern template basic_istream<char> &operator>>(
		basic_istream<char> &__in, unsigned char &__c);
	extern template basic_istream<char> &operator>>(
		basic_istream<char> &__in, signed char &__c);
	extern template basic_istream<char>::__istream_type &
	basic_istream<char>::_M_extract(unsigned short &__v);
	extern template basic_istream<char>::__istream_type &
	basic_istream<char>::_M_extract(unsigned &__v);
	extern template basic_istream<char>::__istream_type &
	basic_istream<char>::_M_extract(long &__v);
	extern template basic_istream<char>::__istream_type &
	basic_istream<char>::_M_extract(unsigned long &__v);
	extern template basic_istream<char>::__istream_type &
	basic_istream<char>::_M_extract(bool &__v);
	extern template basic_istream<char>::__istream_type &
	basic_istream<char>::_M_extract(long long &__v);
	extern template basic_istream<char>::__istream_type &
	basic_istream<char>::_M_extract(unsigned long long &__v);
	extern template basic_istream<char>::__istream_type &
	basic_istream<char>::_M_extract(float &__v);
	extern template basic_istream<char>::__istream_type &
	basic_istream<char>::_M_extract(double &__v);
	extern template basic_istream<char>::__istream_type &
	basic_istream<char>::_M_extract(long double &__v);
	extern template basic_istream<char>::__istream_type &
	basic_istream<char>::_M_extract(void *&__v);
	extern template class basic_iostream<char>;
	extern template class basic_istream<wchar_t>;
	extern template basic_istream<wchar_t> &ws(basic_istream<wchar_t> &
						   __is);
	extern template basic_istream<wchar_t> &operator>>(
		basic_istream<wchar_t> &__in, wchar_t &__c);
	extern template void __istream_extract(basic_istream<wchar_t> &,
					       wchar_t *, streamsize);
	extern template basic_istream<wchar_t>::__istream_type &
	basic_istream<wchar_t>::_M_extract(unsigned short &__v);
	extern template basic_istream<wchar_t>::__istream_type &
	basic_istream<wchar_t>::_M_extract(unsigned &__v);
	extern template basic_istream<wchar_t>::__istream_type &
	basic_istream<wchar_t>::_M_extract(long &__v);
	extern template basic_istream<wchar_t>::__istream_type &
	basic_istream<wchar_t>::_M_extract(unsigned long &__v);
	extern template basic_istream<wchar_t>::__istream_type &
	basic_istream<wchar_t>::_M_extract(bool &__v);
	extern template basic_istream<wchar_t>::__istream_type &
	basic_istream<wchar_t>::_M_extract(long long &__v);
	extern template basic_istream<wchar_t>::__istream_type &
	basic_istream<wchar_t>::_M_extract(unsigned long long &__v);
	extern template basic_istream<wchar_t>::__istream_type &
	basic_istream<wchar_t>::_M_extract(float &__v);
	extern template basic_istream<wchar_t>::__istream_type &
	basic_istream<wchar_t>::_M_extract(double &__v);
	extern template basic_istream<wchar_t>::__istream_type &
	basic_istream<wchar_t>::_M_extract(long double &__v);
	extern template basic_istream<wchar_t>::__istream_type &
	basic_istream<wchar_t>::_M_extract(void *&__v);
	extern template class basic_iostream<wchar_t>;
} // namespace )
namespace std __attribute((__visibility__("default")))
{
	extern istream cin;
	extern ostream cout;
	extern ostream cerr;
	extern ostream clog;
	extern wistream wcin;
	extern wostream wcout;
	extern wostream wcerr;
	extern wostream wclog;
	static ios_base::Init __ioinit;
} // namespace )

static int d_N;
static int d_numRows;
void matMulTiled(const float *A, const float *B, float *C);
void spmvCSR(const int *rowPtr, const int *colInd, const float *vals,
	     const float *x, float *y);
int main()
{
	const int h_N = 1024;
	cudaMemcpyToSymbol(d_N, &h_N, sizeof h_N);
	size_t matBytes = ((((size_t)h_N) * h_N) * sizeof(float));
	std::vector<float> h_A(h_N * h_N), h_B(h_N * h_N), h_C(h_N * h_N);
	for (int i = 0; i < (h_N * h_N); ++i) {
		h_A[i] = (1.0F);
		h_B[i] = (2.0F);
	}
	float *d_A, *d_B, *d_C;
	cudaMalloc(&d_A, matBytes);
	cudaMalloc(&d_B, matBytes);
	cudaMalloc(&d_C, matBytes);
	cudaMemcpy(d_A, h_A.data(), matBytes, cudaMemcpyHostToDevice);
	cudaMemcpy(d_B, h_B.data(), matBytes, cudaMemcpyHostToDevice);
	dim3 blockDim(32, 32);
	dim3 gridDim(((h_N + 32) - 1) / 32, ((h_N + 32) - 1) / 32);
	(__cudaPushCallConfiguration(gridDim, blockDim)) ?
		(void)0 :
		matMulTiled(d_A, d_B, d_C);
	cudaDeviceSynchronize();
	cudaMemcpy(h_C.data(), d_C, matBytes, cudaMemcpyDeviceToHost);
	(((((((((std::cout << ("C[0,0] = "))) << (h_C[0]))) << ("  (expected ")))
	   << (((float)h_N) * (2.0F))))
	 << (")\n"));
	cudaFree(d_A);
	cudaFree(d_B);
	cudaFree(d_C);
	return 0;
}

template <typename T> static inline T *__cudaAddressOf(T &val)
{
	return (T *)((void *)(&(const_cast<char &>(
		reinterpret_cast<const volatile char &>(val)))));
}
extern "C" cudaError_t __cudaPopCallConfiguration(dim3 *gridDim, dim3 *blockDim,
						  size_t *sharedMem,
						  void *stream);
static void ____nv_dummy_param_ref(void *param)
{
	volatile static void **__ref __attribute__((unused));
	__ref = (volatile void **)param;
}

extern "C" {
void __cudaRegisterLinkedBinary__NV_MODULE_ID(void (*)(void **), void *, void *,
					      void (*)(void *));
}

extern "C" {

static const unsigned char __module_id_str[]
	__attribute__((section("__nv_module_id"))) = "__NV_MODULE_ID";
}

extern "C" {
extern void **__cudaRegisterFatBinary(void *fatCubin);

extern void __cudaRegisterFatBinaryEnd(void **fatCubinHandle);

extern void __cudaUnregisterFatBinary(void **fatCubinHandle);

extern void __cudaRegisterVar(void **fatCubinHandle, char *hostVar,
			      char *deviceAddress, const char *deviceName,
			      int ext, size_t size, int constant, int global);

extern void __cudaRegisterManagedVar(void **fatCubinHandle,
				     void **hostVarPtrAddress,
				     char *deviceAddress,
				     const char *deviceName, int ext,
				     size_t size, int constant, int global);

extern char __cudaInitModule(void **fatCubinHandle);

extern void __cudaRegisterTexture(void **fatCubinHandle,
				  const struct textureReference *hostVar,
				  const void **deviceAddress,
				  const char *deviceName, int dim, int norm,
				  int ext);

extern void __cudaRegisterSurface(void **fatCubinHandle,
				  const struct surfaceReference *hostVar,
				  const void **deviceAddress,
				  const char *deviceName, int dim, int ext);

extern void __cudaRegisterFunction(void **fatCubinHandle, const char *hostFun,
				   char *deviceFun, const char *deviceName,
				   int thread_limit, uint3 *tid, uint3 *bid,
				   dim3 *bDim, dim3 *gDim, int *wSize);

extern int atexit(void (*)(void)) throw();
}

static void **__cudaFatCubinHandle;

static void __cudaUnregisterBinaryUtil(void)
{
	____nv_dummy_param_ref((void *)&__cudaFatCubinHandle);
	__cudaUnregisterFatBinary(__cudaFatCubinHandle);
}

static char __nv_init_managed_rt_with_module(void **handle)
{
	return __cudaInitModule(handle);
}

inline double rsqrt(double a);

inline double rcbrt(double a);

inline double sinpi(double a);

inline double cospi(double a);

inline void sincospi(double a, double *sptr, double *cptr);

inline double erfinv(double a);

inline double erfcinv(double a);

inline double normcdfinv(double a);

inline double normcdf(double a);

inline double erfcx(double a);

inline float rsqrtf(float a);

inline float rcbrtf(float a);

inline float sinpif(float a);

inline float cospif(float a);

inline void sincospif(float a, float *sptr, float *cptr);

inline float erfinvf(float a);

inline float erfcinvf(float a);

inline float normcdfinvf(float a);

inline float normcdff(float a);

inline float erfcxf(float a);

inline int min(int a, int b);

inline unsigned int umin(unsigned int a, unsigned int b);

inline long long int llmin(long long int a, long long int b);

inline unsigned long long int ullmin(unsigned long long int a,
				     unsigned long long int b);

inline int max(int a, int b);

inline unsigned int umax(unsigned int a, unsigned int b);

inline long long int llmax(long long int a, long long int b);

inline unsigned long long int ullmax(unsigned long long int a,
				     unsigned long long int b);
inline double rsqrt(const double a)
{
	return 1.0 / sqrt(a);
}

inline double rcbrt(const double a)
{
	double s, t;

	if (__isnan(a)) {
		return a + a;
	}
	if (a == 0.0 || __isinf(a)) {
		return 1.0 / a;
	}
	s = fabs(a);
	t = exp2(-3.3333333333333333e-1 * log2(s));
	t = ((t * t) * (-s * t) + 1.0) * (3.3333333333333333e-1 * t) + t;

	if (__signbit(a))

	{
		t = -t;
	}
	return t;
}

inline double sinpi(double a)
{
	int n;

	if (__isnan(a)) {
		return a + a;
	}
	if (a == 0.0 || __isinf(a)) {
		return sin(a);
	}
	if (a == floor(a)) {
		return ((a / 1.0e308) / 1.0e308) / 1.0e308;
	}
	double twoa = a + a;
	double rtwoa = round(twoa);
	long long int l = (long long int)rtwoa;
	n = (int)l;
	a -= rtwoa * 0.5;
	a = a * 3.1415926535897931e+0;
	if (n & 1) {
		a = cos(a);
	} else {
		a = sin(a);
	}
	if (n & 2) {
		a = -a;
	}
	return a;
}

inline double cospi(double a)
{
	int n;

	if (__isnan(a)) {
		return a + a;
	}
	if (__isinf(a)) {
		return cos(a);
	}
	if (fabs(a) > 9.0071992547409920e+015) {
		a = 0.0;
	}
	double twoa = a + a;
	double rtwoa = round(twoa);
	long long int l = (long long int)rtwoa;
	n = (int)l;
	a -= rtwoa * 0.5;
	a = a * 3.1415926535897931e+0;
	n++;
	if (n & 1) {
		a = cos(a);
	} else {
		a = sin(a);
	}
	if (n & 2) {
		a = -a;
	}
	if (a == 0.0) {
		a = fabs(a);
	}
	return a;
}

inline void sincospi(const double a, double *sptr, double *cptr)
{
	*sptr = sinpi(a);
	*cptr = cospi(a);
}

inline double erfinv(const double a)
{
	double p, q, t, fa;
	unsigned long long int l;

	fa = fabs(a);
	if (fa >= 1.0) {
		l = 0xfff8000000000000ULL;
		memcpy(&t, &l, sizeof(double));
		if (fa == 1.0) {
			t = a * exp(1000.0);
		}
	} else if (fa >= 0.9375) {
		t = log1p(-fa);
		t = 1.0 / sqrt(-t);
		p = 2.7834010353747001060e-3;
		p = p * t + 8.6030097526280260580e-1;
		p = p * t + 2.1371214997265515515e+0;
		p = p * t + 3.1598519601132090206e+0;
		p = p * t + 3.5780402569085996758e+0;
		p = p * t + 1.5335297523989890804e+0;
		p = p * t + 3.4839207139657522572e-1;
		p = p * t + 5.3644861147153648366e-2;
		p = p * t + 4.3836709877126095665e-3;
		p = p * t + 1.3858518113496718808e-4;
		p = p * t + 1.1738352509991666680e-6;
		q = t + 2.2859981272422905412e+0;
		q = q * t + 4.3859045256449554654e+0;
		q = q * t + 4.6632960348736635331e+0;
		q = q * t + 3.9846608184671757296e+0;
		q = q * t + 1.6068377709719017609e+0;
		q = q * t + 3.5609087305900265560e-1;
		q = q * t + 5.3963550303200816744e-2;
		q = q * t + 4.3873424022706935023e-3;
		q = q * t + 1.3858762165532246059e-4;
		q = q * t + 1.1738313872397777529e-6;
		t = p / (q * t);
		if (a < 0.0)
			t = -t;
	} else if (fa >= 0.75) {
		t = a * a - .87890625;
		p = .21489185007307062000e+0;
		p = p * t - .64200071507209448655e+1;
		p = p * t + .29631331505876308123e+2;
		p = p * t - .47644367129787181803e+2;
		p = p * t + .34810057749357500873e+2;
		p = p * t - .12954198980646771502e+2;
		p = p * t + .25349389220714893917e+1;
		p = p * t - .24758242362823355486e+0;
		p = p * t + .94897362808681080020e-2;
		q = t - .12831383833953226499e+2;
		q = q * t + .41409991778428888716e+2;
		q = q * t - .53715373448862143349e+2;
		q = q * t + .33880176779595142685e+2;
		q = q * t - .11315360624238054876e+2;
		q = q * t + .20369295047216351160e+1;
		q = q * t - .18611650627372178511e+0;
		q = q * t + .67544512778850945940e-2;
		p = p / q;
		t = a * p;
	} else {
		t = a * a - .5625;
		p = -.23886240104308755900e+2;
		p = p * t + .45560204272689128170e+3;
		p = p * t - .22977467176607144887e+4;
		p = p * t + .46631433533434331287e+4;
		p = p * t - .43799652308386926161e+4;
		p = p * t + .19007153590528134753e+4;
		p = p * t - .30786872642313695280e+3;
		q = t - .83288327901936570000e+2;
		q = q * t + .92741319160935318800e+3;
		q = q * t - .35088976383877264098e+4;
		q = q * t + .59039348134843665626e+4;
		q = q * t - .48481635430048872102e+4;
		q = q * t + .18997769186453057810e+4;
		q = q * t - .28386514725366621129e+3;
		p = p / q;
		t = a * p;
	}
	return t;
}

inline double erfcinv(const double a)
{
	double t;
	unsigned long long int l;

	if (__isnan(a)) {
		return a + a;
	}
	if (a <= 0.0) {
		l = 0xfff8000000000000ULL;
		memcpy(&t, &l, sizeof(double));
		if (a == 0.0) {
			t = (1.0 - a) * exp(1000.0);
		}
	} else if (a >= 0.0625) {
		t = erfinv(1.0 - a);
	} else if (a >= 1e-100) {
		double p, q;
		t = log(a);
		t = 1.0 / sqrt(-t);
		p = 2.7834010353747001060e-3;
		p = p * t + 8.6030097526280260580e-1;
		p = p * t + 2.1371214997265515515e+0;
		p = p * t + 3.1598519601132090206e+0;
		p = p * t + 3.5780402569085996758e+0;
		p = p * t + 1.5335297523989890804e+0;
		p = p * t + 3.4839207139657522572e-1;
		p = p * t + 5.3644861147153648366e-2;
		p = p * t + 4.3836709877126095665e-3;
		p = p * t + 1.3858518113496718808e-4;
		p = p * t + 1.1738352509991666680e-6;
		q = t + 2.2859981272422905412e+0;
		q = q * t + 4.3859045256449554654e+0;
		q = q * t + 4.6632960348736635331e+0;
		q = q * t + 3.9846608184671757296e+0;
		q = q * t + 1.6068377709719017609e+0;
		q = q * t + 3.5609087305900265560e-1;
		q = q * t + 5.3963550303200816744e-2;
		q = q * t + 4.3873424022706935023e-3;
		q = q * t + 1.3858762165532246059e-4;
		q = q * t + 1.1738313872397777529e-6;
		t = p / (q * t);
	} else {
		double p, q;
		t = log(a);
		t = 1.0 / sqrt(-t);
		p = 6.9952990607058154858e-1;
		p = p * t + 1.9507620287580568829e+0;
		p = p * t + 8.2810030904462690216e-1;
		p = p * t + 1.1279046353630280005e-1;
		p = p * t + 6.0537914739162189689e-3;
		p = p * t + 1.3714329569665128933e-4;
		p = p * t + 1.2964481560643197452e-6;
		p = p * t + 4.6156006321345332510e-9;
		p = p * t + 4.5344689563209398450e-12;
		q = t + 1.5771922386662040546e+0;
		q = q * t + 2.1238242087454993542e+0;
		q = q * t + 8.4001814918178042919e-1;
		q = q * t + 1.1311889334355782065e-1;
		q = q * t + 6.0574830550097140404e-3;
		q = q * t + 1.3715891988350205065e-4;
		q = q * t + 1.2964671850944981713e-6;
		q = q * t + 4.6156017600933592558e-9;
		q = q * t + 4.5344687377088206783e-12;
		t = p / (q * t);
	}
	return t;
}

inline double normcdfinv(const double a)
{
	return -1.4142135623730951 * erfcinv(a + a);
}

inline double normcdf(double a)
{
	double ah, al, t1, t2, u1, u2, v1, v2, z;
	if (fabs(a) > 38.5)
		a = copysign(38.5, a);
	ah = a * 134217729.0;
	u1 = (a - ah) + ah;
	u2 = a - u1;
	v1 = -7.0710678398609161e-01;
	v2 = 2.7995440410322203e-09;
	t1 = a * -7.0710678118654757e-1;
	t2 = (((u1 * v1 - t1) + u1 * v2) + u2 * v1) + u2 * v2;
	t2 = (a * -(-4.8336466567264567e-17)) + t2;
	ah = t1 + t2;
	z = erfc(ah);
	if (a < -1.0) {
		al = (t1 - ah) + t2;
		t1 = -2.0 * ah * z;
		z = t1 * al + z;
	}
	return 0.5 * z;
}

inline double erfcx(const double a)
{
	double x, t1, t2, t3;

	if (__isnan(a)) {
		return a + a;
	}
	x = fabs(a);
	if (x < 32.0) {
		t1 = x - 4.0;
		t2 = x + 4.0;
		t2 = t1 / t2;

		t1 = -3.5602694826817400E-010;
		t1 = t1 * t2 - 9.7239122591447274E-009;
		t1 = t1 * t2 - 8.9350224851649119E-009;
		t1 = t1 * t2 + 1.0404430921625484E-007;
		t1 = t1 * t2 + 5.8806698585341259E-008;
		t1 = t1 * t2 - 8.2147414929116908E-007;
		t1 = t1 * t2 + 3.0956409853306241E-007;
		t1 = t1 * t2 + 5.7087871844325649E-006;
		t1 = t1 * t2 - 1.1231787437600085E-005;
		t1 = t1 * t2 - 2.4399558857200190E-005;
		t1 = t1 * t2 + 1.5062557169571788E-004;
		t1 = t1 * t2 - 1.9925637684786154E-004;
		t1 = t1 * t2 - 7.5777429182785833E-004;
		t1 = t1 * t2 + 5.0319698792599572E-003;
		t1 = t1 * t2 - 1.6197733895953217E-002;
		t1 = t1 * t2 + 3.7167515553018733E-002;
		t1 = t1 * t2 - 6.6330365827532434E-002;
		t1 = t1 * t2 + 9.3732834997115544E-002;
		t1 = t1 * t2 - 1.0103906603555676E-001;
		t1 = t1 * t2 + 6.8097054254735140E-002;
		t1 = t1 * t2 + 1.5379652102605428E-002;
		t1 = t1 * t2 - 1.3962111684056291E-001;
		t1 = t1 * t2 + 1.2329951186255526E+000;

		t2 = 2.0 * x + 1.0;
		t1 = t1 / t2;
	} else {
		t2 = 1.0 / x;
		t3 = t2 * t2;
		t1 = -29.53125;
		t1 = t1 * t3 + 6.5625;
		t1 = t1 * t3 - 1.875;
		t1 = t1 * t3 + 0.75;
		t1 = t1 * t3 - 0.5;
		t1 = t1 * t3 + 1.0;
		t2 = t2 * 5.6418958354775628e-001;
		t1 = t1 * t2;
	}
	if (a < 0.0) {
		t2 = (static_cast<int>(x * 16.0)) * 0.0625;
		t3 = (x - t2) * (x + t2);
		t3 = exp(t2 * t2) * exp(t3);
		t3 = t3 + t3;
		t1 = t3 - t1;
	}
	return t1;
}

inline float rsqrtf(const float a)
{
	return static_cast<float>(rsqrt(static_cast<double>(a)));
}

inline float rcbrtf(const float a)
{
	return static_cast<float>(rcbrt(static_cast<double>(a)));
}

inline float sinpif(const float a)
{
	return static_cast<float>(sinpi(static_cast<double>(a)));
}

inline float cospif(const float a)
{
	return static_cast<float>(cospi(static_cast<double>(a)));
}

inline void sincospif(const float a, float *sptr, float *cptr)
{
	double s, c;

	sincospi(static_cast<double>(a), &s, &c);
	*sptr = static_cast<float>(s);
	*cptr = static_cast<float>(c);
}

inline float erfinvf(const float a)
{
	return static_cast<float>(erfinv(static_cast<double>(a)));
}

inline float erfcinvf(const float a)
{
	return static_cast<float>(erfcinv(static_cast<double>(a)));
}

inline float normcdfinvf(const float a)
{
	return static_cast<float>(normcdfinv(static_cast<double>(a)));
}

inline float normcdff(const float a)
{
	return static_cast<float>(normcdf(static_cast<double>(a)));
}

inline float erfcxf(const float a)
{
	return static_cast<float>(erfcx(static_cast<double>(a)));
}

extern "C" {
typedef struct {
	int magic;
	int version;
	const unsigned long long *data;
	void *filename_or_fatbins;

} __fatBinC_Wrapper_t;
}

asm(".section .nv_fatbin, \"a\"\n"
    ".align 8\n"
    "fatbinData:\n"
    ".quad 0x00100001ba55ed50,0x0000000000002e80,0x0000004001010002,0x0000000000002220\n"
    ".quad 0x0000000000000000,0x0000003400010007,0x0000000000000000,0x0000000000000011\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x33010102464c457f,0x0000000000000007\n"
    ".quad 0x0000007e00be0002,0x0000000000000000,0x0000000000002140,0x0000000000001d80\n"
    ".quad 0x0038004000340534,0x0001000f00400004,0x7472747368732e00,0x747274732e006261\n"
    ".quad 0x746d79732e006261,0x746d79732e006261,0x78646e68735f6261,0x666e692e766e2e00\n"
    ".quad 0x2e747865742e006f,0x43766d7073375a5f,0x5f3053694b505253,0x66505f3253664b50\n"
    ".quad 0x666e692e766e2e00,0x6d7073375a5f2e6f,0x53694b5052534376,0x5f3253664b505f30\n"
    ".quad 0x732e766e2e006650,0x5a5f2e6465726168,0x525343766d707337,0x4b505f3053694b50\n"
    ".quad 0x2e0066505f325366,0x74736e6f632e766e,0x766e2e0033746e61,0x6e6174736e6f632e\n"
    ".quad 0x7073375a5f2e3074,0x694b50525343766d,0x3253664b505f3053,0x6c65722e0066505f\n"
    ".quad 0x736e6f632e766e2e,0x5a5f2e30746e6174,0x525343766d707337,0x4b505f3053694b50\n"
    ".quad 0x2e0066505f325366,0x315a5f2e74786574,0x546c754d74616d31,0x53664b5064656c69\n"
    ".quad 0x766e2e0066505f30,0x5a5f2e6f666e692e,0x6c754d74616d3131,0x664b5064656c6954\n"
    ".quad 0x6e2e0066505f3053,0x6465726168732e76,0x74616d31315a5f2e,0x64656c69546c754d\n"
    ".quad 0x66505f3053664b50,0x6e6f632e766e2e00,0x5f2e30746e617473,0x754d74616d31315a\n"
    ".quad 0x4b5064656c69546c,0x2e0066505f305366,0x632e766e2e6c6572,0x30746e6174736e6f\n"
    ".quad 0x74616d31315a5f2e,0x64656c69546c754d,0x66505f3053664b50,0x6c61632e766e2e00\n"
    ".quad 0x2e0068706172676c,0x6f746f72702e766e,0x766e2e0065707974,0x7463612e6c65722e\n"
    ".quad 0x68732e00006e6f69,0x2e00626174727473,0x2e00626174727473,0x2e006261746d7973\n"
    ".quad 0x735f6261746d7973,0x766e2e0078646e68,0x742e006f666e692e,0x73375a5f2e747865\n"
    ".quad 0x4b50525343766d70,0x53664b505f305369,0x766e2e0066505f32,0x5a5f2e6f666e692e\n"
    ".quad 0x525343766d707337,0x4b505f3053694b50,0x2e0066505f325366,0x65726168732e766e\n"
    ".quad 0x6d7073375a5f2e64,0x53694b5052534376,0x5f3253664b505f30,0x632e766e2e006650\n"
    ".quad 0x33746e6174736e6f,0x6e5f64004e5f6400,0x2e0073776f526d75,0x632e766e2e6c6572\n"
    ".quad 0x30746e6174736e6f,0x766d7073375a5f2e,0x3053694b50525343,0x505f3253664b505f\n"
    ".quad 0x6f632e766e2e0066,0x2e30746e6174736e,0x43766d7073375a5f,0x5f3053694b505253\n"
    ".quad 0x66505f3253664b50,0x5f2e747865742e00,0x754d74616d31315a,0x4b5064656c69546c\n"
    ".quad 0x2e0066505f305366,0x2e6f666e692e766e,0x4d74616d31315a5f,0x5064656c69546c75\n"
    ".quad 0x0066505f3053664b,0x726168732e766e2e,0x6d31315a5f2e6465,0x6c69546c754d7461\n"
    ".quad 0x5f3053664b506465,0x2e6c65722e006650,0x74736e6f632e766e,0x315a5f2e30746e61\n"
    ".quad 0x546c754d74616d31,0x53664b5064656c69,0x766e2e0066505f30,0x6e6174736e6f632e\n"
    ".quad 0x6d31315a5f2e3074,0x6c69546c754d7461,0x5f3053664b506465,0x632e766e2e006650\n"
    ".quad 0x68706172676c6c61,0x6f72702e766e2e00,0x2e00657079746f74,0x612e6c65722e766e\n"
    ".quad 0x5a5f006e6f697463,0x525343766d707337,0x4b505f3053694b50,0x5f0066505f325366\n"
    ".quad 0x754d74616d31315a,0x4b5064656c69546c,0x000066505f305366,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x000c000300000032,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0009000300000097,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x00090001000000a5,0x0000000000000000,0x0000000000000004,0x00090001000000a9\n"
    ".quad 0x0000000000000004,0x0000000000000004,0x000a0003000000de,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x000d000300000105,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x000e000300000144,0x0000000000000000,0x0000000000000000,0x000b000300000191\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x00070003000001b7,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x00080003000001d3,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x000c1012000001e2,0x0000000000000000,0x0000000000000d80,0x000d1012000001fb\n"
    ".quad 0x0000000000000000,0x00000000000005c0,0x0000000c00082f04,0x000811040000001e\n"
    ".quad 0x000000000000000c,0x0000000b00082f04,0x0008110400000020,0x000000000000000b\n"
    ".quad 0x0000000b00081204,0x0008120400000000,0x000000000000000c,0x0000007e00043704\n"
    ".quad 0x00002a0100003001,0x0000000500080a04,0x0028190300280140,0x00000000000c1704\n"
    ".quad 0x0021f00000200004,0x00000000000c1704,0x0021f00000180003,0x00000000000c1704\n"
    ".quad 0x0021f00000100002,0x00000000000c1704,0x0021f00000080001,0x00000000000c1704\n"
    ".quad 0x0021f00000000000,0x00041d0400ff1b03,0x00081c0400000010,0x00000d5000000058\n"
    ".quad 0x000000c800a03404,0x0000000100000000,0x0000012800000d20,0x0000000100000000\n"
    ".quad 0x0000024800000250,0x0000000100000000,0x0000025000000250,0x0000000100000000\n"
    ".quad 0x000002d000000d20,0x0000000100000000,0x00000898000008a0,0x0000000100000000\n"
    ".quad 0x000008c8000008a0,0x0000000100000000,0x00000bb000000bb8,0x0000000100000000\n"
    ".quad 0x00000bc800000bb8,0x0000000100000000,0x00000d1800000d20,0x0000000100000000\n"
    ".quad 0x00041e0400000d20,0x0004370400000220,0x000030010000007e,0x00080a0400002a01\n"
    ".quad 0x0018014000000008,0x000c170400181903,0x0010000200000000,0x000c17040021f000\n"
    ".quad 0x0008000100000000,0x000c17040021f000,0x0000000000000000,0x00ff1b030021f000\n"
    ".quad 0x0000001800081d04,0x00081c0400000048,0x000005b000000548,0xffffffff00000000\n"
    ".quad 0xfffffffe00000000,0xfffffffd00000000,0xfffffffc00000000,0x0000000000000073\n"
    ".quad 0x3605002511000000,0x0000000000000000,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x001cfc00e22007f6,0x4c98078000870001\n"
    ".quad 0xf0c8000002570000,0xf0c8000002170002,0x001fd842fec20ff1,0x4f107f8000270003\n"
    ".quad 0x4e00010000270002,0x5b30011800370000,0x001ff400fd4007ed,0x4b6d038c00170007\n"
    ".quad 0x50b0000000070f00,0xe30000000000000f,0x081fd800fe2207f0,0x3829000001e70002\n"
    ".quad 0xe2900000ca800000,0x4c18810005070004,0x001ec400fe2007f2,0x4c10080005170205\n"
    ".quad 0xeed4200000070415,0xeed4200000470412,0x041fb400fe4007e1,0x3829000001f70013\n"
    ".quad 0x5c9807800ff70002,0x5b69038001571207,0x001fc400fe0007fd,0xf0f800000008000f\n"
    ".quad 0x5c4707000157ff03,0xe290000017000000,0x001fc400fe2007f5,0x5c12000001271502\n"
    ".quad 0x5c10000000371204,0x0400000000370203,0x001fb400fc2007f4,0x5c9807800ff70002\n"
    ".quad 0x366c038000370407,0x5b6b03800ff7030f,0x001fc440fe2007fd,0xf0f800000009000f\n"
    ".quad 0x3848000000271509,0x5c9807800ff70002,0x001fc440fec007f4,0x3829000001e7150a\n"
    ".quad 0x4c1080000527090b,0x4c10080005370a0c,0x001fc400fec007e6,0x4c10800005470909\n"
    ".quad 0x4c10080005570a0a,0x5c98078000b70004,0x003fc40017a007f2,0x5c98078000c70005\n"
    ".quad 0xeed4200000070406,0x5c98078000970004,0x041f8400fe2007f2,0x5c98078000a70005\n"
    ".quad 0xeed4200000070408,0x3829000001e70607,0x001ec400fe4007f6,0x4c18810005670606\n"
    ".quad 0x4c10080005770707,0xeed4200000070607,0x001f8400fea007f1,0x1c0ffffffff70303\n"
    ".quad 0x1c10000000470b0b,0x5b6b03800ff7030f,0x001fd400fe2007f1,0x5c10080000c7ff0c\n"
    ".quad 0x1c10000000470909,0x1c00000000171515,0x001ff420fe0007f7,0x5c10080000a7ff0a\n"
    ".quad 0x5980010000870702,0xe2400ffff381000f,0x081fc000ffa007fd,0xf0f800000007000f\n"
    ".quad 0xf0f800000008000f,0x3829000001e71503,0x001fc400fe2007f1,0xe290000063000000\n"
    ".quad 0x5c11000001571205,0x3818810000871504,0x001f8400fe2007f4,0x50900380e0077007\n"
    ".quad 0x3669038000c7050f,0x5c1008000037ff03,0x001fd840fe2207f6,0x4c10800005470406\n"
    ".quad 0x4c10080005570307,0x4c10800005270404,0x001fc400fec007f0,0x4c10080005370305\n"
    ".quad 0xf0f800000009000f,0x50900380e007f007,0x001ed800fe0007ec,0x1c0fffffff471214\n"
    ".quad 0x1c00000001071515,0xeed42fffff870410,0x001ec400f62007f0,0x5b6d03800147150f\n"
    ".quad 0xeed42fffffc7040e,0xeed4200000070416,0x001ec400f62007b1,0xeed420000047041c\n"
    ".quad 0xeed4200000870408,0xeed4200000c7040c,0x001fc400fe2007b1,0xeed420000107041e\n"
    ".quad 0xeed42fffffc7060a,0xeed4200000070618,0x001f8400fe6007f5,0xeed4200001470419\n"
    ".quad 0xf0f0000034570000,0x3829000001e71003,0x001fc040fea007f1,0x4c18810005671010\n"
    ".quad 0x3829000001e70e09,0x4c10080005770311,0x0002d800fe0007f2,0xeed42fffff870603\n"
    ".quad 0x4c18810005670e0e,0xeed4200000071010,0x001fcc00f6a007f2,0x4c1008000577090f\n"
    ".quad 0xeed4200000070e0b,0xf0f0000034670000,0x001fc000fe2207f0,0x3829000001e71609\n"
    ".quad 0xeed420000047060e,0x4c18810005671616,0x001fcc00fce007f6,0xeed420000187040f\n"
    ".quad 0x4c10080005770917,0xf0f0000034470000,0x001fd800362207f0,0x3829000001e71c09\n"
    ".quad 0xeed420000007161b,0x4c18810005671c1c,0x000ac440fe0007f2,0x4c1008000577091d\n"
    ".quad 0x3829000001e70809,0xeed4200000071c0d,0x003f8400fe6007ed,0x4c18810005670808\n"
    ".quad 0xf0f0000034570000,0x3829000001e70c11,0x001ed802fe0007f1,0x4c10080005770909\n"
    ".quad 0x4c18810005670c16,0xeed4200001c7040c,0x001fc800fe6007f7,0x4c10080005771117\n"
    ".quad 0xf0f0000034570000,0xeed4200000070808,0x001fc000f62207f0,0x3829000001e71e1a\n"
    ".quad 0xeed4200000870609,0x4c18810005671e1e,0x0003c400fe0007b6,0xeed4200002070411\n"
    ".quad 0x4c10080005771a1f,0xeed420000007161d,0x001ec400fe2007b1,0xeed420000307041a\n"
    ".quad 0xeed4200000071e1e,0xeed4200003470416,0x001fc000fe6007f3,0xeed420000207061f\n"
    ".quad 0xf0f0000034770000,0x5980010000371010,0x001ec404fe0007b6,0xeed4200000c70603\n"
    ".quad 0x5980080000a70b1c,0xeed4200002470402,0x001ec400f62007b1,0xeed420000287040a\n"
    ".quad 0xeed420000107060b,0xeed4200002c70410,0x081fc401fc2007f3,0xf0f0000034a70000\n"
    ".quad 0x59800e0001871b17,0x3829000001e7191b,0x001fc800fe4007f4,0x4c18810005671918\n"
    ".quad 0x59800b8000e70d17,0x4c10080005771b19,0x001f9800fe2207f0,0x3829000001e70f0d\n"
    ".quad 0xeed4200000071818,0x4c18810005670f0e,0x081fc000fe6007f7,0x4c10080005770d0f\n"
    ".quad 0xf0f0000034770000,0x3829000001e70c0d,0x001fc000fe2000f1,0xeed4200000070e1b\n"
    ".quad 0x4c18810005670c0c,0x59800b800097081c,0x001fc800fc8007b1,0xeed4200001470617\n"
    ".quad 0x3829000001e71109,0x4c10080005770d0d,0x001fdc00fec007f0,0x4c18810005671108\n"
    ".quad 0xeed4200000070c0c,0x4c10080005770909,0x003fc0003e2007f3,0xf0f0000034770000\n"
    ".quad 0xeed4200000070819,0x3829000001e71a0f,0x001fcc02fc2007fd,0xf0f0000034670000\n"
    ".quad 0x3829000001e71609,0xf0f0000034470000,0x081fc400f62007f0,0x59800e0000371d1d\n"
    ".quad 0xeed420000187061c,0x3829000001e70203,0x001fc400fe6007ed,0x4c18810005670202\n"
    ".quad 0xf0f0000034270000,0x3829000001e70a11,0x001f8800f62007f0,0x59800e8000b71e1d\n"
    ".quad 0xeed4200001c7061e,0x4c10080005770303,0x081fc000fe4007f0,0x4c18810005670a0a\n"
    ".quad 0xeed4200000070202,0x3829000001e7100d,0x001fc000fe4007f4,0xeed4200003070603\n"
    ".quad 0x4c1008000577110b,0x4c18810005671010,0x001ec400fe0007f6,0xeed4200000070a0a\n"
    ".quad 0x4c10080005770d11,0xeed420000247060d,0x001fc000f6c007f0,0x4c18810005671a0e\n"
    ".quad 0xeed420000287061a,0x4c10080005770f0f,0x001ed800fe0007f1,0xeed4200000071010\n"
    ".quad 0x4c18810005671608,0xeed4200002c70616,0x001fcc00f6e007f0,0x4c10080005770909\n"
    ".quad 0xeed4200000070e0e,0xf0f0000034670000,0x001fc0001e2007f0,0x59800e800177181d\n"
    ".quad 0xeed420000347060b,0x1c10000004070404,0x003fd800fc2007b6,0xeed4200000070808\n"
    ".quad 0x5c1008000057ff05,0x1c10000004070606,0x001fc000fe6007f7,0x5c1008000077ff07\n"
    ".quad 0xf0f0000034670000,0x59800e8001c71b1b,0x001fc000ffa007f6,0xf0f0000034570000\n"
    ".quad 0x59800d8001e70c0c,0x5980060001f7190c,0x001fc000fcc007f6,0xf0f0000034370000\n"
    ".quad 0x5980060000d7020c,0x5980060001a70a0d,0x001fd800fec007f6,0xf0f0000034170000\n"
    ".quad 0x598006800167100d,0x5980068000370e0d,0x001ff400ffa107f0,0x5980068000b70802\n"
    ".quad 0xe2400fffa589000f,0xf0f800000007000f,0x001fb400fec007f0,0x5c11000001571203\n"
    ".quad 0xe290000030000000,0x366903800047030f,0x001ec400fe0007fd,0xf0f800000009000f\n"
    ".quad 0x50900380e007f007,0xeed42fffff87040a,0x001fc400f62007f0,0x1c00000000871515\n"
    ".quad 0xeed42fffffc7041a,0xeed4200000070410,0x001ec400f62007b1,0xeed420000047040c\n"
    ".quad 0xeed4200000870408,0xeed4200000c7040f,0x001fc400f62007b1,0xeed420000107040e\n"
    ".quad 0xeed4200001470416,0xeed42fffffc70618,0x001fcc00fe6007f1,0xeed420000007061c\n"
    ".quad 0xeed420000047061d,0xf0f0000034470000,0x081fc400fe2007e1,0x3829000001e70a03\n"
    ".quad 0x4c18810005670a0a,0x3829000001e71a09,0x001fc000fe4007f4,0x3829000001e70c0d\n"
    ".quad 0x4c1008000577030b,0x4c18810005671a1a,0x001fc400fca000f1,0xeed4200000070a14\n"
    ".quad 0x3829000001e71003,0x4c1008000577091b,0x001fc800fe6007ed,0x4c18810005671010\n"
    ".quad 0xf0f0000034370000,0xeed4200000071a17,0x001fc000fe2007f0,0x3829000001e70809\n"
    ".quad 0xeed420000087061a,0x4c10080005770311,0x0006d800fe0007b2,0xeed42fffff870603\n"
    ".quad 0x4c18810005670c0c,0xeed4200000071019,0x001eb400fe0007e2,0x4c10080005770d0d\n"
    ".quad 0x4c18810005670808,0xeed4200000070c0c,0x001fc440fe0007f3,0xf0f0000034470000\n"
    ".quad 0x3829000001e70f1e,0xeed4200000c7060d,0x001ec801fe0007f2,0x4c10080005770909\n"
    ".quad 0x4c18810005670f0a,0xeed4200000070808,0x001f8800fe8007f0,0x3829000001e70e0f\n"
    ".quad 0xeed4200001470609,0x4c10080005771e0b,0x001fcc00f5a007f0,0x4c18810005670e0e\n"
    ".quad 0xeed4200000070a0a,0xf0f0000034570000,0x001fc000fe2217f1,0x3829000001e71611\n"
    ".quad 0x4c10080005770f0f,0x4c18810005671610,0x001ec800fe0000f6,0xeed4200001070616\n"
    ".quad 0x4c10080005771111,0xeed4200000070e0f,0x001f8400f6c007f0,0x1c10000002070404\n"
    ".quad 0xeed4200000071010,0x5c1008000057ff05,0x001fcc00fee00ff6,0x1c10000002070606\n"
    ".quad 0x5c1008000077ff07,0xf0f0000034670000,0x001fd800fe0007f6,0x5980010000371402\n"
    ".quad 0x5980010001871702,0xf0f0000034470000,0x001fd800fe0007fd,0x5980010001c71902\n"
    ".quad 0x5980010001d70c1d,0xf0f0000034270000,0x041fd800fec007f6,0x59800e8001a70808\n"
    ".quad 0x5980040000d70a08,0x5980040001670f0f,0x001fb400ffa007f0,0x5980078000971002\n"
    ".quad 0xf0f800000007000f,0x5b63200001271507,0x001ec400f62007fd,0xf0f800000008000f\n"
    ".quad 0xeed42fffff870408,0xeed42fffffc7040a,0x001fc400f62007b1,0xeed420000007040c\n"
    ".quad 0xeed420000047040e,0xeed42fffffc70610,0x001f8400fe6007f1,0xeed4200000470611\n"
    ".quad 0xf0f0000034170000,0x3829000001e70809,0x081fd040fe2007f1,0x4c18810005670808\n"
    ".quad 0x3829000001e70a03,0x3829000001e70c0d,0x001fd800fe0007f2,0x4c10080005770909\n"
    ".quad 0x4c18810005670a0a,0xeed4200000070808,0x001fc000f64007f0,0x4c1008000577030b\n"
    ".quad 0xeed42fffff870603,0x4c18810005670c0c,0x001f8400fe6007ad,0xeed4200000070a0a\n"
    ".quad 0xf0f0000034270000,0x3829000001e70e05,0x001fd800fe0007f1,0x4c10080005770d0d\n"
    ".quad 0x4c18810005670e04,0xeed420000007060e,0x001ed400f64007f0,0x4c10080005770505\n"
    ".quad 0xeed4200000070c0c,0xeed4200000070404,0x001fd800fcc007f3,0xf0f0000034270000\n"
    ".quad 0x5980010000370803,0x5980018001070a03,0x001ff400fe0107f6,0x5980018000e70c03\n"
    ".quad 0x5980018001170402,0xf0f800000007000f,0x001fd400fe4207f6,0x4bd7810005870004\n"
    ".quad 0x1a17098005970005,0xeedc200000070402,0x001ffc00ffe007e3,0x50b0000000070f00\n"
    ".quad 0xe30000000007000f,0xe2400fffff87000f,0x001f8000fc0007e0,0x50b0000000070f00\n"
    ".quad 0x50b0000000070f00,0x50b0000000070f00,0x001c4400fe0007f6,0x4c98078000870001\n"
    ".quad 0x4c98078c00070000,0xf0c8000002570005,0x001fc000e2a007f0,0x5c9807800ff7000b\n"
    ".quad 0xf0c8000002170006,0x366d03800207000f,0x003fd800e6200731,0xf0c8000002670013\n"
    ".quad 0xf0c8000002270011,0x5c18028000670512,0x001fc002fd8007e1,0x4b6d038c00071207\n"
    ".quad 0x5c18028001171313,0x4b6d200c00071307,0x001fc540fe2007ed,0xe24000004889000f\n"
    ".quad 0x4e00030c00071102,0x4f107f8c00071103,0x001fc400fe2207f1,0x4e00030c00071304\n"
    ".quad 0x4f107f8c00071309,0x3848000000270610,0x001fc440fe2007e2,0x5c9807800ff7000b\n"
    ".quad 0x5b30011800371102,0x3829000001f70003,0x001fc400fe6007f1,0x5b30021800971304\n"
    ".quad 0x3848000000771111,0x5c18028000270502,0x081fc400fe2007e1,0x5c9807800ff70005\n"
    ".quad 0x182f7f8c00070303,0x3829000001e70408,0x001fc800fe6007f1,0x4c18810005070404\n"
    ".quad 0x5c18010001170607,0x3829000000570306,0x001fc440fe2007e6,0x4c10080005170803\n"
    ".quad 0x3829000001e70209,0x5c98078000470016,0x001ecc00fe4007f1,0x4c18810005270208\n"
    ".quad 0x5c98078000370017,0xeed4200000071614,0x001fd800f62007e2,0x4c10080005370909\n"
    ".quad 0xeed4200000070818,0x1c00000000170505,0x001fd400fe2007f1,0x5b6d03800067050f\n"
    ".quad 0x1c10000008070404,0x5c18028000270002,0x001fc420fe2007e7,0x5c1008000037ff03\n"
    ".quad 0xef5c000000070714,0xef5c000100070718,0x001fc400fea007ff,0xf0a81b8000070000\n"
    ".quad 0xef98000000070000,0xef4c10010007100a,0x001d4400e6200711,0xef4e10000007110c\n"
    ".quad 0xef4c10010807101a,0xef4c100110071019,0x001fc400fe200771,0xef4c10011807101d\n"
    ".quad 0xef4c100120071015,0xef4c100128071014,0x005fc000e2c00ff0,0x5980058000c70a0c\n"
    ".quad 0xef4e100001071108,0x5980060000d71a0c,0x001d5804fe00073d,0xef4c100130071018\n"
    ".quad 0x5980060000e7190c,0xef4c100138071016,0x003fc000fec047f0,0x5980060000f71d0f\n"
    ".quad 0xef4c100140071017,0x598007800087151a,0x001dd800fe000716,0xef4e10000207110c\n"
    ".quad 0x59800d0000971409,0xef4c100148071014,0x009fc000e6c017f0,0x5980048000a71809\n"
    ".quad 0xef4c100150071018,0x5980048000b71609,0x001fd801fe00075d,0xef4c100158071015\n"
    ".quad 0x5980048000c71717,0xef4c100160071016,0x005fc000e2c047f0,0x59800b8000d7140d\n"
    ".quad 0xef4e100003071108,0x5980068000e7180e,0x001d7404fe000736,0xef4c100168071014\n"
    ".quad 0x5980070000f7150f,0xef4c100170071017,0x005fc000e2c00ff0,0x5980078000871616\n"
    ".quad 0xef4c100178071018,0x59800b0000971409,0x001cf404fe0007f6,0xef4c100180071015\n"
    ".quad 0x5980048000a71709,0xef4e10000407110c,0x005fc000e3a00ff0,0x5980048000b7180b\n"
    ".quad 0xef4c100188071014,0x5980058000c7151a,0x001c7401fe00073d,0xef4c10019007101b\n"
    ".quad 0x59800d0000d7140d,0xef4c100198071016,0x003fc000ffa017f0,0x5980068000e71b0d\n"
    ".quad 0xef4c1001a0071017,0x5980068000f7160d,0x001d4400e6200711,0xef4e100005071108\n"
    ".quad 0xef4c1001a8071014,0xef4c1001b0071018,0x003fc000ffa00771,0xef4c1001b8071015\n"
    ".quad 0xef4c1001c0071016,0x5980068000871717,0x001cd802fe000716,0xef4e10000607110c\n"
    ".quad 0x59800b8000971409,0xef4c1001c8071014,0x011fc000eac027f0,0x5980048000a7180a\n"
    ".quad 0xef4c1001d0071017,0x5980050000b7150b,0x001fd801fe000776,0xef4c1001d8071018\n"
    ".quad 0x5980058000c71616,0xef4c1001e0071015,0x009fc000e2c017f0,0x59800b0000d7140d\n"
    ".quad 0xef4e100007071108,0x5980068000e7170d,0x001d7408fe000736,0xef4c1001e8071016\n"
    ".quad 0x5980068000f7180f,0xef4c1001f0071017,0x005f9800e2c00ff0,0x5980078000871508\n"
    ".quad 0xef4c1001f807100d,0x5980040000971608,0x001ffc01fe2027fd,0x5980040000a71708\n"
    ".quad 0x5980040000b70d0b,0xf0a81b8000070000,0x001fbc00ffa007f5,0xef98000000070000\n"
    ".quad 0xe2400fffc389000f,0x50b0000000070f00,0x001f8800fde007ef,0x50b0000000070f00\n"
    ".quad 0x50b0000000070f00,0x50b0000000070f00,0x081fd840fe2007fd,0xe30000000000000f\n"
    ".quad 0x4e00090c00071302,0x4f107f8c00071300,0x001fd840fe2007f6,0x5b30011800071302\n"
    ".quad 0x3829000001e70200,0x4c18810005470202,0x001fbc00fea007e2,0x4c10080005570003\n"
    ".quad 0xeedc20000007020b,0x50b0000000070f00,0x001ffc00ffe007e7,0x50b0000000070f00\n"
    ".quad 0xe30000000007000f,0xe2400fffff87000f,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x0000000300000001,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000040,0x00000000000001d4,0x0000000000000000\n"
    ".quad 0x0000000000000001,0x0000000000000000,0x000000030000000b,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000214,0x0000000000000213,0x0000000000000000\n"
    ".quad 0x0000000000000001,0x0000000000000000,0x0000000200000013,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000428,0x0000000000000138,0x0000000b00000002\n"
    ".quad 0x0000000000000008,0x0000000000000018,0x7000000000000029,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000560,0x0000000000000048,0x0000000000000003\n"
    ".quad 0x0000000000000004,0x0000000000000000,0x7000000000000051,0x0000000000000040\n"
    ".quad 0x0000000000000000,0x00000000000005a8,0x0000000000000134,0x0000000c00000003\n"
    ".quad 0x0000000000000004,0x0000000000000000,0x7000000000000115,0x0000000000000040\n"
    ".quad 0x0000000000000000,0x00000000000006dc,0x000000000000006c,0x0000000d00000003\n"
    ".quad 0x0000000000000004,0x0000000000000000,0x70000001000001a9,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000748,0x0000000000000020,0x0000000000000003\n"
    ".quad 0x0000000000000004,0x0000000000000008,0x7000000b000001c5,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000000768,0x0000000000000010,0x0000000000000000\n"
    ".quad 0x0000000000000008,0x0000000000000008,0x0000000100000097,0x0000000000000002\n"
    ".quad 0x0000000000000000,0x0000000000000778,0x0000000000000008,0x0000000000000000\n"
    ".quad 0x0000000000000004,0x0000000000000000,0x00000001000000a5,0x0000000000000042\n"
    ".quad 0x0000000000000000,0x0000000000000780,0x0000000000000168,0x0000000c00000000\n"
    ".quad 0x0000000000000004,0x0000000000000000,0x0000000100000159,0x0000000000000042\n"
    ".quad 0x0000000000000000,0x00000000000008e8,0x0000000000000158,0x0000000d00000000\n"
    ".quad 0x0000000000000004,0x0000000000000000,0x0000000100000032,0x0000000000000006\n"
    ".quad 0x0000000000000000,0x0000000000000a40,0x0000000000000d80,0x2000000b00000003\n"
    ".quad 0x0000000000000020,0x0000000000000000,0x00000001000000f7,0x0000000000100006\n"
    ".quad 0x0000000000000000,0x00000000000017c0,0x00000000000005c0,0x1e00000c00000003\n"
    ".quad 0x0000000000000020,0x0000000000000000,0x0000000800000136,0x0000000000000043\n"
    ".quad 0x0000000000000000,0x0000000000001d80,0x0000000000002000,0x0000000d00000000\n"
    ".quad 0x0000000000000004,0x0000000000000000,0x0000000500000006,0x0000000000002140\n"
    ".quad 0x0000000000000000,0x0000000000000000,0x00000000000000e0,0x00000000000000e0\n"
    ".quad 0x0000000000000008,0x0000000500000001,0x0000000000000778,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000001608,0x0000000000001608,0x0000000000000008\n"
    ".quad 0x0000000600000001,0x0000000000001d80,0x0000000000000000,0x0000000000000000\n"
    ".quad 0x0000000000000000,0x0000000000002000,0x0000000000000008,0x0000000500000001\n"
    ".quad 0x0000000000002140,0x0000000000000000,0x0000000000000000,0x00000000000000e0\n"
    ".quad 0x00000000000000e0,0x0000000000000008,0x0000005001010001,0x0000000000000bd0\n"
    ".quad 0x0000004000000bcd,0x0000003400080005,0x0000000000000000,0x0000000000002011\n"
    ".quad 0x0000000000000000,0x0000000000002082,0x0000000000000048,0x0000000000000000\n"
    ".quad 0x1ef000032f2f0a3c,0x6f69737265762e0a,0x742e0a352e38206e,0x6d73207465677261\n"
    ".quad 0x6464612e0a32355f,0x7a69735f73736572,0xff00310a34362065,0x2074736e6f632e0a\n"
    ".quad 0x34206e67696c612e,0x5f64203233752e20,0x756e8605001a3b4e,0x00713b73776f526d\n"
    ".quad 0x656c6269736923ff,0x207972746e652e20,0x4d74616d31315a5f,0x5064656c69546c75\n"
    ".quad 0x2866505f3053664b,0x206d617261702e0a,0x110500253436752e,0x2d2c305f3f00235f\n"
    ".quad 0xf319002d311f1800,0x2e0a7b0a290a3208,0x6572702e20676572,0x3b3e363c70252064\n"
    ".quad 0x2520323366a50012,0x1000133530313c66,0x12333c7237001362,0x647225203436a100\n"
    ".quad 0x2e4001043e36313c,0x012806004a616873,0x00875a5f2038625f,0x345b41733245af03\n"
    ".quad 0x1422003c5d363930,0xf5646c0a32003c42,0x354f008f752e2200,0x303d0b00fb5b202c\n"
    ".quad 0x0036361f00363b5d,0x371f000036311f0e,0x0a3b5d32710e0036,0x2504f30232766f6d\n"
    ".quad 0x746325202c383172,0x730a3b792e646961,0x2c39313301566c68,0x2c42002f3519001e\n"
    ".quad 0x646151002c742520,0x2c32260015732e64,0x303225002d080031,0x3323005c7818005c\n"
    ".quad 0x3413005b09001d2c,0x3524005b7818005b,0x0100ec341100302c,0x01210000310302f7\n"
    ".quad 0x730a3b5d4e5f64d2,0x0034746c2e707465,0x3322001d2c317032,0x3183023a02005f32\n"
    ".quad 0x01306630202c3430,0x7025400a3b07f700,0x4c24206172622031,0x3b335f3042425f5f\n"
    ".quad 0x3800d6321200a50a,0x33323f00a537202c,0x2300bc080a02402c,0x08004d0000312c39\n"
    ".quad 0x00f02c3432320100,0x342c3725002f3218,0x73351f0073341900,0x3233004442180a00\n"
    ".quad 0x0600740200322c36,0x18001f2c3826005e,0x0033303127001934,0x6c2e646153007900\n"
    ".quad 0x0105373223001d6f,0x003a722529015101,0x331800232c333335,0x1c003132312300e0\n"
    ".quad 0x13004a3815004f35,0x61747663e4004f32,0x626f6c672e6f742e,0x1000280102c66c61\n"
    ".quad 0x772e6c7573003f64,0x3964330041656469,0x3002008a0400472c,0x1000372c35313600\n"
    ".quad 0x1300737214008c39,0x0017313322007339,0x1d2c303333015502,0xec0600d437322900\n"
    ".quad 0x3133004830332800,0x00b5351f001f2c33,0x7536642f00d30105,0x1a331001d7060a02\n"
    ".quad 0x20027e0a0a3b3400,0x0200520302e03a32,0x00dd0102e100003e,0x010490741302e300\n"
    ".quad 0x5d3772255b60001c,0xd10201230e00232c,0x2601240b019d0001,0x3b30313d00a62c31\n"
    ".quad 0x311f006f3713006f,0xc2006f381101006f,0x732e7261620a3b37,0x2607004220636e79\n"
    ".quad 0x3e00423866253100,0x1b3911001b5d3031,0x6d660a3b5d39a500,0x2c1201216e722e61\n"
    ".quad 0x013101003d01001d,0x0058313123003c0e,0x00005c3832312b4f,0x342b2d005d323122\n"
    ".quad 0x0200202c3323005f,0x00400f0061000046,0x35323f0060341400,0x0060351301006036\n"
    ".quad 0x202c36230060381d,0x0f00720000460200,0x3f00603714000040,0x3813010060343833\n"
    ".quad 0x23006132312d0060,0x0000470200212c39,0x30322400410e0073,0x200d004335110061\n"
    ".quad 0x61361c0061311400,0x0200210104e70100,0x00410f0073000047,0x34362f0061331400\n"
    ".quad 0x00613432230101de,0x2c3523006130322d,0x0073000047020021,0x006136140000410f\n"
    ".quad 0x32240101e336372f,0x550101e40d006137,0x0000470200210104,0x39140000410f0073\n"
    ".quad 0x00613639383f0061,0xe50d006130332400,0x0200210104140101,0x00410f0073000047\n"
    ".quad 0x30314f0061321400,0x6233130100623432,0x040c0001e6331d00,0x7400004802002102\n"
    ".quad 0x6235150000410f00,0x240101e735312f00,0x3301e70d00623633,0x00480200212c3733\n"
    ".quad 0x170000410f007400,0x240101e80f036938,0x3301e80d036a3933,0x00480200212c3034\n"
    ".quad 0x341600410e007400,0x0101e930342f03cb,0x3301e90d03cc3415,0x00480200212c3334\n"
    ".quad 0x050000410f007400,0x62363335314f03cd,0xea341d03ce040100,0x0200212c36343301\n"
    ".quad 0x00410f0074000048,0x3636313f03cf0500,0x2d03d034140101ea,0x212c392300623235\n"
    ".quad 0x0e00740000480200,0x313f03d035150041,0xd135140101ea3937,0x3533006236352c03\n"
    ".quad 0x0000480200212c32,0xd1050000410f0074,0x0062303239314f03,0x01ea361d03d20401\n"
    ".quad 0x480200212c353533,0x0000410f00740000,0x383430324f03d205,0x362d03d304010062\n"
    ".quad 0x00212c3823006234,0x410f007400004802,0x31323f03d3050000,0x03d436140101ea37\n"
    ".quad 0x313633006238362c,0x740000480200212c,0x03d4050000410f00,0x140101ea3033323f\n"
    ".quad 0x3301ea371d03d436,0x00480200212c3436,0x050000410f007400,0x62323334324f03d4\n"
    ".quad 0x36372d03d4040100,0x0200212c37230062,0x00410f0074000048,0x01ea0f06dd381700\n"
    ".quad 0x30382c03d4361401,0x00212c3037330062,0x410e007400004802,0x36323f03d4371500\n"
    ".quad 0x03d437140101ea38,0x2c3323006234382d,0x0074000048020021,0x4f03d4050000410f\n"
    ".quad 0x0401006236313832,0x23006238382d03d4,0x0000480200212c36,0xd4050000410f0074\n"
    ".quad 0x0062343439324f03,0x6232392d03d40401,0x480200212c392300,0x1500410e00740000\n"
    ".quad 0x022e30332103d438,0x392c03d40400210d,0x212c323833006236,0x0f00740000480200\n"
    ".quad 0x333f03d405000041,0xd438140101ea3032,0x2300633030313d03,0x0000490200222c35\n"
    ".quad 0xd5050000420f0075,0x2502098b33332f03,0x3301ec0d00633738,0x00490200222c3838\n"
    ".quad 0x050000420f007500,0x02098e34332f03d6,0x01ed0d0063303925,0x490200222c313933\n"
    ".quad 0x0000420f00750000,0x099135332f03d705,0x92311e03d7391402,0x0200222c34393309\n"
    ".quad 0x00420f0075000049,0x9337332f03d80500,0x0d00633639250209,0x00222c37393301ef\n"
    ".quad 0x420f007500004902,0xef0f0a5638170000,0x0d0a573939250101,0x232c3030314301ef\n"
    ".quad 0x0e007600004a0200,0x2f03dc3031250043,0x3031350209993933,0xff0101f20d006632\n"
    ".quad 0x00004d030024030c,0x520c0c46301a0007,0xe232312f0006020e,0x323139000700010d\n"
    ".quad 0x00062c3423003538,0x202c3225100a311c,0x32190ff233312100,0x33220d8032170ff2\n"
    ".quad 0x340d496713003d3a,0x3b362b10802c3370,0x36540ec23415001b,0x352312ae726f0a3b\n"
    ".quad 0x19006d7012001c2c,0x0e0a3b353a006d35,0x590f0f0e32332a0f,0x64723f0cc001060e\n"
    ".quad 0x492c3323000dec37,0x0400a2010dec0b00,0x070dd13331210039,0x5d34250de8010ded\n"
    ".quad 0x3a35a10106050d72,0x7d0a0a3b7465720a,0x7337b0143f0d1303,0x4b50525343766d70\n"
    ".quad 0x3253664b4e108169,0x410e0400260f1440,0x2e311f10002e0f14,0x1f1a002e321f1a00\n"
    ".quad 0x149f341f1a002e33,0x303326149f371c00,0x323c3d01a301148c,0x0e14b13410149e38\n"
    ".quad 0x013d0f0e27011427,0x39312f0013f30f0d,0x000038311f0f0038,0x321f0f003830322f\n"
    ".quad 0x0f0038311f010038,0x38312f000038331f,0x03055d342f0f0038,0x117e0f007c2c1206\n"
    ".quad 0x1205002039312f0b,0x2001118409004033,0x00170714756e1303,0x0700180714b83318\n"
    ".quad 0x2c312412d80914a3,0xae311e12fc030036,0x17a25b1504ba0014,0x482c312504535d1c\n"
    ".quad 0x5f3150149c351d00,0x03e00000d80a3b39,0x0f03e36411007403,0x350f01100307010f\n"
    ".quad 0x31722c0f86010004,0x0039050fa3010434,0x00c3021221333228,0x5d3432644e05ea02\n"
    ".quad 0x2b24001c3314001c,0x0587656c2900dc34,0x322d159209000500,0x1000f53219159139\n"
    ".quad 0x00b8627523159138,0x6e61330047363128,0x1e0014bb02036264,0x7165280079331300\n"
    ".quad 0x78301f00200005c3,0x153f0301e1060900,0x01008b3319008b01,0x00790101480c05bd\n"
    ".quad 0x90040ea101057c0d,0x3127001c35322a02,0x1c0096351f028c2c,0x3a3406fe008e0a14\n"
    ".quad 0x616d676172702e0a,0x6f726e756f6e2220,0x3731220194226c6c,0x02065d32343f0195\n"
    ".quad 0x070b00232c362300,0x1e036f05087d0002,0x01eb323123142736,0x080300001d5d372f\n"
    ".quad 0x080c090471341002,0x322313910a00e000,0x361100e608007939,0x014f0300900707c7\n"
    ".quad 0x072c31240168341e,0xf635140049341900,0xb96e1a08112d1401,0x7025404902110207\n"
    ".quad 0x860162341701e434,0x622e746f6e0a3a35,0x2500653272281924,0x77383126028d3931\n"
    ".quad 0x0108080101780108,0x02d50208070e0022,0x0a00fc3814024a0d,0x001f0201340100e3\n"
    ".quad 0x0248341800fc381a,0x02803318001c391a,0x233a372d00d53917,0x334f01b030322302\n"
    ".quad 0xf601000226382d2b,0x01009a0a00260112,0x30332f0226041314,0x644f0c6c02000209\n"
    ".quad 0x351300001d5d3133,0x540f007634120076,0x00b90d00c5000c15,0x00b9341f00b93116\n"
    ".quad 0xb90b00262c322301,0x9c321f00b9331800,0x33333f0335030000,0x00b9381600001d5d\n"
    ".quad 0x00b90a1615ac341f,0x0100b60f00b93214,0x00b60b00232c3423,0x0099341e00b63518\n"
    ".quad 0x1d5d35333f01c804,0xfe341f012c040000,0x6c331500b30a1615,0xe9361402016b0f01\n"
    ".quad 0x1f044a0800b50b1a,0x1f00580400044a33,0x6b34322501044a33,0xb10103044c341f01\n"
    ".quad 0x0716540200450106,0x000700032003007b,0x342701031e36312f,0x037e323323001a33\n"
    ".quad 0x1a050c470a038405,0x361903d272252200,0x382f0363371703d2,0x001513010407903a\n"
    ".quad 0x0016031b29030904,0x00c00b07cb2c3923,0x39332f00352c3027,0x0bc0303421010bc0\n"
    ".quad 0x500bbf391303e209, 0x000000000a0a7d0a\n"
    ".text\n");

extern "C" {

extern const unsigned long long fatbinData[1490];
}

extern "C" {

static const __fatBinC_Wrapper_t __fatDeviceText __attribute__((aligned(8)))
__attribute__((section(".nvFatBinSegment"))) = { 0x466243b1, 1, fatbinData, 0 };
}
extern void __device_stub__Z11matMulTiledPKfS0_Pf(const float *, const float *,
						  float *);
extern void __device_stub__Z7spmvCSRPKiS0_PKfS2_Pf(const int *, const int *,
						   const float *, const float *,
						   float *);
static void __nv_cudaEntityRegisterCallback(void **);
static void __sti____cudaRegisterAll(void) __attribute__((__constructor__));
void __device_stub__Z11matMulTiledPKfS0_Pf(const float *__par0,
					   const float *__par1, float *__par2)
{
	void *__args_arr[3];
	int __args_idx = 0;
	__args_arr[__args_idx] = (void *)(char *)&__par0;
	++__args_idx;
	__args_arr[__args_idx] = (void *)(char *)&__par1;
	++__args_idx;
	__args_arr[__args_idx] = (void *)(char *)&__par2;
	++__args_idx;
	{
		volatile static char *__f __attribute__((unused));
		__f = ((char *)((void (*)(const float *, const float *,
					  float *))matMulTiled));
		dim3 __gridDim, __blockDim;
		size_t __sharedMem;
		cudaStream_t __stream;
		if (__cudaPopCallConfiguration(&__gridDim, &__blockDim,
					       &__sharedMem,
					       &__stream) != cudaSuccess)
			return;
		if (__args_idx == 0) {
			(void)cudaLaunchKernel(
				((char *)((void (*)(const float *, const float *,
						    float *))matMulTiled)),
				__gridDim, __blockDim, &__args_arr[__args_idx],
				__sharedMem, __stream);
		} else {
			(void)cudaLaunchKernel(
				((char *)((void (*)(const float *, const float *,
						    float *))matMulTiled)),
				__gridDim, __blockDim, &__args_arr[0],
				__sharedMem, __stream);
		}
	};
}

void matMulTiled(const float *__cuda_0, const float *__cuda_1, float *__cuda_2)
{
	__device_stub__Z11matMulTiledPKfS0_Pf(__cuda_0, __cuda_1, __cuda_2);
}
void __device_stub__Z7spmvCSRPKiS0_PKfS2_Pf(const int *__par0,
					    const int *__par1,
					    const float *__par2,
					    const float *__par3, float *__par4)
{
	void *__args_arr[5];
	int __args_idx = 0;
	__args_arr[__args_idx] = (void *)(char *)&__par0;
	++__args_idx;
	__args_arr[__args_idx] = (void *)(char *)&__par1;
	++__args_idx;
	__args_arr[__args_idx] = (void *)(char *)&__par2;
	++__args_idx;
	__args_arr[__args_idx] = (void *)(char *)&__par3;
	++__args_idx;
	__args_arr[__args_idx] = (void *)(char *)&__par4;
	++__args_idx;
	{
		volatile static char *__f __attribute__((unused));
		__f = ((char *)((void (*)(const int *, const int *,
					  const float *, const float *,
					  float *))spmvCSR));
		dim3 __gridDim, __blockDim;
		size_t __sharedMem;
		cudaStream_t __stream;
		if (__cudaPopCallConfiguration(&__gridDim, &__blockDim,
					       &__sharedMem,
					       &__stream) != cudaSuccess)
			return;
		if (__args_idx == 0) {
			(void)cudaLaunchKernel(
				((char *)((void (*)(
					const int *, const int *, const float *,
					const float *, float *))spmvCSR)),
				__gridDim, __blockDim, &__args_arr[__args_idx],
				__sharedMem, __stream);
		} else {
			(void)cudaLaunchKernel(
				((char *)((void (*)(
					const int *, const int *, const float *,
					const float *, float *))spmvCSR)),
				__gridDim, __blockDim, &__args_arr[0],
				__sharedMem, __stream);
		}
	};
}
void spmvCSR(const int *__cuda_0, const int *__cuda_1, const float *__cuda_2,
	     const float *__cuda_3, float *__cuda_4)
{
	__device_stub__Z7spmvCSRPKiS0_PKfS2_Pf(__cuda_0, __cuda_1, __cuda_2,
					       __cuda_3, __cuda_4);
}
static void __nv_cudaEntityRegisterCallback(void **__T5)
{
	{
		volatile static void **__ref __attribute__((unused));
		__ref = (volatile void **)__T5;
	};
	__nv_save_fatbinhandle_for_managed_rt(__T5);
	__cudaRegisterFunction(
		__T5,
		(const char *)((void (*)(const int *, const int *, const float *,
					 const float *, float *))spmvCSR),
		(char *)"_Z7spmvCSRPKiS0_PKfS2_Pf", "_Z7spmvCSRPKiS0_PKfS2_Pf",
		-1, (uint3 *)0, (uint3 *)0, (dim3 *)0, (dim3 *)0, (int *)0);
	__cudaRegisterFunction(
		__T5,
		(const char *)((void (*)(const float *, const float *,
					 float *))matMulTiled),
		(char *)"_Z11matMulTiledPKfS0_Pf", "_Z11matMulTiledPKfS0_Pf",
		-1, (uint3 *)0, (uint3 *)0, (dim3 *)0, (dim3 *)0, (int *)0);
	__cudaRegisterVar(__T5, (char *)&::d_N, (char *)"d_N", "d_N", 0, 4UL, 1,
			  0);
	__cudaRegisterVar(__T5, (char *)&::d_numRows, (char *)"d_numRows",
			  "d_numRows", 0, 4UL, 1, 0);
}
static void __sti____cudaRegisterAll(void)
{
	__cudaFatCubinHandle =
		__cudaRegisterFatBinary((void *)&__fatDeviceText);
	{
		void (*callback_fp)(void **) =
			(void (*)(void **))(__nv_cudaEntityRegisterCallback);
		(*callback_fp)(__cudaFatCubinHandle);
		__cudaRegisterFatBinaryEnd(__cudaFatCubinHandle);
	}
	atexit(__cudaUnregisterBinaryUtil);
}
